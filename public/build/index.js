/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(36);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _vue = __webpack_require__(2);
	
	var _vue2 = _interopRequireDefault(_vue);
	
	var _vueRouter = __webpack_require__(5);
	
	var _vueRouter2 = _interopRequireDefault(_vueRouter);
	
	var _vueResource = __webpack_require__(6);
	
	var _vueResource2 = _interopRequireDefault(_vueResource);
	
	var _app = __webpack_require__(30);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _auth = __webpack_require__(36);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	var _map = __webpack_require__(37);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _about = __webpack_require__(333);
	
	var _about2 = _interopRequireDefault(_about);
	
	var _venue = __webpack_require__(339);
	
	var _venue2 = _interopRequireDefault(_venue);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// install plugin
	_vue2.default.use(_vueRouter2.default);
	_vue2.default.use(_vueResource2.default);
	
	_vue2.default.http.headers.common['Authorization'] = 'Bearer ' + localStorage.getItem('id_token');
	
	// routing
	var router = new _vueRouter2.default();
	
	router.map({
	  '/map': {
	    component: _map2.default
	  },
	  '/about': {
	    component: _about2.default
	  },
	  '/venue/:geohash': {
	    component: _venue2.default
	  }
	});
	
	router.beforeEach(function () {
	  window.scrollTo(0, 0);
	});
	
	router.redirect({
	  '*': '/map'
	});
	
	router.start(_app2.default, '#app');
	
	exports.default = router;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, console) {/*!
	 * Vue.js v1.0.24
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	'use strict';
	
	function set(obj, key, val) {
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._proxy(key);
	      vm._digest();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!hasOwn(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj._digest();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      vm._unproxy(key);
	      vm._digest();
	    }
	  }
	}
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Check if an expression is a literal value.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
	
	function isLiteral(exp) {
	  return literalValueRE.test(exp);
	}
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	/**
	 * Guard text output, make sure undefined outputs
	 * empty string
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function _toString(value) {
	  return value == null ? '' : value.toString();
	}
	
	/**
	 * Check and convert possible numeric strings to numbers
	 * before setting back to data
	 *
	 * @param {*} value
	 * @return {*|Number}
	 */
	
	function toNumber(value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	}
	
	/**
	 * Convert string boolean literals into real booleans.
	 *
	 * @param {*} value
	 * @return {*|Boolean}
	 */
	
	function toBoolean(value) {
	  return value === 'true' ? true : value === 'false' ? false : value;
	}
	
	/**
	 * Strip quotes from a string
	 *
	 * @param {String} str
	 * @return {String | false}
	 */
	
	function stripQuotes(str) {
	  var a = str.charCodeAt(0);
	  var b = str.charCodeAt(str.length - 1);
	  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	
	function camelize(str) {
	  return str.replace(camelizeRE, toUpper);
	}
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	
	function hyphenate(str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	}
	
	/**
	 * Converts hyphen/underscore/slash delimitered names into
	 * camelized classNames.
	 *
	 * e.g. my-component => MyComponent
	 *      some_else    => SomeElse
	 *      some/comp    => SomeComp
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var classifyRE = /(?:^|[-_\/])(\w)/g;
	
	function classify(str) {
	  return str.replace(classifyRE, toUpper);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(to, from) {
	  var keys = Object.keys(from);
	  var i = keys.length;
	  while (i--) {
	    to[keys[i]] = from[keys[i]];
	  }
	  return to;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}
	
	/**
	 * Array type check.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Debounce a function so it only gets called after the
	 * input stops arriving after the given wait period.
	 *
	 * @param {Function} func
	 * @param {Number} wait
	 * @return {Function} - the debounced function
	 */
	
	function _debounce(func, wait) {
	  var timeout, args, context, timestamp, result;
	  var later = function later() {
	    var last = Date.now() - timestamp;
	    if (last < wait && last >= 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    }
	  };
	  return function () {
	    context = this;
	    args = arguments;
	    timestamp = Date.now();
	    if (!timeout) {
	      timeout = setTimeout(later, wait);
	    }
	    return result;
	  };
	}
	
	/**
	 * Manual indexOf because it's slightly faster than
	 * native.
	 *
	 * @param {Array} arr
	 * @param {*} obj
	 */
	
	function indexOf(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	}
	
	/**
	 * Make a cancellable version of an async callback.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cancellable(fn) {
	  var cb = function cb() {
	    if (!cb.cancelled) {
	      return fn.apply(this, arguments);
	    }
	  };
	  cb.cancel = function () {
	    cb.cancelled = true;
	  };
	  return cb;
	}
	
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 *
	 * @param {*} a
	 * @param {*} b
	 * @return {Boolean}
	 */
	
	function looseEqual(a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
	  /* eslint-enable eqeqeq */
	}
	
	var hasProto = ('__proto__' in {});
	
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
	
	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
	
	// UA sniffing for working around browser-specific quirks
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
	var isWechat = UA && UA.indexOf('micromessenger') > 0;
	
	var transitionProp = undefined;
	var transitionEndEvent = undefined;
	var animationProp = undefined;
	var animationEndEvent = undefined;
	
	// Transition property/event sniffing
	if (inBrowser && !isIE9) {
	  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
	  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
	  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
	  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
	  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
	  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
	}
	
	/**
	 * Defer a task to execute it asynchronously. Ideally this
	 * should be executed as a microtask, so we leverage
	 * MutationObserver if it's available, and fallback to
	 * setTimeout(0).
	 *
	 * @param {Function} cb
	 * @param {Object} ctx
	 */
	
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;
	  function nextTickHandler() {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks = [];
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }
	
	  /* istanbul ignore if */
	  if (typeof MutationObserver !== 'undefined' && !(isWechat && isIos)) {
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(counter);
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = counter;
	    };
	  } else {
	    // webpack attempts to inject a shim for setImmediate
	    // if it is used as a global, so we have to work around that to
	    // avoid bundling unnecessary code.
	    var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
	    timerFunc = context.setImmediate || setTimeout;
	  }
	  return function (cb, ctx) {
	    var func = ctx ? function () {
	      cb.call(ctx);
	    } : cb;
	    callbacks.push(func);
	    if (pending) return;
	    pending = true;
	    timerFunc(nextTickHandler, 0);
	  };
	})();
	
	var _Set = undefined;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = function () {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	function Cache(limit) {
	  this.size = 0;
	  this.limit = limit;
	  this.head = this.tail = undefined;
	  this._keymap = Object.create(null);
	}
	
	var p = Cache.prototype;
	
	/**
	 * Put <value> into the cache associated with <key>.
	 * Returns the entry which was removed to make room for
	 * the new entry. Otherwise undefined is returned.
	 * (i.e. if there was enough room already).
	 *
	 * @param {String} key
	 * @param {*} value
	 * @return {Entry|undefined}
	 */
	
	p.put = function (key, value) {
	  var removed;
	  if (this.size === this.limit) {
	    removed = this.shift();
	  }
	
	  var entry = this.get(key, true);
	  if (!entry) {
	    entry = {
	      key: key
	    };
	    this._keymap[key] = entry;
	    if (this.tail) {
	      this.tail.newer = entry;
	      entry.older = this.tail;
	    } else {
	      this.head = entry;
	    }
	    this.tail = entry;
	    this.size++;
	  }
	  entry.value = value;
	
	  return removed;
	};
	
	/**
	 * Purge the least recently used (oldest) entry from the
	 * cache. Returns the removed entry or undefined if the
	 * cache was empty.
	 */
	
	p.shift = function () {
	  var entry = this.head;
	  if (entry) {
	    this.head = this.head.newer;
	    this.head.older = undefined;
	    entry.newer = entry.older = undefined;
	    this._keymap[entry.key] = undefined;
	    this.size--;
	  }
	  return entry;
	};
	
	/**
	 * Get and register recent use of <key>. Returns the value
	 * associated with <key> or undefined if not in cache.
	 *
	 * @param {String} key
	 * @param {Boolean} returnEntry
	 * @return {Entry|*}
	 */
	
	p.get = function (key, returnEntry) {
	  var entry = this._keymap[key];
	  if (entry === undefined) return;
	  if (entry === this.tail) {
	    return returnEntry ? entry : entry.value;
	  }
	  // HEAD--------------TAIL
	  //   <.older   .newer>
	  //  <--- add direction --
	  //   A  B  C  <D>  E
	  if (entry.newer) {
	    if (entry === this.head) {
	      this.head = entry.newer;
	    }
	    entry.newer.older = entry.older; // C <-- E.
	  }
	  if (entry.older) {
	    entry.older.newer = entry.newer; // C. --> E
	  }
	  entry.newer = undefined; // D --x
	  entry.older = this.tail; // D. --> E
	  if (this.tail) {
	    this.tail.newer = entry; // E. <-- D
	  }
	  this.tail = entry;
	  return returnEntry ? entry : entry.value;
	};
	
	var cache$1 = new Cache(1000);
	var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
	var reservedArgRE = /^in$|^-?\d+/;
	
	/**
	 * Parser state
	 */
	
	var str;
	var dir;
	var c;
	var prev;
	var i;
	var l;
	var lastFilterIndex;
	var inSingle;
	var inDouble;
	var curly;
	var square;
	var paren;
	/**
	 * Push a filter to the current directive object
	 */
	
	function pushFilter() {
	  var exp = str.slice(lastFilterIndex, i).trim();
	  var filter;
	  if (exp) {
	    filter = {};
	    var tokens = exp.match(filterTokenRE);
	    filter.name = tokens[0];
	    if (tokens.length > 1) {
	      filter.args = tokens.slice(1).map(processFilterArg);
	    }
	  }
	  if (filter) {
	    (dir.filters = dir.filters || []).push(filter);
	  }
	  lastFilterIndex = i + 1;
	}
	
	/**
	 * Check if an argument is dynamic and strip quotes.
	 *
	 * @param {String} arg
	 * @return {Object}
	 */
	
	function processFilterArg(arg) {
	  if (reservedArgRE.test(arg)) {
	    return {
	      value: toNumber(arg),
	      dynamic: false
	    };
	  } else {
	    var stripped = stripQuotes(arg);
	    var dynamic = stripped === arg;
	    return {
	      value: dynamic ? arg : stripped,
	      dynamic: dynamic
	    };
	  }
	}
	
	/**
	 * Parse a directive value and extract the expression
	 * and its filters into a descriptor.
	 *
	 * Example:
	 *
	 * "a + 1 | uppercase" will yield:
	 * {
	 *   expression: 'a + 1',
	 *   filters: [
	 *     { name: 'uppercase', args: null }
	 *   ]
	 * }
	 *
	 * @param {String} s
	 * @return {Object}
	 */
	
	function parseDirective(s) {
	  var hit = cache$1.get(s);
	  if (hit) {
	    return hit;
	  }
	
	  // reset parser state
	  str = s;
	  inSingle = inDouble = false;
	  curly = square = paren = 0;
	  lastFilterIndex = 0;
	  dir = {};
	
	  for (i = 0, l = str.length; i < l; i++) {
	    prev = c;
	    c = str.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
	    } else if (c === 0x7C && // pipe
	    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
	      if (dir.expression == null) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        dir.expression = str.slice(0, i).trim();
	      } else {
	        // already has filter
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22:
	          inDouble = true;break; // "
	        case 0x27:
	          inSingle = true;break; // '
	        case 0x28:
	          paren++;break; // (
	        case 0x29:
	          paren--;break; // )
	        case 0x5B:
	          square++;break; // [
	        case 0x5D:
	          square--;break; // ]
	        case 0x7B:
	          curly++;break; // {
	        case 0x7D:
	          curly--;break; // }
	      }
	    }
	  }
	
	  if (dir.expression == null) {
	    dir.expression = str.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }
	
	  cache$1.put(s, dir);
	  return dir;
	}
	
	var directive = Object.freeze({
	  parseDirective: parseDirective
	});
	
	var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	var cache = undefined;
	var tagRE = undefined;
	var htmlRE = undefined;
	/**
	 * Escape a string so it can be used in a RegExp
	 * constructor.
	 *
	 * @param {String} str
	 */
	
	function escapeRegex(str) {
	  return str.replace(regexEscapeRE, '\\$&');
	}
	
	function compileRegex() {
	  var open = escapeRegex(config.delimiters[0]);
	  var close = escapeRegex(config.delimiters[1]);
	  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
	  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
	  tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
	  htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
	  // reset cache
	  cache = new Cache(1000);
	}
	
	/**
	 * Parse a template text string into an array of tokens.
	 *
	 * @param {String} text
	 * @return {Array<Object> | null}
	 *               - {String} type
	 *               - {String} value
	 *               - {Boolean} [html]
	 *               - {Boolean} [oneTime]
	 */
	
	function parseText(text) {
	  if (!cache) {
	    compileRegex();
	  }
	  var hit = cache.get(text);
	  if (hit) {
	    return hit;
	  }
	  if (!tagRE.test(text)) {
	    return null;
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index, html, value, first, oneTime;
	  /* eslint-disable no-cond-assign */
	  while (match = tagRE.exec(text)) {
	    /* eslint-enable no-cond-assign */
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push({
	        value: text.slice(lastIndex, index)
	      });
	    }
	    // tag token
	    html = htmlRE.test(match[0]);
	    value = html ? match[1] : match[2];
	    first = value.charCodeAt(0);
	    oneTime = first === 42; // *
	    value = oneTime ? value.slice(1) : value;
	    tokens.push({
	      tag: true,
	      value: value.trim(),
	      html: html,
	      oneTime: oneTime
	    });
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push({
	      value: text.slice(lastIndex)
	    });
	  }
	  cache.put(text, tokens);
	  return tokens;
	}
	
	/**
	 * Format a list of tokens into an expression.
	 * e.g. tokens parsed from 'a {{b}} c' can be serialized
	 * into one single expression as '"a " + b + " c"'.
	 *
	 * @param {Array} tokens
	 * @param {Vue} [vm]
	 * @return {String}
	 */
	
	function tokensToExp(tokens, vm) {
	  if (tokens.length > 1) {
	    return tokens.map(function (token) {
	      return formatToken(token, vm);
	    }).join('+');
	  } else {
	    return formatToken(tokens[0], vm, true);
	  }
	}
	
	/**
	 * Format a single token.
	 *
	 * @param {Object} token
	 * @param {Vue} [vm]
	 * @param {Boolean} [single]
	 * @return {String}
	 */
	
	function formatToken(token, vm, single) {
	  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
	}
	
	/**
	 * For an attribute with multiple interpolation tags,
	 * e.g. attr="some-{{thing | filter}}", in order to combine
	 * the whole thing into a single watchable expression, we
	 * have to inline those filters. This function does exactly
	 * that. This is a bit hacky but it avoids heavy changes
	 * to directive parser and watcher mechanism.
	 *
	 * @param {String} exp
	 * @param {Boolean} single
	 * @return {String}
	 */
	
	var filterRE = /[^|]\|[^|]/;
	function inlineFilters(exp, single) {
	  if (!filterRE.test(exp)) {
	    return single ? exp : '(' + exp + ')';
	  } else {
	    var dir = parseDirective(exp);
	    if (!dir.filters) {
	      return '(' + exp + ')';
	    } else {
	      return 'this._applyFilters(' + dir.expression + // value
	      ',null,' + // oldValue (null for read)
	      JSON.stringify(dir.filters) + // filter descriptors
	      ',false)'; // write?
	    }
	  }
	}
	
	var text = Object.freeze({
	  compileRegex: compileRegex,
	  parseText: parseText,
	  tokensToExp: tokensToExp
	});
	
	var delimiters = ['{{', '}}'];
	var unsafeDelimiters = ['{{{', '}}}'];
	
	var config = Object.defineProperties({
	
	  /**
	   * Whether to print debug messages.
	   * Also enables stack trace for warnings.
	   *
	   * @type {Boolean}
	   */
	
	  debug: false,
	
	  /**
	   * Whether to suppress warnings.
	   *
	   * @type {Boolean}
	   */
	
	  silent: false,
	
	  /**
	   * Whether to use async rendering.
	   */
	
	  async: true,
	
	  /**
	   * Whether to warn against errors caught when evaluating
	   * expressions.
	   */
	
	  warnExpressionErrors: true,
	
	  /**
	   * Whether to allow devtools inspection.
	   * Disabled by default in production builds.
	   */
	
	  devtools: process.env.NODE_ENV !== 'production',
	
	  /**
	   * Internal flag to indicate the delimiters have been
	   * changed.
	   *
	   * @type {Boolean}
	   */
	
	  _delimitersChanged: true,
	
	  /**
	   * List of asset types that a component can own.
	   *
	   * @type {Array}
	   */
	
	  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
	
	  /**
	   * prop binding modes
	   */
	
	  _propBindingModes: {
	    ONE_WAY: 0,
	    TWO_WAY: 1,
	    ONE_TIME: 2
	  },
	
	  /**
	   * Max circular updates allowed in a batcher flush cycle.
	   */
	
	  _maxUpdateCount: 100
	
	}, {
	  delimiters: { /**
	                 * Interpolation delimiters. Changing these would trigger
	                 * the text parser to re-compile the regular expressions.
	                 *
	                 * @type {Array<String>}
	                 */
	
	    get: function get() {
	      return delimiters;
	    },
	    set: function set(val) {
	      delimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  },
	  unsafeDelimiters: {
	    get: function get() {
	      return unsafeDelimiters;
	    },
	    set: function set(val) {
	      unsafeDelimiters = val;
	      compileRegex();
	    },
	    configurable: true,
	    enumerable: true
	  }
	});
	
	var warn = undefined;
	var formatComponentName = undefined;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var hasConsole = typeof console !== 'undefined';
	
	    warn = function (msg, vm) {
	      if (hasConsole && !config.silent) {
	        console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
	      }
	    };
	
	    formatComponentName = function (vm) {
	      var name = vm._isVue ? vm.$options.name : vm.name;
	      return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
	    };
	  })();
	}
	
	/**
	 * Append with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function appendWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    target.appendChild(el);
	  }, vm, cb);
	}
	
	/**
	 * InsertBefore with transition.
	 *
	 * @param {Element} el
	 * @param {Element} target
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function beforeWithTransition(el, target, vm, cb) {
	  applyTransition(el, 1, function () {
	    before(el, target);
	  }, vm, cb);
	}
	
	/**
	 * Remove with transition.
	 *
	 * @param {Element} el
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function removeWithTransition(el, vm, cb) {
	  applyTransition(el, -1, function () {
	    remove(el);
	  }, vm, cb);
	}
	
	/**
	 * Apply transitions with an operation callback.
	 *
	 * @param {Element} el
	 * @param {Number} direction
	 *                  1: enter
	 *                 -1: leave
	 * @param {Function} op - the actual DOM operation
	 * @param {Vue} vm
	 * @param {Function} [cb]
	 */
	
	function applyTransition(el, direction, op, vm, cb) {
	  var transition = el.__v_trans;
	  if (!transition ||
	  // skip if there are no js hooks and CSS transition is
	  // not supported
	  !transition.hooks && !transitionEndEvent ||
	  // skip transitions for initial compile
	  !vm._isCompiled ||
	  // if the vm is being manipulated by a parent directive
	  // during the parent's compilation phase, skip the
	  // animation.
	  vm.$parent && !vm.$parent._isCompiled) {
	    op();
	    if (cb) cb();
	    return;
	  }
	  var action = direction > 0 ? 'enter' : 'leave';
	  transition[action](op, cb);
	}
	
	var transition = Object.freeze({
	  appendWithTransition: appendWithTransition,
	  beforeWithTransition: beforeWithTransition,
	  removeWithTransition: removeWithTransition,
	  applyTransition: applyTransition
	});
	
	/**
	 * Query an element selector if it's not an element already.
	 *
	 * @param {String|Element} el
	 * @return {Element}
	 */
	
	function query(el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
	    }
	  }
	  return el;
	}
	
	/**
	 * Check if a node is in the document.
	 * Note: document.documentElement.contains should work here
	 * but always returns false for comment nodes in phantomjs,
	 * making unit tests difficult. This is fixed by doing the
	 * contains() check on the node's parentNode instead of
	 * the node itself.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function inDoc(node) {
	  if (!node) return false;
	  var doc = node.ownerDocument.documentElement;
	  var parent = node.parentNode;
	  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
	}
	
	/**
	 * Get and remove an attribute from a node.
	 *
	 * @param {Node} node
	 * @param {String} _attr
	 */
	
	function getAttr(node, _attr) {
	  var val = node.getAttribute(_attr);
	  if (val !== null) {
	    node.removeAttribute(_attr);
	  }
	  return val;
	}
	
	/**
	 * Get an attribute with colon or v-bind: prefix.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {String|null}
	 */
	
	function getBindAttr(node, name) {
	  var val = getAttr(node, ':' + name);
	  if (val === null) {
	    val = getAttr(node, 'v-bind:' + name);
	  }
	  return val;
	}
	
	/**
	 * Check the presence of a bind attribute.
	 *
	 * @param {Node} node
	 * @param {String} name
	 * @return {Boolean}
	 */
	
	function hasBindAttr(node, name) {
	  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
	}
	
	/**
	 * Insert el before target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function before(el, target) {
	  target.parentNode.insertBefore(el, target);
	}
	
	/**
	 * Insert el after target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function after(el, target) {
	  if (target.nextSibling) {
	    before(el, target.nextSibling);
	  } else {
	    target.parentNode.appendChild(el);
	  }
	}
	
	/**
	 * Remove el from DOM
	 *
	 * @param {Element} el
	 */
	
	function remove(el) {
	  el.parentNode.removeChild(el);
	}
	
	/**
	 * Prepend el to target
	 *
	 * @param {Element} el
	 * @param {Element} target
	 */
	
	function prepend(el, target) {
	  if (target.firstChild) {
	    before(el, target.firstChild);
	  } else {
	    target.appendChild(el);
	  }
	}
	
	/**
	 * Replace target with el
	 *
	 * @param {Element} target
	 * @param {Element} el
	 */
	
	function replace(target, el) {
	  var parent = target.parentNode;
	  if (parent) {
	    parent.replaceChild(el, target);
	  }
	}
	
	/**
	 * Add event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 * @param {Boolean} [useCapture]
	 */
	
	function on(el, event, cb, useCapture) {
	  el.addEventListener(event, cb, useCapture);
	}
	
	/**
	 * Remove event listener shorthand.
	 *
	 * @param {Element} el
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	function off(el, event, cb) {
	  el.removeEventListener(event, cb);
	}
	
	/**
	 * For IE9 compat: when both class and :class are present
	 * getAttribute('class') returns wrong value...
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getClass(el) {
	  var classname = el.className;
	  if (typeof classname === 'object') {
	    classname = classname.baseVal || '';
	  }
	  return classname;
	}
	
	/**
	 * In IE9, setAttribute('class') will result in empty class
	 * if the element also has the :class attribute; However in
	 * PhantomJS, setting `className` does not work on SVG elements...
	 * So we have to do a conditional check here.
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function setClass(el, cls) {
	  /* istanbul ignore if */
	  if (isIE9 && !/svg$/.test(el.namespaceURI)) {
	    el.className = cls;
	  } else {
	    el.setAttribute('class', cls);
	  }
	}
	
	/**
	 * Add class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function addClass(el, cls) {
	  if (el.classList) {
	    el.classList.add(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      setClass(el, (cur + cls).trim());
	    }
	  }
	}
	
	/**
	 * Remove class with compatibility for IE & SVG
	 *
	 * @param {Element} el
	 * @param {String} cls
	 */
	
	function removeClass(el, cls) {
	  if (el.classList) {
	    el.classList.remove(cls);
	  } else {
	    var cur = ' ' + getClass(el) + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    setClass(el, cur.trim());
	  }
	  if (!el.className) {
	    el.removeAttribute('class');
	  }
	}
	
	/**
	 * Extract raw content inside an element into a temporary
	 * container div
	 *
	 * @param {Element} el
	 * @param {Boolean} asFragment
	 * @return {Element|DocumentFragment}
	 */
	
	function extractContent(el, asFragment) {
	  var child;
	  var rawContent;
	  /* istanbul ignore if */
	  if (isTemplate(el) && isFragment(el.content)) {
	    el = el.content;
	  }
	  if (el.hasChildNodes()) {
	    trimNode(el);
	    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
	    /* eslint-disable no-cond-assign */
	    while (child = el.firstChild) {
	      /* eslint-enable no-cond-assign */
	      rawContent.appendChild(child);
	    }
	  }
	  return rawContent;
	}
	
	/**
	 * Trim possible empty head/tail text and comment
	 * nodes inside a parent.
	 *
	 * @param {Node} node
	 */
	
	function trimNode(node) {
	  var child;
	  /* eslint-disable no-sequences */
	  while ((child = node.firstChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  while ((child = node.lastChild, isTrimmable(child))) {
	    node.removeChild(child);
	  }
	  /* eslint-enable no-sequences */
	}
	
	function isTrimmable(node) {
	  return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
	}
	
	/**
	 * Check if an element is a template tag.
	 * Note if the template appears inside an SVG its tagName
	 * will be in lowercase.
	 *
	 * @param {Element} el
	 */
	
	function isTemplate(el) {
	  return el.tagName && el.tagName.toLowerCase() === 'template';
	}
	
	/**
	 * Create an "anchor" for performing dom insertion/removals.
	 * This is used in a number of scenarios:
	 * - fragment instance
	 * - v-html
	 * - v-if
	 * - v-for
	 * - component
	 *
	 * @param {String} content
	 * @param {Boolean} persist - IE trashes empty textNodes on
	 *                            cloneNode(true), so in certain
	 *                            cases the anchor needs to be
	 *                            non-empty to be persisted in
	 *                            templates.
	 * @return {Comment|Text}
	 */
	
	function createAnchor(content, persist) {
	  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
	  anchor.__v_anchor = true;
	  return anchor;
	}
	
	/**
	 * Find a component ref attribute that starts with $.
	 *
	 * @param {Element} node
	 * @return {String|undefined}
	 */
	
	var refRE = /^v-ref:/;
	
	function findRef(node) {
	  if (node.hasAttributes()) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var name = attrs[i].name;
	      if (refRE.test(name)) {
	        return camelize(name.replace(refRE, ''));
	      }
	    }
	  }
	}
	
	/**
	 * Map a function to a range of nodes .
	 *
	 * @param {Node} node
	 * @param {Node} end
	 * @param {Function} op
	 */
	
	function mapNodeRange(node, end, op) {
	  var next;
	  while (node !== end) {
	    next = node.nextSibling;
	    op(node);
	    node = next;
	  }
	  op(end);
	}
	
	/**
	 * Remove a range of nodes with transition, store
	 * the nodes in a fragment with correct ordering,
	 * and call callback when done.
	 *
	 * @param {Node} start
	 * @param {Node} end
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Function} cb
	 */
	
	function removeNodeRange(start, end, vm, frag, cb) {
	  var done = false;
	  var removed = 0;
	  var nodes = [];
	  mapNodeRange(start, end, function (node) {
	    if (node === end) done = true;
	    nodes.push(node);
	    removeWithTransition(node, vm, onRemoved);
	  });
	  function onRemoved() {
	    removed++;
	    if (done && removed >= nodes.length) {
	      for (var i = 0; i < nodes.length; i++) {
	        frag.appendChild(nodes[i]);
	      }
	      cb && cb();
	    }
	  }
	}
	
	/**
	 * Check if a node is a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isFragment(node) {
	  return node && node.nodeType === 11;
	}
	
	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 *
	 * @param {Element} el
	 * @return {String}
	 */
	
	function getOuterHTML(el) {
	  if (el.outerHTML) {
	    return el.outerHTML;
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML;
	  }
	}
	
	var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
	var reservedTagRE = /^(slot|partial|component)$/i;
	
	var isUnknownElement = undefined;
	if (process.env.NODE_ENV !== 'production') {
	  isUnknownElement = function (el, tag) {
	    if (tag.indexOf('-') > -1) {
	      // http://stackoverflow.com/a/28210364/1070244
	      return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
	    } else {
	      return (/HTMLUnknownElement/.test(el.toString()) &&
	        // Chrome returns unknown for several HTML5 elements.
	        // https://code.google.com/p/chromium/issues/detail?id=540526
	        !/^(data|time|rtc|rb)$/.test(tag)
	      );
	    }
	  };
	}
	
	/**
	 * Check if an element is a component, if yes return its
	 * component id.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function checkComponentAttr(el, options) {
	  var tag = el.tagName.toLowerCase();
	  var hasAttrs = el.hasAttributes();
	  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
	    if (resolveAsset(options, 'components', tag)) {
	      return { id: tag };
	    } else {
	      var is = hasAttrs && getIsBinding(el, options);
	      if (is) {
	        return is;
	      } else if (process.env.NODE_ENV !== 'production') {
	        var expectedTag = options._componentNameMap && options._componentNameMap[tag];
	        if (expectedTag) {
	          warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
	        } else if (isUnknownElement(el, tag)) {
	          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
	        }
	      }
	    }
	  } else if (hasAttrs) {
	    return getIsBinding(el, options);
	  }
	}
	
	/**
	 * Get "is" binding from an element.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Object|undefined}
	 */
	
	function getIsBinding(el, options) {
	  // dynamic syntax
	  var exp = el.getAttribute('is');
	  if (exp != null) {
	    if (resolveAsset(options, 'components', exp)) {
	      el.removeAttribute('is');
	      return { id: exp };
	    }
	  } else {
	    exp = getBindAttr(el, 'is');
	    if (exp != null) {
	      return { id: exp, dynamic: true };
	    }
	  }
	}
	
	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 *
	 * All strategy functions follow the same signature:
	 *
	 * @param {*} parentVal
	 * @param {*} childVal
	 * @param {Vue} [vm]
	 */
	
	var strats = config.optionMergeStrategies = Object.create(null);
	
	/**
	 * Helper that recursively merges two data objects together.
	 */
	
	function mergeData(to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to;
	}
	
	/**
	 * Data
	 */
	
	strats.data = function (parentVal, childVal, vm) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal;
	    }
	    if (typeof childVal !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	      return parentVal;
	    }
	    if (!parentVal) {
	      return childVal;
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn() {
	      return mergeData(childVal.call(this), parentVal.call(this));
	    };
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn() {
	      // instance merge
	      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
	      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData);
	      } else {
	        return defaultData;
	      }
	    };
	  }
	};
	
	/**
	 * El
	 */
	
	strats.el = function (parentVal, childVal, vm) {
	  if (!vm && childVal && typeof childVal !== 'function') {
	    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
	    return;
	  }
	  var ret = childVal || parentVal;
	  // invoke the element factory if this is instance merge
	  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
	};
	
	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	
	strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
	  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	};
	
	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	
	function mergeAssets(parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
	}
	
	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});
	
	/**
	 * Events & Watchers.
	 *
	 * Events & watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	
	strats.watch = strats.events = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent ? parent.concat(child) : [child];
	  }
	  return ret;
	};
	
	/**
	 * Other object hashes.
	 */
	
	strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
	  if (!childVal) return parentVal;
	  if (!parentVal) return childVal;
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret;
	};
	
	/**
	 * Default strategy.
	 */
	
	var defaultStrat = function defaultStrat(parentVal, childVal) {
	  return childVal === undefined ? parentVal : childVal;
	};
	
	/**
	 * Make sure component options get converted to actual
	 * constructors.
	 *
	 * @param {Object} options
	 */
	
	function guardComponents(options) {
	  if (options.components) {
	    var components = options.components = guardArrayAssets(options.components);
	    var ids = Object.keys(components);
	    var def;
	    if (process.env.NODE_ENV !== 'production') {
	      var map = options._componentNameMap = {};
	    }
	    for (var i = 0, l = ids.length; i < l; i++) {
	      var key = ids[i];
	      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
	        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
	        continue;
	      }
	      // record a all lowercase <-> kebab-case mapping for
	      // possible custom element case error warning
	      if (process.env.NODE_ENV !== 'production') {
	        map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
	      }
	      def = components[key];
	      if (isPlainObject(def)) {
	        components[key] = Vue.extend(def);
	      }
	    }
	  }
	}
	
	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 *
	 * @param {Object} options
	 */
	
	function guardProps(options) {
	  var props = options.props;
	  var i, val;
	  if (isArray(props)) {
	    options.props = {};
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        options.props[val] = null;
	      } else if (val.name) {
	        options.props[val.name] = val;
	      }
	    }
	  } else if (isPlainObject(props)) {
	    var keys = Object.keys(props);
	    i = keys.length;
	    while (i--) {
	      val = props[keys[i]];
	      if (typeof val === 'function') {
	        props[keys[i]] = { type: val };
	      }
	    }
	  }
	}
	
	/**
	 * Guard an Array-format assets option and converted it
	 * into the key-value Object format.
	 *
	 * @param {Object|Array} assets
	 * @return {Object}
	 */
	
	function guardArrayAssets(assets) {
	  if (isArray(assets)) {
	    var res = {};
	    var i = assets.length;
	    var asset;
	    while (i--) {
	      asset = assets[i];
	      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
	      if (!id) {
	        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
	      } else {
	        res[id] = asset;
	      }
	    }
	    return res;
	  }
	  return assets;
	}
	
	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 *
	 * @param {Object} parent
	 * @param {Object} child
	 * @param {Vue} [vm] - if vm is present, indicates this is
	 *                     an instantiation merge.
	 */
	
	function mergeOptions(parent, child, vm) {
	  guardComponents(child);
	  guardProps(child);
	  if (process.env.NODE_ENV !== 'production') {
	    if (child.propsData && !vm) {
	      warn('propsData can only be used as an instantiation option.');
	    }
	  }
	  var options = {};
	  var key;
	  if (child['extends']) {
	    parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      parent = mergeOptions(parent, child.mixins[i], vm);
	    }
	  }
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField(key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options;
	}
	
	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 *
	 * @param {Object} options
	 * @param {String} type
	 * @param {String} id
	 * @param {Boolean} warnMissing
	 * @return {Object|Function}
	 */
	
	function resolveAsset(options, type, id, warnMissing) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return;
	  }
	  var assets = options[type];
	  var camelizedId;
	  var res = assets[id] ||
	  // camelCase ID
	  assets[camelizedId = camelize(id)] ||
	  // Pascal Case ID
	  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
	  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
	    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
	  }
	  return res;
	}
	
	var uid$1 = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	function Dep() {
	  this.id = uid$1++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  this.subs.$remove(sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = toArray(this.subs);
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};
	
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	def(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = Number(index) + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index or target element reference.
	 *
	 * @param {*} item
	 */
	
	def(arrayProto, '$remove', function $remove(item) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  var index = indexOf(this, item);
	  if (index > -1) {
	    return this.splice(index, 1);
	  }
	});
	
	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	
	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However in certain cases, e.g.
	 * v-for scope alias and props, we don't want to force conversion
	 * because the value may be a nested value under a frozen data structure.
	 *
	 * So whenever we want to set a reactive property without forcing
	 * conversion on the new value, we wrap that call inside this function.
	 */
	
	var shouldConvert = true;
	
	function withoutConversion(fn) {
	  shouldConvert = false;
	  fn();
	  shouldConvert = true;
	}
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new Dep();
	  def(value, '__ob__', this);
	  if (isArray(value)) {
	    var augment = hasProto ? protoAugment : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    this.convert(keys[i], obj[keys[i]]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  this.vms.$remove(vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!value || typeof value !== 'object') {
	    return;
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new Dep();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	
	
	var util = Object.freeze({
		defineReactive: defineReactive,
		set: set,
		del: del,
		hasOwn: hasOwn,
		isLiteral: isLiteral,
		isReserved: isReserved,
		_toString: _toString,
		toNumber: toNumber,
		toBoolean: toBoolean,
		stripQuotes: stripQuotes,
		camelize: camelize,
		hyphenate: hyphenate,
		classify: classify,
		bind: bind,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		def: def,
		debounce: _debounce,
		indexOf: indexOf,
		cancellable: cancellable,
		looseEqual: looseEqual,
		isArray: isArray,
		hasProto: hasProto,
		inBrowser: inBrowser,
		devtools: devtools,
		isIE9: isIE9,
		isAndroid: isAndroid,
		isIos: isIos,
		isWechat: isWechat,
		get transitionProp () { return transitionProp; },
		get transitionEndEvent () { return transitionEndEvent; },
		get animationProp () { return animationProp; },
		get animationEndEvent () { return animationEndEvent; },
		nextTick: nextTick,
		get _Set () { return _Set; },
		query: query,
		inDoc: inDoc,
		getAttr: getAttr,
		getBindAttr: getBindAttr,
		hasBindAttr: hasBindAttr,
		before: before,
		after: after,
		remove: remove,
		prepend: prepend,
		replace: replace,
		on: on,
		off: off,
		setClass: setClass,
		addClass: addClass,
		removeClass: removeClass,
		extractContent: extractContent,
		trimNode: trimNode,
		isTemplate: isTemplate,
		createAnchor: createAnchor,
		findRef: findRef,
		mapNodeRange: mapNodeRange,
		removeNodeRange: removeNodeRange,
		isFragment: isFragment,
		getOuterHTML: getOuterHTML,
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		checkComponentAttr: checkComponentAttr,
		commonTagRE: commonTagRE,
		reservedTagRE: reservedTagRE,
		get warn () { return warn; }
	});
	
	var uid = 0;
	
	function initMixin (Vue) {
	  /**
	   * The main init sequence. This is called for every
	   * instance, including ones that are created from extended
	   * constructors.
	   *
	   * @param {Object} options - this options object should be
	   *                           the result of merging class
	   *                           options and the options passed
	   *                           in to the constructor.
	   */
	
	  Vue.prototype._init = function (options) {
	    options = options || {};
	
	    this.$el = null;
	    this.$parent = options.parent;
	    this.$root = this.$parent ? this.$parent.$root : this;
	    this.$children = [];
	    this.$refs = {}; // child vm references
	    this.$els = {}; // element references
	    this._watchers = []; // all watchers as an array
	    this._directives = []; // all directives
	
	    // a uid
	    this._uid = uid++;
	
	    // a flag to avoid this being observed
	    this._isVue = true;
	
	    // events bookkeeping
	    this._events = {}; // registered callbacks
	    this._eventsCount = {}; // for $broadcast optimization
	
	    // fragment instance properties
	    this._isFragment = false;
	    this._fragment = // @type {DocumentFragment}
	    this._fragmentStart = // @type {Text|Comment}
	    this._fragmentEnd = null; // @type {Text|Comment}
	
	    // lifecycle state
	    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
	    this._unlinkFn = null;
	
	    // context:
	    // if this is a transcluded component, context
	    // will be the common parent vm of this instance
	    // and its host.
	    this._context = options._context || this.$parent;
	
	    // scope:
	    // if this is inside an inline v-for, the scope
	    // will be the intermediate scope created for this
	    // repeat fragment. this is used for linking props
	    // and container directives.
	    this._scope = options._scope;
	
	    // fragment:
	    // if this instance is compiled inside a Fragment, it
	    // needs to reigster itself as a child of that fragment
	    // for attach/detach to work properly.
	    this._frag = options._frag;
	    if (this._frag) {
	      this._frag.children.push(this);
	    }
	
	    // push self into parent / transclusion host
	    if (this.$parent) {
	      this.$parent.$children.push(this);
	    }
	
	    // merge options.
	    options = this.$options = mergeOptions(this.constructor.options, options, this);
	
	    // set ref
	    this._updateRef();
	
	    // initialize data as empty object.
	    // it will be filled up in _initData().
	    this._data = {};
	
	    // call init hook
	    this._callHook('init');
	
	    // initialize data observation and scope inheritance.
	    this._initState();
	
	    // setup event system and option events.
	    this._initEvents();
	
	    // call created hook
	    this._callHook('created');
	
	    // if `el` option is passed, start compilation.
	    if (options.el) {
	      this.$mount(options.el);
	    }
	  };
	}
	
	var pathCache = new Cache(1000);
	
	// actions
	var APPEND = 0;
	var PUSH = 1;
	var INC_SUB_PATH_DEPTH = 2;
	var PUSH_SUB_PATH = 3;
	
	// states
	var BEFORE_PATH = 0;
	var IN_PATH = 1;
	var BEFORE_IDENT = 2;
	var IN_IDENT = 3;
	var IN_SUB_PATH = 4;
	var IN_SINGLE_QUOTE = 5;
	var IN_DOUBLE_QUOTE = 6;
	var AFTER_PATH = 7;
	var ERROR = 8;
	
	var pathStateMachine = [];
	
	pathStateMachine[BEFORE_PATH] = {
	  'ws': [BEFORE_PATH],
	  'ident': [IN_IDENT, APPEND],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[IN_PATH] = {
	  'ws': [IN_PATH],
	  '.': [BEFORE_IDENT],
	  '[': [IN_SUB_PATH],
	  'eof': [AFTER_PATH]
	};
	
	pathStateMachine[BEFORE_IDENT] = {
	  'ws': [BEFORE_IDENT],
	  'ident': [IN_IDENT, APPEND]
	};
	
	pathStateMachine[IN_IDENT] = {
	  'ident': [IN_IDENT, APPEND],
	  '0': [IN_IDENT, APPEND],
	  'number': [IN_IDENT, APPEND],
	  'ws': [IN_PATH, PUSH],
	  '.': [BEFORE_IDENT, PUSH],
	  '[': [IN_SUB_PATH, PUSH],
	  'eof': [AFTER_PATH, PUSH]
	};
	
	pathStateMachine[IN_SUB_PATH] = {
	  "'": [IN_SINGLE_QUOTE, APPEND],
	  '"': [IN_DOUBLE_QUOTE, APPEND],
	  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
	  ']': [IN_PATH, PUSH_SUB_PATH],
	  'eof': ERROR,
	  'else': [IN_SUB_PATH, APPEND]
	};
	
	pathStateMachine[IN_SINGLE_QUOTE] = {
	  "'": [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_SINGLE_QUOTE, APPEND]
	};
	
	pathStateMachine[IN_DOUBLE_QUOTE] = {
	  '"': [IN_SUB_PATH, APPEND],
	  'eof': ERROR,
	  'else': [IN_DOUBLE_QUOTE, APPEND]
	};
	
	/**
	 * Determine the type of a character in a keypath.
	 *
	 * @param {Char} ch
	 * @return {String} type
	 */
	
	function getPathCharType(ch) {
	  if (ch === undefined) {
	    return 'eof';
	  }
	
	  var code = ch.charCodeAt(0);
	
	  switch (code) {
	    case 0x5B: // [
	    case 0x5D: // ]
	    case 0x2E: // .
	    case 0x22: // "
	    case 0x27: // '
	    case 0x30:
	      // 0
	      return ch;
	
	    case 0x5F: // _
	    case 0x24:
	      // $
	      return 'ident';
	
	    case 0x20: // Space
	    case 0x09: // Tab
	    case 0x0A: // Newline
	    case 0x0D: // Return
	    case 0xA0: // No-break space
	    case 0xFEFF: // Byte Order Mark
	    case 0x2028: // Line Separator
	    case 0x2029:
	      // Paragraph Separator
	      return 'ws';
	  }
	
	  // a-z, A-Z
	  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
	    return 'ident';
	  }
	
	  // 1-9
	  if (code >= 0x31 && code <= 0x39) {
	    return 'number';
	  }
	
	  return 'else';
	}
	
	/**
	 * Format a subPath, return its plain form if it is
	 * a literal string or number. Otherwise prepend the
	 * dynamic indicator (*).
	 *
	 * @param {String} path
	 * @return {String}
	 */
	
	function formatSubPath(path) {
	  var trimmed = path.trim();
	  // invalid leading 0
	  if (path.charAt(0) === '0' && isNaN(path)) {
	    return false;
	  }
	  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
	}
	
	/**
	 * Parse a string path into an array of segments
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parse(path) {
	  var keys = [];
	  var index = -1;
	  var mode = BEFORE_PATH;
	  var subPathDepth = 0;
	  var c, newChar, key, type, transition, action, typeMap;
	
	  var actions = [];
	
	  actions[PUSH] = function () {
	    if (key !== undefined) {
	      keys.push(key);
	      key = undefined;
	    }
	  };
	
	  actions[APPEND] = function () {
	    if (key === undefined) {
	      key = newChar;
	    } else {
	      key += newChar;
	    }
	  };
	
	  actions[INC_SUB_PATH_DEPTH] = function () {
	    actions[APPEND]();
	    subPathDepth++;
	  };
	
	  actions[PUSH_SUB_PATH] = function () {
	    if (subPathDepth > 0) {
	      subPathDepth--;
	      mode = IN_SUB_PATH;
	      actions[APPEND]();
	    } else {
	      subPathDepth = 0;
	      key = formatSubPath(key);
	      if (key === false) {
	        return false;
	      } else {
	        actions[PUSH]();
	      }
	    }
	  };
	
	  function maybeUnescapeQuote() {
	    var nextChar = path[index + 1];
	    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
	      index++;
	      newChar = '\\' + nextChar;
	      actions[APPEND]();
	      return true;
	    }
	  }
	
	  while (mode != null) {
	    index++;
	    c = path[index];
	
	    if (c === '\\' && maybeUnescapeQuote()) {
	      continue;
	    }
	
	    type = getPathCharType(c);
	    typeMap = pathStateMachine[mode];
	    transition = typeMap[type] || typeMap['else'] || ERROR;
	
	    if (transition === ERROR) {
	      return; // parse error
	    }
	
	    mode = transition[0];
	    action = actions[transition[1]];
	    if (action) {
	      newChar = transition[2];
	      newChar = newChar === undefined ? c : newChar;
	      if (action() === false) {
	        return;
	      }
	    }
	
	    if (mode === AFTER_PATH) {
	      keys.raw = path;
	      return keys;
	    }
	  }
	}
	
	/**
	 * External parse that check for a cache hit first
	 *
	 * @param {String} path
	 * @return {Array|undefined}
	 */
	
	function parsePath(path) {
	  var hit = pathCache.get(path);
	  if (!hit) {
	    hit = parse(path);
	    if (hit) {
	      pathCache.put(path, hit);
	    }
	  }
	  return hit;
	}
	
	/**
	 * Get from an object from a path string
	 *
	 * @param {Object} obj
	 * @param {String} path
	 */
	
	function getPath(obj, path) {
	  return parseExpression(path).get(obj);
	}
	
	/**
	 * Warn against setting non-existent root path on a vm.
	 */
	
	var warnNonExistent;
	if (process.env.NODE_ENV !== 'production') {
	  warnNonExistent = function (path, vm) {
	    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
	  };
	}
	
	/**
	 * Set on an object from a path
	 *
	 * @param {Object} obj
	 * @param {String | Array} path
	 * @param {*} val
	 */
	
	function setPath(obj, path, val) {
	  var original = obj;
	  if (typeof path === 'string') {
	    path = parse(path);
	  }
	  if (!path || !isObject(obj)) {
	    return false;
	  }
	  var last, key;
	  for (var i = 0, l = path.length; i < l; i++) {
	    last = obj;
	    key = path[i];
	    if (key.charAt(0) === '*') {
	      key = parseExpression(key.slice(1)).get.call(original, original);
	    }
	    if (i < l - 1) {
	      obj = obj[key];
	      if (!isObject(obj)) {
	        obj = {};
	        if (process.env.NODE_ENV !== 'production' && last._isVue) {
	          warnNonExistent(path, last);
	        }
	        set(last, key, obj);
	      }
	    } else {
	      if (isArray(obj)) {
	        obj.$set(key, val);
	      } else if (key in obj) {
	        obj[key] = val;
	      } else {
	        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
	          warnNonExistent(path, obj);
	        }
	        set(obj, key, val);
	      }
	    }
	  }
	  return true;
	}
	
	var path = Object.freeze({
	  parsePath: parsePath,
	  getPath: getPath,
	  setPath: setPath
	});
	
	var expressionCache = new Cache(1000);
	
	var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
	var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	// keywords that don't make sense inside expressions
	var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
	var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
	
	var wsRE = /\s/g;
	var newlineRE = /\n/g;
	var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
	var restoreRE = /"(\d+)"/g;
	var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
	var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
	var booleanLiteralRE = /^(?:true|false)$/;
	
	/**
	 * Save / Rewrite / Restore
	 *
	 * When rewriting paths found in an expression, it is
	 * possible for the same letter sequences to be found in
	 * strings and Object literal property keys. Therefore we
	 * remove and store these parts in a temporary array, and
	 * restore them after the path rewrite.
	 */
	
	var saved = [];
	
	/**
	 * Save replacer
	 *
	 * The save regex can match two possible cases:
	 * 1. An opening object literal
	 * 2. A string
	 * If matched as a plain string, we need to escape its
	 * newlines, since the string needs to be preserved when
	 * generating the function body.
	 *
	 * @param {String} str
	 * @param {String} isString - str if matched as a string
	 * @return {String} - placeholder with index
	 */
	
	function save(str, isString) {
	  var i = saved.length;
	  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
	  return '"' + i + '"';
	}
	
	/**
	 * Path rewrite replacer
	 *
	 * @param {String} raw
	 * @return {String}
	 */
	
	function rewrite(raw) {
	  var c = raw.charAt(0);
	  var path = raw.slice(1);
	  if (allowedKeywordsRE.test(path)) {
	    return raw;
	  } else {
	    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
	    return c + 'scope.' + path;
	  }
	}
	
	/**
	 * Restore replacer
	 *
	 * @param {String} str
	 * @param {String} i - matched save index
	 * @return {String}
	 */
	
	function restore(str, i) {
	  return saved[i];
	}
	
	/**
	 * Rewrite an expression, prefixing all path accessors with
	 * `scope.` and generate getter/setter functions.
	 *
	 * @param {String} exp
	 * @return {Function}
	 */
	
	function compileGetter(exp) {
	  if (improperKeywordsRE.test(exp)) {
	    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
	  }
	  // reset state
	  saved.length = 0;
	  // save strings and object literal keys
	  var body = exp.replace(saveRE, save).replace(wsRE, '');
	  // rewrite all paths
	  // pad 1 space here becaue the regex matches 1 extra char
	  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
	  return makeGetterFn(body);
	}
	
	/**
	 * Build a getter function. Requires eval.
	 *
	 * We isolate the try/catch so it doesn't affect the
	 * optimization of the parse function when it is not called.
	 *
	 * @param {String} body
	 * @return {Function|undefined}
	 */
	
	function makeGetterFn(body) {
	  try {
	    /* eslint-disable no-new-func */
	    return new Function('scope', 'return ' + body + ';');
	    /* eslint-enable no-new-func */
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
	  }
	}
	
	/**
	 * Compile a setter function for the expression.
	 *
	 * @param {String} exp
	 * @return {Function|undefined}
	 */
	
	function compileSetter(exp) {
	  var path = parsePath(exp);
	  if (path) {
	    return function (scope, val) {
	      setPath(scope, path, val);
	    };
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
	  }
	}
	
	/**
	 * Parse an expression into re-written getter/setters.
	 *
	 * @param {String} exp
	 * @param {Boolean} needSet
	 * @return {Function}
	 */
	
	function parseExpression(exp, needSet) {
	  exp = exp.trim();
	  // try cache
	  var hit = expressionCache.get(exp);
	  if (hit) {
	    if (needSet && !hit.set) {
	      hit.set = compileSetter(hit.exp);
	    }
	    return hit;
	  }
	  var res = { exp: exp };
	  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
	  // optimized super simple getter
	  ? makeGetterFn('scope.' + exp)
	  // dynamic getter
	  : compileGetter(exp);
	  if (needSet) {
	    res.set = compileSetter(exp);
	  }
	  expressionCache.put(exp, res);
	  return res;
	}
	
	/**
	 * Check if an expression is a simple path.
	 *
	 * @param {String} exp
	 * @return {Boolean}
	 */
	
	function isSimplePath(exp) {
	  return pathTestRE.test(exp) &&
	  // don't treat true/false as paths
	  !booleanLiteralRE.test(exp) &&
	  // Math constants e.g. Math.PI, Math.E etc.
	  exp.slice(0, 5) !== 'Math.';
	}
	
	var expression = Object.freeze({
	  parseExpression: parseExpression,
	  isSimplePath: isSimplePath
	});
	
	// we have two separate queues: one for directive updates
	// and one for user watcher registered via $watch().
	// we want to guarantee directive updates to be called
	// before user watchers so that when user watchers are
	// triggered, the DOM would have already been in updated
	// state.
	
	var queue = [];
	var userQueue = [];
	var has = {};
	var circular = {};
	var waiting = false;
	
	/**
	 * Reset the batcher's state.
	 */
	
	function resetBatcherState() {
	  queue.length = 0;
	  userQueue.length = 0;
	  has = {};
	  circular = {};
	  waiting = false;
	}
	
	/**
	 * Flush both queues and run the watchers.
	 */
	
	function flushBatcherQueue() {
	  var _again = true;
	
	  _function: while (_again) {
	    _again = false;
	
	    runBatcherQueue(queue);
	    runBatcherQueue(userQueue);
	    // user watchers triggered more watchers,
	    // keep flushing until it depletes
	    if (queue.length) {
	      _again = true;
	      continue _function;
	    }
	    // dev tool hook
	    /* istanbul ignore if */
	    if (devtools && config.devtools) {
	      devtools.emit('flush');
	    }
	    resetBatcherState();
	  }
	}
	
	/**
	 * Run the watchers in a single queue.
	 *
	 * @param {Array} queue
	 */
	
	function runBatcherQueue(queue) {
	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (var i = 0; i < queue.length; i++) {
	    var watcher = queue[i];
	    var id = watcher.id;
	    has[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
	        break;
	      }
	    }
	  }
	  queue.length = 0;
	}
	
	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 *
	 * @param {Watcher} watcher
	 *   properties:
	 *   - {Number} id
	 *   - {Function} run
	 */
	
	function pushWatcher(watcher) {
	  var id = watcher.id;
	  if (has[id] == null) {
	    // push watcher into appropriate queue
	    var q = watcher.user ? userQueue : queue;
	    has[id] = q.length;
	    q.push(watcher);
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushBatcherQueue);
	    }
	  }
	}
	
	var uid$2 = 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    extend(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid$2; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  this.prevError = null; // for async error stacks
	  // parse expression for getter/setter
	  if (isFn) {
	    this.getter = expOrFn;
	    this.setter = undefined;
	  } else {
	    var res = parseExpression(expOrFn, this.twoWay);
	    this.getter = res.get;
	    this.setter = res.set;
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var scope = this.scope || this.vm;
	  var value;
	  try {
	    value = this.getter.call(scope, scope);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  if (this.preProcess) {
	    value = this.preProcess(value);
	  }
	  if (this.filters) {
	    value = scope._applyFilters(value, null, this.filters, false);
	  }
	  if (this.postProcess) {
	    value = this.postProcess(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Set the corresponding value with the setter.
	 *
	 * @param {*} value
	 */
	
	Watcher.prototype.set = function (value) {
	  var scope = this.scope || this.vm;
	  if (this.filters) {
	    value = scope._applyFilters(value, this.value, this.filters, true);
	  }
	  try {
	    this.setter.call(scope, scope, value);
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
	      warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
	    }
	  }
	  // two-way sync for v-for alias
	  var forContext = scope.$forContext;
	  if (forContext && forContext.alias === this.expression) {
	    if (forContext.filters) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
	      return;
	    }
	    forContext._withLock(function () {
	      if (scope.$key) {
	        // original is an object
	        forContext.rawValue[scope.$key] = value;
	      } else {
	        forContext.rawValue.$set(scope.$index, value);
	      }
	    });
	  }
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  Dep.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  Dep.target = null;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync || !config.async) {
	    this.run();
	  } else {
	    // if queued, only overwrite shallow with non-shallow,
	    // but not the other way around.
	    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
	    this.queued = true;
	    // record before-push error stack in debug mode
	    /* istanbul ignore if */
	    if (process.env.NODE_ENV !== 'production' && config.debug) {
	      this.prevError = new Error('[vue] async stack trace');
	    }
	    pushWatcher(this);
	  }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    (isObject(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      // in debug + async mode, when a watcher callbacks
	      // throws, we also throw the saved before-push error
	      // so the full cross-tick stack trace is available.
	      var prevError = this.prevError;
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
	        this.prevError = null;
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          nextTick(function () {
	            throw prevError;
	          }, 0);
	          throw e;
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = Dep.target;
	  this.value = this.get();
	  this.dirty = false;
	  Dep.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      this.vm._watchers.$remove(this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 */
	
	var seenObjects = new _Set();
	function traverse(val, seen) {
	  var i = undefined,
	      keys = undefined;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  var isA = isArray(val);
	  var isO = isObject(val);
	  if (isA || isO) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) traverse(val[i], seen);
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) traverse(val[keys[i]], seen);
	    }
	  }
	}
	
	var text$1 = {
	
	  bind: function bind() {
	    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
	  },
	
	  update: function update(value) {
	    this.el[this.attr] = _toString(value);
	  }
	};
	
	var templateCache = new Cache(1000);
	var idSelectorCache = new Cache(1000);
	
	var map = {
	  efault: [0, '', ''],
	  legend: [1, '<fieldset>', '</fieldset>'],
	  tr: [2, '<table><tbody>', '</tbody></table>'],
	  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
	};
	
	map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
	
	map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
	
	map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
	
	/**
	 * Check if a node is a supported template node with a
	 * DocumentFragment content.
	 *
	 * @param {Node} node
	 * @return {Boolean}
	 */
	
	function isRealTemplate(node) {
	  return isTemplate(node) && isFragment(node.content);
	}
	
	var tagRE$1 = /<([\w:-]+)/;
	var entityRE = /&#?\w+?;/;
	
	/**
	 * Convert a string template to a DocumentFragment.
	 * Determines correct wrapping by tag types. Wrapping
	 * strategy found in jQuery & component/domify.
	 *
	 * @param {String} templateString
	 * @param {Boolean} raw
	 * @return {DocumentFragment}
	 */
	
	function stringToFragment(templateString, raw) {
	  // try a cache hit first
	  var cacheKey = raw ? templateString : templateString.trim();
	  var hit = templateCache.get(cacheKey);
	  if (hit) {
	    return hit;
	  }
	
	  var frag = document.createDocumentFragment();
	  var tagMatch = templateString.match(tagRE$1);
	  var entityMatch = entityRE.test(templateString);
	
	  if (!tagMatch && !entityMatch) {
	    // text only, return a single text node.
	    frag.appendChild(document.createTextNode(templateString));
	  } else {
	    var tag = tagMatch && tagMatch[1];
	    var wrap = map[tag] || map.efault;
	    var depth = wrap[0];
	    var prefix = wrap[1];
	    var suffix = wrap[2];
	    var node = document.createElement('div');
	
	    node.innerHTML = prefix + templateString + suffix;
	    while (depth--) {
	      node = node.lastChild;
	    }
	
	    var child;
	    /* eslint-disable no-cond-assign */
	    while (child = node.firstChild) {
	      /* eslint-enable no-cond-assign */
	      frag.appendChild(child);
	    }
	  }
	  if (!raw) {
	    trimNode(frag);
	  }
	  templateCache.put(cacheKey, frag);
	  return frag;
	}
	
	/**
	 * Convert a template node to a DocumentFragment.
	 *
	 * @param {Node} node
	 * @return {DocumentFragment}
	 */
	
	function nodeToFragment(node) {
	  // if its a template tag and the browser supports it,
	  // its content is already a document fragment. However, iOS Safari has
	  // bug when using directly cloned template content with touch
	  // events and can cause crashes when the nodes are removed from DOM, so we
	  // have to treat template elements as string templates. (#2805)
	  /* istanbul ignore if */
	  if (isRealTemplate(node)) {
	    return stringToFragment(node.innerHTML);
	  }
	  // script template
	  if (node.tagName === 'SCRIPT') {
	    return stringToFragment(node.textContent);
	  }
	  // normal node, clone it to avoid mutating the original
	  var clonedNode = cloneNode(node);
	  var frag = document.createDocumentFragment();
	  var child;
	  /* eslint-disable no-cond-assign */
	  while (child = clonedNode.firstChild) {
	    /* eslint-enable no-cond-assign */
	    frag.appendChild(child);
	  }
	  trimNode(frag);
	  return frag;
	}
	
	// Test for the presence of the Safari template cloning bug
	// https://bugs.webkit.org/showug.cgi?id=137755
	var hasBrokenTemplate = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var a = document.createElement('div');
	    a.innerHTML = '<template>1</template>';
	    return !a.cloneNode(true).firstChild.innerHTML;
	  } else {
	    return false;
	  }
	})();
	
	// Test for IE10/11 textarea placeholder clone bug
	var hasTextareaCloneBug = (function () {
	  /* istanbul ignore else */
	  if (inBrowser) {
	    var t = document.createElement('textarea');
	    t.placeholder = 't';
	    return t.cloneNode(true).value === 't';
	  } else {
	    return false;
	  }
	})();
	
	/**
	 * 1. Deal with Safari cloning nested <template> bug by
	 *    manually cloning all template instances.
	 * 2. Deal with IE10/11 textarea placeholder bug by setting
	 *    the correct value after cloning.
	 *
	 * @param {Element|DocumentFragment} node
	 * @return {Element|DocumentFragment}
	 */
	
	function cloneNode(node) {
	  /* istanbul ignore if */
	  if (!node.querySelectorAll) {
	    return node.cloneNode();
	  }
	  var res = node.cloneNode(true);
	  var i, original, cloned;
	  /* istanbul ignore if */
	  if (hasBrokenTemplate) {
	    var tempClone = res;
	    if (isRealTemplate(node)) {
	      node = node.content;
	      tempClone = res.content;
	    }
	    original = node.querySelectorAll('template');
	    if (original.length) {
	      cloned = tempClone.querySelectorAll('template');
	      i = cloned.length;
	      while (i--) {
	        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
	      }
	    }
	  }
	  /* istanbul ignore if */
	  if (hasTextareaCloneBug) {
	    if (node.tagName === 'TEXTAREA') {
	      res.value = node.value;
	    } else {
	      original = node.querySelectorAll('textarea');
	      if (original.length) {
	        cloned = res.querySelectorAll('textarea');
	        i = cloned.length;
	        while (i--) {
	          cloned[i].value = original[i].value;
	        }
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Process the template option and normalizes it into a
	 * a DocumentFragment that can be used as a partial or a
	 * instance template.
	 *
	 * @param {*} template
	 *        Possible values include:
	 *        - DocumentFragment object
	 *        - Node object of type Template
	 *        - id selector: '#some-template-id'
	 *        - template string: '<div><span>{{msg}}</span></div>'
	 * @param {Boolean} shouldClone
	 * @param {Boolean} raw
	 *        inline HTML interpolation. Do not check for id
	 *        selector and keep whitespace in the string.
	 * @return {DocumentFragment|undefined}
	 */
	
	function parseTemplate(template, shouldClone, raw) {
	  var node, frag;
	
	  // if the template is already a document fragment,
	  // do nothing
	  if (isFragment(template)) {
	    trimNode(template);
	    return shouldClone ? cloneNode(template) : template;
	  }
	
	  if (typeof template === 'string') {
	    // id selector
	    if (!raw && template.charAt(0) === '#') {
	      // id selector can be cached too
	      frag = idSelectorCache.get(template);
	      if (!frag) {
	        node = document.getElementById(template.slice(1));
	        if (node) {
	          frag = nodeToFragment(node);
	          // save selector to cache
	          idSelectorCache.put(template, frag);
	        }
	      }
	    } else {
	      // normal string template
	      frag = stringToFragment(template, raw);
	    }
	  } else if (template.nodeType) {
	    // a direct node
	    frag = nodeToFragment(template);
	  }
	
	  return frag && shouldClone ? cloneNode(frag) : frag;
	}
	
	var template = Object.freeze({
	  cloneNode: cloneNode,
	  parseTemplate: parseTemplate
	});
	
	var html = {
	
	  bind: function bind() {
	    // a comment node means this is a binding for
	    // {{{ inline unescaped html }}}
	    if (this.el.nodeType === 8) {
	      // hold nodes
	      this.nodes = [];
	      // replace the placeholder with proper anchor
	      this.anchor = createAnchor('v-html');
	      replace(this.el, this.anchor);
	    }
	  },
	
	  update: function update(value) {
	    value = _toString(value);
	    if (this.nodes) {
	      this.swap(value);
	    } else {
	      this.el.innerHTML = value;
	    }
	  },
	
	  swap: function swap(value) {
	    // remove old nodes
	    var i = this.nodes.length;
	    while (i--) {
	      remove(this.nodes[i]);
	    }
	    // convert new value to a fragment
	    // do not attempt to retrieve from id selector
	    var frag = parseTemplate(value, true, true);
	    // save a reference to these nodes so we can remove later
	    this.nodes = toArray(frag.childNodes);
	    before(frag, this.anchor);
	  }
	};
	
	/**
	 * Abstraction for a partially-compiled fragment.
	 * Can optionally compile content with a child scope.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 * @param {DocumentFragment} frag
	 * @param {Vue} [host]
	 * @param {Object} [scope]
	 * @param {Fragment} [parentFrag]
	 */
	function Fragment(linker, vm, frag, host, scope, parentFrag) {
	  this.children = [];
	  this.childFrags = [];
	  this.vm = vm;
	  this.scope = scope;
	  this.inserted = false;
	  this.parentFrag = parentFrag;
	  if (parentFrag) {
	    parentFrag.childFrags.push(this);
	  }
	  this.unlink = linker(vm, frag, host, scope, this);
	  var single = this.single = frag.childNodes.length === 1 &&
	  // do not go single mode if the only node is an anchor
	  !frag.childNodes[0].__v_anchor;
	  if (single) {
	    this.node = frag.childNodes[0];
	    this.before = singleBefore;
	    this.remove = singleRemove;
	  } else {
	    this.node = createAnchor('fragment-start');
	    this.end = createAnchor('fragment-end');
	    this.frag = frag;
	    prepend(this.node, frag);
	    frag.appendChild(this.end);
	    this.before = multiBefore;
	    this.remove = multiRemove;
	  }
	  this.node.__v_frag = this;
	}
	
	/**
	 * Call attach/detach for all components contained within
	 * this fragment. Also do so recursively for all child
	 * fragments.
	 *
	 * @param {Function} hook
	 */
	
	Fragment.prototype.callHook = function (hook) {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    this.childFrags[i].callHook(hook);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    hook(this.children[i]);
	  }
	};
	
	/**
	 * Insert fragment before target, single node version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function singleBefore(target, withTransition) {
	  this.inserted = true;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  method(this.node, target, this.vm);
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, single node version
	 */
	
	function singleRemove() {
	  this.inserted = false;
	  var shouldCallRemove = inDoc(this.node);
	  var self = this;
	  this.beforeRemove();
	  removeWithTransition(this.node, this.vm, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Insert fragment before target, multi-nodes version
	 *
	 * @param {Node} target
	 * @param {Boolean} withTransition
	 */
	
	function multiBefore(target, withTransition) {
	  this.inserted = true;
	  var vm = this.vm;
	  var method = withTransition !== false ? beforeWithTransition : before;
	  mapNodeRange(this.node, this.end, function (node) {
	    method(node, target, vm);
	  });
	  if (inDoc(this.node)) {
	    this.callHook(attach);
	  }
	}
	
	/**
	 * Remove fragment, multi-nodes version
	 */
	
	function multiRemove() {
	  this.inserted = false;
	  var self = this;
	  var shouldCallRemove = inDoc(this.node);
	  this.beforeRemove();
	  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
	    if (shouldCallRemove) {
	      self.callHook(detach);
	    }
	    self.destroy();
	  });
	}
	
	/**
	 * Prepare the fragment for removal.
	 */
	
	Fragment.prototype.beforeRemove = function () {
	  var i, l;
	  for (i = 0, l = this.childFrags.length; i < l; i++) {
	    // call the same method recursively on child
	    // fragments, depth-first
	    this.childFrags[i].beforeRemove(false);
	  }
	  for (i = 0, l = this.children.length; i < l; i++) {
	    // Call destroy for all contained instances,
	    // with remove:false and defer:true.
	    // Defer is necessary because we need to
	    // keep the children to call detach hooks
	    // on them.
	    this.children[i].$destroy(false, true);
	  }
	  var dirs = this.unlink.dirs;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    // disable the watchers on all the directives
	    // so that the rendered content stays the same
	    // during removal.
	    dirs[i]._watcher && dirs[i]._watcher.teardown();
	  }
	};
	
	/**
	 * Destroy the fragment.
	 */
	
	Fragment.prototype.destroy = function () {
	  if (this.parentFrag) {
	    this.parentFrag.childFrags.$remove(this);
	  }
	  this.node.__v_frag = null;
	  this.unlink();
	};
	
	/**
	 * Call attach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function attach(child) {
	  if (!child._isAttached && inDoc(child.$el)) {
	    child._callHook('attached');
	  }
	}
	
	/**
	 * Call detach hook for a Vue instance.
	 *
	 * @param {Vue} child
	 */
	
	function detach(child) {
	  if (child._isAttached && !inDoc(child.$el)) {
	    child._callHook('detached');
	  }
	}
	
	var linkerCache = new Cache(5000);
	
	/**
	 * A factory that can be used to create instances of a
	 * fragment. Caches the compiled linker if possible.
	 *
	 * @param {Vue} vm
	 * @param {Element|String} el
	 */
	function FragmentFactory(vm, el) {
	  this.vm = vm;
	  var template;
	  var isString = typeof el === 'string';
	  if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
	    template = parseTemplate(el, true);
	  } else {
	    template = document.createDocumentFragment();
	    template.appendChild(el);
	  }
	  this.template = template;
	  // linker can be cached, but only for components
	  var linker;
	  var cid = vm.constructor.cid;
	  if (cid > 0) {
	    var cacheId = cid + (isString ? el : getOuterHTML(el));
	    linker = linkerCache.get(cacheId);
	    if (!linker) {
	      linker = compile(template, vm.$options, true);
	      linkerCache.put(cacheId, linker);
	    }
	  } else {
	    linker = compile(template, vm.$options, true);
	  }
	  this.linker = linker;
	}
	
	/**
	 * Create a fragment instance with given host and scope.
	 *
	 * @param {Vue} host
	 * @param {Object} scope
	 * @param {Fragment} parentFrag
	 */
	
	FragmentFactory.prototype.create = function (host, scope, parentFrag) {
	  var frag = cloneNode(this.template);
	  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
	};
	
	var ON = 700;
	var MODEL = 800;
	var BIND = 850;
	var TRANSITION = 1100;
	var EL = 1500;
	var COMPONENT = 1500;
	var PARTIAL = 1750;
	var IF = 2100;
	var FOR = 2200;
	var SLOT = 2300;
	
	var uid$3 = 0;
	
	var vFor = {
	
	  priority: FOR,
	  terminal: true,
	
	  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
	
	  bind: function bind() {
	    // support "item in/of items" syntax
	    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
	    if (inMatch) {
	      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
	      if (itMatch) {
	        this.iterator = itMatch[1].trim();
	        this.alias = itMatch[2].trim();
	      } else {
	        this.alias = inMatch[1].trim();
	      }
	      this.expression = inMatch[2];
	    }
	
	    if (!this.alias) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
	      return;
	    }
	
	    // uid as a cache identifier
	    this.id = '__v-for__' + ++uid$3;
	
	    // check if this is an option list,
	    // so that we know if we need to update the <select>'s
	    // v-model when the option list has changed.
	    // because v-model has a lower priority than v-for,
	    // the v-model is not bound here yet, so we have to
	    // retrive it in the actual updateModel() function.
	    var tag = this.el.tagName;
	    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
	
	    // setup anchor nodes
	    this.start = createAnchor('v-for-start');
	    this.end = createAnchor('v-for-end');
	    replace(this.el, this.end);
	    before(this.start, this.end);
	
	    // cache
	    this.cache = Object.create(null);
	
	    // fragment factory
	    this.factory = new FragmentFactory(this.vm, this.el);
	  },
	
	  update: function update(data) {
	    this.diff(data);
	    this.updateRef();
	    this.updateModel();
	  },
	
	  /**
	   * Diff, based on new data and old data, determine the
	   * minimum amount of DOM manipulations needed to make the
	   * DOM reflect the new data Array.
	   *
	   * The algorithm diffs the new data Array by storing a
	   * hidden reference to an owner vm instance on previously
	   * seen data. This allows us to achieve O(n) which is
	   * better than a levenshtein distance based algorithm,
	   * which is O(m * n).
	   *
	   * @param {Array} data
	   */
	
	  diff: function diff(data) {
	    // check if the Array was converted from an Object
	    var item = data[0];
	    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
	
	    var trackByKey = this.params.trackBy;
	    var oldFrags = this.frags;
	    var frags = this.frags = new Array(data.length);
	    var alias = this.alias;
	    var iterator = this.iterator;
	    var start = this.start;
	    var end = this.end;
	    var inDocument = inDoc(start);
	    var init = !oldFrags;
	    var i, l, frag, key, value, primitive;
	
	    // First pass, go through the new Array and fill up
	    // the new frags array. If a piece of data has a cached
	    // instance for it, we reuse it. Otherwise build a new
	    // instance.
	    for (i = 0, l = data.length; i < l; i++) {
	      item = data[i];
	      key = convertedFromObject ? item.$key : null;
	      value = convertedFromObject ? item.$value : item;
	      primitive = !isObject(value);
	      frag = !init && this.getCachedFrag(value, i, key);
	      if (frag) {
	        // reusable fragment
	        frag.reused = true;
	        // update $index
	        frag.scope.$index = i;
	        // update $key
	        if (key) {
	          frag.scope.$key = key;
	        }
	        // update iterator
	        if (iterator) {
	          frag.scope[iterator] = key !== null ? key : i;
	        }
	        // update data for track-by, object repeat &
	        // primitive values.
	        if (trackByKey || convertedFromObject || primitive) {
	          withoutConversion(function () {
	            frag.scope[alias] = value;
	          });
	        }
	      } else {
	        // new isntance
	        frag = this.create(value, alias, i, key);
	        frag.fresh = !init;
	      }
	      frags[i] = frag;
	      if (init) {
	        frag.before(end);
	      }
	    }
	
	    // we're done for the initial render.
	    if (init) {
	      return;
	    }
	
	    // Second pass, go through the old fragments and
	    // destroy those who are not reused (and remove them
	    // from cache)
	    var removalIndex = 0;
	    var totalRemoved = oldFrags.length - frags.length;
	    // when removing a large number of fragments, watcher removal
	    // turns out to be a perf bottleneck, so we batch the watcher
	    // removals into a single filter call!
	    this.vm._vForRemoving = true;
	    for (i = 0, l = oldFrags.length; i < l; i++) {
	      frag = oldFrags[i];
	      if (!frag.reused) {
	        this.deleteCachedFrag(frag);
	        this.remove(frag, removalIndex++, totalRemoved, inDocument);
	      }
	    }
	    this.vm._vForRemoving = false;
	    if (removalIndex) {
	      this.vm._watchers = this.vm._watchers.filter(function (w) {
	        return w.active;
	      });
	    }
	
	    // Final pass, move/insert new fragments into the
	    // right place.
	    var targetPrev, prevEl, currentPrev;
	    var insertionIndex = 0;
	    for (i = 0, l = frags.length; i < l; i++) {
	      frag = frags[i];
	      // this is the frag that we should be after
	      targetPrev = frags[i - 1];
	      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
	      if (frag.reused && !frag.staggerCb) {
	        currentPrev = findPrevFrag(frag, start, this.id);
	        if (currentPrev !== targetPrev && (!currentPrev ||
	        // optimization for moving a single item.
	        // thanks to suggestions by @livoras in #1807
	        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
	          this.move(frag, prevEl);
	        }
	      } else {
	        // new instance, or still in stagger.
	        // insert with updated stagger index.
	        this.insert(frag, insertionIndex++, prevEl, inDocument);
	      }
	      frag.reused = frag.fresh = false;
	    }
	  },
	
	  /**
	   * Create a new fragment instance.
	   *
	   * @param {*} value
	   * @param {String} alias
	   * @param {Number} index
	   * @param {String} [key]
	   * @return {Fragment}
	   */
	
	  create: function create(value, alias, index, key) {
	    var host = this._host;
	    // create iteration scope
	    var parentScope = this._scope || this.vm;
	    var scope = Object.create(parentScope);
	    // ref holder for the scope
	    scope.$refs = Object.create(parentScope.$refs);
	    scope.$els = Object.create(parentScope.$els);
	    // make sure point $parent to parent scope
	    scope.$parent = parentScope;
	    // for two-way binding on alias
	    scope.$forContext = this;
	    // define scope properties
	    // important: define the scope alias without forced conversion
	    // so that frozen data structures remain non-reactive.
	    withoutConversion(function () {
	      defineReactive(scope, alias, value);
	    });
	    defineReactive(scope, '$index', index);
	    if (key) {
	      defineReactive(scope, '$key', key);
	    } else if (scope.$key) {
	      // avoid accidental fallback
	      def(scope, '$key', null);
	    }
	    if (this.iterator) {
	      defineReactive(scope, this.iterator, key !== null ? key : index);
	    }
	    var frag = this.factory.create(host, scope, this._frag);
	    frag.forId = this.id;
	    this.cacheFrag(value, frag, index, key);
	    return frag;
	  },
	
	  /**
	   * Update the v-ref on owner vm.
	   */
	
	  updateRef: function updateRef() {
	    var ref = this.descriptor.ref;
	    if (!ref) return;
	    var hash = (this._scope || this.vm).$refs;
	    var refs;
	    if (!this.fromObject) {
	      refs = this.frags.map(findVmFromFrag);
	    } else {
	      refs = {};
	      this.frags.forEach(function (frag) {
	        refs[frag.scope.$key] = findVmFromFrag(frag);
	      });
	    }
	    hash[ref] = refs;
	  },
	
	  /**
	   * For option lists, update the containing v-model on
	   * parent <select>.
	   */
	
	  updateModel: function updateModel() {
	    if (this.isOption) {
	      var parent = this.start.parentNode;
	      var model = parent && parent.__v_model;
	      if (model) {
	        model.forceUpdate();
	      }
	    }
	  },
	
	  /**
	   * Insert a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Node} prevEl
	   * @param {Boolean} inDocument
	   */
	
	  insert: function insert(frag, index, prevEl, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	    }
	    var staggerAmount = this.getStagger(frag, index, null, 'enter');
	    if (inDocument && staggerAmount) {
	      // create an anchor and insert it synchronously,
	      // so that we can resolve the correct order without
	      // worrying about some elements not inserted yet
	      var anchor = frag.staggerAnchor;
	      if (!anchor) {
	        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
	        anchor.__v_frag = frag;
	      }
	      after(anchor, prevEl);
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.before(anchor);
	        remove(anchor);
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      var target = prevEl.nextSibling;
	      /* istanbul ignore if */
	      if (!target) {
	        // reset end anchor position in case the position was messed up
	        // by an external drag-n-drop library.
	        after(this.end, prevEl);
	        target = this.end;
	      }
	      frag.before(target);
	    }
	  },
	
	  /**
	   * Remove a fragment. Handles staggering.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {Boolean} inDocument
	   */
	
	  remove: function remove(frag, index, total, inDocument) {
	    if (frag.staggerCb) {
	      frag.staggerCb.cancel();
	      frag.staggerCb = null;
	      // it's not possible for the same frag to be removed
	      // twice, so if we have a pending stagger callback,
	      // it means this frag is queued for enter but removed
	      // before its transition started. Since it is already
	      // destroyed, we can just leave it in detached state.
	      return;
	    }
	    var staggerAmount = this.getStagger(frag, index, total, 'leave');
	    if (inDocument && staggerAmount) {
	      var op = frag.staggerCb = cancellable(function () {
	        frag.staggerCb = null;
	        frag.remove();
	      });
	      setTimeout(op, staggerAmount);
	    } else {
	      frag.remove();
	    }
	  },
	
	  /**
	   * Move a fragment to a new position.
	   * Force no transition.
	   *
	   * @param {Fragment} frag
	   * @param {Node} prevEl
	   */
	
	  move: function move(frag, prevEl) {
	    // fix a common issue with Sortable:
	    // if prevEl doesn't have nextSibling, this means it's
	    // been dragged after the end anchor. Just re-position
	    // the end anchor to the end of the container.
	    /* istanbul ignore if */
	    if (!prevEl.nextSibling) {
	      this.end.parentNode.appendChild(this.end);
	    }
	    frag.before(prevEl.nextSibling, false);
	  },
	
	  /**
	   * Cache a fragment using track-by or the object key.
	   *
	   * @param {*} value
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {String} [key]
	   */
	
	  cacheFrag: function cacheFrag(value, frag, index, key) {
	    var trackByKey = this.params.trackBy;
	    var cache = this.cache;
	    var primitive = !isObject(value);
	    var id;
	    if (key || trackByKey || primitive) {
	      id = getTrackByKey(index, key, value, trackByKey);
	      if (!cache[id]) {
	        cache[id] = frag;
	      } else if (trackByKey !== '$index') {
	        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	      }
	    } else {
	      id = this.id;
	      if (hasOwn(value, id)) {
	        if (value[id] === null) {
	          value[id] = frag;
	        } else {
	          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	        }
	      } else if (Object.isExtensible(value)) {
	        def(value, id, frag);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
	      }
	    }
	    frag.raw = value;
	  },
	
	  /**
	   * Get a cached fragment from the value/index/key
	   *
	   * @param {*} value
	   * @param {Number} index
	   * @param {String} key
	   * @return {Fragment}
	   */
	
	  getCachedFrag: function getCachedFrag(value, index, key) {
	    var trackByKey = this.params.trackBy;
	    var primitive = !isObject(value);
	    var frag;
	    if (key || trackByKey || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      frag = this.cache[id];
	    } else {
	      frag = value[this.id];
	    }
	    if (frag && (frag.reused || frag.fresh)) {
	      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
	    }
	    return frag;
	  },
	
	  /**
	   * Delete a fragment from cache.
	   *
	   * @param {Fragment} frag
	   */
	
	  deleteCachedFrag: function deleteCachedFrag(frag) {
	    var value = frag.raw;
	    var trackByKey = this.params.trackBy;
	    var scope = frag.scope;
	    var index = scope.$index;
	    // fix #948: avoid accidentally fall through to
	    // a parent repeater which happens to have $key.
	    var key = hasOwn(scope, '$key') && scope.$key;
	    var primitive = !isObject(value);
	    if (trackByKey || key || primitive) {
	      var id = getTrackByKey(index, key, value, trackByKey);
	      this.cache[id] = null;
	    } else {
	      value[this.id] = null;
	      frag.raw = null;
	    }
	  },
	
	  /**
	   * Get the stagger amount for an insertion/removal.
	   *
	   * @param {Fragment} frag
	   * @param {Number} index
	   * @param {Number} total
	   * @param {String} type
	   */
	
	  getStagger: function getStagger(frag, index, total, type) {
	    type = type + 'Stagger';
	    var trans = frag.node.__v_trans;
	    var hooks = trans && trans.hooks;
	    var hook = hooks && (hooks[type] || hooks.stagger);
	    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
	  },
	
	  /**
	   * Pre-process the value before piping it through the
	   * filters. This is passed to and called by the watcher.
	   */
	
	  _preProcess: function _preProcess(value) {
	    // regardless of type, store the un-filtered raw value.
	    this.rawValue = value;
	    return value;
	  },
	
	  /**
	   * Post-process the value after it has been piped through
	   * the filters. This is passed to and called by the watcher.
	   *
	   * It is necessary for this to be called during the
	   * wathcer's dependency collection phase because we want
	   * the v-for to update when the source Object is mutated.
	   */
	
	  _postProcess: function _postProcess(value) {
	    if (isArray(value)) {
	      return value;
	    } else if (isPlainObject(value)) {
	      // convert plain object to array.
	      var keys = Object.keys(value);
	      var i = keys.length;
	      var res = new Array(i);
	      var key;
	      while (i--) {
	        key = keys[i];
	        res[i] = {
	          $key: key,
	          $value: value[key]
	        };
	      }
	      return res;
	    } else {
	      if (typeof value === 'number' && !isNaN(value)) {
	        value = range(value);
	      }
	      return value || [];
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.descriptor.ref) {
	      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
	    }
	    if (this.frags) {
	      var i = this.frags.length;
	      var frag;
	      while (i--) {
	        frag = this.frags[i];
	        this.deleteCachedFrag(frag);
	        frag.destroy();
	      }
	    }
	  }
	};
	
	/**
	 * Helper to find the previous element that is a fragment
	 * anchor. This is necessary because a destroyed frag's
	 * element could still be lingering in the DOM before its
	 * leaving transition finishes, but its inserted flag
	 * should have been set to false so we can skip them.
	 *
	 * If this is a block repeat, we want to make sure we only
	 * return frag that is bound to this v-for. (see #929)
	 *
	 * @param {Fragment} frag
	 * @param {Comment|Text} anchor
	 * @param {String} id
	 * @return {Fragment}
	 */
	
	function findPrevFrag(frag, anchor, id) {
	  var el = frag.node.previousSibling;
	  /* istanbul ignore if */
	  if (!el) return;
	  frag = el.__v_frag;
	  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
	    el = el.previousSibling;
	    /* istanbul ignore if */
	    if (!el) return;
	    frag = el.__v_frag;
	  }
	  return frag;
	}
	
	/**
	 * Find a vm from a fragment.
	 *
	 * @param {Fragment} frag
	 * @return {Vue|undefined}
	 */
	
	function findVmFromFrag(frag) {
	  var node = frag.node;
	  // handle multi-node frag
	  if (frag.end) {
	    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
	      node = node.nextSibling;
	    }
	  }
	  return node.__vue__;
	}
	
	/**
	 * Create a range array from given number.
	 *
	 * @param {Number} n
	 * @return {Array}
	 */
	
	function range(n) {
	  var i = -1;
	  var ret = new Array(Math.floor(n));
	  while (++i < n) {
	    ret[i] = i;
	  }
	  return ret;
	}
	
	/**
	 * Get the track by key for an item.
	 *
	 * @param {Number} index
	 * @param {String} key
	 * @param {*} value
	 * @param {String} [trackByKey]
	 */
	
	function getTrackByKey(index, key, value, trackByKey) {
	  return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  vFor.warnDuplicate = function (value) {
	    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
	  };
	}
	
	var vIf = {
	
	  priority: IF,
	  terminal: true,
	
	  bind: function bind() {
	    var el = this.el;
	    if (!el.__vue__) {
	      // check else block
	      var next = el.nextElementSibling;
	      if (next && getAttr(next, 'v-else') !== null) {
	        remove(next);
	        this.elseEl = next;
	      }
	      // check main block
	      this.anchor = createAnchor('v-if');
	      replace(el, this.anchor);
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
	      this.invalid = true;
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) return;
	    if (value) {
	      if (!this.frag) {
	        this.insert();
	      }
	    } else {
	      this.remove();
	    }
	  },
	
	  insert: function insert() {
	    if (this.elseFrag) {
	      this.elseFrag.remove();
	      this.elseFrag = null;
	    }
	    // lazy init factory
	    if (!this.factory) {
	      this.factory = new FragmentFactory(this.vm, this.el);
	    }
	    this.frag = this.factory.create(this._host, this._scope, this._frag);
	    this.frag.before(this.anchor);
	  },
	
	  remove: function remove() {
	    if (this.frag) {
	      this.frag.remove();
	      this.frag = null;
	    }
	    if (this.elseEl && !this.elseFrag) {
	      if (!this.elseFactory) {
	        this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
	      }
	      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
	      this.elseFrag.before(this.anchor);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	    if (this.elseFrag) {
	      this.elseFrag.destroy();
	    }
	  }
	};
	
	var show = {
	
	  bind: function bind() {
	    // check else block
	    var next = this.el.nextElementSibling;
	    if (next && getAttr(next, 'v-else') !== null) {
	      this.elseEl = next;
	    }
	  },
	
	  update: function update(value) {
	    this.apply(this.el, value);
	    if (this.elseEl) {
	      this.apply(this.elseEl, !value);
	    }
	  },
	
	  apply: function apply(el, value) {
	    if (inDoc(el)) {
	      applyTransition(el, value ? 1 : -1, toggle, this.vm);
	    } else {
	      toggle();
	    }
	    function toggle() {
	      el.style.display = value ? '' : 'none';
	    }
	  }
	};
	
	var text$2 = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	    var isRange = el.type === 'range';
	    var lazy = this.params.lazy;
	    var number = this.params.number;
	    var debounce = this.params.debounce;
	
	    // handle composition events.
	    //   http://blog.evanyou.me/2014/01/03/composition-event/
	    // skip this for Android because it handles composition
	    // events quite differently. Android doesn't trigger
	    // composition events for language input methods e.g.
	    // Chinese, but instead triggers them for spelling
	    // suggestions... (see Discussion/#162)
	    var composing = false;
	    if (!isAndroid && !isRange) {
	      this.on('compositionstart', function () {
	        composing = true;
	      });
	      this.on('compositionend', function () {
	        composing = false;
	        // in IE11 the "compositionend" event fires AFTER
	        // the "input" event, so the input handler is blocked
	        // at the end... have to call it here.
	        //
	        // #1327: in lazy mode this is unecessary.
	        if (!lazy) {
	          self.listener();
	        }
	      });
	    }
	
	    // prevent messing with the input when user is typing,
	    // and force update on blur.
	    this.focused = false;
	    if (!isRange && !lazy) {
	      this.on('focus', function () {
	        self.focused = true;
	      });
	      this.on('blur', function () {
	        self.focused = false;
	        // do not sync value after fragment removal (#2017)
	        if (!self._frag || self._frag.inserted) {
	          self.rawListener();
	        }
	      });
	    }
	
	    // Now attach the main listener
	    this.listener = this.rawListener = function () {
	      if (composing || !self._bound) {
	        return;
	      }
	      var val = number || isRange ? toNumber(el.value) : el.value;
	      self.set(val);
	      // force update on next tick to avoid lock & same value
	      // also only update when user is not typing
	      nextTick(function () {
	        if (self._bound && !self.focused) {
	          self.update(self._watcher.value);
	        }
	      });
	    };
	
	    // apply debounce
	    if (debounce) {
	      this.listener = _debounce(this.listener, debounce);
	    }
	
	    // Support jQuery events, since jQuery.trigger() doesn't
	    // trigger native events in some cases and some plugins
	    // rely on $.trigger()
	    //
	    // We want to make sure if a listener is attached using
	    // jQuery, it is also removed with jQuery, that's why
	    // we do the check for each directive instance and
	    // store that check result on itself. This also allows
	    // easier test coverage control by unsetting the global
	    // jQuery variable in tests.
	    this.hasjQuery = typeof jQuery === 'function';
	    if (this.hasjQuery) {
	      var method = jQuery.fn.on ? 'on' : 'bind';
	      jQuery(el)[method]('change', this.rawListener);
	      if (!lazy) {
	        jQuery(el)[method]('input', this.listener);
	      }
	    } else {
	      this.on('change', this.rawListener);
	      if (!lazy) {
	        this.on('input', this.listener);
	      }
	    }
	
	    // IE9 doesn't fire input event on backspace/del/cut
	    if (!lazy && isIE9) {
	      this.on('cut', function () {
	        nextTick(self.listener);
	      });
	      this.on('keyup', function (e) {
	        if (e.keyCode === 46 || e.keyCode === 8) {
	          self.listener();
	        }
	      });
	    }
	
	    // set initial value if present
	    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.value = _toString(value);
	  },
	
	  unbind: function unbind() {
	    var el = this.el;
	    if (this.hasjQuery) {
	      var method = jQuery.fn.off ? 'off' : 'unbind';
	      jQuery(el)[method]('change', this.listener);
	      jQuery(el)[method]('input', this.listener);
	    }
	  }
	};
	
	var radio = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      // value overwrite via v-bind:value
	      if (el.hasOwnProperty('_value')) {
	        return el._value;
	      }
	      var val = el.value;
	      if (self.params.number) {
	        val = toNumber(val);
	      }
	      return val;
	    };
	
	    this.listener = function () {
	      self.set(self.getValue());
	    };
	    this.on('change', this.listener);
	
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    this.el.checked = looseEqual(value, this.getValue());
	  }
	};
	
	var select = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    // method to force update DOM using latest value.
	    this.forceUpdate = function () {
	      if (self._watcher) {
	        self.update(self._watcher.get());
	      }
	    };
	
	    // check if this is a multiple select
	    var multiple = this.multiple = el.hasAttribute('multiple');
	
	    // attach listener
	    this.listener = function () {
	      var value = getValue(el, multiple);
	      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
	      self.set(value);
	    };
	    this.on('change', this.listener);
	
	    // if has initial value, set afterBind
	    var initValue = getValue(el, multiple, true);
	    if (multiple && initValue.length || !multiple && initValue !== null) {
	      this.afterBind = this.listener;
	    }
	
	    // All major browsers except Firefox resets
	    // selectedIndex with value -1 to 0 when the element
	    // is appended to a new parent, therefore we have to
	    // force a DOM update whenever that happens...
	    this.vm.$on('hook:attached', this.forceUpdate);
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    el.selectedIndex = -1;
	    var multi = this.multiple && isArray(value);
	    var options = el.options;
	    var i = options.length;
	    var op, val;
	    while (i--) {
	      op = options[i];
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      /* eslint-disable eqeqeq */
	      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
	      /* eslint-enable eqeqeq */
	    }
	  },
	
	  unbind: function unbind() {
	    /* istanbul ignore next */
	    this.vm.$off('hook:attached', this.forceUpdate);
	  }
	};
	
	/**
	 * Get select value
	 *
	 * @param {SelectElement} el
	 * @param {Boolean} multi
	 * @param {Boolean} init
	 * @return {Array|*}
	 */
	
	function getValue(el, multi, init) {
	  var res = multi ? [] : null;
	  var op, val, selected;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    op = el.options[i];
	    selected = init ? op.hasAttribute('selected') : op.selected;
	    if (selected) {
	      val = op.hasOwnProperty('_value') ? op._value : op.value;
	      if (multi) {
	        res.push(val);
	      } else {
	        return val;
	      }
	    }
	  }
	  return res;
	}
	
	/**
	 * Native Array.indexOf uses strict equal, but in this
	 * case we need to match string/numbers with custom equal.
	 *
	 * @param {Array} arr
	 * @param {*} val
	 */
	
	function indexOf$1(arr, val) {
	  var i = arr.length;
	  while (i--) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	var checkbox = {
	
	  bind: function bind() {
	    var self = this;
	    var el = this.el;
	
	    this.getValue = function () {
	      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
	    };
	
	    function getBooleanValue() {
	      var val = el.checked;
	      if (val && el.hasOwnProperty('_trueValue')) {
	        return el._trueValue;
	      }
	      if (!val && el.hasOwnProperty('_falseValue')) {
	        return el._falseValue;
	      }
	      return val;
	    }
	
	    this.listener = function () {
	      var model = self._watcher.value;
	      if (isArray(model)) {
	        var val = self.getValue();
	        if (el.checked) {
	          if (indexOf(model, val) < 0) {
	            model.push(val);
	          }
	        } else {
	          model.$remove(val);
	        }
	      } else {
	        self.set(getBooleanValue());
	      }
	    };
	
	    this.on('change', this.listener);
	    if (el.hasAttribute('checked')) {
	      this.afterBind = this.listener;
	    }
	  },
	
	  update: function update(value) {
	    var el = this.el;
	    if (isArray(value)) {
	      el.checked = indexOf(value, this.getValue()) > -1;
	    } else {
	      if (el.hasOwnProperty('_trueValue')) {
	        el.checked = looseEqual(value, el._trueValue);
	      } else {
	        el.checked = !!value;
	      }
	    }
	  }
	};
	
	var handlers = {
	  text: text$2,
	  radio: radio,
	  select: select,
	  checkbox: checkbox
	};
	
	var model = {
	
	  priority: MODEL,
	  twoWay: true,
	  handlers: handlers,
	  params: ['lazy', 'number', 'debounce'],
	
	  /**
	   * Possible elements:
	   *   <select>
	   *   <textarea>
	   *   <input type="*">
	   *     - text
	   *     - checkbox
	   *     - radio
	   *     - number
	   */
	
	  bind: function bind() {
	    // friendly warning...
	    this.checkFilters();
	    if (this.hasRead && !this.hasWrite) {
	      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
	    }
	    var el = this.el;
	    var tag = el.tagName;
	    var handler;
	    if (tag === 'INPUT') {
	      handler = handlers[el.type] || handlers.text;
	    } else if (tag === 'SELECT') {
	      handler = handlers.select;
	    } else if (tag === 'TEXTAREA') {
	      handler = handlers.text;
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
	      return;
	    }
	    el.__v_model = this;
	    handler.bind.call(this);
	    this.update = handler.update;
	    this._unbind = handler.unbind;
	  },
	
	  /**
	   * Check read/write filter stats.
	   */
	
	  checkFilters: function checkFilters() {
	    var filters = this.filters;
	    if (!filters) return;
	    var i = filters.length;
	    while (i--) {
	      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
	      if (typeof filter === 'function' || filter.read) {
	        this.hasRead = true;
	      }
	      if (filter.write) {
	        this.hasWrite = true;
	      }
	    }
	  },
	
	  unbind: function unbind() {
	    this.el.__v_model = null;
	    this._unbind && this._unbind();
	  }
	};
	
	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  'delete': [8, 46],
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40
	};
	
	function keyFilter(handler, keys) {
	  var codes = keys.map(function (key) {
	    var charCode = key.charCodeAt(0);
	    if (charCode > 47 && charCode < 58) {
	      return parseInt(key, 10);
	    }
	    if (key.length === 1) {
	      charCode = key.toUpperCase().charCodeAt(0);
	      if (charCode > 64 && charCode < 91) {
	        return charCode;
	      }
	    }
	    return keyCodes[key];
	  });
	  codes = [].concat.apply([], codes);
	  return function keyHandler(e) {
	    if (codes.indexOf(e.keyCode) > -1) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	function stopFilter(handler) {
	  return function stopHandler(e) {
	    e.stopPropagation();
	    return handler.call(this, e);
	  };
	}
	
	function preventFilter(handler) {
	  return function preventHandler(e) {
	    e.preventDefault();
	    return handler.call(this, e);
	  };
	}
	
	function selfFilter(handler) {
	  return function selfHandler(e) {
	    if (e.target === e.currentTarget) {
	      return handler.call(this, e);
	    }
	  };
	}
	
	var on$1 = {
	
	  priority: ON,
	  acceptStatement: true,
	  keyCodes: keyCodes,
	
	  bind: function bind() {
	    // deal with iframes
	    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
	      var self = this;
	      this.iframeBind = function () {
	        on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
	      };
	      this.on('load', this.iframeBind);
	    }
	  },
	
	  update: function update(handler) {
	    // stub a noop for v-on with no value,
	    // e.g. @mousedown.prevent
	    if (!this.descriptor.raw) {
	      handler = function () {};
	    }
	
	    if (typeof handler !== 'function') {
	      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
	      return;
	    }
	
	    // apply modifiers
	    if (this.modifiers.stop) {
	      handler = stopFilter(handler);
	    }
	    if (this.modifiers.prevent) {
	      handler = preventFilter(handler);
	    }
	    if (this.modifiers.self) {
	      handler = selfFilter(handler);
	    }
	    // key filter
	    var keys = Object.keys(this.modifiers).filter(function (key) {
	      return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
	    });
	    if (keys.length) {
	      handler = keyFilter(handler, keys);
	    }
	
	    this.reset();
	    this.handler = handler;
	
	    if (this.iframeBind) {
	      this.iframeBind();
	    } else {
	      on(this.el, this.arg, this.handler, this.modifiers.capture);
	    }
	  },
	
	  reset: function reset() {
	    var el = this.iframeBind ? this.el.contentWindow : this.el;
	    if (this.handler) {
	      off(el, this.arg, this.handler);
	    }
	  },
	
	  unbind: function unbind() {
	    this.reset();
	  }
	};
	
	var prefixes = ['-webkit-', '-moz-', '-ms-'];
	var camelPrefixes = ['Webkit', 'Moz', 'ms'];
	var importantRE = /!important;?$/;
	var propCache = Object.create(null);
	
	var testEl = null;
	
	var style = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (typeof value === 'string') {
	      this.el.style.cssText = value;
	    } else if (isArray(value)) {
	      this.handleObject(value.reduce(extend, {}));
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  handleObject: function handleObject(value) {
	    // cache object styles so that only changed props
	    // are actually updated.
	    var cache = this.cache || (this.cache = {});
	    var name, val;
	    for (name in cache) {
	      if (!(name in value)) {
	        this.handleSingle(name, null);
	        delete cache[name];
	      }
	    }
	    for (name in value) {
	      val = value[name];
	      if (val !== cache[name]) {
	        cache[name] = val;
	        this.handleSingle(name, val);
	      }
	    }
	  },
	
	  handleSingle: function handleSingle(prop, value) {
	    prop = normalize(prop);
	    if (!prop) return; // unsupported prop
	    // cast possible numbers/booleans into strings
	    if (value != null) value += '';
	    if (value) {
	      var isImportant = importantRE.test(value) ? 'important' : '';
	      if (isImportant) {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
	        }
	        value = value.replace(importantRE, '').trim();
	        this.el.style.setProperty(prop.kebab, value, isImportant);
	      } else {
	        this.el.style[prop.camel] = value;
	      }
	    } else {
	      this.el.style[prop.camel] = '';
	    }
	  }
	
	};
	
	/**
	 * Normalize a CSS property name.
	 * - cache result
	 * - auto prefix
	 * - camelCase -> dash-case
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function normalize(prop) {
	  if (propCache[prop]) {
	    return propCache[prop];
	  }
	  var res = prefix(prop);
	  propCache[prop] = propCache[res] = res;
	  return res;
	}
	
	/**
	 * Auto detect the appropriate prefix for a CSS property.
	 * https://gist.github.com/paulirish/523692
	 *
	 * @param {String} prop
	 * @return {String}
	 */
	
	function prefix(prop) {
	  prop = hyphenate(prop);
	  var camel = camelize(prop);
	  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
	  if (!testEl) {
	    testEl = document.createElement('div');
	  }
	  var i = prefixes.length;
	  var prefixed;
	  if (camel !== 'filter' && camel in testEl.style) {
	    return {
	      kebab: prop,
	      camel: camel
	    };
	  }
	  while (i--) {
	    prefixed = camelPrefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return {
	        kebab: prefixes[i] + prop,
	        camel: prefixed
	      };
	    }
	  }
	}
	
	// xlink
	var xlinkNS = 'http://www.w3.org/1999/xlink';
	var xlinkRE = /^xlink:/;
	
	// check for attributes that prohibit interpolations
	var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
	// these attributes should also set their corresponding properties
	// because they only affect the initial state of the element
	var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
	// these attributes expect enumrated values of "true" or "false"
	// but are not boolean attributes
	var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
	
	// these attributes should set a hidden property for
	// binding v-model to object values
	var modelProps = {
	  value: '_value',
	  'true-value': '_trueValue',
	  'false-value': '_falseValue'
	};
	
	var bind$1 = {
	
	  priority: BIND,
	
	  bind: function bind() {
	    var attr = this.arg;
	    var tag = this.el.tagName;
	    // should be deep watch on object mode
	    if (!attr) {
	      this.deep = true;
	    }
	    // handle interpolation bindings
	    var descriptor = this.descriptor;
	    var tokens = descriptor.interp;
	    if (tokens) {
	      // handle interpolations with one-time tokens
	      if (descriptor.hasOneTime) {
	        this.expression = tokensToExp(tokens, this._scope || this.vm);
	      }
	
	      // only allow binding on native attributes
	      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
	        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
	        this.el.removeAttribute(attr);
	        this.invalid = true;
	      }
	
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production') {
	        var raw = attr + '="' + descriptor.raw + '": ';
	        // warn src
	        if (attr === 'src') {
	          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
	        }
	
	        // warn style
	        if (attr === 'style') {
	          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
	        }
	      }
	    }
	  },
	
	  update: function update(value) {
	    if (this.invalid) {
	      return;
	    }
	    var attr = this.arg;
	    if (this.arg) {
	      this.handleSingle(attr, value);
	    } else {
	      this.handleObject(value || {});
	    }
	  },
	
	  // share object handler with v-bind:class
	  handleObject: style.handleObject,
	
	  handleSingle: function handleSingle(attr, value) {
	    var el = this.el;
	    var interp = this.descriptor.interp;
	    if (this.modifiers.camel) {
	      attr = camelize(attr);
	    }
	    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
	      var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
	      ? '' : value : value;
	
	      if (el[attr] !== attrValue) {
	        el[attr] = attrValue;
	      }
	    }
	    // set model props
	    var modelProp = modelProps[attr];
	    if (!interp && modelProp) {
	      el[modelProp] = value;
	      // update v-model if present
	      var model = el.__v_model;
	      if (model) {
	        model.listener();
	      }
	    }
	    // do not set value attribute for textarea
	    if (attr === 'value' && el.tagName === 'TEXTAREA') {
	      el.removeAttribute(attr);
	      return;
	    }
	    // update attribute
	    if (enumeratedAttrRE.test(attr)) {
	      el.setAttribute(attr, value ? 'true' : 'false');
	    } else if (value != null && value !== false) {
	      if (attr === 'class') {
	        // handle edge case #1960:
	        // class interpolation should not overwrite Vue transition class
	        if (el.__v_trans) {
	          value += ' ' + el.__v_trans.id + '-transition';
	        }
	        setClass(el, value);
	      } else if (xlinkRE.test(attr)) {
	        el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
	      } else {
	        el.setAttribute(attr, value === true ? '' : value);
	      }
	    } else {
	      el.removeAttribute(attr);
	    }
	  }
	};
	
	var el = {
	
	  priority: EL,
	
	  bind: function bind() {
	    /* istanbul ignore if */
	    if (!this.arg) {
	      return;
	    }
	    var id = this.id = camelize(this.arg);
	    var refs = (this._scope || this.vm).$els;
	    if (hasOwn(refs, id)) {
	      refs[id] = this.el;
	    } else {
	      defineReactive(refs, id, this.el);
	    }
	  },
	
	  unbind: function unbind() {
	    var refs = (this._scope || this.vm).$els;
	    if (refs[this.id] === this.el) {
	      refs[this.id] = null;
	    }
	  }
	};
	
	var ref = {
	  bind: function bind() {
	    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
	  }
	};
	
	var cloak = {
	  bind: function bind() {
	    var el = this.el;
	    this.vm.$once('pre-hook:compiled', function () {
	      el.removeAttribute('v-cloak');
	    });
	  }
	};
	
	// must export plain object
	var directives = {
	  text: text$1,
	  html: html,
	  'for': vFor,
	  'if': vIf,
	  show: show,
	  model: model,
	  on: on$1,
	  bind: bind$1,
	  el: el,
	  ref: ref,
	  cloak: cloak
	};
	
	var vClass = {
	
	  deep: true,
	
	  update: function update(value) {
	    if (!value) {
	      this.cleanup();
	    } else if (typeof value === 'string') {
	      this.setClass(value.trim().split(/\s+/));
	    } else {
	      this.setClass(normalize$1(value));
	    }
	  },
	
	  setClass: function setClass(value) {
	    this.cleanup(value);
	    for (var i = 0, l = value.length; i < l; i++) {
	      var val = value[i];
	      if (val) {
	        apply(this.el, val, addClass);
	      }
	    }
	    this.prevKeys = value;
	  },
	
	  cleanup: function cleanup(value) {
	    var prevKeys = this.prevKeys;
	    if (!prevKeys) return;
	    var i = prevKeys.length;
	    while (i--) {
	      var key = prevKeys[i];
	      if (!value || value.indexOf(key) < 0) {
	        apply(this.el, key, removeClass);
	      }
	    }
	  }
	};
	
	/**
	 * Normalize objects and arrays (potentially containing objects)
	 * into array of strings.
	 *
	 * @param {Object|Array<String|Object>} value
	 * @return {Array<String>}
	 */
	
	function normalize$1(value) {
	  var res = [];
	  if (isArray(value)) {
	    for (var i = 0, l = value.length; i < l; i++) {
	      var _key = value[i];
	      if (_key) {
	        if (typeof _key === 'string') {
	          res.push(_key);
	        } else {
	          for (var k in _key) {
	            if (_key[k]) res.push(k);
	          }
	        }
	      }
	    }
	  } else if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) res.push(key);
	    }
	  }
	  return res;
	}
	
	/**
	 * Add or remove a class/classes on an element
	 *
	 * @param {Element} el
	 * @param {String} key The class name. This may or may not
	 *                     contain a space character, in such a
	 *                     case we'll deal with multiple class
	 *                     names at once.
	 * @param {Function} fn
	 */
	
	function apply(el, key, fn) {
	  key = key.trim();
	  if (key.indexOf(' ') === -1) {
	    fn(el, key);
	    return;
	  }
	  // The key contains one or more space characters.
	  // Since a class name doesn't accept such characters, we
	  // treat it as multiple classes.
	  var keys = key.split(/\s+/);
	  for (var i = 0, l = keys.length; i < l; i++) {
	    fn(el, keys[i]);
	  }
	}
	
	var component = {
	
	  priority: COMPONENT,
	
	  params: ['keep-alive', 'transition-mode', 'inline-template'],
	
	  /**
	   * Setup. Two possible usages:
	   *
	   * - static:
	   *   <comp> or <div v-component="comp">
	   *
	   * - dynamic:
	   *   <component :is="view">
	   */
	
	  bind: function bind() {
	    if (!this.el.__vue__) {
	      // keep-alive cache
	      this.keepAlive = this.params.keepAlive;
	      if (this.keepAlive) {
	        this.cache = {};
	      }
	      // check inline-template
	      if (this.params.inlineTemplate) {
	        // extract inline template as a DocumentFragment
	        this.inlineTemplate = extractContent(this.el, true);
	      }
	      // component resolution related state
	      this.pendingComponentCb = this.Component = null;
	      // transition related state
	      this.pendingRemovals = 0;
	      this.pendingRemovalCb = null;
	      // create a ref anchor
	      this.anchor = createAnchor('v-component');
	      replace(this.el, this.anchor);
	      // remove is attribute.
	      // this is removed during compilation, but because compilation is
	      // cached, when the component is used elsewhere this attribute
	      // will remain at link time.
	      this.el.removeAttribute('is');
	      this.el.removeAttribute(':is');
	      // remove ref, same as above
	      if (this.descriptor.ref) {
	        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
	      }
	      // if static, build right now.
	      if (this.literal) {
	        this.setComponent(this.expression);
	      }
	    } else {
	      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
	    }
	  },
	
	  /**
	   * Public update, called by the watcher in the dynamic
	   * literal scenario, e.g. <component :is="view">
	   */
	
	  update: function update(value) {
	    if (!this.literal) {
	      this.setComponent(value);
	    }
	  },
	
	  /**
	   * Switch dynamic components. May resolve the component
	   * asynchronously, and perform transition based on
	   * specified transition mode. Accepts a few additional
	   * arguments specifically for vue-router.
	   *
	   * The callback is called when the full transition is
	   * finished.
	   *
	   * @param {String} value
	   * @param {Function} [cb]
	   */
	
	  setComponent: function setComponent(value, cb) {
	    this.invalidatePending();
	    if (!value) {
	      // just remove current
	      this.unbuild(true);
	      this.remove(this.childVM, cb);
	      this.childVM = null;
	    } else {
	      var self = this;
	      this.resolveComponent(value, function () {
	        self.mountComponent(cb);
	      });
	    }
	  },
	
	  /**
	   * Resolve the component constructor to use when creating
	   * the child vm.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  resolveComponent: function resolveComponent(value, cb) {
	    var self = this;
	    this.pendingComponentCb = cancellable(function (Component) {
	      self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
	      self.Component = Component;
	      cb();
	    });
	    this.vm._resolveComponent(value, this.pendingComponentCb);
	  },
	
	  /**
	   * Create a new instance using the current constructor and
	   * replace the existing instance. This method doesn't care
	   * whether the new component and the old one are actually
	   * the same.
	   *
	   * @param {Function} [cb]
	   */
	
	  mountComponent: function mountComponent(cb) {
	    // actual mount
	    this.unbuild(true);
	    var self = this;
	    var activateHooks = this.Component.options.activate;
	    var cached = this.getCached();
	    var newComponent = this.build();
	    if (activateHooks && !cached) {
	      this.waitingFor = newComponent;
	      callActivateHooks(activateHooks, newComponent, function () {
	        if (self.waitingFor !== newComponent) {
	          return;
	        }
	        self.waitingFor = null;
	        self.transition(newComponent, cb);
	      });
	    } else {
	      // update ref for kept-alive component
	      if (cached) {
	        newComponent._updateRef();
	      }
	      this.transition(newComponent, cb);
	    }
	  },
	
	  /**
	   * When the component changes or unbinds before an async
	   * constructor is resolved, we need to invalidate its
	   * pending callback.
	   */
	
	  invalidatePending: function invalidatePending() {
	    if (this.pendingComponentCb) {
	      this.pendingComponentCb.cancel();
	      this.pendingComponentCb = null;
	    }
	  },
	
	  /**
	   * Instantiate/insert a new child vm.
	   * If keep alive and has cached instance, insert that
	   * instance; otherwise build a new one and cache it.
	   *
	   * @param {Object} [extraOptions]
	   * @return {Vue} - the created instance
	   */
	
	  build: function build(extraOptions) {
	    var cached = this.getCached();
	    if (cached) {
	      return cached;
	    }
	    if (this.Component) {
	      // default options
	      var options = {
	        name: this.ComponentName,
	        el: cloneNode(this.el),
	        template: this.inlineTemplate,
	        // make sure to add the child with correct parent
	        // if this is a transcluded component, its parent
	        // should be the transclusion host.
	        parent: this._host || this.vm,
	        // if no inline-template, then the compiled
	        // linker can be cached for better performance.
	        _linkerCachable: !this.inlineTemplate,
	        _ref: this.descriptor.ref,
	        _asComponent: true,
	        _isRouterView: this._isRouterView,
	        // if this is a transcluded component, context
	        // will be the common parent vm of this instance
	        // and its host.
	        _context: this.vm,
	        // if this is inside an inline v-for, the scope
	        // will be the intermediate scope created for this
	        // repeat fragment. this is used for linking props
	        // and container directives.
	        _scope: this._scope,
	        // pass in the owner fragment of this component.
	        // this is necessary so that the fragment can keep
	        // track of its contained components in order to
	        // call attach/detach hooks for them.
	        _frag: this._frag
	      };
	      // extra options
	      // in 1.0.0 this is used by vue-router only
	      /* istanbul ignore if */
	      if (extraOptions) {
	        extend(options, extraOptions);
	      }
	      var child = new this.Component(options);
	      if (this.keepAlive) {
	        this.cache[this.Component.cid] = child;
	      }
	      /* istanbul ignore if */
	      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
	        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
	      }
	      return child;
	    }
	  },
	
	  /**
	   * Try to get a cached instance of the current component.
	   *
	   * @return {Vue|undefined}
	   */
	
	  getCached: function getCached() {
	    return this.keepAlive && this.cache[this.Component.cid];
	  },
	
	  /**
	   * Teardown the current child, but defers cleanup so
	   * that we can separate the destroy and removal steps.
	   *
	   * @param {Boolean} defer
	   */
	
	  unbuild: function unbuild(defer) {
	    if (this.waitingFor) {
	      if (!this.keepAlive) {
	        this.waitingFor.$destroy();
	      }
	      this.waitingFor = null;
	    }
	    var child = this.childVM;
	    if (!child || this.keepAlive) {
	      if (child) {
	        // remove ref
	        child._inactive = true;
	        child._updateRef(true);
	      }
	      return;
	    }
	    // the sole purpose of `deferCleanup` is so that we can
	    // "deactivate" the vm right now and perform DOM removal
	    // later.
	    child.$destroy(false, defer);
	  },
	
	  /**
	   * Remove current destroyed child and manually do
	   * the cleanup after removal.
	   *
	   * @param {Function} cb
	   */
	
	  remove: function remove(child, cb) {
	    var keepAlive = this.keepAlive;
	    if (child) {
	      // we may have a component switch when a previous
	      // component is still being transitioned out.
	      // we want to trigger only one lastest insertion cb
	      // when the existing transition finishes. (#1119)
	      this.pendingRemovals++;
	      this.pendingRemovalCb = cb;
	      var self = this;
	      child.$remove(function () {
	        self.pendingRemovals--;
	        if (!keepAlive) child._cleanup();
	        if (!self.pendingRemovals && self.pendingRemovalCb) {
	          self.pendingRemovalCb();
	          self.pendingRemovalCb = null;
	        }
	      });
	    } else if (cb) {
	      cb();
	    }
	  },
	
	  /**
	   * Actually swap the components, depending on the
	   * transition mode. Defaults to simultaneous.
	   *
	   * @param {Vue} target
	   * @param {Function} [cb]
	   */
	
	  transition: function transition(target, cb) {
	    var self = this;
	    var current = this.childVM;
	    // for devtool inspection
	    if (current) current._inactive = true;
	    target._inactive = false;
	    this.childVM = target;
	    switch (self.params.transitionMode) {
	      case 'in-out':
	        target.$before(self.anchor, function () {
	          self.remove(current, cb);
	        });
	        break;
	      case 'out-in':
	        self.remove(current, function () {
	          target.$before(self.anchor, cb);
	        });
	        break;
	      default:
	        self.remove(current);
	        target.$before(self.anchor, cb);
	    }
	  },
	
	  /**
	   * Unbind.
	   */
	
	  unbind: function unbind() {
	    this.invalidatePending();
	    // Do not defer cleanup when unbinding
	    this.unbuild();
	    // destroy all keep-alive cached instances
	    if (this.cache) {
	      for (var key in this.cache) {
	        this.cache[key].$destroy();
	      }
	      this.cache = null;
	    }
	  }
	};
	
	/**
	 * Call activate hooks in order (asynchronous)
	 *
	 * @param {Array} hooks
	 * @param {Vue} vm
	 * @param {Function} cb
	 */
	
	function callActivateHooks(hooks, vm, cb) {
	  var total = hooks.length;
	  var called = 0;
	  hooks[0].call(vm, next);
	  function next() {
	    if (++called >= total) {
	      cb();
	    } else {
	      hooks[called].call(vm, next);
	    }
	  }
	}
	
	var propBindingModes = config._propBindingModes;
	var empty = {};
	
	// regexes
	var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
	var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
	
	/**
	 * Compile props on a root element and return
	 * a props link function.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Array} propOptions
	 * @param {Vue} vm
	 * @return {Function} propsLinkFn
	 */
	
	function compileProps(el, propOptions, vm) {
	  var props = [];
	  var names = Object.keys(propOptions);
	  var i = names.length;
	  var options, name, attr, value, path, parsed, prop;
	  while (i--) {
	    name = names[i];
	    options = propOptions[name] || empty;
	
	    if (process.env.NODE_ENV !== 'production' && name === '$data') {
	      warn('Do not use $data as prop.', vm);
	      continue;
	    }
	
	    // props could contain dashes, which will be
	    // interpreted as minus calculations by the parser
	    // so we need to camelize the path here
	    path = camelize(name);
	    if (!identRE$1.test(path)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
	      continue;
	    }
	
	    prop = {
	      name: name,
	      path: path,
	      options: options,
	      mode: propBindingModes.ONE_WAY,
	      raw: null
	    };
	
	    attr = hyphenate(name);
	    // first check dynamic version
	    if ((value = getBindAttr(el, attr)) === null) {
	      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
	        prop.mode = propBindingModes.TWO_WAY;
	      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
	        prop.mode = propBindingModes.ONE_TIME;
	      }
	    }
	    if (value !== null) {
	      // has dynamic binding!
	      prop.raw = value;
	      parsed = parseDirective(value);
	      value = parsed.expression;
	      prop.filters = parsed.filters;
	      // check binding type
	      if (isLiteral(value) && !parsed.filters) {
	        // for expressions containing literal numbers and
	        // booleans, there's no need to setup a prop binding,
	        // so we can optimize them as a one-time set.
	        prop.optimizedLiteral = true;
	      } else {
	        prop.dynamic = true;
	        // check non-settable path for two-way bindings
	        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
	          prop.mode = propBindingModes.ONE_WAY;
	          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
	        }
	      }
	      prop.parentPath = value;
	
	      // warn required two-way
	      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
	        warn('Prop "' + name + '" expects a two-way binding type.', vm);
	      }
	    } else if ((value = getAttr(el, attr)) !== null) {
	      // has literal binding!
	      prop.raw = value;
	    } else if (process.env.NODE_ENV !== 'production') {
	      // check possible camelCase prop usage
	      var lowerCaseName = path.toLowerCase();
	      value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
	      if (value) {
	        warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
	      } else if (options.required) {
	        // warn missing required
	        warn('Missing required prop: ' + name, vm);
	      }
	    }
	    // push prop
	    props.push(prop);
	  }
	  return makePropsLinkFn(props);
	}
	
	/**
	 * Build a function that applies props to a vm.
	 *
	 * @param {Array} props
	 * @return {Function} propsLinkFn
	 */
	
	function makePropsLinkFn(props) {
	  return function propsLinkFn(vm, scope) {
	    // store resolved props info
	    vm._props = {};
	    var inlineProps = vm.$options.propsData;
	    var i = props.length;
	    var prop, path, options, value, raw;
	    while (i--) {
	      prop = props[i];
	      raw = prop.raw;
	      path = prop.path;
	      options = prop.options;
	      vm._props[path] = prop;
	      if (inlineProps && hasOwn(inlineProps, path)) {
	        initProp(vm, prop, inlineProps[path]);
	      }if (raw === null) {
	        // initialize absent prop
	        initProp(vm, prop, undefined);
	      } else if (prop.dynamic) {
	        // dynamic prop
	        if (prop.mode === propBindingModes.ONE_TIME) {
	          // one time binding
	          value = (scope || vm._context || vm).$get(prop.parentPath);
	          initProp(vm, prop, value);
	        } else {
	          if (vm._context) {
	            // dynamic binding
	            vm._bindDir({
	              name: 'prop',
	              def: propDef,
	              prop: prop
	            }, null, null, scope); // el, host, scope
	          } else {
	              // root instance
	              initProp(vm, prop, vm.$get(prop.parentPath));
	            }
	        }
	      } else if (prop.optimizedLiteral) {
	        // optimized literal, cast it and just set once
	        var stripped = stripQuotes(raw);
	        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
	        initProp(vm, prop, value);
	      } else {
	        // string literal, but we need to cater for
	        // Boolean props with no value, or with same
	        // literal value (e.g. disabled="disabled")
	        // see https://github.com/vuejs/vue-loader/issues/182
	        value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
	        initProp(vm, prop, value);
	      }
	    }
	  };
	}
	
	/**
	 * Process a prop with a rawValue, applying necessary coersions,
	 * default values & assertions and call the given callback with
	 * processed value.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} rawValue
	 * @param {Function} fn
	 */
	
	function processPropValue(vm, prop, rawValue, fn) {
	  var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
	  var value = rawValue;
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop);
	  }
	  value = coerceProp(prop, value);
	  var coerced = value !== rawValue;
	  if (!assertProp(prop, value, vm)) {
	    value = undefined;
	  }
	  if (isSimple && !coerced) {
	    withoutConversion(function () {
	      fn(value);
	    });
	  } else {
	    fn(value);
	  }
	}
	
	/**
	 * Set a prop's initial value on a vm and its data object.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function initProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    defineReactive(vm, prop.path, value);
	  });
	}
	
	/**
	 * Update a prop's value on a vm.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @param {*} value
	 */
	
	function updateProp(vm, prop, value) {
	  processPropValue(vm, prop, value, function (value) {
	    vm[prop.path] = value;
	  });
	}
	
	/**
	 * Get the default value of a prop.
	 *
	 * @param {Vue} vm
	 * @param {Object} prop
	 * @return {*}
	 */
	
	function getPropDefaultValue(vm, prop) {
	  // no default, return undefined
	  var options = prop.options;
	  if (!hasOwn(options, 'default')) {
	    // absent boolean value defaults to false
	    return options.type === Boolean ? false : undefined;
	  }
	  var def = options['default'];
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    process.env.NODE_ENV !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
	}
	
	/**
	 * Assert whether a prop is valid.
	 *
	 * @param {Object} prop
	 * @param {*} value
	 * @param {Vue} vm
	 */
	
	function assertProp(prop, value, vm) {
	  if (!prop.options.required && ( // non-required
	  prop.raw === null || // abscent
	  value == null) // null or undefined
	  ) {
	      return true;
	    }
	  var options = prop.options;
	  var type = options.type;
	  var valid = !type;
	  var expectedTypes = [];
	  if (type) {
	    if (!isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
	    }
	    return false;
	  }
	  var validator = options.validator;
	  if (validator) {
	    if (!validator(value)) {
	      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Force parsing value with coerce option.
	 *
	 * @param {*} value
	 * @param {Object} options
	 * @return {*}
	 */
	
	function coerceProp(prop, value) {
	  var coerce = prop.options.coerce;
	  if (!coerce) {
	    return value;
	  }
	  // coerce is a function
	  return coerce(value);
	}
	
	/**
	 * Assert the type of a value
	 *
	 * @param {*} value
	 * @param {Function} type
	 * @return {Object}
	 */
	
	function assertType(value, type) {
	  var valid;
	  var expectedType;
	  if (type === String) {
	    expectedType = 'string';
	    valid = typeof value === expectedType;
	  } else if (type === Number) {
	    expectedType = 'number';
	    valid = typeof value === expectedType;
	  } else if (type === Boolean) {
	    expectedType = 'boolean';
	    valid = typeof value === expectedType;
	  } else if (type === Function) {
	    expectedType = 'function';
	    valid = typeof value === expectedType;
	  } else if (type === Object) {
	    expectedType = 'object';
	    valid = isPlainObject(value);
	  } else if (type === Array) {
	    expectedType = 'array';
	    valid = isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  };
	}
	
	/**
	 * Format type for output
	 *
	 * @param {String} type
	 * @return {String}
	 */
	
	function formatType(type) {
	  return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
	}
	
	/**
	 * Format value
	 *
	 * @param {*} value
	 * @return {String}
	 */
	
	function formatValue(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	}
	
	var bindingModes = config._propBindingModes;
	
	var propDef = {
	
	  bind: function bind() {
	    var child = this.vm;
	    var parent = child._context;
	    // passed in from compiler directly
	    var prop = this.descriptor.prop;
	    var childKey = prop.path;
	    var parentKey = prop.parentPath;
	    var twoWay = prop.mode === bindingModes.TWO_WAY;
	
	    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
	      updateProp(child, prop, val);
	    }, {
	      twoWay: twoWay,
	      filters: prop.filters,
	      // important: props need to be observed on the
	      // v-for scope if present
	      scope: this._scope
	    });
	
	    // set the child initial value.
	    initProp(child, prop, parentWatcher.value);
	
	    // setup two-way binding
	    if (twoWay) {
	      // important: defer the child watcher creation until
	      // the created hook (after data observation)
	      var self = this;
	      child.$once('pre-hook:created', function () {
	        self.childWatcher = new Watcher(child, childKey, function (val) {
	          parentWatcher.set(val);
	        }, {
	          // ensure sync upward before parent sync down.
	          // this is necessary in cases e.g. the child
	          // mutates a prop array, then replaces it. (#1683)
	          sync: true
	        });
	      });
	    }
	  },
	
	  unbind: function unbind() {
	    this.parentWatcher.teardown();
	    if (this.childWatcher) {
	      this.childWatcher.teardown();
	    }
	  }
	};
	
	var queue$1 = [];
	var queued = false;
	
	/**
	 * Push a job into the queue.
	 *
	 * @param {Function} job
	 */
	
	function pushJob(job) {
	  queue$1.push(job);
	  if (!queued) {
	    queued = true;
	    nextTick(flush);
	  }
	}
	
	/**
	 * Flush the queue, and do one forced reflow before
	 * triggering transitions.
	 */
	
	function flush() {
	  // Force layout
	  var f = document.documentElement.offsetHeight;
	  for (var i = 0; i < queue$1.length; i++) {
	    queue$1[i]();
	  }
	  queue$1 = [];
	  queued = false;
	  // dummy return, so js linters don't complain about
	  // unused variable f
	  return f;
	}
	
	var TYPE_TRANSITION = 'transition';
	var TYPE_ANIMATION = 'animation';
	var transDurationProp = transitionProp + 'Duration';
	var animDurationProp = animationProp + 'Duration';
	
	/**
	 * If a just-entered element is applied the
	 * leave class while its enter transition hasn't started yet,
	 * and the transitioned property has the same value for both
	 * enter/leave, then the leave transition will be skipped and
	 * the transitionend event never fires. This function ensures
	 * its callback to be called after a transition has started
	 * by waiting for double raf.
	 *
	 * It falls back to setTimeout on devices that support CSS
	 * transitions but not raf (e.g. Android 4.2 browser) - since
	 * these environments are usually slow, we are giving it a
	 * relatively large timeout.
	 */
	
	var raf = inBrowser && window.requestAnimationFrame;
	var waitForTransitionStart = raf
	/* istanbul ignore next */
	? function (fn) {
	  raf(function () {
	    raf(fn);
	  });
	} : function (fn) {
	  setTimeout(fn, 50);
	};
	
	/**
	 * A Transition object that encapsulates the state and logic
	 * of the transition.
	 *
	 * @param {Element} el
	 * @param {String} id
	 * @param {Object} hooks
	 * @param {Vue} vm
	 */
	function Transition(el, id, hooks, vm) {
	  this.id = id;
	  this.el = el;
	  this.enterClass = hooks && hooks.enterClass || id + '-enter';
	  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
	  this.hooks = hooks;
	  this.vm = vm;
	  // async state
	  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
	  this.justEntered = false;
	  this.entered = this.left = false;
	  this.typeCache = {};
	  // check css transition type
	  this.type = hooks && hooks.type;
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV !== 'production') {
	    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
	      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
	    }
	  }
	  // bind
	  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
	    self[m] = bind(self[m], self);
	  });
	}
	
	var p$1 = Transition.prototype;
	
	/**
	 * Start an entering transition.
	 *
	 * 1. enter transition triggered
	 * 2. call beforeEnter hook
	 * 3. add enter class
	 * 4. insert/show element
	 * 5. call enter hook (with possible explicit js callback)
	 * 6. reflow
	 * 7. based on transition type:
	 *    - transition:
	 *        remove class now, wait for transitionend,
	 *        then done if there's no explicit js callback.
	 *    - animation:
	 *        wait for animationend, remove class,
	 *        then done if there's no explicit js callback.
	 *    - no css transition:
	 *        done now if there's no explicit js callback.
	 * 8. wait for either done or js callback, then call
	 *    afterEnter hook.
	 *
	 * @param {Function} op - insert/show the element
	 * @param {Function} [cb]
	 */
	
	p$1.enter = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeEnter');
	  this.cb = cb;
	  addClass(this.el, this.enterClass);
	  op();
	  this.entered = false;
	  this.callHookWithCb('enter');
	  if (this.entered) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.enterCancelled;
	  pushJob(this.enterNextTick);
	};
	
	/**
	 * The "nextTick" phase of an entering transition, which is
	 * to be pushed into a queue and executed after a reflow so
	 * that removing the class can trigger a CSS transition.
	 */
	
	p$1.enterNextTick = function () {
	  var _this = this;
	
	  // prevent transition skipping
	  this.justEntered = true;
	  waitForTransitionStart(function () {
	    _this.justEntered = false;
	  });
	  var enterDone = this.enterDone;
	  var type = this.getCssTransitionType(this.enterClass);
	  if (!this.pendingJsCb) {
	    if (type === TYPE_TRANSITION) {
	      // trigger transition by removing enter class now
	      removeClass(this.el, this.enterClass);
	      this.setupCssCb(transitionEndEvent, enterDone);
	    } else if (type === TYPE_ANIMATION) {
	      this.setupCssCb(animationEndEvent, enterDone);
	    } else {
	      enterDone();
	    }
	  } else if (type === TYPE_TRANSITION) {
	    removeClass(this.el, this.enterClass);
	  }
	};
	
	/**
	 * The "cleanup" phase of an entering transition.
	 */
	
	p$1.enterDone = function () {
	  this.entered = true;
	  this.cancel = this.pendingJsCb = null;
	  removeClass(this.el, this.enterClass);
	  this.callHook('afterEnter');
	  if (this.cb) this.cb();
	};
	
	/**
	 * Start a leaving transition.
	 *
	 * 1. leave transition triggered.
	 * 2. call beforeLeave hook
	 * 3. add leave class (trigger css transition)
	 * 4. call leave hook (with possible explicit js callback)
	 * 5. reflow if no explicit js callback is provided
	 * 6. based on transition type:
	 *    - transition or animation:
	 *        wait for end event, remove class, then done if
	 *        there's no explicit js callback.
	 *    - no css transition:
	 *        done if there's no explicit js callback.
	 * 7. wait for either done or js callback, then call
	 *    afterLeave hook.
	 *
	 * @param {Function} op - remove/hide the element
	 * @param {Function} [cb]
	 */
	
	p$1.leave = function (op, cb) {
	  this.cancelPending();
	  this.callHook('beforeLeave');
	  this.op = op;
	  this.cb = cb;
	  addClass(this.el, this.leaveClass);
	  this.left = false;
	  this.callHookWithCb('leave');
	  if (this.left) {
	    return; // user called done synchronously.
	  }
	  this.cancel = this.hooks && this.hooks.leaveCancelled;
	  // only need to handle leaveDone if
	  // 1. the transition is already done (synchronously called
	  //    by the user, which causes this.op set to null)
	  // 2. there's no explicit js callback
	  if (this.op && !this.pendingJsCb) {
	    // if a CSS transition leaves immediately after enter,
	    // the transitionend event never fires. therefore we
	    // detect such cases and end the leave immediately.
	    if (this.justEntered) {
	      this.leaveDone();
	    } else {
	      pushJob(this.leaveNextTick);
	    }
	  }
	};
	
	/**
	 * The "nextTick" phase of a leaving transition.
	 */
	
	p$1.leaveNextTick = function () {
	  var type = this.getCssTransitionType(this.leaveClass);
	  if (type) {
	    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
	    this.setupCssCb(event, this.leaveDone);
	  } else {
	    this.leaveDone();
	  }
	};
	
	/**
	 * The "cleanup" phase of a leaving transition.
	 */
	
	p$1.leaveDone = function () {
	  this.left = true;
	  this.cancel = this.pendingJsCb = null;
	  this.op();
	  removeClass(this.el, this.leaveClass);
	  this.callHook('afterLeave');
	  if (this.cb) this.cb();
	  this.op = null;
	};
	
	/**
	 * Cancel any pending callbacks from a previously running
	 * but not finished transition.
	 */
	
	p$1.cancelPending = function () {
	  this.op = this.cb = null;
	  var hasPending = false;
	  if (this.pendingCssCb) {
	    hasPending = true;
	    off(this.el, this.pendingCssEvent, this.pendingCssCb);
	    this.pendingCssEvent = this.pendingCssCb = null;
	  }
	  if (this.pendingJsCb) {
	    hasPending = true;
	    this.pendingJsCb.cancel();
	    this.pendingJsCb = null;
	  }
	  if (hasPending) {
	    removeClass(this.el, this.enterClass);
	    removeClass(this.el, this.leaveClass);
	  }
	  if (this.cancel) {
	    this.cancel.call(this.vm, this.el);
	    this.cancel = null;
	  }
	};
	
	/**
	 * Call a user-provided synchronous hook function.
	 *
	 * @param {String} type
	 */
	
	p$1.callHook = function (type) {
	  if (this.hooks && this.hooks[type]) {
	    this.hooks[type].call(this.vm, this.el);
	  }
	};
	
	/**
	 * Call a user-provided, potentially-async hook function.
	 * We check for the length of arguments to see if the hook
	 * expects a `done` callback. If true, the transition's end
	 * will be determined by when the user calls that callback;
	 * otherwise, the end is determined by the CSS transition or
	 * animation.
	 *
	 * @param {String} type
	 */
	
	p$1.callHookWithCb = function (type) {
	  var hook = this.hooks && this.hooks[type];
	  if (hook) {
	    if (hook.length > 1) {
	      this.pendingJsCb = cancellable(this[type + 'Done']);
	    }
	    hook.call(this.vm, this.el, this.pendingJsCb);
	  }
	};
	
	/**
	 * Get an element's transition type based on the
	 * calculated styles.
	 *
	 * @param {String} className
	 * @return {Number}
	 */
	
	p$1.getCssTransitionType = function (className) {
	  /* istanbul ignore if */
	  if (!transitionEndEvent ||
	  // skip CSS transitions if page is not visible -
	  // this solves the issue of transitionend events not
	  // firing until the page is visible again.
	  // pageVisibility API is supported in IE10+, same as
	  // CSS transitions.
	  document.hidden ||
	  // explicit js-only transition
	  this.hooks && this.hooks.css === false ||
	  // element is hidden
	  isHidden(this.el)) {
	    return;
	  }
	  var type = this.type || this.typeCache[className];
	  if (type) return type;
	  var inlineStyles = this.el.style;
	  var computedStyles = window.getComputedStyle(this.el);
	  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
	  if (transDuration && transDuration !== '0s') {
	    type = TYPE_TRANSITION;
	  } else {
	    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
	    if (animDuration && animDuration !== '0s') {
	      type = TYPE_ANIMATION;
	    }
	  }
	  if (type) {
	    this.typeCache[className] = type;
	  }
	  return type;
	};
	
	/**
	 * Setup a CSS transitionend/animationend callback.
	 *
	 * @param {String} event
	 * @param {Function} cb
	 */
	
	p$1.setupCssCb = function (event, cb) {
	  this.pendingCssEvent = event;
	  var self = this;
	  var el = this.el;
	  var onEnd = this.pendingCssCb = function (e) {
	    if (e.target === el) {
	      off(el, event, onEnd);
	      self.pendingCssEvent = self.pendingCssCb = null;
	      if (!self.pendingJsCb && cb) {
	        cb();
	      }
	    }
	  };
	  on(el, event, onEnd);
	};
	
	/**
	 * Check if an element is hidden - in that case we can just
	 * skip the transition alltogether.
	 *
	 * @param {Element} el
	 * @return {Boolean}
	 */
	
	function isHidden(el) {
	  if (/svg$/.test(el.namespaceURI)) {
	    // SVG elements do not have offset(Width|Height)
	    // so we need to check the client rect
	    var rect = el.getBoundingClientRect();
	    return !(rect.width || rect.height);
	  } else {
	    return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
	  }
	}
	
	var transition$1 = {
	
	  priority: TRANSITION,
	
	  update: function update(id, oldId) {
	    var el = this.el;
	    // resolve on owner vm
	    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
	    id = id || 'v';
	    el.__v_trans = new Transition(el, id, hooks, this.vm);
	    if (oldId) {
	      removeClass(el, oldId + '-transition');
	    }
	    addClass(el, id + '-transition');
	  }
	};
	
	var internalDirectives = {
	  style: style,
	  'class': vClass,
	  component: component,
	  prop: propDef,
	  transition: transition$1
	};
	
	// special binding prefixes
	var bindRE = /^v-bind:|^:/;
	var onRE = /^v-on:|^@/;
	var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
	var modifierRE = /\.[^\.]+/g;
	var transitionRE = /^(v-bind:|:)?transition$/;
	
	// default directive priority
	var DEFAULT_PRIORITY = 1000;
	var DEFAULT_TERMINAL_PRIORITY = 2000;
	
	/**
	 * Compile a template and return a reusable composite link
	 * function, which recursively contains more link functions
	 * inside. This top level compile function would normally
	 * be called on instance root nodes, but can also be used
	 * for partial compilation if the partial argument is true.
	 *
	 * The returned composite link function, when called, will
	 * return an unlink function that tearsdown all directives
	 * created during the linking phase.
	 *
	 * @param {Element|DocumentFragment} el
	 * @param {Object} options
	 * @param {Boolean} partial
	 * @return {Function}
	 */
	
	function compile(el, options, partial) {
	  // link function for the node itself.
	  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
	  // link function for the childNodes
	  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
	
	  /**
	   * A composite linker function to be called on a already
	   * compiled piece of DOM, which instantiates all directive
	   * instances.
	   *
	   * @param {Vue} vm
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host] - host vm of transcluded content
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - link context fragment
	   * @return {Function|undefined}
	   */
	
	  return function compositeLinkFn(vm, el, host, scope, frag) {
	    // cache childNodes before linking parent, fix #657
	    var childNodes = toArray(el.childNodes);
	    // link
	    var dirs = linkAndCapture(function compositeLinkCapturer() {
	      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
	      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
	    }, vm);
	    return makeUnlinkFn(vm, dirs);
	  };
	}
	
	/**
	 * Apply a linker to a vm/element pair and capture the
	 * directives created during the process.
	 *
	 * @param {Function} linker
	 * @param {Vue} vm
	 */
	
	function linkAndCapture(linker, vm) {
	  /* istanbul ignore if */
	  if (process.env.NODE_ENV === 'production') {
	    // reset directives before every capture in production
	    // mode, so that when unlinking we don't need to splice
	    // them out (which turns out to be a perf hit).
	    // they are kept in development mode because they are
	    // useful for Vue's own tests.
	    vm._directives = [];
	  }
	  var originalDirCount = vm._directives.length;
	  linker();
	  var dirs = vm._directives.slice(originalDirCount);
	  dirs.sort(directiveComparator);
	  for (var i = 0, l = dirs.length; i < l; i++) {
	    dirs[i]._bind();
	  }
	  return dirs;
	}
	
	/**
	 * Directive priority sort comparator
	 *
	 * @param {Object} a
	 * @param {Object} b
	 */
	
	function directiveComparator(a, b) {
	  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
	  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
	  return a > b ? -1 : a === b ? 0 : 1;
	}
	
	/**
	 * Linker functions return an unlink function that
	 * tearsdown all directives instances generated during
	 * the process.
	 *
	 * We create unlink functions with only the necessary
	 * information to avoid retaining additional closures.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Vue} [context]
	 * @param {Array} [contextDirs]
	 * @return {Function}
	 */
	
	function makeUnlinkFn(vm, dirs, context, contextDirs) {
	  function unlink(destroying) {
	    teardownDirs(vm, dirs, destroying);
	    if (context && contextDirs) {
	      teardownDirs(context, contextDirs);
	    }
	  }
	  // expose linked directives
	  unlink.dirs = dirs;
	  return unlink;
	}
	
	/**
	 * Teardown partial linked directives.
	 *
	 * @param {Vue} vm
	 * @param {Array} dirs
	 * @param {Boolean} destroying
	 */
	
	function teardownDirs(vm, dirs, destroying) {
	  var i = dirs.length;
	  while (i--) {
	    dirs[i]._teardown();
	    if (process.env.NODE_ENV !== 'production' && !destroying) {
	      vm._directives.$remove(dirs[i]);
	    }
	  }
	}
	
	/**
	 * Compile link props on an instance.
	 *
	 * @param {Vue} vm
	 * @param {Element} el
	 * @param {Object} props
	 * @param {Object} [scope]
	 * @return {Function}
	 */
	
	function compileAndLinkProps(vm, el, props, scope) {
	  var propsLinkFn = compileProps(el, props, vm);
	  var propDirs = linkAndCapture(function () {
	    propsLinkFn(vm, scope);
	  }, vm);
	  return makeUnlinkFn(vm, propDirs);
	}
	
	/**
	 * Compile the root element of an instance.
	 *
	 * 1. attrs on context container (context scope)
	 * 2. attrs on the component template root node, if
	 *    replace:true (child scope)
	 *
	 * If this is a fragment instance, we only need to compile 1.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @param {Object} contextOptions
	 * @return {Function}
	 */
	
	function compileRoot(el, options, contextOptions) {
	  var containerAttrs = options._containerAttrs;
	  var replacerAttrs = options._replacerAttrs;
	  var contextLinkFn, replacerLinkFn;
	
	  // only need to compile other attributes for
	  // non-fragment instances
	  if (el.nodeType !== 11) {
	    // for components, container and replacer need to be
	    // compiled separately and linked in different scopes.
	    if (options._asComponent) {
	      // 2. container attributes
	      if (containerAttrs && contextOptions) {
	        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
	      }
	      if (replacerAttrs) {
	        // 3. replacer attributes
	        replacerLinkFn = compileDirectives(replacerAttrs, options);
	      }
	    } else {
	      // non-component, just compile as a normal element.
	      replacerLinkFn = compileDirectives(el.attributes, options);
	    }
	  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
	    // warn container directives for fragment instances
	    var names = containerAttrs.filter(function (attr) {
	      // allow vue-loader/vueify scoped css attributes
	      return attr.name.indexOf('_v-') < 0 &&
	      // allow event listeners
	      !onRE.test(attr.name) &&
	      // allow slots
	      attr.name !== 'slot';
	    }).map(function (attr) {
	      return '"' + attr.name + '"';
	    });
	    if (names.length) {
	      var plural = names.length > 1;
	      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
	    }
	  }
	
	  options._containerAttrs = options._replacerAttrs = null;
	  return function rootLinkFn(vm, el, scope) {
	    // link context scope dirs
	    var context = vm._context;
	    var contextDirs;
	    if (context && contextLinkFn) {
	      contextDirs = linkAndCapture(function () {
	        contextLinkFn(context, el, null, scope);
	      }, context);
	    }
	
	    // link self
	    var selfDirs = linkAndCapture(function () {
	      if (replacerLinkFn) replacerLinkFn(vm, el);
	    }, vm);
	
	    // return the unlink function that tearsdown context
	    // container directives.
	    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
	  };
	}
	
	/**
	 * Compile a node and return a nodeLinkFn based on the
	 * node type.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileNode(node, options) {
	  var type = node.nodeType;
	  if (type === 1 && !isScript(node)) {
	    return compileElement(node, options);
	  } else if (type === 3 && node.data.trim()) {
	    return compileTextNode(node, options);
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Compile an element and return a nodeLinkFn.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|null}
	 */
	
	function compileElement(el, options) {
	  // preprocess textareas.
	  // textarea treats its text content as the initial value.
	  // just bind it as an attr directive for value.
	  if (el.tagName === 'TEXTAREA') {
	    var tokens = parseText(el.value);
	    if (tokens) {
	      el.setAttribute(':value', tokensToExp(tokens));
	      el.value = '';
	    }
	  }
	  var linkFn;
	  var hasAttrs = el.hasAttributes();
	  var attrs = hasAttrs && toArray(el.attributes);
	  // check terminal directives (for & if)
	  if (hasAttrs) {
	    linkFn = checkTerminalDirectives(el, attrs, options);
	  }
	  // check element directives
	  if (!linkFn) {
	    linkFn = checkElementDirectives(el, options);
	  }
	  // check component
	  if (!linkFn) {
	    linkFn = checkComponent(el, options);
	  }
	  // normal directives
	  if (!linkFn && hasAttrs) {
	    linkFn = compileDirectives(attrs, options);
	  }
	  return linkFn;
	}
	
	/**
	 * Compile a textNode and return a nodeLinkFn.
	 *
	 * @param {TextNode} node
	 * @param {Object} options
	 * @return {Function|null} textNodeLinkFn
	 */
	
	function compileTextNode(node, options) {
	  // skip marked text nodes
	  if (node._skip) {
	    return removeText;
	  }
	
	  var tokens = parseText(node.wholeText);
	  if (!tokens) {
	    return null;
	  }
	
	  // mark adjacent text nodes as skipped,
	  // because we are using node.wholeText to compile
	  // all adjacent text nodes together. This fixes
	  // issues in IE where sometimes it splits up a single
	  // text node into multiple ones.
	  var next = node.nextSibling;
	  while (next && next.nodeType === 3) {
	    next._skip = true;
	    next = next.nextSibling;
	  }
	
	  var frag = document.createDocumentFragment();
	  var el, token;
	  for (var i = 0, l = tokens.length; i < l; i++) {
	    token = tokens[i];
	    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
	    frag.appendChild(el);
	  }
	  return makeTextNodeLinkFn(tokens, frag, options);
	}
	
	/**
	 * Linker for an skipped text node.
	 *
	 * @param {Vue} vm
	 * @param {Text} node
	 */
	
	function removeText(vm, node) {
	  remove(node);
	}
	
	/**
	 * Process a single text token.
	 *
	 * @param {Object} token
	 * @param {Object} options
	 * @return {Node}
	 */
	
	function processTextToken(token, options) {
	  var el;
	  if (token.oneTime) {
	    el = document.createTextNode(token.value);
	  } else {
	    if (token.html) {
	      el = document.createComment('v-html');
	      setTokenType('html');
	    } else {
	      // IE will clean up empty textNodes during
	      // frag.cloneNode(true), so we have to give it
	      // something here...
	      el = document.createTextNode(' ');
	      setTokenType('text');
	    }
	  }
	  function setTokenType(type) {
	    if (token.descriptor) return;
	    var parsed = parseDirective(token.value);
	    token.descriptor = {
	      name: type,
	      def: directives[type],
	      expression: parsed.expression,
	      filters: parsed.filters
	    };
	  }
	  return el;
	}
	
	/**
	 * Build a function that processes a textNode.
	 *
	 * @param {Array<Object>} tokens
	 * @param {DocumentFragment} frag
	 */
	
	function makeTextNodeLinkFn(tokens, frag) {
	  return function textNodeLinkFn(vm, el, host, scope) {
	    var fragClone = frag.cloneNode(true);
	    var childNodes = toArray(fragClone.childNodes);
	    var token, value, node;
	    for (var i = 0, l = tokens.length; i < l; i++) {
	      token = tokens[i];
	      value = token.value;
	      if (token.tag) {
	        node = childNodes[i];
	        if (token.oneTime) {
	          value = (scope || vm).$eval(value);
	          if (token.html) {
	            replace(node, parseTemplate(value, true));
	          } else {
	            node.data = value;
	          }
	        } else {
	          vm._bindDir(token.descriptor, node, host, scope);
	        }
	      }
	    }
	    replace(el, fragClone);
	  };
	}
	
	/**
	 * Compile a node list and return a childLinkFn.
	 *
	 * @param {NodeList} nodeList
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function compileNodeList(nodeList, options) {
	  var linkFns = [];
	  var nodeLinkFn, childLinkFn, node;
	  for (var i = 0, l = nodeList.length; i < l; i++) {
	    node = nodeList[i];
	    nodeLinkFn = compileNode(node, options);
	    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
	    linkFns.push(nodeLinkFn, childLinkFn);
	  }
	  return linkFns.length ? makeChildLinkFn(linkFns) : null;
	}
	
	/**
	 * Make a child link function for a node's childNodes.
	 *
	 * @param {Array<Function>} linkFns
	 * @return {Function} childLinkFn
	 */
	
	function makeChildLinkFn(linkFns) {
	  return function childLinkFn(vm, nodes, host, scope, frag) {
	    var node, nodeLinkFn, childrenLinkFn;
	    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
	      node = nodes[n];
	      nodeLinkFn = linkFns[i++];
	      childrenLinkFn = linkFns[i++];
	      // cache childNodes before linking parent, fix #657
	      var childNodes = toArray(node.childNodes);
	      if (nodeLinkFn) {
	        nodeLinkFn(vm, node, host, scope, frag);
	      }
	      if (childrenLinkFn) {
	        childrenLinkFn(vm, childNodes, host, scope, frag);
	      }
	    }
	  };
	}
	
	/**
	 * Check for element directives (custom elements that should
	 * be resovled as terminal directives).
	 *
	 * @param {Element} el
	 * @param {Object} options
	 */
	
	function checkElementDirectives(el, options) {
	  var tag = el.tagName.toLowerCase();
	  if (commonTagRE.test(tag)) {
	    return;
	  }
	  var def = resolveAsset(options, 'elementDirectives', tag);
	  if (def) {
	    return makeTerminalNodeLinkFn(el, tag, '', options, def);
	  }
	}
	
	/**
	 * Check if an element is a component. If yes, return
	 * a component link function.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Function|undefined}
	 */
	
	function checkComponent(el, options) {
	  var component = checkComponentAttr(el, options);
	  if (component) {
	    var ref = findRef(el);
	    var descriptor = {
	      name: 'component',
	      ref: ref,
	      expression: component.id,
	      def: internalDirectives.component,
	      modifiers: {
	        literal: !component.dynamic
	      }
	    };
	    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
	      if (ref) {
	        defineReactive((scope || vm).$refs, ref, null);
	      }
	      vm._bindDir(descriptor, el, host, scope, frag);
	    };
	    componentLinkFn.terminal = true;
	    return componentLinkFn;
	  }
	}
	
	/**
	 * Check an element for terminal directives in fixed order.
	 * If it finds one, return a terminal link function.
	 *
	 * @param {Element} el
	 * @param {Array} attrs
	 * @param {Object} options
	 * @return {Function} terminalLinkFn
	 */
	
	function checkTerminalDirectives(el, attrs, options) {
	  // skip v-pre
	  if (getAttr(el, 'v-pre') !== null) {
	    return skip;
	  }
	  // skip v-else block, but only if following v-if
	  if (el.hasAttribute('v-else')) {
	    var prev = el.previousElementSibling;
	    if (prev && prev.hasAttribute('v-if')) {
	      return skip;
	    }
	  }
	
	  var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
	  for (var i = 0, j = attrs.length; i < j; i++) {
	    attr = attrs[i];
	    name = attr.name.replace(modifierRE, '');
	    if (matched = name.match(dirAttrRE)) {
	      def = resolveAsset(options, 'directives', matched[1]);
	      if (def && def.terminal) {
	        if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
	          termDef = def;
	          rawName = attr.name;
	          modifiers = parseModifiers(attr.name);
	          value = attr.value;
	          dirName = matched[1];
	          arg = matched[2];
	        }
	      }
	    }
	  }
	
	  if (termDef) {
	    return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
	  }
	}
	
	function skip() {}
	skip.terminal = true;
	
	/**
	 * Build a node link function for a terminal directive.
	 * A terminal link function terminates the current
	 * compilation recursion and handles compilation of the
	 * subtree in the directive.
	 *
	 * @param {Element} el
	 * @param {String} dirName
	 * @param {String} value
	 * @param {Object} options
	 * @param {Object} def
	 * @param {String} [rawName]
	 * @param {String} [arg]
	 * @param {Object} [modifiers]
	 * @return {Function} terminalLinkFn
	 */
	
	function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
	  var parsed = parseDirective(value);
	  var descriptor = {
	    name: dirName,
	    arg: arg,
	    expression: parsed.expression,
	    filters: parsed.filters,
	    raw: value,
	    attr: rawName,
	    modifiers: modifiers,
	    def: def
	  };
	  // check ref for v-for and router-view
	  if (dirName === 'for' || dirName === 'router-view') {
	    descriptor.ref = findRef(el);
	  }
	  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
	    if (descriptor.ref) {
	      defineReactive((scope || vm).$refs, descriptor.ref, null);
	    }
	    vm._bindDir(descriptor, el, host, scope, frag);
	  };
	  fn.terminal = true;
	  return fn;
	}
	
	/**
	 * Compile the directives on an element and return a linker.
	 *
	 * @param {Array|NamedNodeMap} attrs
	 * @param {Object} options
	 * @return {Function}
	 */
	
	function compileDirectives(attrs, options) {
	  var i = attrs.length;
	  var dirs = [];
	  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
	  while (i--) {
	    attr = attrs[i];
	    name = rawName = attr.name;
	    value = rawValue = attr.value;
	    tokens = parseText(value);
	    // reset arg
	    arg = null;
	    // check modifiers
	    modifiers = parseModifiers(name);
	    name = name.replace(modifierRE, '');
	
	    // attribute interpolations
	    if (tokens) {
	      value = tokensToExp(tokens);
	      arg = name;
	      pushDir('bind', directives.bind, tokens);
	      // warn against mixing mustaches with v-bind
	      if (process.env.NODE_ENV !== 'production') {
	        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
	          return attr.name === ':class' || attr.name === 'v-bind:class';
	        })) {
	          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
	        }
	      }
	    } else
	
	      // special attribute: transition
	      if (transitionRE.test(name)) {
	        modifiers.literal = !bindRE.test(name);
	        pushDir('transition', internalDirectives.transition);
	      } else
	
	        // event handlers
	        if (onRE.test(name)) {
	          arg = name.replace(onRE, '');
	          pushDir('on', directives.on);
	        } else
	
	          // attribute bindings
	          if (bindRE.test(name)) {
	            dirName = name.replace(bindRE, '');
	            if (dirName === 'style' || dirName === 'class') {
	              pushDir(dirName, internalDirectives[dirName]);
	            } else {
	              arg = dirName;
	              pushDir('bind', directives.bind);
	            }
	          } else
	
	            // normal directives
	            if (matched = name.match(dirAttrRE)) {
	              dirName = matched[1];
	              arg = matched[2];
	
	              // skip v-else (when used with v-show)
	              if (dirName === 'else') {
	                continue;
	              }
	
	              dirDef = resolveAsset(options, 'directives', dirName, true);
	              if (dirDef) {
	                pushDir(dirName, dirDef);
	              }
	            }
	  }
	
	  /**
	   * Push a directive.
	   *
	   * @param {String} dirName
	   * @param {Object|Function} def
	   * @param {Array} [interpTokens]
	   */
	
	  function pushDir(dirName, def, interpTokens) {
	    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
	    var parsed = !hasOneTimeToken && parseDirective(value);
	    dirs.push({
	      name: dirName,
	      attr: rawName,
	      raw: rawValue,
	      def: def,
	      arg: arg,
	      modifiers: modifiers,
	      // conversion from interpolation strings with one-time token
	      // to expression is differed until directive bind time so that we
	      // have access to the actual vm context for one-time bindings.
	      expression: parsed && parsed.expression,
	      filters: parsed && parsed.filters,
	      interp: interpTokens,
	      hasOneTime: hasOneTimeToken
	    });
	  }
	
	  if (dirs.length) {
	    return makeNodeLinkFn(dirs);
	  }
	}
	
	/**
	 * Parse modifiers from directive attribute name.
	 *
	 * @param {String} name
	 * @return {Object}
	 */
	
	function parseModifiers(name) {
	  var res = Object.create(null);
	  var match = name.match(modifierRE);
	  if (match) {
	    var i = match.length;
	    while (i--) {
	      res[match[i].slice(1)] = true;
	    }
	  }
	  return res;
	}
	
	/**
	 * Build a link function for all directives on a single node.
	 *
	 * @param {Array} directives
	 * @return {Function} directivesLinkFn
	 */
	
	function makeNodeLinkFn(directives) {
	  return function nodeLinkFn(vm, el, host, scope, frag) {
	    // reverse apply because it's sorted low to high
	    var i = directives.length;
	    while (i--) {
	      vm._bindDir(directives[i], el, host, scope, frag);
	    }
	  };
	}
	
	/**
	 * Check if an interpolation string contains one-time tokens.
	 *
	 * @param {Array} tokens
	 * @return {Boolean}
	 */
	
	function hasOneTime(tokens) {
	  var i = tokens.length;
	  while (i--) {
	    if (tokens[i].oneTime) return true;
	  }
	}
	
	function isScript(el) {
	  return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
	}
	
	var specialCharRE = /[^\w\-:\.]/;
	
	/**
	 * Process an element or a DocumentFragment based on a
	 * instance option object. This allows us to transclude
	 * a template node/fragment before the instance is created,
	 * so the processed fragment can then be cloned and reused
	 * in v-for.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transclude(el, options) {
	  // extract container attributes to pass them down
	  // to compiler, because they need to be compiled in
	  // parent scope. we are mutating the options object here
	  // assuming the same object will be used for compile
	  // right after this.
	  if (options) {
	    options._containerAttrs = extractAttrs(el);
	  }
	  // for template tags, what we want is its content as
	  // a documentFragment (for fragment instances)
	  if (isTemplate(el)) {
	    el = parseTemplate(el);
	  }
	  if (options) {
	    if (options._asComponent && !options.template) {
	      options.template = '<slot></slot>';
	    }
	    if (options.template) {
	      options._content = extractContent(el);
	      el = transcludeTemplate(el, options);
	    }
	  }
	  if (isFragment(el)) {
	    // anchors for fragment instance
	    // passing in `persist: true` to avoid them being
	    // discarded by IE during template cloning
	    prepend(createAnchor('v-start', true), el);
	    el.appendChild(createAnchor('v-end', true));
	  }
	  return el;
	}
	
	/**
	 * Process the template option.
	 * If the replace option is true this will swap the $el.
	 *
	 * @param {Element} el
	 * @param {Object} options
	 * @return {Element|DocumentFragment}
	 */
	
	function transcludeTemplate(el, options) {
	  var template = options.template;
	  var frag = parseTemplate(template, true);
	  if (frag) {
	    var replacer = frag.firstChild;
	    var tag = replacer.tagName && replacer.tagName.toLowerCase();
	    if (options.replace) {
	      /* istanbul ignore if */
	      if (el === document.body) {
	        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
	      }
	      // there are many cases where the instance must
	      // become a fragment instance: basically anything that
	      // can create more than 1 root nodes.
	      if (
	      // multi-children template
	      frag.childNodes.length > 1 ||
	      // non-element template
	      replacer.nodeType !== 1 ||
	      // single nested component
	      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
	      // element directive
	      resolveAsset(options, 'elementDirectives', tag) ||
	      // for block
	      replacer.hasAttribute('v-for') ||
	      // if block
	      replacer.hasAttribute('v-if')) {
	        return frag;
	      } else {
	        options._replacerAttrs = extractAttrs(replacer);
	        mergeAttrs(el, replacer);
	        return replacer;
	      }
	    } else {
	      el.appendChild(frag);
	      return el;
	    }
	  } else {
	    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
	  }
	}
	
	/**
	 * Helper to extract a component container's attributes
	 * into a plain object array.
	 *
	 * @param {Element} el
	 * @return {Array}
	 */
	
	function extractAttrs(el) {
	  if (el.nodeType === 1 && el.hasAttributes()) {
	    return toArray(el.attributes);
	  }
	}
	
	/**
	 * Merge the attributes of two elements, and make sure
	 * the class names are merged properly.
	 *
	 * @param {Element} from
	 * @param {Element} to
	 */
	
	function mergeAttrs(from, to) {
	  var attrs = from.attributes;
	  var i = attrs.length;
	  var name, value;
	  while (i--) {
	    name = attrs[i].name;
	    value = attrs[i].value;
	    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
	      to.setAttribute(name, value);
	    } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
	      value.split(/\s+/).forEach(function (cls) {
	        addClass(to, cls);
	      });
	    }
	  }
	}
	
	/**
	 * Scan and determine slot content distribution.
	 * We do this during transclusion instead at compile time so that
	 * the distribution is decoupled from the compilation order of
	 * the slots.
	 *
	 * @param {Element|DocumentFragment} template
	 * @param {Element} content
	 * @param {Vue} vm
	 */
	
	function resolveSlots(vm, content) {
	  if (!content) {
	    return;
	  }
	  var contents = vm._slotContents = Object.create(null);
	  var el, name;
	  for (var i = 0, l = content.children.length; i < l; i++) {
	    el = content.children[i];
	    /* eslint-disable no-cond-assign */
	    if (name = el.getAttribute('slot')) {
	      (contents[name] || (contents[name] = [])).push(el);
	    }
	    /* eslint-enable no-cond-assign */
	    if (process.env.NODE_ENV !== 'production' && getBindAttr(el, 'slot')) {
	      warn('The "slot" attribute must be static.', vm.$parent);
	    }
	  }
	  for (name in contents) {
	    contents[name] = extractFragment(contents[name], content);
	  }
	  if (content.hasChildNodes()) {
	    var nodes = content.childNodes;
	    if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
	      return;
	    }
	    contents['default'] = extractFragment(content.childNodes, content);
	  }
	}
	
	/**
	 * Extract qualified content nodes from a node list.
	 *
	 * @param {NodeList} nodes
	 * @return {DocumentFragment}
	 */
	
	function extractFragment(nodes, parent) {
	  var frag = document.createDocumentFragment();
	  nodes = toArray(nodes);
	  for (var i = 0, l = nodes.length; i < l; i++) {
	    var node = nodes[i];
	    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
	      parent.removeChild(node);
	      node = parseTemplate(node, true);
	    }
	    frag.appendChild(node);
	  }
	  return frag;
	}
	
	
	
	var compiler = Object.freeze({
		compile: compile,
		compileAndLinkProps: compileAndLinkProps,
		compileRoot: compileRoot,
		transclude: transclude,
		resolveSlots: resolveSlots
	});
	
	function stateMixin (Vue) {
	  /**
	   * Accessor for `$data` property, since setting $data
	   * requires observing the new object and updating
	   * proxied properties.
	   */
	
	  Object.defineProperty(Vue.prototype, '$data', {
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      if (newData !== this._data) {
	        this._setData(newData);
	      }
	    }
	  });
	
	  /**
	   * Setup the scope of an instance, which contains:
	   * - observed data
	   * - computed properties
	   * - user methods
	   * - meta properties
	   */
	
	  Vue.prototype._initState = function () {
	    this._initProps();
	    this._initMeta();
	    this._initMethods();
	    this._initData();
	    this._initComputed();
	  };
	
	  /**
	   * Initialize props.
	   */
	
	  Vue.prototype._initProps = function () {
	    var options = this.$options;
	    var el = options.el;
	    var props = options.props;
	    if (props && !el) {
	      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
	    }
	    // make sure to convert string selectors into element now
	    el = options.el = query(el);
	    this._propsUnlinkFn = el && el.nodeType === 1 && props
	    // props must be linked in proper scope if inside v-for
	    ? compileAndLinkProps(this, el, props, this._scope) : null;
	  };
	
	  /**
	   * Initialize the data.
	   */
	
	  Vue.prototype._initData = function () {
	    var dataFn = this.$options.data;
	    var data = this._data = dataFn ? dataFn() : {};
	    if (!isPlainObject(data)) {
	      data = {};
	      process.env.NODE_ENV !== 'production' && warn('data functions should return an object.', this);
	    }
	    var props = this._props;
	    // proxy data on instance
	    var keys = Object.keys(data);
	    var i, key;
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      // there are two scenarios where we can proxy a data key:
	      // 1. it's not already defined as a prop
	      // 2. it's provided via a instantiation option AND there are no
	      //    template prop present
	      if (!props || !hasOwn(props, key)) {
	        this._proxy(key);
	      } else if (process.env.NODE_ENV !== 'production') {
	        warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
	      }
	    }
	    // observe data
	    observe(data, this);
	  };
	
	  /**
	   * Swap the instance's $data. Called in $data's setter.
	   *
	   * @param {Object} newData
	   */
	
	  Vue.prototype._setData = function (newData) {
	    newData = newData || {};
	    var oldData = this._data;
	    this._data = newData;
	    var keys, key, i;
	    // unproxy keys not present in new data
	    keys = Object.keys(oldData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!(key in newData)) {
	        this._unproxy(key);
	      }
	    }
	    // proxy keys not already proxied,
	    // and trigger change for changed values
	    keys = Object.keys(newData);
	    i = keys.length;
	    while (i--) {
	      key = keys[i];
	      if (!hasOwn(this, key)) {
	        // new property
	        this._proxy(key);
	      }
	    }
	    oldData.__ob__.removeVm(this);
	    observe(newData, this);
	    this._digest();
	  };
	
	  /**
	   * Proxy a property, so that
	   * vm.prop === vm._data.prop
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._proxy = function (key) {
	    if (!isReserved(key)) {
	      // need to store ref to self here
	      // because these getter/setters might
	      // be called by child scopes via
	      // prototype inheritance.
	      var self = this;
	      Object.defineProperty(self, key, {
	        configurable: true,
	        enumerable: true,
	        get: function proxyGetter() {
	          return self._data[key];
	        },
	        set: function proxySetter(val) {
	          self._data[key] = val;
	        }
	      });
	    }
	  };
	
	  /**
	   * Unproxy a property.
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype._unproxy = function (key) {
	    if (!isReserved(key)) {
	      delete this[key];
	    }
	  };
	
	  /**
	   * Force update on every watcher in scope.
	   */
	
	  Vue.prototype._digest = function () {
	    for (var i = 0, l = this._watchers.length; i < l; i++) {
	      this._watchers[i].update(true); // shallow updates
	    }
	  };
	
	  /**
	   * Setup computed properties. They are essentially
	   * special getter/setters
	   */
	
	  function noop() {}
	  Vue.prototype._initComputed = function () {
	    var computed = this.$options.computed;
	    if (computed) {
	      for (var key in computed) {
	        var userDef = computed[key];
	        var def = {
	          enumerable: true,
	          configurable: true
	        };
	        if (typeof userDef === 'function') {
	          def.get = makeComputedGetter(userDef, this);
	          def.set = noop;
	        } else {
	          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
	          def.set = userDef.set ? bind(userDef.set, this) : noop;
	        }
	        Object.defineProperty(this, key, def);
	      }
	    }
	  };
	
	  function makeComputedGetter(getter, owner) {
	    var watcher = new Watcher(owner, getter, null, {
	      lazy: true
	    });
	    return function computedGetter() {
	      if (watcher.dirty) {
	        watcher.evaluate();
	      }
	      if (Dep.target) {
	        watcher.depend();
	      }
	      return watcher.value;
	    };
	  }
	
	  /**
	   * Setup instance methods. Methods must be bound to the
	   * instance since they might be passed down as a prop to
	   * child components.
	   */
	
	  Vue.prototype._initMethods = function () {
	    var methods = this.$options.methods;
	    if (methods) {
	      for (var key in methods) {
	        this[key] = bind(methods[key], this);
	      }
	    }
	  };
	
	  /**
	   * Initialize meta information like $index, $key & $value.
	   */
	
	  Vue.prototype._initMeta = function () {
	    var metas = this.$options._meta;
	    if (metas) {
	      for (var key in metas) {
	        defineReactive(this, key, metas[key]);
	      }
	    }
	  };
	}
	
	var eventRE = /^v-on:|^@/;
	
	function eventsMixin (Vue) {
	  /**
	   * Setup the instance's option events & watchers.
	   * If the value is a string, we pull it from the
	   * instance's methods by name.
	   */
	
	  Vue.prototype._initEvents = function () {
	    var options = this.$options;
	    if (options._asComponent) {
	      registerComponentEvents(this, options.el);
	    }
	    registerCallbacks(this, '$on', options.events);
	    registerCallbacks(this, '$watch', options.watch);
	  };
	
	  /**
	   * Register v-on events on a child component
	   *
	   * @param {Vue} vm
	   * @param {Element} el
	   */
	
	  function registerComponentEvents(vm, el) {
	    var attrs = el.attributes;
	    var name, value, handler;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      name = attrs[i].name;
	      if (eventRE.test(name)) {
	        name = name.replace(eventRE, '');
	        // force the expression into a statement so that
	        // it always dynamically resolves the method to call (#2670)
	        // kinda ugly hack, but does the job.
	        value = attrs[i].value;
	        if (isSimplePath(value)) {
	          value += '.apply(this, $arguments)';
	        }
	        handler = (vm._scope || vm._context).$eval(value, true);
	        handler._fromParent = true;
	        vm.$on(name.replace(eventRE), handler);
	      }
	    }
	  }
	
	  /**
	   * Register callbacks for option events and watchers.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {Object} hash
	   */
	
	  function registerCallbacks(vm, action, hash) {
	    if (!hash) return;
	    var handlers, key, i, j;
	    for (key in hash) {
	      handlers = hash[key];
	      if (isArray(handlers)) {
	        for (i = 0, j = handlers.length; i < j; i++) {
	          register(vm, action, key, handlers[i]);
	        }
	      } else {
	        register(vm, action, key, handlers);
	      }
	    }
	  }
	
	  /**
	   * Helper to register an event/watch callback.
	   *
	   * @param {Vue} vm
	   * @param {String} action
	   * @param {String} key
	   * @param {Function|String|Object} handler
	   * @param {Object} [options]
	   */
	
	  function register(vm, action, key, handler, options) {
	    var type = typeof handler;
	    if (type === 'function') {
	      vm[action](key, handler, options);
	    } else if (type === 'string') {
	      var methods = vm.$options.methods;
	      var method = methods && methods[handler];
	      if (method) {
	        vm[action](key, method, options);
	      } else {
	        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
	      }
	    } else if (handler && type === 'object') {
	      register(vm, action, key, handler.handler, handler);
	    }
	  }
	
	  /**
	   * Setup recursive attached/detached calls
	   */
	
	  Vue.prototype._initDOMHooks = function () {
	    this.$on('hook:attached', onAttached);
	    this.$on('hook:detached', onDetached);
	  };
	
	  /**
	   * Callback to recursively call attached hook on children
	   */
	
	  function onAttached() {
	    if (!this._isAttached) {
	      this._isAttached = true;
	      this.$children.forEach(callAttach);
	    }
	  }
	
	  /**
	   * Iterator to call attached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callAttach(child) {
	    if (!child._isAttached && inDoc(child.$el)) {
	      child._callHook('attached');
	    }
	  }
	
	  /**
	   * Callback to recursively call detached hook on children
	   */
	
	  function onDetached() {
	    if (this._isAttached) {
	      this._isAttached = false;
	      this.$children.forEach(callDetach);
	    }
	  }
	
	  /**
	   * Iterator to call detached hook
	   *
	   * @param {Vue} child
	   */
	
	  function callDetach(child) {
	    if (child._isAttached && !inDoc(child.$el)) {
	      child._callHook('detached');
	    }
	  }
	
	  /**
	   * Trigger all handlers for a hook
	   *
	   * @param {String} hook
	   */
	
	  Vue.prototype._callHook = function (hook) {
	    this.$emit('pre-hook:' + hook);
	    var handlers = this.$options[hook];
	    if (handlers) {
	      for (var i = 0, j = handlers.length; i < j; i++) {
	        handlers[i].call(this);
	      }
	    }
	    this.$emit('hook:' + hook);
	  };
	}
	
	function noop() {}
	
	/**
	 * A directive links a DOM element with a piece of data,
	 * which is the result of evaluating an expression.
	 * It registers a watcher with the expression and calls
	 * the DOM update function when a change is triggered.
	 *
	 * @param {Object} descriptor
	 *                 - {String} name
	 *                 - {Object} def
	 *                 - {String} expression
	 *                 - {Array<Object>} [filters]
	 *                 - {Object} [modifiers]
	 *                 - {Boolean} literal
	 *                 - {String} attr
	 *                 - {String} arg
	 *                 - {String} raw
	 *                 - {String} [ref]
	 *                 - {Array<Object>} [interp]
	 *                 - {Boolean} [hasOneTime]
	 * @param {Vue} vm
	 * @param {Node} el
	 * @param {Vue} [host] - transclusion host component
	 * @param {Object} [scope] - v-for scope
	 * @param {Fragment} [frag] - owner fragment
	 * @constructor
	 */
	function Directive(descriptor, vm, el, host, scope, frag) {
	  this.vm = vm;
	  this.el = el;
	  // copy descriptor properties
	  this.descriptor = descriptor;
	  this.name = descriptor.name;
	  this.expression = descriptor.expression;
	  this.arg = descriptor.arg;
	  this.modifiers = descriptor.modifiers;
	  this.filters = descriptor.filters;
	  this.literal = this.modifiers && this.modifiers.literal;
	  // private
	  this._locked = false;
	  this._bound = false;
	  this._listeners = null;
	  // link context
	  this._host = host;
	  this._scope = scope;
	  this._frag = frag;
	  // store directives on node in dev mode
	  if (process.env.NODE_ENV !== 'production' && this.el) {
	    this.el._vue_directives = this.el._vue_directives || [];
	    this.el._vue_directives.push(this);
	  }
	}
	
	/**
	 * Initialize the directive, mixin definition properties,
	 * setup the watcher, call definition bind() and update()
	 * if present.
	 */
	
	Directive.prototype._bind = function () {
	  var name = this.name;
	  var descriptor = this.descriptor;
	
	  // remove attribute
	  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
	    var attr = descriptor.attr || 'v-' + name;
	    this.el.removeAttribute(attr);
	  }
	
	  // copy def properties
	  var def = descriptor.def;
	  if (typeof def === 'function') {
	    this.update = def;
	  } else {
	    extend(this, def);
	  }
	
	  // setup directive params
	  this._setupParams();
	
	  // initial bind
	  if (this.bind) {
	    this.bind();
	  }
	  this._bound = true;
	
	  if (this.literal) {
	    this.update && this.update(descriptor.raw);
	  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
	    // wrapped updater for context
	    var dir = this;
	    if (this.update) {
	      this._update = function (val, oldVal) {
	        if (!dir._locked) {
	          dir.update(val, oldVal);
	        }
	      };
	    } else {
	      this._update = noop;
	    }
	    var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
	    var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
	    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
	    {
	      filters: this.filters,
	      twoWay: this.twoWay,
	      deep: this.deep,
	      preProcess: preProcess,
	      postProcess: postProcess,
	      scope: this._scope
	    });
	    // v-model with inital inline value need to sync back to
	    // model instead of update to DOM on init. They would
	    // set the afterBind hook to indicate that.
	    if (this.afterBind) {
	      this.afterBind();
	    } else if (this.update) {
	      this.update(watcher.value);
	    }
	  }
	};
	
	/**
	 * Setup all param attributes, e.g. track-by,
	 * transition-mode, etc...
	 */
	
	Directive.prototype._setupParams = function () {
	  if (!this.params) {
	    return;
	  }
	  var params = this.params;
	  // swap the params array with a fresh object.
	  this.params = Object.create(null);
	  var i = params.length;
	  var key, val, mappedKey;
	  while (i--) {
	    key = hyphenate(params[i]);
	    mappedKey = camelize(key);
	    val = getBindAttr(this.el, key);
	    if (val != null) {
	      // dynamic
	      this._setupParamWatcher(mappedKey, val);
	    } else {
	      // static
	      val = getAttr(this.el, key);
	      if (val != null) {
	        this.params[mappedKey] = val === '' ? true : val;
	      }
	    }
	  }
	};
	
	/**
	 * Setup a watcher for a dynamic param.
	 *
	 * @param {String} key
	 * @param {String} expression
	 */
	
	Directive.prototype._setupParamWatcher = function (key, expression) {
	  var self = this;
	  var called = false;
	  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
	    self.params[key] = val;
	    // since we are in immediate mode,
	    // only call the param change callbacks if this is not the first update.
	    if (called) {
	      var cb = self.paramWatchers && self.paramWatchers[key];
	      if (cb) {
	        cb.call(self, val, oldVal);
	      }
	    } else {
	      called = true;
	    }
	  }, {
	    immediate: true,
	    user: false
	  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
	};
	
	/**
	 * Check if the directive is a function caller
	 * and if the expression is a callable one. If both true,
	 * we wrap up the expression and use it as the event
	 * handler.
	 *
	 * e.g. on-click="a++"
	 *
	 * @return {Boolean}
	 */
	
	Directive.prototype._checkStatement = function () {
	  var expression = this.expression;
	  if (expression && this.acceptStatement && !isSimplePath(expression)) {
	    var fn = parseExpression(expression).get;
	    var scope = this._scope || this.vm;
	    var handler = function handler(e) {
	      scope.$event = e;
	      fn.call(scope, scope);
	      scope.$event = null;
	    };
	    if (this.filters) {
	      handler = scope._applyFilters(handler, null, this.filters);
	    }
	    this.update(handler);
	    return true;
	  }
	};
	
	/**
	 * Set the corresponding value with the setter.
	 * This should only be used in two-way directives
	 * e.g. v-model.
	 *
	 * @param {*} value
	 * @public
	 */
	
	Directive.prototype.set = function (value) {
	  /* istanbul ignore else */
	  if (this.twoWay) {
	    this._withLock(function () {
	      this._watcher.set(value);
	    });
	  } else if (process.env.NODE_ENV !== 'production') {
	    warn('Directive.set() can only be used inside twoWay' + 'directives.');
	  }
	};
	
	/**
	 * Execute a function while preventing that function from
	 * triggering updates on this directive instance.
	 *
	 * @param {Function} fn
	 */
	
	Directive.prototype._withLock = function (fn) {
	  var self = this;
	  self._locked = true;
	  fn.call(self);
	  nextTick(function () {
	    self._locked = false;
	  });
	};
	
	/**
	 * Convenience method that attaches a DOM event listener
	 * to the directive element and autometically tears it down
	 * during unbind.
	 *
	 * @param {String} event
	 * @param {Function} handler
	 * @param {Boolean} [useCapture]
	 */
	
	Directive.prototype.on = function (event, handler, useCapture) {
	  on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
	};
	
	/**
	 * Teardown the watcher and call unbind.
	 */
	
	Directive.prototype._teardown = function () {
	  if (this._bound) {
	    this._bound = false;
	    if (this.unbind) {
	      this.unbind();
	    }
	    if (this._watcher) {
	      this._watcher.teardown();
	    }
	    var listeners = this._listeners;
	    var i;
	    if (listeners) {
	      i = listeners.length;
	      while (i--) {
	        off(this.el, listeners[i][0], listeners[i][1]);
	      }
	    }
	    var unwatchFns = this._paramUnwatchFns;
	    if (unwatchFns) {
	      i = unwatchFns.length;
	      while (i--) {
	        unwatchFns[i]();
	      }
	    }
	    if (process.env.NODE_ENV !== 'production' && this.el) {
	      this.el._vue_directives.$remove(this);
	    }
	    this.vm = this.el = this._watcher = this._listeners = null;
	  }
	};
	
	function lifecycleMixin (Vue) {
	  /**
	   * Update v-ref for component.
	   *
	   * @param {Boolean} remove
	   */
	
	  Vue.prototype._updateRef = function (remove) {
	    var ref = this.$options._ref;
	    if (ref) {
	      var refs = (this._scope || this._context).$refs;
	      if (remove) {
	        if (refs[ref] === this) {
	          refs[ref] = null;
	        }
	      } else {
	        refs[ref] = this;
	      }
	    }
	  };
	
	  /**
	   * Transclude, compile and link element.
	   *
	   * If a pre-compiled linker is available, that means the
	   * passed in element will be pre-transcluded and compiled
	   * as well - all we need to do is to call the linker.
	   *
	   * Otherwise we need to call transclude/compile/link here.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._compile = function (el) {
	    var options = this.$options;
	
	    // transclude and init element
	    // transclude can potentially replace original
	    // so we need to keep reference; this step also injects
	    // the template and caches the original attributes
	    // on the container node and replacer node.
	    var original = el;
	    el = transclude(el, options);
	    this._initElement(el);
	
	    // handle v-pre on root node (#2026)
	    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
	      return;
	    }
	
	    // root is always compiled per-instance, because
	    // container attrs and props can be different every time.
	    var contextOptions = this._context && this._context.$options;
	    var rootLinker = compileRoot(el, options, contextOptions);
	
	    // resolve slot distribution
	    resolveSlots(this, options._content);
	
	    // compile and link the rest
	    var contentLinkFn;
	    var ctor = this.constructor;
	    // component compilation can be cached
	    // as long as it's not using inline-template
	    if (options._linkerCachable) {
	      contentLinkFn = ctor.linker;
	      if (!contentLinkFn) {
	        contentLinkFn = ctor.linker = compile(el, options);
	      }
	    }
	
	    // link phase
	    // make sure to link root with prop scope!
	    var rootUnlinkFn = rootLinker(this, el, this._scope);
	    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
	
	    // register composite unlink function
	    // to be called during instance destruction
	    this._unlinkFn = function () {
	      rootUnlinkFn();
	      // passing destroying: true to avoid searching and
	      // splicing the directives
	      contentUnlinkFn(true);
	    };
	
	    // finally replace original
	    if (options.replace) {
	      replace(original, el);
	    }
	
	    this._isCompiled = true;
	    this._callHook('compiled');
	  };
	
	  /**
	   * Initialize instance element. Called in the public
	   * $mount() method.
	   *
	   * @param {Element} el
	   */
	
	  Vue.prototype._initElement = function (el) {
	    if (isFragment(el)) {
	      this._isFragment = true;
	      this.$el = this._fragmentStart = el.firstChild;
	      this._fragmentEnd = el.lastChild;
	      // set persisted text anchors to empty
	      if (this._fragmentStart.nodeType === 3) {
	        this._fragmentStart.data = this._fragmentEnd.data = '';
	      }
	      this._fragment = el;
	    } else {
	      this.$el = el;
	    }
	    this.$el.__vue__ = this;
	    this._callHook('beforeCompile');
	  };
	
	  /**
	   * Create and bind a directive to an element.
	   *
	   * @param {Object} descriptor - parsed directive descriptor
	   * @param {Node} node   - target node
	   * @param {Vue} [host] - transclusion host component
	   * @param {Object} [scope] - v-for scope
	   * @param {Fragment} [frag] - owner fragment
	   */
	
	  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
	    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
	  };
	
	  /**
	   * Teardown an instance, unobserves the data, unbind all the
	   * directives, turn off all the event listeners, etc.
	   *
	   * @param {Boolean} remove - whether to remove the DOM node.
	   * @param {Boolean} deferCleanup - if true, defer cleanup to
	   *                                 be called later
	   */
	
	  Vue.prototype._destroy = function (remove, deferCleanup) {
	    if (this._isBeingDestroyed) {
	      if (!deferCleanup) {
	        this._cleanup();
	      }
	      return;
	    }
	
	    var destroyReady;
	    var pendingRemoval;
	
	    var self = this;
	    // Cleanup should be called either synchronously or asynchronoysly as
	    // callback of this.$remove(), or if remove and deferCleanup are false.
	    // In any case it should be called after all other removing, unbinding and
	    // turning of is done
	    var cleanupIfPossible = function cleanupIfPossible() {
	      if (destroyReady && !pendingRemoval && !deferCleanup) {
	        self._cleanup();
	      }
	    };
	
	    // remove DOM element
	    if (remove && this.$el) {
	      pendingRemoval = true;
	      this.$remove(function () {
	        pendingRemoval = false;
	        cleanupIfPossible();
	      });
	    }
	
	    this._callHook('beforeDestroy');
	    this._isBeingDestroyed = true;
	    var i;
	    // remove self from parent. only necessary
	    // if parent is not being destroyed as well.
	    var parent = this.$parent;
	    if (parent && !parent._isBeingDestroyed) {
	      parent.$children.$remove(this);
	      // unregister ref (remove: true)
	      this._updateRef(true);
	    }
	    // destroy all children.
	    i = this.$children.length;
	    while (i--) {
	      this.$children[i].$destroy();
	    }
	    // teardown props
	    if (this._propsUnlinkFn) {
	      this._propsUnlinkFn();
	    }
	    // teardown all directives. this also tearsdown all
	    // directive-owned watchers.
	    if (this._unlinkFn) {
	      this._unlinkFn();
	    }
	    i = this._watchers.length;
	    while (i--) {
	      this._watchers[i].teardown();
	    }
	    // remove reference to self on $el
	    if (this.$el) {
	      this.$el.__vue__ = null;
	    }
	
	    destroyReady = true;
	    cleanupIfPossible();
	  };
	
	  /**
	   * Clean up to ensure garbage collection.
	   * This is called after the leave transition if there
	   * is any.
	   */
	
	  Vue.prototype._cleanup = function () {
	    if (this._isDestroyed) {
	      return;
	    }
	    // remove self from owner fragment
	    // do it in cleanup so that we can call $destroy with
	    // defer right when a fragment is about to be removed.
	    if (this._frag) {
	      this._frag.children.$remove(this);
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (this._data && this._data.__ob__) {
	      this._data.__ob__.removeVm(this);
	    }
	    // Clean up references to private properties and other
	    // instances. preserve reference to _data so that proxy
	    // accessors still work. The only potential side effect
	    // here is that mutating the instance after it's destroyed
	    // may affect the state of other components that are still
	    // observing the same object, but that seems to be a
	    // reasonable responsibility for the user rather than
	    // always throwing an error on them.
	    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
	    // call the last hook...
	    this._isDestroyed = true;
	    this._callHook('destroyed');
	    // turn off all instance listeners.
	    this.$off();
	  };
	}
	
	function miscMixin (Vue) {
	  /**
	   * Apply a list of filter (descriptors) to a value.
	   * Using plain for loops here because this will be called in
	   * the getter of any watcher with filters so it is very
	   * performance sensitive.
	   *
	   * @param {*} value
	   * @param {*} [oldValue]
	   * @param {Array} filters
	   * @param {Boolean} write
	   * @return {*}
	   */
	
	  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
	    var filter, fn, args, arg, offset, i, l, j, k;
	    for (i = 0, l = filters.length; i < l; i++) {
	      filter = filters[write ? l - i - 1 : i];
	      fn = resolveAsset(this.$options, 'filters', filter.name, true);
	      if (!fn) continue;
	      fn = write ? fn.write : fn.read || fn;
	      if (typeof fn !== 'function') continue;
	      args = write ? [value, oldValue] : [value];
	      offset = write ? 2 : 1;
	      if (filter.args) {
	        for (j = 0, k = filter.args.length; j < k; j++) {
	          arg = filter.args[j];
	          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
	        }
	      }
	      value = fn.apply(this, args);
	    }
	    return value;
	  };
	
	  /**
	   * Resolve a component, depending on whether the component
	   * is defined normally or using an async factory function.
	   * Resolves synchronously if already resolved, otherwise
	   * resolves asynchronously and caches the resolved
	   * constructor on the factory.
	   *
	   * @param {String|Function} value
	   * @param {Function} cb
	   */
	
	  Vue.prototype._resolveComponent = function (value, cb) {
	    var factory;
	    if (typeof value === 'function') {
	      factory = value;
	    } else {
	      factory = resolveAsset(this.$options, 'components', value, true);
	    }
	    /* istanbul ignore if */
	    if (!factory) {
	      return;
	    }
	    // async component factory
	    if (!factory.options) {
	      if (factory.resolved) {
	        // cached
	        cb(factory.resolved);
	      } else if (factory.requested) {
	        // pool callbacks
	        factory.pendingCallbacks.push(cb);
	      } else {
	        factory.requested = true;
	        var cbs = factory.pendingCallbacks = [cb];
	        factory.call(this, function resolve(res) {
	          if (isPlainObject(res)) {
	            res = Vue.extend(res);
	          }
	          // cache resolved
	          factory.resolved = res;
	          // invoke callbacks
	          for (var i = 0, l = cbs.length; i < l; i++) {
	            cbs[i](res);
	          }
	        }, function reject(reason) {
	          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
	        });
	      }
	    } else {
	      // normal component
	      cb(factory);
	    }
	  };
	}
	
	var filterRE$1 = /[^|]\|[^|]/;
	
	function dataAPI (Vue) {
	  /**
	   * Get the value from an expression on this vm.
	   *
	   * @param {String} exp
	   * @param {Boolean} [asStatement]
	   * @return {*}
	   */
	
	  Vue.prototype.$get = function (exp, asStatement) {
	    var res = parseExpression(exp);
	    if (res) {
	      if (asStatement) {
	        var self = this;
	        return function statementHandler() {
	          self.$arguments = toArray(arguments);
	          var result = res.get.call(self, self);
	          self.$arguments = null;
	          return result;
	        };
	      } else {
	        try {
	          return res.get.call(this, this);
	        } catch (e) {}
	      }
	    }
	  };
	
	  /**
	   * Set the value from an expression on this vm.
	   * The expression must be a valid left-hand
	   * expression in an assignment.
	   *
	   * @param {String} exp
	   * @param {*} val
	   */
	
	  Vue.prototype.$set = function (exp, val) {
	    var res = parseExpression(exp, true);
	    if (res && res.set) {
	      res.set.call(this, this, val);
	    }
	  };
	
	  /**
	   * Delete a property on the VM
	   *
	   * @param {String} key
	   */
	
	  Vue.prototype.$delete = function (key) {
	    del(this._data, key);
	  };
	
	  /**
	   * Watch an expression, trigger callback when its
	   * value changes.
	   *
	   * @param {String|Function} expOrFn
	   * @param {Function} cb
	   * @param {Object} [options]
	   *                 - {Boolean} deep
	   *                 - {Boolean} immediate
	   * @return {Function} - unwatchFn
	   */
	
	  Vue.prototype.$watch = function (expOrFn, cb, options) {
	    var vm = this;
	    var parsed;
	    if (typeof expOrFn === 'string') {
	      parsed = parseDirective(expOrFn);
	      expOrFn = parsed.expression;
	    }
	    var watcher = new Watcher(vm, expOrFn, cb, {
	      deep: options && options.deep,
	      sync: options && options.sync,
	      filters: parsed && parsed.filters,
	      user: !options || options.user !== false
	    });
	    if (options && options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn() {
	      watcher.teardown();
	    };
	  };
	
	  /**
	   * Evaluate a text directive, including filters.
	   *
	   * @param {String} text
	   * @param {Boolean} [asStatement]
	   * @return {String}
	   */
	
	  Vue.prototype.$eval = function (text, asStatement) {
	    // check for filters.
	    if (filterRE$1.test(text)) {
	      var dir = parseDirective(text);
	      // the filter regex check might give false positive
	      // for pipes inside strings, so it's possible that
	      // we don't get any filters here
	      var val = this.$get(dir.expression, asStatement);
	      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
	    } else {
	      // no filter
	      return this.$get(text, asStatement);
	    }
	  };
	
	  /**
	   * Interpolate a piece of template text.
	   *
	   * @param {String} text
	   * @return {String}
	   */
	
	  Vue.prototype.$interpolate = function (text) {
	    var tokens = parseText(text);
	    var vm = this;
	    if (tokens) {
	      if (tokens.length === 1) {
	        return vm.$eval(tokens[0].value) + '';
	      } else {
	        return tokens.map(function (token) {
	          return token.tag ? vm.$eval(token.value) : token.value;
	        }).join('');
	      }
	    } else {
	      return text;
	    }
	  };
	
	  /**
	   * Log instance data as a plain JS object
	   * so that it is easier to inspect in console.
	   * This method assumes console is available.
	   *
	   * @param {String} [path]
	   */
	
	  Vue.prototype.$log = function (path) {
	    var data = path ? getPath(this._data, path) : this._data;
	    if (data) {
	      data = clean(data);
	    }
	    // include computed fields
	    if (!path) {
	      var key;
	      for (key in this.$options.computed) {
	        data[key] = clean(this[key]);
	      }
	      if (this._props) {
	        for (key in this._props) {
	          data[key] = clean(this[key]);
	        }
	      }
	    }
	    console.log(data);
	  };
	
	  /**
	   * "clean" a getter/setter converted object into a plain
	   * object copy.
	   *
	   * @param {Object} - obj
	   * @return {Object}
	   */
	
	  function clean(obj) {
	    return JSON.parse(JSON.stringify(obj));
	  }
	}
	
	function domAPI (Vue) {
	  /**
	   * Convenience on-instance nextTick. The callback is
	   * auto-bound to the instance, and this avoids component
	   * modules having to rely on the global Vue.
	   *
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };
	
	  /**
	   * Append instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$appendTo = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, append, appendWithTransition);
	  };
	
	  /**
	   * Prepend instance to target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$prependTo = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.hasChildNodes()) {
	      this.$before(target.firstChild, cb, withTransition);
	    } else {
	      this.$appendTo(target, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Insert instance before target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$before = function (target, cb, withTransition) {
	    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
	  };
	
	  /**
	   * Insert instance after target
	   *
	   * @param {Node} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$after = function (target, cb, withTransition) {
	    target = query(target);
	    if (target.nextSibling) {
	      this.$before(target.nextSibling, cb, withTransition);
	    } else {
	      this.$appendTo(target.parentNode, cb, withTransition);
	    }
	    return this;
	  };
	
	  /**
	   * Remove instance from DOM
	   *
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition] - defaults to true
	   */
	
	  Vue.prototype.$remove = function (cb, withTransition) {
	    if (!this.$el.parentNode) {
	      return cb && cb();
	    }
	    var inDocument = this._isAttached && inDoc(this.$el);
	    // if we are not in document, no need to check
	    // for transitions
	    if (!inDocument) withTransition = false;
	    var self = this;
	    var realCb = function realCb() {
	      if (inDocument) self._callHook('detached');
	      if (cb) cb();
	    };
	    if (this._isFragment) {
	      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
	    } else {
	      var op = withTransition === false ? removeWithCb : removeWithTransition;
	      op(this.$el, this, realCb);
	    }
	    return this;
	  };
	
	  /**
	   * Shared DOM insertion function.
	   *
	   * @param {Vue} vm
	   * @param {Element} target
	   * @param {Function} [cb]
	   * @param {Boolean} [withTransition]
	   * @param {Function} op1 - op for non-transition insert
	   * @param {Function} op2 - op for transition insert
	   * @return vm
	   */
	
	  function insert(vm, target, cb, withTransition, op1, op2) {
	    target = query(target);
	    var targetIsDetached = !inDoc(target);
	    var op = withTransition === false || targetIsDetached ? op1 : op2;
	    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
	    if (vm._isFragment) {
	      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
	        op(node, target, vm);
	      });
	      cb && cb();
	    } else {
	      op(vm.$el, target, vm, cb);
	    }
	    if (shouldCallHook) {
	      vm._callHook('attached');
	    }
	    return vm;
	  }
	
	  /**
	   * Check for selectors
	   *
	   * @param {String|Element} el
	   */
	
	  function query(el) {
	    return typeof el === 'string' ? document.querySelector(el) : el;
	  }
	
	  /**
	   * Append operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function append(el, target, vm, cb) {
	    target.appendChild(el);
	    if (cb) cb();
	  }
	
	  /**
	   * InsertBefore operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Node} target
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function beforeWithCb(el, target, vm, cb) {
	    before(el, target);
	    if (cb) cb();
	  }
	
	  /**
	   * Remove operation that takes a callback.
	   *
	   * @param {Node} el
	   * @param {Vue} vm - unused
	   * @param {Function} [cb]
	   */
	
	  function removeWithCb(el, vm, cb) {
	    remove(el);
	    if (cb) cb();
	  }
	}
	
	function eventsAPI (Vue) {
	  /**
	   * Listen on the given `event` with `fn`.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$on = function (event, fn) {
	    (this._events[event] || (this._events[event] = [])).push(fn);
	    modifyListenerCount(this, event, 1);
	    return this;
	  };
	
	  /**
	   * Adds an `event` listener that will be invoked a single
	   * time then automatically removed.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$once = function (event, fn) {
	    var self = this;
	    function on() {
	      self.$off(event, on);
	      fn.apply(this, arguments);
	    }
	    on.fn = fn;
	    this.$on(event, on);
	    return this;
	  };
	
	  /**
	   * Remove the given callback for `event` or all
	   * registered callbacks.
	   *
	   * @param {String} event
	   * @param {Function} fn
	   */
	
	  Vue.prototype.$off = function (event, fn) {
	    var cbs;
	    // all
	    if (!arguments.length) {
	      if (this.$parent) {
	        for (event in this._events) {
	          cbs = this._events[event];
	          if (cbs) {
	            modifyListenerCount(this, event, -cbs.length);
	          }
	        }
	      }
	      this._events = {};
	      return this;
	    }
	    // specific event
	    cbs = this._events[event];
	    if (!cbs) {
	      return this;
	    }
	    if (arguments.length === 1) {
	      modifyListenerCount(this, event, -cbs.length);
	      this._events[event] = null;
	      return this;
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        modifyListenerCount(this, event, -1);
	        cbs.splice(i, 1);
	        break;
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Trigger an event on self.
	   *
	   * @param {String|Object} event
	   * @return {Boolean} shouldPropagate
	   */
	
	  Vue.prototype.$emit = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    var cbs = this._events[event];
	    var shouldPropagate = isSource || !cbs;
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      // this is a somewhat hacky solution to the question raised
	      // in #2102: for an inline component listener like <comp @test="doThis">,
	      // the propagation handling is somewhat broken. Therefore we
	      // need to treat these inline callbacks differently.
	      var hasParentCbs = isSource && cbs.some(function (cb) {
	        return cb._fromParent;
	      });
	      if (hasParentCbs) {
	        shouldPropagate = false;
	      }
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        var cb = cbs[i];
	        var res = cb.apply(this, args);
	        if (res === true && (!hasParentCbs || cb._fromParent)) {
	          shouldPropagate = true;
	        }
	      }
	    }
	    return shouldPropagate;
	  };
	
	  /**
	   * Recursively broadcast an event to all children instances.
	   *
	   * @param {String|Object} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$broadcast = function (event) {
	    var isSource = typeof event === 'string';
	    event = isSource ? event : event.name;
	    // if no child has registered for this event,
	    // then there's no need to broadcast.
	    if (!this._eventsCount[event]) return;
	    var children = this.$children;
	    var args = toArray(arguments);
	    if (isSource) {
	      // use object event to indicate non-source emit
	      // on children
	      args[0] = { name: event, source: this };
	    }
	    for (var i = 0, l = children.length; i < l; i++) {
	      var child = children[i];
	      var shouldPropagate = child.$emit.apply(child, args);
	      if (shouldPropagate) {
	        child.$broadcast.apply(child, args);
	      }
	    }
	    return this;
	  };
	
	  /**
	   * Recursively propagate an event up the parent chain.
	   *
	   * @param {String} event
	   * @param {...*} additional arguments
	   */
	
	  Vue.prototype.$dispatch = function (event) {
	    var shouldPropagate = this.$emit.apply(this, arguments);
	    if (!shouldPropagate) return;
	    var parent = this.$parent;
	    var args = toArray(arguments);
	    // use object event to indicate non-source emit
	    // on parents
	    args[0] = { name: event, source: this };
	    while (parent) {
	      shouldPropagate = parent.$emit.apply(parent, args);
	      parent = shouldPropagate ? parent.$parent : null;
	    }
	    return this;
	  };
	
	  /**
	   * Modify the listener counts on all parents.
	   * This bookkeeping allows $broadcast to return early when
	   * no child has listened to a certain event.
	   *
	   * @param {Vue} vm
	   * @param {String} event
	   * @param {Number} count
	   */
	
	  var hookRE = /^hook:/;
	  function modifyListenerCount(vm, event, count) {
	    var parent = vm.$parent;
	    // hooks do not get broadcasted so no need
	    // to do bookkeeping for them
	    if (!parent || !count || hookRE.test(event)) return;
	    while (parent) {
	      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
	      parent = parent.$parent;
	    }
	  }
	}
	
	function lifecycleAPI (Vue) {
	  /**
	   * Set instance target element and kick off the compilation
	   * process. The passed in `el` can be a selector string, an
	   * existing Element, or a DocumentFragment (for block
	   * instances).
	   *
	   * @param {Element|DocumentFragment|string} el
	   * @public
	   */
	
	  Vue.prototype.$mount = function (el) {
	    if (this._isCompiled) {
	      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.', this);
	      return;
	    }
	    el = query(el);
	    if (!el) {
	      el = document.createElement('div');
	    }
	    this._compile(el);
	    this._initDOMHooks();
	    if (inDoc(this.$el)) {
	      this._callHook('attached');
	      ready.call(this);
	    } else {
	      this.$once('hook:attached', ready);
	    }
	    return this;
	  };
	
	  /**
	   * Mark an instance as ready.
	   */
	
	  function ready() {
	    this._isAttached = true;
	    this._isReady = true;
	    this._callHook('ready');
	  }
	
	  /**
	   * Teardown the instance, simply delegate to the internal
	   * _destroy.
	   *
	   * @param {Boolean} remove
	   * @param {Boolean} deferCleanup
	   */
	
	  Vue.prototype.$destroy = function (remove, deferCleanup) {
	    this._destroy(remove, deferCleanup);
	  };
	
	  /**
	   * Partially compile a piece of DOM and return a
	   * decompile function.
	   *
	   * @param {Element|DocumentFragment} el
	   * @param {Vue} [host]
	   * @param {Object} [scope]
	   * @param {Fragment} [frag]
	   * @return {Function}
	   */
	
	  Vue.prototype.$compile = function (el, host, scope, frag) {
	    return compile(el, this.$options, true)(this, el, host, scope, frag);
	  };
	}
	
	/**
	 * The exposed Vue constructor.
	 *
	 * API conventions:
	 * - public API methods/properties are prefixed with `$`
	 * - internal methods/properties are prefixed with `_`
	 * - non-prefixed properties are assumed to be proxied user
	 *   data.
	 *
	 * @constructor
	 * @param {Object} [options]
	 * @public
	 */
	
	function Vue(options) {
	  this._init(options);
	}
	
	// install internals
	initMixin(Vue);
	stateMixin(Vue);
	eventsMixin(Vue);
	lifecycleMixin(Vue);
	miscMixin(Vue);
	
	// install instance APIs
	dataAPI(Vue);
	domAPI(Vue);
	eventsAPI(Vue);
	lifecycleAPI(Vue);
	
	var slot = {
	
	  priority: SLOT,
	  params: ['name'],
	
	  bind: function bind() {
	    // this was resolved during component transclusion
	    var name = this.params.name || 'default';
	    var content = this.vm._slotContents && this.vm._slotContents[name];
	    if (!content || !content.hasChildNodes()) {
	      this.fallback();
	    } else {
	      this.compile(content.cloneNode(true), this.vm._context, this.vm);
	    }
	  },
	
	  compile: function compile(content, context, host) {
	    if (content && context) {
	      if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
	        // if the inserted slot has v-if
	        // inject fallback content as the v-else
	        var elseBlock = document.createElement('template');
	        elseBlock.setAttribute('v-else', '');
	        elseBlock.innerHTML = this.el.innerHTML;
	        // the else block should be compiled in child scope
	        elseBlock._context = this.vm;
	        content.appendChild(elseBlock);
	      }
	      var scope = host ? host._scope : this._scope;
	      this.unlink = context.$compile(content, host, scope, this._frag);
	    }
	    if (content) {
	      replace(this.el, content);
	    } else {
	      remove(this.el);
	    }
	  },
	
	  fallback: function fallback() {
	    this.compile(extractContent(this.el, true), this.vm);
	  },
	
	  unbind: function unbind() {
	    if (this.unlink) {
	      this.unlink();
	    }
	  }
	};
	
	var partial = {
	
	  priority: PARTIAL,
	
	  params: ['name'],
	
	  // watch changes to name for dynamic partials
	  paramWatchers: {
	    name: function name(value) {
	      vIf.remove.call(this);
	      if (value) {
	        this.insert(value);
	      }
	    }
	  },
	
	  bind: function bind() {
	    this.anchor = createAnchor('v-partial');
	    replace(this.el, this.anchor);
	    this.insert(this.params.name);
	  },
	
	  insert: function insert(id) {
	    var partial = resolveAsset(this.vm.$options, 'partials', id, true);
	    if (partial) {
	      this.factory = new FragmentFactory(this.vm, partial);
	      vIf.insert.call(this);
	    }
	  },
	
	  unbind: function unbind() {
	    if (this.frag) {
	      this.frag.destroy();
	    }
	  }
	};
	
	var elementDirectives = {
	  slot: slot,
	  partial: partial
	};
	
	var convertArray = vFor._postProcess;
	
	/**
	 * Limit filter for arrays
	 *
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */
	
	function limitBy(arr, n, offset) {
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String} search
	 * @param {String} [delimiter]
	 * @param {String} ...dataKeys
	 */
	
	function filterBy(arr, search, delimiter) {
	  arr = convertArray(arr);
	  if (search == null) {
	    return arr;
	  }
	  if (typeof search === 'function') {
	    return arr.filter(search);
	  }
	  // cast to lowercase string
	  search = ('' + search).toLowerCase();
	  // allow optional `in` delimiter
	  // because why not
	  var n = delimiter === 'in' ? 3 : 2;
	  // extract and flatten keys
	  var keys = Array.prototype.concat.apply([], toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;
	    if (j) {
	      while (j--) {
	        key = keys[j];
	        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }
	  return res;
	}
	
	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */
	
	function orderBy(arr) {
	  var comparator = null;
	  var sortKeys = undefined;
	  arr = convertArray(arr);
	
	  // determine order (last argument)
	  var args = toArray(arguments, 1);
	  var order = args[args.length - 1];
	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  }
	
	  // determine sortKeys & comparator
	  var firstArg = args[0];
	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    comparator = function (a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);
	    comparator = function (a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
	    };
	  }
	
	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];
	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (isObject(a) && '$value' in a) a = a.$value;
	        if (isObject(b) && '$value' in b) b = b.$value;
	      }
	      a = isObject(a) ? getPath(a, sortKey) : a;
	      b = isObject(b) ? getPath(b, sortKey) : b;
	    }
	    return a === b ? 0 : a > b ? order : -order;
	  }
	
	  // sort on a copy to avoid mutating original array
	  return arr.slice().sort(comparator);
	}
	
	/**
	 * String contain helper
	 *
	 * @param {*} val
	 * @param {String} search
	 */
	
	function contains(val, search) {
	  var i;
	  if (isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;
	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (isArray(val)) {
	    i = val.length;
	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}
	
	var digitsRE = /(\d{3})(?=\d)/g;
	
	// asset collections must be a plain object.
	var filters = {
	
	  orderBy: orderBy,
	  filterBy: filterBy,
	  limitBy: limitBy,
	
	  /**
	   * Stringify value.
	   *
	   * @param {Number} indent
	   */
	
	  json: {
	    read: function read(value, indent) {
	      return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
	    },
	    write: function write(value) {
	      try {
	        return JSON.parse(value);
	      } catch (e) {
	        return value;
	      }
	    }
	  },
	
	  /**
	   * 'abc' => 'Abc'
	   */
	
	  capitalize: function capitalize(value) {
	    if (!value && value !== 0) return '';
	    value = value.toString();
	    return value.charAt(0).toUpperCase() + value.slice(1);
	  },
	
	  /**
	   * 'abc' => 'ABC'
	   */
	
	  uppercase: function uppercase(value) {
	    return value || value === 0 ? value.toString().toUpperCase() : '';
	  },
	
	  /**
	   * 'AbC' => 'abc'
	   */
	
	  lowercase: function lowercase(value) {
	    return value || value === 0 ? value.toString().toLowerCase() : '';
	  },
	
	  /**
	   * 12345 => $12,345.00
	   *
	   * @param {String} sign
	   * @param {Number} decimals Decimal places
	   */
	
	  currency: function currency(value, _currency, decimals) {
	    value = parseFloat(value);
	    if (!isFinite(value) || !value && value !== 0) return '';
	    _currency = _currency != null ? _currency : '$';
	    decimals = decimals != null ? decimals : 2;
	    var stringified = Math.abs(value).toFixed(decimals);
	    var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
	    var i = _int.length % 3;
	    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
	    var _float = decimals ? stringified.slice(-1 - decimals) : '';
	    var sign = value < 0 ? '-' : '';
	    return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
	  },
	
	  /**
	   * 'item' => 'items'
	   *
	   * @params
	   *  an array of strings corresponding to
	   *  the single, double, triple ... forms of the word to
	   *  be pluralized. When the number to be pluralized
	   *  exceeds the length of the args, it will use the last
	   *  entry in the array.
	   *
	   *  e.g. ['single', 'double', 'triple', 'multiple']
	   */
	
	  pluralize: function pluralize(value) {
	    var args = toArray(arguments, 1);
	    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
	  },
	
	  /**
	   * Debounce a handler function.
	   *
	   * @param {Function} handler
	   * @param {Number} delay = 300
	   * @return {Function}
	   */
	
	  debounce: function debounce(handler, delay) {
	    if (!handler) return;
	    if (!delay) {
	      delay = 300;
	    }
	    return _debounce(handler, delay);
	  }
	};
	
	function installGlobalAPI (Vue) {
	  /**
	   * Vue and every constructor that extends Vue has an
	   * associated options object, which can be accessed during
	   * compilation steps as `this.constructor.options`.
	   *
	   * These can be seen as the default options of every
	   * Vue instance.
	   */
	
	  Vue.options = {
	    directives: directives,
	    elementDirectives: elementDirectives,
	    filters: filters,
	    transitions: {},
	    components: {},
	    partials: {},
	    replace: true
	  };
	
	  /**
	   * Expose useful internals
	   */
	
	  Vue.util = util;
	  Vue.config = config;
	  Vue.set = set;
	  Vue['delete'] = del;
	  Vue.nextTick = nextTick;
	
	  /**
	   * The following are exposed for advanced usage / plugins
	   */
	
	  Vue.compiler = compiler;
	  Vue.FragmentFactory = FragmentFactory;
	  Vue.internalDirectives = internalDirectives;
	  Vue.parsers = {
	    path: path,
	    text: text,
	    template: template,
	    directive: directive,
	    expression: expression
	  };
	
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	
	  Vue.cid = 0;
	  var cid = 1;
	
	  /**
	   * Class inheritance
	   *
	   * @param {Object} extendOptions
	   */
	
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor;
	    }
	    var name = extendOptions.name || Super.options.name;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
	        name = null;
	      }
	    }
	    var Sub = createClass(name || 'VueComponent');
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(Super.options, extendOptions);
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub;
	  };
	
	  /**
	   * A function that returns a sub-class constructor with the
	   * given name. This gives us much nicer output when
	   * logging instances in the console.
	   *
	   * @param {String} name
	   * @return {Function}
	   */
	
	  function createClass(name) {
	    /* eslint-disable no-new-func */
	    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
	    /* eslint-enable no-new-func */
	  }
	
	  /**
	   * Plugin system
	   *
	   * @param {Object} plugin
	   */
	
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return;
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this;
	  };
	
	  /**
	   * Apply a global mixin by merging it into the default
	   * options.
	   */
	
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	
	  /**
	   * Create asset registration methods with the following
	   * signature:
	   *
	   * @param {String} id
	   * @param {*} definition
	   */
	
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (id, definition) {
	      if (!definition) {
	        return this.options[type + 's'][id];
	      } else {
	        /* istanbul ignore if */
	        if (process.env.NODE_ENV !== 'production') {
	          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
	            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = id;
	          definition = Vue.extend(definition);
	        }
	        this.options[type + 's'][id] = definition;
	        return definition;
	      }
	    };
	  });
	
	  // expose internal transition API
	  extend(Vue.transition, transition);
	}
	
	installGlobalAPI(Vue);
	
	Vue.version = '1.0.24';
	
	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue);
	    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
	      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
	    }
	  }
	}, 0);
	
	module.exports = Vue;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3), __webpack_require__(4)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 4 */
/***/ function(module, exports) {



/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {/*!
	 * vue-router v0.7.13
	 * (c) 2016 Evan You
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  global.VueRouter = factory();
	}(this, function () { 'use strict';
	
	  var babelHelpers = {};
	
	  babelHelpers.classCallCheck = function (instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  };
	  function Target(path, matcher, delegate) {
	    this.path = path;
	    this.matcher = matcher;
	    this.delegate = delegate;
	  }
	
	  Target.prototype = {
	    to: function to(target, callback) {
	      var delegate = this.delegate;
	
	      if (delegate && delegate.willAddRoute) {
	        target = delegate.willAddRoute(this.matcher.target, target);
	      }
	
	      this.matcher.add(this.path, target);
	
	      if (callback) {
	        if (callback.length === 0) {
	          throw new Error("You must have an argument in the function passed to `to`");
	        }
	        this.matcher.addChild(this.path, target, callback, this.delegate);
	      }
	      return this;
	    }
	  };
	
	  function Matcher(target) {
	    this.routes = {};
	    this.children = {};
	    this.target = target;
	  }
	
	  Matcher.prototype = {
	    add: function add(path, handler) {
	      this.routes[path] = handler;
	    },
	
	    addChild: function addChild(path, target, callback, delegate) {
	      var matcher = new Matcher(target);
	      this.children[path] = matcher;
	
	      var match = generateMatch(path, matcher, delegate);
	
	      if (delegate && delegate.contextEntered) {
	        delegate.contextEntered(target, match);
	      }
	
	      callback(match);
	    }
	  };
	
	  function generateMatch(startingPath, matcher, delegate) {
	    return function (path, nestedCallback) {
	      var fullPath = startingPath + path;
	
	      if (nestedCallback) {
	        nestedCallback(generateMatch(fullPath, matcher, delegate));
	      } else {
	        return new Target(startingPath + path, matcher, delegate);
	      }
	    };
	  }
	
	  function addRoute(routeArray, path, handler) {
	    var len = 0;
	    for (var i = 0, l = routeArray.length; i < l; i++) {
	      len += routeArray[i].path.length;
	    }
	
	    path = path.substr(len);
	    var route = { path: path, handler: handler };
	    routeArray.push(route);
	  }
	
	  function eachRoute(baseRoute, matcher, callback, binding) {
	    var routes = matcher.routes;
	
	    for (var path in routes) {
	      if (routes.hasOwnProperty(path)) {
	        var routeArray = baseRoute.slice();
	        addRoute(routeArray, path, routes[path]);
	
	        if (matcher.children[path]) {
	          eachRoute(routeArray, matcher.children[path], callback, binding);
	        } else {
	          callback.call(binding, routeArray);
	        }
	      }
	    }
	  }
	
	  function map (callback, addRouteCallback) {
	    var matcher = new Matcher();
	
	    callback(generateMatch("", matcher, this.delegate));
	
	    eachRoute([], matcher, function (route) {
	      if (addRouteCallback) {
	        addRouteCallback(this, route);
	      } else {
	        this.add(route);
	      }
	    }, this);
	  }
	
	  var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
	
	  var escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');
	
	  var noWarning = false;
	  function warn(msg) {
	    if (!noWarning && typeof console !== 'undefined') {
	      console.error('[vue-router] ' + msg);
	    }
	  }
	
	  function tryDecode(uri, asComponent) {
	    try {
	      return asComponent ? decodeURIComponent(uri) : decodeURI(uri);
	    } catch (e) {
	      warn('malformed URI' + (asComponent ? ' component: ' : ': ') + uri);
	    }
	  }
	
	  function isArray(test) {
	    return Object.prototype.toString.call(test) === "[object Array]";
	  }
	
	  // A Segment represents a segment in the original route description.
	  // Each Segment type provides an `eachChar` and `regex` method.
	  //
	  // The `eachChar` method invokes the callback with one or more character
	  // specifications. A character specification consumes one or more input
	  // characters.
	  //
	  // The `regex` method returns a regex fragment for the segment. If the
	  // segment is a dynamic of star segment, the regex fragment also includes
	  // a capture.
	  //
	  // A character specification contains:
	  //
	  // * `validChars`: a String with a list of all valid characters, or
	  // * `invalidChars`: a String with a list of all invalid characters
	  // * `repeat`: true if the character specification can repeat
	
	  function StaticSegment(string) {
	    this.string = string;
	  }
	  StaticSegment.prototype = {
	    eachChar: function eachChar(callback) {
	      var string = this.string,
	          ch;
	
	      for (var i = 0, l = string.length; i < l; i++) {
	        ch = string.charAt(i);
	        callback({ validChars: ch });
	      }
	    },
	
	    regex: function regex() {
	      return this.string.replace(escapeRegex, '\\$1');
	    },
	
	    generate: function generate() {
	      return this.string;
	    }
	  };
	
	  function DynamicSegment(name) {
	    this.name = name;
	  }
	  DynamicSegment.prototype = {
	    eachChar: function eachChar(callback) {
	      callback({ invalidChars: "/", repeat: true });
	    },
	
	    regex: function regex() {
	      return "([^/]+)";
	    },
	
	    generate: function generate(params) {
	      var val = params[this.name];
	      return val == null ? ":" + this.name : val;
	    }
	  };
	
	  function StarSegment(name) {
	    this.name = name;
	  }
	  StarSegment.prototype = {
	    eachChar: function eachChar(callback) {
	      callback({ invalidChars: "", repeat: true });
	    },
	
	    regex: function regex() {
	      return "(.+)";
	    },
	
	    generate: function generate(params) {
	      var val = params[this.name];
	      return val == null ? ":" + this.name : val;
	    }
	  };
	
	  function EpsilonSegment() {}
	  EpsilonSegment.prototype = {
	    eachChar: function eachChar() {},
	    regex: function regex() {
	      return "";
	    },
	    generate: function generate() {
	      return "";
	    }
	  };
	
	  function parse(route, names, specificity) {
	    // normalize route as not starting with a "/". Recognition will
	    // also normalize.
	    if (route.charAt(0) === "/") {
	      route = route.substr(1);
	    }
	
	    var segments = route.split("/"),
	        results = [];
	
	    // A routes has specificity determined by the order that its different segments
	    // appear in. This system mirrors how the magnitude of numbers written as strings
	    // works.
	    // Consider a number written as: "abc". An example would be "200". Any other number written
	    // "xyz" will be smaller than "abc" so long as `a > z`. For instance, "199" is smaller
	    // then "200", even though "y" and "z" (which are both 9) are larger than "0" (the value
	    // of (`b` and `c`). This is because the leading symbol, "2", is larger than the other
	    // leading symbol, "1".
	    // The rule is that symbols to the left carry more weight than symbols to the right
	    // when a number is written out as a string. In the above strings, the leading digit
	    // represents how many 100's are in the number, and it carries more weight than the middle
	    // number which represents how many 10's are in the number.
	    // This system of number magnitude works well for route specificity, too. A route written as
	    // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than
	    // `x`, irrespective of the other parts.
	    // Because of this similarity, we assign each type of segment a number value written as a
	    // string. We can find the specificity of compound routes by concatenating these strings
	    // together, from left to right. After we have looped through all of the segments,
	    // we convert the string to a number.
	    specificity.val = '';
	
	    for (var i = 0, l = segments.length; i < l; i++) {
	      var segment = segments[i],
	          match;
	
	      if (match = segment.match(/^:([^\/]+)$/)) {
	        results.push(new DynamicSegment(match[1]));
	        names.push(match[1]);
	        specificity.val += '3';
	      } else if (match = segment.match(/^\*([^\/]+)$/)) {
	        results.push(new StarSegment(match[1]));
	        specificity.val += '2';
	        names.push(match[1]);
	      } else if (segment === "") {
	        results.push(new EpsilonSegment());
	        specificity.val += '1';
	      } else {
	        results.push(new StaticSegment(segment));
	        specificity.val += '4';
	      }
	    }
	
	    specificity.val = +specificity.val;
	
	    return results;
	  }
	
	  // A State has a character specification and (`charSpec`) and a list of possible
	  // subsequent states (`nextStates`).
	  //
	  // If a State is an accepting state, it will also have several additional
	  // properties:
	  //
	  // * `regex`: A regular expression that is used to extract parameters from paths
	  //   that reached this accepting state.
	  // * `handlers`: Information on how to convert the list of captures into calls
	  //   to registered handlers with the specified parameters
	  // * `types`: How many static, dynamic or star segments in this route. Used to
	  //   decide which route to use if multiple registered routes match a path.
	  //
	  // Currently, State is implemented naively by looping over `nextStates` and
	  // comparing a character specification against a character. A more efficient
	  // implementation would use a hash of keys pointing at one or more next states.
	
	  function State(charSpec) {
	    this.charSpec = charSpec;
	    this.nextStates = [];
	  }
	
	  State.prototype = {
	    get: function get(charSpec) {
	      var nextStates = this.nextStates;
	
	      for (var i = 0, l = nextStates.length; i < l; i++) {
	        var child = nextStates[i];
	
	        var isEqual = child.charSpec.validChars === charSpec.validChars;
	        isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;
	
	        if (isEqual) {
	          return child;
	        }
	      }
	    },
	
	    put: function put(charSpec) {
	      var state;
	
	      // If the character specification already exists in a child of the current
	      // state, just return that state.
	      if (state = this.get(charSpec)) {
	        return state;
	      }
	
	      // Make a new state for the character spec
	      state = new State(charSpec);
	
	      // Insert the new state as a child of the current state
	      this.nextStates.push(state);
	
	      // If this character specification repeats, insert the new state as a child
	      // of itself. Note that this will not trigger an infinite loop because each
	      // transition during recognition consumes a character.
	      if (charSpec.repeat) {
	        state.nextStates.push(state);
	      }
	
	      // Return the new state
	      return state;
	    },
	
	    // Find a list of child states matching the next character
	    match: function match(ch) {
	      // DEBUG "Processing `" + ch + "`:"
	      var nextStates = this.nextStates,
	          child,
	          charSpec,
	          chars;
	
	      // DEBUG "  " + debugState(this)
	      var returned = [];
	
	      for (var i = 0, l = nextStates.length; i < l; i++) {
	        child = nextStates[i];
	
	        charSpec = child.charSpec;
	
	        if (typeof (chars = charSpec.validChars) !== 'undefined') {
	          if (chars.indexOf(ch) !== -1) {
	            returned.push(child);
	          }
	        } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {
	          if (chars.indexOf(ch) === -1) {
	            returned.push(child);
	          }
	        }
	      }
	
	      return returned;
	    }
	
	    /** IF DEBUG
	    , debug: function() {
	      var charSpec = this.charSpec,
	          debug = "[",
	          chars = charSpec.validChars || charSpec.invalidChars;
	       if (charSpec.invalidChars) { debug += "^"; }
	      debug += chars;
	      debug += "]";
	       if (charSpec.repeat) { debug += "+"; }
	       return debug;
	    }
	    END IF **/
	  };
	
	  /** IF DEBUG
	  function debug(log) {
	    console.log(log);
	  }
	
	  function debugState(state) {
	    return state.nextStates.map(function(n) {
	      if (n.nextStates.length === 0) { return "( " + n.debug() + " [accepting] )"; }
	      return "( " + n.debug() + " <then> " + n.nextStates.map(function(s) { return s.debug() }).join(" or ") + " )";
	    }).join(", ")
	  }
	  END IF **/
	
	  // Sort the routes by specificity
	  function sortSolutions(states) {
	    return states.sort(function (a, b) {
	      return b.specificity.val - a.specificity.val;
	    });
	  }
	
	  function recognizeChar(states, ch) {
	    var nextStates = [];
	
	    for (var i = 0, l = states.length; i < l; i++) {
	      var state = states[i];
	
	      nextStates = nextStates.concat(state.match(ch));
	    }
	
	    return nextStates;
	  }
	
	  var oCreate = Object.create || function (proto) {
	    function F() {}
	    F.prototype = proto;
	    return new F();
	  };
	
	  function RecognizeResults(queryParams) {
	    this.queryParams = queryParams || {};
	  }
	  RecognizeResults.prototype = oCreate({
	    splice: Array.prototype.splice,
	    slice: Array.prototype.slice,
	    push: Array.prototype.push,
	    length: 0,
	    queryParams: null
	  });
	
	  function findHandler(state, path, queryParams) {
	    var handlers = state.handlers,
	        regex = state.regex;
	    var captures = path.match(regex),
	        currentCapture = 1;
	    var result = new RecognizeResults(queryParams);
	
	    for (var i = 0, l = handlers.length; i < l; i++) {
	      var handler = handlers[i],
	          names = handler.names,
	          params = {};
	
	      for (var j = 0, m = names.length; j < m; j++) {
	        params[names[j]] = captures[currentCapture++];
	      }
	
	      result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });
	    }
	
	    return result;
	  }
	
	  function addSegment(currentState, segment) {
	    segment.eachChar(function (ch) {
	      var state;
	
	      currentState = currentState.put(ch);
	    });
	
	    return currentState;
	  }
	
	  function decodeQueryParamPart(part) {
	    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1
	    part = part.replace(/\+/gm, '%20');
	    return tryDecode(part, true);
	  }
	
	  // The main interface
	
	  var RouteRecognizer = function RouteRecognizer() {
	    this.rootState = new State();
	    this.names = {};
	  };
	
	  RouteRecognizer.prototype = {
	    add: function add(routes, options) {
	      var currentState = this.rootState,
	          regex = "^",
	          specificity = {},
	          handlers = [],
	          allSegments = [],
	          name;
	
	      var isEmpty = true;
	
	      for (var i = 0, l = routes.length; i < l; i++) {
	        var route = routes[i],
	            names = [];
	
	        var segments = parse(route.path, names, specificity);
	
	        allSegments = allSegments.concat(segments);
	
	        for (var j = 0, m = segments.length; j < m; j++) {
	          var segment = segments[j];
	
	          if (segment instanceof EpsilonSegment) {
	            continue;
	          }
	
	          isEmpty = false;
	
	          // Add a "/" for the new segment
	          currentState = currentState.put({ validChars: "/" });
	          regex += "/";
	
	          // Add a representation of the segment to the NFA and regex
	          currentState = addSegment(currentState, segment);
	          regex += segment.regex();
	        }
	
	        var handler = { handler: route.handler, names: names };
	        handlers.push(handler);
	      }
	
	      if (isEmpty) {
	        currentState = currentState.put({ validChars: "/" });
	        regex += "/";
	      }
	
	      currentState.handlers = handlers;
	      currentState.regex = new RegExp(regex + "$");
	      currentState.specificity = specificity;
	
	      if (name = options && options.as) {
	        this.names[name] = {
	          segments: allSegments,
	          handlers: handlers
	        };
	      }
	    },
	
	    handlersFor: function handlersFor(name) {
	      var route = this.names[name],
	          result = [];
	      if (!route) {
	        throw new Error("There is no route named " + name);
	      }
	
	      for (var i = 0, l = route.handlers.length; i < l; i++) {
	        result.push(route.handlers[i]);
	      }
	
	      return result;
	    },
	
	    hasRoute: function hasRoute(name) {
	      return !!this.names[name];
	    },
	
	    generate: function generate(name, params) {
	      var route = this.names[name],
	          output = "";
	      if (!route) {
	        throw new Error("There is no route named " + name);
	      }
	
	      var segments = route.segments;
	
	      for (var i = 0, l = segments.length; i < l; i++) {
	        var segment = segments[i];
	
	        if (segment instanceof EpsilonSegment) {
	          continue;
	        }
	
	        output += "/";
	        output += segment.generate(params);
	      }
	
	      if (output.charAt(0) !== '/') {
	        output = '/' + output;
	      }
	
	      if (params && params.queryParams) {
	        output += this.generateQueryString(params.queryParams);
	      }
	
	      return output;
	    },
	
	    generateQueryString: function generateQueryString(params) {
	      var pairs = [];
	      var keys = [];
	      for (var key in params) {
	        if (params.hasOwnProperty(key)) {
	          keys.push(key);
	        }
	      }
	      keys.sort();
	      for (var i = 0, len = keys.length; i < len; i++) {
	        key = keys[i];
	        var value = params[key];
	        if (value == null) {
	          continue;
	        }
	        var pair = encodeURIComponent(key);
	        if (isArray(value)) {
	          for (var j = 0, l = value.length; j < l; j++) {
	            var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);
	            pairs.push(arrayPair);
	          }
	        } else {
	          pair += "=" + encodeURIComponent(value);
	          pairs.push(pair);
	        }
	      }
	
	      if (pairs.length === 0) {
	        return '';
	      }
	
	      return "?" + pairs.join("&");
	    },
	
	    parseQueryString: function parseQueryString(queryString) {
	      var pairs = queryString.split("&"),
	          queryParams = {};
	      for (var i = 0; i < pairs.length; i++) {
	        var pair = pairs[i].split('='),
	            key = decodeQueryParamPart(pair[0]),
	            keyLength = key.length,
	            isArray = false,
	            value;
	        if (pair.length === 1) {
	          value = 'true';
	        } else {
	          //Handle arrays
	          if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {
	            isArray = true;
	            key = key.slice(0, keyLength - 2);
	            if (!queryParams[key]) {
	              queryParams[key] = [];
	            }
	          }
	          value = pair[1] ? decodeQueryParamPart(pair[1]) : '';
	        }
	        if (isArray) {
	          queryParams[key].push(value);
	        } else {
	          queryParams[key] = value;
	        }
	      }
	      return queryParams;
	    },
	
	    recognize: function recognize(path, silent) {
	      noWarning = silent;
	      var states = [this.rootState],
	          pathLen,
	          i,
	          l,
	          queryStart,
	          queryParams = {},
	          isSlashDropped = false;
	
	      queryStart = path.indexOf('?');
	      if (queryStart !== -1) {
	        var queryString = path.substr(queryStart + 1, path.length);
	        path = path.substr(0, queryStart);
	        if (queryString) {
	          queryParams = this.parseQueryString(queryString);
	        }
	      }
	
	      path = tryDecode(path);
	      if (!path) return;
	
	      // DEBUG GROUP path
	
	      if (path.charAt(0) !== "/") {
	        path = "/" + path;
	      }
	
	      pathLen = path.length;
	      if (pathLen > 1 && path.charAt(pathLen - 1) === "/") {
	        path = path.substr(0, pathLen - 1);
	        isSlashDropped = true;
	      }
	
	      for (i = 0, l = path.length; i < l; i++) {
	        states = recognizeChar(states, path.charAt(i));
	        if (!states.length) {
	          break;
	        }
	      }
	
	      // END DEBUG GROUP
	
	      var solutions = [];
	      for (i = 0, l = states.length; i < l; i++) {
	        if (states[i].handlers) {
	          solutions.push(states[i]);
	        }
	      }
	
	      states = sortSolutions(solutions);
	
	      var state = solutions[0];
	
	      if (state && state.handlers) {
	        // if a trailing slash was dropped and a star segment is the last segment
	        // specified, put the trailing slash back
	        if (isSlashDropped && state.regex.source.slice(-5) === "(.+)$") {
	          path = path + "/";
	        }
	        return findHandler(state, path, queryParams);
	      }
	    }
	  };
	
	  RouteRecognizer.prototype.map = map;
	
	  var genQuery = RouteRecognizer.prototype.generateQueryString;
	
	  // export default for holding the Vue reference
	  var exports$1 = {};
	  /**
	   * Warn stuff.
	   *
	   * @param {String} msg
	   */
	
	  function warn$1(msg) {
	    /* istanbul ignore next */
	    if (typeof console !== 'undefined') {
	      console.error('[vue-router] ' + msg);
	    }
	  }
	
	  /**
	   * Resolve a relative path.
	   *
	   * @param {String} base
	   * @param {String} relative
	   * @param {Boolean} append
	   * @return {String}
	   */
	
	  function resolvePath(base, relative, append) {
	    var query = base.match(/(\?.*)$/);
	    if (query) {
	      query = query[1];
	      base = base.slice(0, -query.length);
	    }
	    // a query!
	    if (relative.charAt(0) === '?') {
	      return base + relative;
	    }
	    var stack = base.split('/');
	    // remove trailing segment if:
	    // - not appending
	    // - appending to trailing slash (last segment is empty)
	    if (!append || !stack[stack.length - 1]) {
	      stack.pop();
	    }
	    // resolve relative path
	    var segments = relative.replace(/^\//, '').split('/');
	    for (var i = 0; i < segments.length; i++) {
	      var segment = segments[i];
	      if (segment === '.') {
	        continue;
	      } else if (segment === '..') {
	        stack.pop();
	      } else {
	        stack.push(segment);
	      }
	    }
	    // ensure leading slash
	    if (stack[0] !== '') {
	      stack.unshift('');
	    }
	    return stack.join('/');
	  }
	
	  /**
	   * Forgiving check for a promise
	   *
	   * @param {Object} p
	   * @return {Boolean}
	   */
	
	  function isPromise(p) {
	    return p && typeof p.then === 'function';
	  }
	
	  /**
	   * Retrive a route config field from a component instance
	   * OR a component contructor.
	   *
	   * @param {Function|Vue} component
	   * @param {String} name
	   * @return {*}
	   */
	
	  function getRouteConfig(component, name) {
	    var options = component && (component.$options || component.options);
	    return options && options.route && options.route[name];
	  }
	
	  /**
	   * Resolve an async component factory. Have to do a dirty
	   * mock here because of Vue core's internal API depends on
	   * an ID check.
	   *
	   * @param {Object} handler
	   * @param {Function} cb
	   */
	
	  var resolver = undefined;
	
	  function resolveAsyncComponent(handler, cb) {
	    if (!resolver) {
	      resolver = {
	        resolve: exports$1.Vue.prototype._resolveComponent,
	        $options: {
	          components: {
	            _: handler.component
	          }
	        }
	      };
	    } else {
	      resolver.$options.components._ = handler.component;
	    }
	    resolver.resolve('_', function (Component) {
	      handler.component = Component;
	      cb(Component);
	    });
	  }
	
	  /**
	   * Map the dynamic segments in a path to params.
	   *
	   * @param {String} path
	   * @param {Object} params
	   * @param {Object} query
	   */
	
	  function mapParams(path, params, query) {
	    if (params === undefined) params = {};
	
	    path = path.replace(/:([^\/]+)/g, function (_, key) {
	      var val = params[key];
	      /* istanbul ignore if */
	      if (!val) {
	        warn$1('param "' + key + '" not found when generating ' + 'path for "' + path + '" with params ' + JSON.stringify(params));
	      }
	      return val || '';
	    });
	    if (query) {
	      path += genQuery(query);
	    }
	    return path;
	  }
	
	  var hashRE = /#.*$/;
	
	  var HTML5History = (function () {
	    function HTML5History(_ref) {
	      var root = _ref.root;
	      var onChange = _ref.onChange;
	      babelHelpers.classCallCheck(this, HTML5History);
	
	      if (root && root !== '/') {
	        // make sure there's the starting slash
	        if (root.charAt(0) !== '/') {
	          root = '/' + root;
	        }
	        // remove trailing slash
	        this.root = root.replace(/\/$/, '');
	        this.rootRE = new RegExp('^\\' + this.root);
	      } else {
	        this.root = null;
	      }
	      this.onChange = onChange;
	      // check base tag
	      var baseEl = document.querySelector('base');
	      this.base = baseEl && baseEl.getAttribute('href');
	    }
	
	    HTML5History.prototype.start = function start() {
	      var _this = this;
	
	      this.listener = function (e) {
	        var url = location.pathname + location.search;
	        if (_this.root) {
	          url = url.replace(_this.rootRE, '');
	        }
	        _this.onChange(url, e && e.state, location.hash);
	      };
	      window.addEventListener('popstate', this.listener);
	      this.listener();
	    };
	
	    HTML5History.prototype.stop = function stop() {
	      window.removeEventListener('popstate', this.listener);
	    };
	
	    HTML5History.prototype.go = function go(path, replace, append) {
	      var url = this.formatPath(path, append);
	      if (replace) {
	        history.replaceState({}, '', url);
	      } else {
	        // record scroll position by replacing current state
	        history.replaceState({
	          pos: {
	            x: window.pageXOffset,
	            y: window.pageYOffset
	          }
	        }, '', location.href);
	        // then push new state
	        history.pushState({}, '', url);
	      }
	      var hashMatch = path.match(hashRE);
	      var hash = hashMatch && hashMatch[0];
	      path = url
	      // strip hash so it doesn't mess up params
	      .replace(hashRE, '')
	      // remove root before matching
	      .replace(this.rootRE, '');
	      this.onChange(path, null, hash);
	    };
	
	    HTML5History.prototype.formatPath = function formatPath(path, append) {
	      return path.charAt(0) === '/'
	      // absolute path
	      ? this.root ? this.root + '/' + path.replace(/^\//, '') : path : resolvePath(this.base || location.pathname, path, append);
	    };
	
	    return HTML5History;
	  })();
	
	  var HashHistory = (function () {
	    function HashHistory(_ref) {
	      var hashbang = _ref.hashbang;
	      var onChange = _ref.onChange;
	      babelHelpers.classCallCheck(this, HashHistory);
	
	      this.hashbang = hashbang;
	      this.onChange = onChange;
	    }
	
	    HashHistory.prototype.start = function start() {
	      var self = this;
	      this.listener = function () {
	        var path = location.hash;
	        var raw = path.replace(/^#!?/, '');
	        // always
	        if (raw.charAt(0) !== '/') {
	          raw = '/' + raw;
	        }
	        var formattedPath = self.formatPath(raw);
	        if (formattedPath !== path) {
	          location.replace(formattedPath);
	          return;
	        }
	        // determine query
	        // note it's possible to have queries in both the actual URL
	        // and the hash fragment itself.
	        var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;
	        self.onChange(path.replace(/^#!?/, '') + query);
	      };
	      window.addEventListener('hashchange', this.listener);
	      this.listener();
	    };
	
	    HashHistory.prototype.stop = function stop() {
	      window.removeEventListener('hashchange', this.listener);
	    };
	
	    HashHistory.prototype.go = function go(path, replace, append) {
	      path = this.formatPath(path, append);
	      if (replace) {
	        location.replace(path);
	      } else {
	        location.hash = path;
	      }
	    };
	
	    HashHistory.prototype.formatPath = function formatPath(path, append) {
	      var isAbsoloute = path.charAt(0) === '/';
	      var prefix = '#' + (this.hashbang ? '!' : '');
	      return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);
	    };
	
	    return HashHistory;
	  })();
	
	  var AbstractHistory = (function () {
	    function AbstractHistory(_ref) {
	      var onChange = _ref.onChange;
	      babelHelpers.classCallCheck(this, AbstractHistory);
	
	      this.onChange = onChange;
	      this.currentPath = '/';
	    }
	
	    AbstractHistory.prototype.start = function start() {
	      this.onChange('/');
	    };
	
	    AbstractHistory.prototype.stop = function stop() {
	      // noop
	    };
	
	    AbstractHistory.prototype.go = function go(path, replace, append) {
	      path = this.currentPath = this.formatPath(path, append);
	      this.onChange(path);
	    };
	
	    AbstractHistory.prototype.formatPath = function formatPath(path, append) {
	      return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);
	    };
	
	    return AbstractHistory;
	  })();
	
	  /**
	   * Determine the reusability of an existing router view.
	   *
	   * @param {Directive} view
	   * @param {Object} handler
	   * @param {Transition} transition
	   */
	
	  function canReuse(view, handler, transition) {
	    var component = view.childVM;
	    if (!component || !handler) {
	      return false;
	    }
	    // important: check view.Component here because it may
	    // have been changed in activate hook
	    if (view.Component !== handler.component) {
	      return false;
	    }
	    var canReuseFn = getRouteConfig(component, 'canReuse');
	    return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {
	      to: transition.to,
	      from: transition.from
	    }) : true; // defaults to true
	  }
	
	  /**
	   * Check if a component can deactivate.
	   *
	   * @param {Directive} view
	   * @param {Transition} transition
	   * @param {Function} next
	   */
	
	  function canDeactivate(view, transition, next) {
	    var fromComponent = view.childVM;
	    var hook = getRouteConfig(fromComponent, 'canDeactivate');
	    if (!hook) {
	      next();
	    } else {
	      transition.callHook(hook, fromComponent, next, {
	        expectBoolean: true
	      });
	    }
	  }
	
	  /**
	   * Check if a component can activate.
	   *
	   * @param {Object} handler
	   * @param {Transition} transition
	   * @param {Function} next
	   */
	
	  function canActivate(handler, transition, next) {
	    resolveAsyncComponent(handler, function (Component) {
	      // have to check due to async-ness
	      if (transition.aborted) {
	        return;
	      }
	      // determine if this component can be activated
	      var hook = getRouteConfig(Component, 'canActivate');
	      if (!hook) {
	        next();
	      } else {
	        transition.callHook(hook, null, next, {
	          expectBoolean: true
	        });
	      }
	    });
	  }
	
	  /**
	   * Call deactivate hooks for existing router-views.
	   *
	   * @param {Directive} view
	   * @param {Transition} transition
	   * @param {Function} next
	   */
	
	  function deactivate(view, transition, next) {
	    var component = view.childVM;
	    var hook = getRouteConfig(component, 'deactivate');
	    if (!hook) {
	      next();
	    } else {
	      transition.callHooks(hook, component, next);
	    }
	  }
	
	  /**
	   * Activate / switch component for a router-view.
	   *
	   * @param {Directive} view
	   * @param {Transition} transition
	   * @param {Number} depth
	   * @param {Function} [cb]
	   */
	
	  function activate(view, transition, depth, cb, reuse) {
	    var handler = transition.activateQueue[depth];
	    if (!handler) {
	      saveChildView(view);
	      if (view._bound) {
	        view.setComponent(null);
	      }
	      cb && cb();
	      return;
	    }
	
	    var Component = view.Component = handler.component;
	    var activateHook = getRouteConfig(Component, 'activate');
	    var dataHook = getRouteConfig(Component, 'data');
	    var waitForData = getRouteConfig(Component, 'waitForData');
	
	    view.depth = depth;
	    view.activated = false;
	
	    var component = undefined;
	    var loading = !!(dataHook && !waitForData);
	
	    // "reuse" is a flag passed down when the parent view is
	    // either reused via keep-alive or as a child of a kept-alive view.
	    // of course we can only reuse if the current kept-alive instance
	    // is of the correct type.
	    reuse = reuse && view.childVM && view.childVM.constructor === Component;
	
	    if (reuse) {
	      // just reuse
	      component = view.childVM;
	      component.$loadingRouteData = loading;
	    } else {
	      saveChildView(view);
	
	      // unbuild current component. this step also destroys
	      // and removes all nested child views.
	      view.unbuild(true);
	
	      // build the new component. this will also create the
	      // direct child view of the current one. it will register
	      // itself as view.childView.
	      component = view.build({
	        _meta: {
	          $loadingRouteData: loading
	        },
	        created: function created() {
	          this._routerView = view;
	        }
	      });
	
	      // handle keep-alive.
	      // when a kept-alive child vm is restored, we need to
	      // add its cached child views into the router's view list,
	      // and also properly update current view's child view.
	      if (view.keepAlive) {
	        component.$loadingRouteData = loading;
	        var cachedChildView = component._keepAliveRouterView;
	        if (cachedChildView) {
	          view.childView = cachedChildView;
	          component._keepAliveRouterView = null;
	        }
	      }
	    }
	
	    // cleanup the component in case the transition is aborted
	    // before the component is ever inserted.
	    var cleanup = function cleanup() {
	      component.$destroy();
	    };
	
	    // actually insert the component and trigger transition
	    var insert = function insert() {
	      if (reuse) {
	        cb && cb();
	        return;
	      }
	      var router = transition.router;
	      if (router._rendered || router._transitionOnLoad) {
	        view.transition(component);
	      } else {
	        // no transition on first render, manual transition
	        /* istanbul ignore if */
	        if (view.setCurrent) {
	          // 0.12 compat
	          view.setCurrent(component);
	        } else {
	          // 1.0
	          view.childVM = component;
	        }
	        component.$before(view.anchor, null, false);
	      }
	      cb && cb();
	    };
	
	    var afterData = function afterData() {
	      // activate the child view
	      if (view.childView) {
	        activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);
	      }
	      insert();
	    };
	
	    // called after activation hook is resolved
	    var afterActivate = function afterActivate() {
	      view.activated = true;
	      if (dataHook && waitForData) {
	        // wait until data loaded to insert
	        loadData(component, transition, dataHook, afterData, cleanup);
	      } else {
	        // load data and insert at the same time
	        if (dataHook) {
	          loadData(component, transition, dataHook);
	        }
	        afterData();
	      }
	    };
	
	    if (activateHook) {
	      transition.callHooks(activateHook, component, afterActivate, {
	        cleanup: cleanup,
	        postActivate: true
	      });
	    } else {
	      afterActivate();
	    }
	  }
	
	  /**
	   * Reuse a view, just reload data if necessary.
	   *
	   * @param {Directive} view
	   * @param {Transition} transition
	   */
	
	  function reuse(view, transition) {
	    var component = view.childVM;
	    var dataHook = getRouteConfig(component, 'data');
	    if (dataHook) {
	      loadData(component, transition, dataHook);
	    }
	  }
	
	  /**
	   * Asynchronously load and apply data to component.
	   *
	   * @param {Vue} component
	   * @param {Transition} transition
	   * @param {Function} hook
	   * @param {Function} cb
	   * @param {Function} cleanup
	   */
	
	  function loadData(component, transition, hook, cb, cleanup) {
	    component.$loadingRouteData = true;
	    transition.callHooks(hook, component, function () {
	      component.$loadingRouteData = false;
	      component.$emit('route-data-loaded', component);
	      cb && cb();
	    }, {
	      cleanup: cleanup,
	      postActivate: true,
	      processData: function processData(data) {
	        // handle promise sugar syntax
	        var promises = [];
	        if (isPlainObject(data)) {
	          Object.keys(data).forEach(function (key) {
	            var val = data[key];
	            if (isPromise(val)) {
	              promises.push(val.then(function (resolvedVal) {
	                component.$set(key, resolvedVal);
	              }));
	            } else {
	              component.$set(key, val);
	            }
	          });
	        }
	        if (promises.length) {
	          return promises[0].constructor.all(promises);
	        }
	      }
	    });
	  }
	
	  /**
	   * Save the child view for a kept-alive view so that
	   * we can restore it when it is switched back to.
	   *
	   * @param {Directive} view
	   */
	
	  function saveChildView(view) {
	    if (view.keepAlive && view.childVM && view.childView) {
	      view.childVM._keepAliveRouterView = view.childView;
	    }
	    view.childView = null;
	  }
	
	  /**
	   * Check plain object.
	   *
	   * @param {*} val
	   */
	
	  function isPlainObject(val) {
	    return Object.prototype.toString.call(val) === '[object Object]';
	  }
	
	  /**
	   * A RouteTransition object manages the pipeline of a
	   * router-view switching process. This is also the object
	   * passed into user route hooks.
	   *
	   * @param {Router} router
	   * @param {Route} to
	   * @param {Route} from
	   */
	
	  var RouteTransition = (function () {
	    function RouteTransition(router, to, from) {
	      babelHelpers.classCallCheck(this, RouteTransition);
	
	      this.router = router;
	      this.to = to;
	      this.from = from;
	      this.next = null;
	      this.aborted = false;
	      this.done = false;
	    }
	
	    /**
	     * Abort current transition and return to previous location.
	     */
	
	    RouteTransition.prototype.abort = function abort() {
	      if (!this.aborted) {
	        this.aborted = true;
	        // if the root path throws an error during validation
	        // on initial load, it gets caught in an infinite loop.
	        var abortingOnLoad = !this.from.path && this.to.path === '/';
	        if (!abortingOnLoad) {
	          this.router.replace(this.from.path || '/');
	        }
	      }
	    };
	
	    /**
	     * Abort current transition and redirect to a new location.
	     *
	     * @param {String} path
	     */
	
	    RouteTransition.prototype.redirect = function redirect(path) {
	      if (!this.aborted) {
	        this.aborted = true;
	        if (typeof path === 'string') {
	          path = mapParams(path, this.to.params, this.to.query);
	        } else {
	          path.params = path.params || this.to.params;
	          path.query = path.query || this.to.query;
	        }
	        this.router.replace(path);
	      }
	    };
	
	    /**
	     * A router view transition's pipeline can be described as
	     * follows, assuming we are transitioning from an existing
	     * <router-view> chain [Component A, Component B] to a new
	     * chain [Component A, Component C]:
	     *
	     *  A    A
	     *  | => |
	     *  B    C
	     *
	     * 1. Reusablity phase:
	     *   -> canReuse(A, A)
	     *   -> canReuse(B, C)
	     *   -> determine new queues:
	     *      - deactivation: [B]
	     *      - activation: [C]
	     *
	     * 2. Validation phase:
	     *   -> canDeactivate(B)
	     *   -> canActivate(C)
	     *
	     * 3. Activation phase:
	     *   -> deactivate(B)
	     *   -> activate(C)
	     *
	     * Each of these steps can be asynchronous, and any
	     * step can potentially abort the transition.
	     *
	     * @param {Function} cb
	     */
	
	    RouteTransition.prototype.start = function start(cb) {
	      var transition = this;
	
	      // determine the queue of views to deactivate
	      var deactivateQueue = [];
	      var view = this.router._rootView;
	      while (view) {
	        deactivateQueue.unshift(view);
	        view = view.childView;
	      }
	      var reverseDeactivateQueue = deactivateQueue.slice().reverse();
	
	      // determine the queue of route handlers to activate
	      var activateQueue = this.activateQueue = toArray(this.to.matched).map(function (match) {
	        return match.handler;
	      });
	
	      // 1. Reusability phase
	      var i = undefined,
	          reuseQueue = undefined;
	      for (i = 0; i < reverseDeactivateQueue.length; i++) {
	        if (!canReuse(reverseDeactivateQueue[i], activateQueue[i], transition)) {
	          break;
	        }
	      }
	      if (i > 0) {
	        reuseQueue = reverseDeactivateQueue.slice(0, i);
	        deactivateQueue = reverseDeactivateQueue.slice(i).reverse();
	        activateQueue = activateQueue.slice(i);
	      }
	
	      // 2. Validation phase
	      transition.runQueue(deactivateQueue, canDeactivate, function () {
	        transition.runQueue(activateQueue, canActivate, function () {
	          transition.runQueue(deactivateQueue, deactivate, function () {
	            // 3. Activation phase
	
	            // Update router current route
	            transition.router._onTransitionValidated(transition);
	
	            // trigger reuse for all reused views
	            reuseQueue && reuseQueue.forEach(function (view) {
	              return reuse(view, transition);
	            });
	
	            // the root of the chain that needs to be replaced
	            // is the top-most non-reusable view.
	            if (deactivateQueue.length) {
	              var _view = deactivateQueue[deactivateQueue.length - 1];
	              var depth = reuseQueue ? reuseQueue.length : 0;
	              activate(_view, transition, depth, cb);
	            } else {
	              cb();
	            }
	          });
	        });
	      });
	    };
	
	    /**
	     * Asynchronously and sequentially apply a function to a
	     * queue.
	     *
	     * @param {Array} queue
	     * @param {Function} fn
	     * @param {Function} cb
	     */
	
	    RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {
	      var transition = this;
	      step(0);
	      function step(index) {
	        if (index >= queue.length) {
	          cb();
	        } else {
	          fn(queue[index], transition, function () {
	            step(index + 1);
	          });
	        }
	      }
	    };
	
	    /**
	     * Call a user provided route transition hook and handle
	     * the response (e.g. if the user returns a promise).
	     *
	     * If the user neither expects an argument nor returns a
	     * promise, the hook is assumed to be synchronous.
	     *
	     * @param {Function} hook
	     * @param {*} [context]
	     * @param {Function} [cb]
	     * @param {Object} [options]
	     *                 - {Boolean} expectBoolean
	     *                 - {Boolean} postActive
	     *                 - {Function} processData
	     *                 - {Function} cleanup
	     */
	
	    RouteTransition.prototype.callHook = function callHook(hook, context, cb) {
	      var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	      var _ref$expectBoolean = _ref.expectBoolean;
	      var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;
	      var _ref$postActivate = _ref.postActivate;
	      var postActivate = _ref$postActivate === undefined ? false : _ref$postActivate;
	      var processData = _ref.processData;
	      var cleanup = _ref.cleanup;
	
	      var transition = this;
	      var nextCalled = false;
	
	      // abort the transition
	      var abort = function abort() {
	        cleanup && cleanup();
	        transition.abort();
	      };
	
	      // handle errors
	      var onError = function onError(err) {
	        postActivate ? next() : abort();
	        if (err && !transition.router._suppress) {
	          warn$1('Uncaught error during transition: ');
	          throw err instanceof Error ? err : new Error(err);
	        }
	      };
	
	      // since promise swallows errors, we have to
	      // throw it in the next tick...
	      var onPromiseError = function onPromiseError(err) {
	        try {
	          onError(err);
	        } catch (e) {
	          setTimeout(function () {
	            throw e;
	          }, 0);
	        }
	      };
	
	      // advance the transition to the next step
	      var next = function next() {
	        if (nextCalled) {
	          warn$1('transition.next() should be called only once.');
	          return;
	        }
	        nextCalled = true;
	        if (transition.aborted) {
	          cleanup && cleanup();
	          return;
	        }
	        cb && cb();
	      };
	
	      var nextWithBoolean = function nextWithBoolean(res) {
	        if (typeof res === 'boolean') {
	          res ? next() : abort();
	        } else if (isPromise(res)) {
	          res.then(function (ok) {
	            ok ? next() : abort();
	          }, onPromiseError);
	        } else if (!hook.length) {
	          next();
	        }
	      };
	
	      var nextWithData = function nextWithData(data) {
	        var res = undefined;
	        try {
	          res = processData(data);
	        } catch (err) {
	          return onError(err);
	        }
	        if (isPromise(res)) {
	          res.then(next, onPromiseError);
	        } else {
	          next();
	        }
	      };
	
	      // expose a clone of the transition object, so that each
	      // hook gets a clean copy and prevent the user from
	      // messing with the internals.
	      var exposed = {
	        to: transition.to,
	        from: transition.from,
	        abort: abort,
	        next: processData ? nextWithData : next,
	        redirect: function redirect() {
	          transition.redirect.apply(transition, arguments);
	        }
	      };
	
	      // actually call the hook
	      var res = undefined;
	      try {
	        res = hook.call(context, exposed);
	      } catch (err) {
	        return onError(err);
	      }
	
	      if (expectBoolean) {
	        // boolean hooks
	        nextWithBoolean(res);
	      } else if (isPromise(res)) {
	        // promise
	        if (processData) {
	          res.then(nextWithData, onPromiseError);
	        } else {
	          res.then(next, onPromiseError);
	        }
	      } else if (processData && isPlainOjbect(res)) {
	        // data promise sugar
	        nextWithData(res);
	      } else if (!hook.length) {
	        next();
	      }
	    };
	
	    /**
	     * Call a single hook or an array of async hooks in series.
	     *
	     * @param {Array} hooks
	     * @param {*} context
	     * @param {Function} cb
	     * @param {Object} [options]
	     */
	
	    RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {
	      var _this = this;
	
	      if (Array.isArray(hooks)) {
	        this.runQueue(hooks, function (hook, _, next) {
	          if (!_this.aborted) {
	            _this.callHook(hook, context, next, options);
	          }
	        }, cb);
	      } else {
	        this.callHook(hooks, context, cb, options);
	      }
	    };
	
	    return RouteTransition;
	  })();
	
	  function isPlainOjbect(val) {
	    return Object.prototype.toString.call(val) === '[object Object]';
	  }
	
	  function toArray(val) {
	    return val ? Array.prototype.slice.call(val) : [];
	  }
	
	  var internalKeysRE = /^(component|subRoutes|fullPath)$/;
	
	  /**
	   * Route Context Object
	   *
	   * @param {String} path
	   * @param {Router} router
	   */
	
	  var Route = function Route(path, router) {
	    var _this = this;
	
	    babelHelpers.classCallCheck(this, Route);
	
	    var matched = router._recognizer.recognize(path);
	    if (matched) {
	      // copy all custom fields from route configs
	      [].forEach.call(matched, function (match) {
	        for (var key in match.handler) {
	          if (!internalKeysRE.test(key)) {
	            _this[key] = match.handler[key];
	          }
	        }
	      });
	      // set query and params
	      this.query = matched.queryParams;
	      this.params = [].reduce.call(matched, function (prev, cur) {
	        if (cur.params) {
	          for (var key in cur.params) {
	            prev[key] = cur.params[key];
	          }
	        }
	        return prev;
	      }, {});
	    }
	    // expose path and router
	    this.path = path;
	    // for internal use
	    this.matched = matched || router._notFoundHandler;
	    // internal reference to router
	    Object.defineProperty(this, 'router', {
	      enumerable: false,
	      value: router
	    });
	    // Important: freeze self to prevent observation
	    Object.freeze(this);
	  };
	
	  function applyOverride (Vue) {
	    var _Vue$util = Vue.util;
	    var extend = _Vue$util.extend;
	    var isArray = _Vue$util.isArray;
	    var defineReactive = _Vue$util.defineReactive;
	
	    // override Vue's init and destroy process to keep track of router instances
	    var init = Vue.prototype._init;
	    Vue.prototype._init = function (options) {
	      options = options || {};
	      var root = options._parent || options.parent || this;
	      var router = root.$router;
	      var route = root.$route;
	      if (router) {
	        // expose router
	        this.$router = router;
	        router._children.push(this);
	        /* istanbul ignore if */
	        if (this._defineMeta) {
	          // 0.12
	          this._defineMeta('$route', route);
	        } else {
	          // 1.0
	          defineReactive(this, '$route', route);
	        }
	      }
	      init.call(this, options);
	    };
	
	    var destroy = Vue.prototype._destroy;
	    Vue.prototype._destroy = function () {
	      if (!this._isBeingDestroyed && this.$router) {
	        this.$router._children.$remove(this);
	      }
	      destroy.apply(this, arguments);
	    };
	
	    // 1.0 only: enable route mixins
	    var strats = Vue.config.optionMergeStrategies;
	    var hooksToMergeRE = /^(data|activate|deactivate)$/;
	
	    if (strats) {
	      strats.route = function (parentVal, childVal) {
	        if (!childVal) return parentVal;
	        if (!parentVal) return childVal;
	        var ret = {};
	        extend(ret, parentVal);
	        for (var key in childVal) {
	          var a = ret[key];
	          var b = childVal[key];
	          // for data, activate and deactivate, we need to merge them into
	          // arrays similar to lifecycle hooks.
	          if (a && hooksToMergeRE.test(key)) {
	            ret[key] = (isArray(a) ? a : [a]).concat(b);
	          } else {
	            ret[key] = b;
	          }
	        }
	        return ret;
	      };
	    }
	  }
	
	  function View (Vue) {
	
	    var _ = Vue.util;
	    var componentDef =
	    // 0.12
	    Vue.directive('_component') ||
	    // 1.0
	    Vue.internalDirectives.component;
	    // <router-view> extends the internal component directive
	    var viewDef = _.extend({}, componentDef);
	
	    // with some overrides
	    _.extend(viewDef, {
	
	      _isRouterView: true,
	
	      bind: function bind() {
	        var route = this.vm.$route;
	        /* istanbul ignore if */
	        if (!route) {
	          warn$1('<router-view> can only be used inside a ' + 'router-enabled app.');
	          return;
	        }
	        // force dynamic directive so v-component doesn't
	        // attempt to build right now
	        this._isDynamicLiteral = true;
	        // finally, init by delegating to v-component
	        componentDef.bind.call(this);
	
	        // locate the parent view
	        var parentView = undefined;
	        var parent = this.vm;
	        while (parent) {
	          if (parent._routerView) {
	            parentView = parent._routerView;
	            break;
	          }
	          parent = parent.$parent;
	        }
	        if (parentView) {
	          // register self as a child of the parent view,
	          // instead of activating now. This is so that the
	          // child's activate hook is called after the
	          // parent's has resolved.
	          this.parentView = parentView;
	          parentView.childView = this;
	        } else {
	          // this is the root view!
	          var router = route.router;
	          router._rootView = this;
	        }
	
	        // handle late-rendered view
	        // two possibilities:
	        // 1. root view rendered after transition has been
	        //    validated;
	        // 2. child view rendered after parent view has been
	        //    activated.
	        var transition = route.router._currentTransition;
	        if (!parentView && transition.done || parentView && parentView.activated) {
	          var depth = parentView ? parentView.depth + 1 : 0;
	          activate(this, transition, depth);
	        }
	      },
	
	      unbind: function unbind() {
	        if (this.parentView) {
	          this.parentView.childView = null;
	        }
	        componentDef.unbind.call(this);
	      }
	    });
	
	    Vue.elementDirective('router-view', viewDef);
	  }
	
	  var trailingSlashRE = /\/$/;
	  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
	  var queryStringRE = /\?.*$/;
	
	  // install v-link, which provides navigation support for
	  // HTML5 history mode
	  function Link (Vue) {
	    var _Vue$util = Vue.util;
	    var _bind = _Vue$util.bind;
	    var isObject = _Vue$util.isObject;
	    var addClass = _Vue$util.addClass;
	    var removeClass = _Vue$util.removeClass;
	
	    var onPriority = Vue.directive('on').priority;
	    var LINK_UPDATE = '__vue-router-link-update__';
	
	    var activeId = 0;
	
	    Vue.directive('link-active', {
	      priority: 9999,
	      bind: function bind() {
	        var _this = this;
	
	        var id = String(activeId++);
	        // collect v-links contained within this element.
	        // we need do this here before the parent-child relationship
	        // gets messed up by terminal directives (if, for, components)
	        var childLinks = this.el.querySelectorAll('[v-link]');
	        for (var i = 0, l = childLinks.length; i < l; i++) {
	          var link = childLinks[i];
	          var existingId = link.getAttribute(LINK_UPDATE);
	          var value = existingId ? existingId + ',' + id : id;
	          // leave a mark on the link element which can be persisted
	          // through fragment clones.
	          link.setAttribute(LINK_UPDATE, value);
	        }
	        this.vm.$on(LINK_UPDATE, this.cb = function (link, path) {
	          if (link.activeIds.indexOf(id) > -1) {
	            link.updateClasses(path, _this.el);
	          }
	        });
	      },
	      unbind: function unbind() {
	        this.vm.$off(LINK_UPDATE, this.cb);
	      }
	    });
	
	    Vue.directive('link', {
	      priority: onPriority - 2,
	
	      bind: function bind() {
	        var vm = this.vm;
	        /* istanbul ignore if */
	        if (!vm.$route) {
	          warn$1('v-link can only be used inside a router-enabled app.');
	          return;
	        }
	        this.router = vm.$route.router;
	        // update things when the route changes
	        this.unwatch = vm.$watch('$route', _bind(this.onRouteUpdate, this));
	        // check v-link-active ids
	        var activeIds = this.el.getAttribute(LINK_UPDATE);
	        if (activeIds) {
	          this.el.removeAttribute(LINK_UPDATE);
	          this.activeIds = activeIds.split(',');
	        }
	        // no need to handle click if link expects to be opened
	        // in a new window/tab.
	        /* istanbul ignore if */
	        if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {
	          return;
	        }
	        // handle click
	        this.handler = _bind(this.onClick, this);
	        this.el.addEventListener('click', this.handler);
	      },
	
	      update: function update(target) {
	        this.target = target;
	        if (isObject(target)) {
	          this.append = target.append;
	          this.exact = target.exact;
	          this.prevActiveClass = this.activeClass;
	          this.activeClass = target.activeClass;
	        }
	        this.onRouteUpdate(this.vm.$route);
	      },
	
	      onClick: function onClick(e) {
	        // don't redirect with control keys
	        /* istanbul ignore if */
	        if (e.metaKey || e.ctrlKey || e.shiftKey) return;
	        // don't redirect when preventDefault called
	        /* istanbul ignore if */
	        if (e.defaultPrevented) return;
	        // don't redirect on right click
	        /* istanbul ignore if */
	        if (e.button !== 0) return;
	
	        var target = this.target;
	        if (target) {
	          // v-link with expression, just go
	          e.preventDefault();
	          this.router.go(target);
	        } else {
	          // no expression, delegate for an <a> inside
	          var el = e.target;
	          while (el.tagName !== 'A' && el !== this.el) {
	            el = el.parentNode;
	          }
	          if (el.tagName === 'A' && sameOrigin(el)) {
	            e.preventDefault();
	            var path = el.pathname;
	            if (this.router.history.root) {
	              path = path.replace(this.router.history.rootRE, '');
	            }
	            this.router.go({
	              path: path,
	              replace: target && target.replace,
	              append: target && target.append
	            });
	          }
	        }
	      },
	
	      onRouteUpdate: function onRouteUpdate(route) {
	        // router.stringifyPath is dependent on current route
	        // and needs to be called again whenver route changes.
	        var newPath = this.router.stringifyPath(this.target);
	        if (this.path !== newPath) {
	          this.path = newPath;
	          this.updateActiveMatch();
	          this.updateHref();
	        }
	        if (this.activeIds) {
	          this.vm.$emit(LINK_UPDATE, this, route.path);
	        } else {
	          this.updateClasses(route.path, this.el);
	        }
	      },
	
	      updateActiveMatch: function updateActiveMatch() {
	        this.activeRE = this.path && !this.exact ? new RegExp('^' + this.path.replace(/\/$/, '').replace(queryStringRE, '').replace(regexEscapeRE, '\\$&') + '(\\/|$)') : null;
	      },
	
	      updateHref: function updateHref() {
	        if (this.el.tagName !== 'A') {
	          return;
	        }
	        var path = this.path;
	        var router = this.router;
	        var isAbsolute = path.charAt(0) === '/';
	        // do not format non-hash relative paths
	        var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, this.append) : path;
	        if (href) {
	          this.el.href = href;
	        } else {
	          this.el.removeAttribute('href');
	        }
	      },
	
	      updateClasses: function updateClasses(path, el) {
	        var activeClass = this.activeClass || this.router._linkActiveClass;
	        // clear old class
	        if (this.prevActiveClass && this.prevActiveClass !== activeClass) {
	          toggleClasses(el, this.prevActiveClass, removeClass);
	        }
	        // remove query string before matching
	        var dest = this.path.replace(queryStringRE, '');
	        path = path.replace(queryStringRE, '');
	        // add new class
	        if (this.exact) {
	          if (dest === path ||
	          // also allow additional trailing slash
	          dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {
	            toggleClasses(el, activeClass, addClass);
	          } else {
	            toggleClasses(el, activeClass, removeClass);
	          }
	        } else {
	          if (this.activeRE && this.activeRE.test(path)) {
	            toggleClasses(el, activeClass, addClass);
	          } else {
	            toggleClasses(el, activeClass, removeClass);
	          }
	        }
	      },
	
	      unbind: function unbind() {
	        this.el.removeEventListener('click', this.handler);
	        this.unwatch && this.unwatch();
	      }
	    });
	
	    function sameOrigin(link) {
	      return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;
	    }
	
	    // this function is copied from v-bind:class implementation until
	    // we properly expose it...
	    function toggleClasses(el, key, fn) {
	      key = key.trim();
	      if (key.indexOf(' ') === -1) {
	        fn(el, key);
	        return;
	      }
	      var keys = key.split(/\s+/);
	      for (var i = 0, l = keys.length; i < l; i++) {
	        fn(el, keys[i]);
	      }
	    }
	  }
	
	  var historyBackends = {
	    abstract: AbstractHistory,
	    hash: HashHistory,
	    html5: HTML5History
	  };
	
	  // late bind during install
	  var Vue = undefined;
	
	  /**
	   * Router constructor
	   *
	   * @param {Object} [options]
	   */
	
	  var Router = (function () {
	    function Router() {
	      var _this = this;
	
	      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	      var _ref$hashbang = _ref.hashbang;
	      var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;
	      var _ref$abstract = _ref.abstract;
	      var abstract = _ref$abstract === undefined ? false : _ref$abstract;
	      var _ref$history = _ref.history;
	      var history = _ref$history === undefined ? false : _ref$history;
	      var _ref$saveScrollPosition = _ref.saveScrollPosition;
	      var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;
	      var _ref$transitionOnLoad = _ref.transitionOnLoad;
	      var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;
	      var _ref$suppressTransitionError = _ref.suppressTransitionError;
	      var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;
	      var _ref$root = _ref.root;
	      var root = _ref$root === undefined ? null : _ref$root;
	      var _ref$linkActiveClass = _ref.linkActiveClass;
	      var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;
	      babelHelpers.classCallCheck(this, Router);
	
	      /* istanbul ignore if */
	      if (!Router.installed) {
	        throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');
	      }
	
	      // Vue instances
	      this.app = null;
	      this._children = [];
	
	      // route recognizer
	      this._recognizer = new RouteRecognizer();
	      this._guardRecognizer = new RouteRecognizer();
	
	      // state
	      this._started = false;
	      this._startCb = null;
	      this._currentRoute = {};
	      this._currentTransition = null;
	      this._previousTransition = null;
	      this._notFoundHandler = null;
	      this._notFoundRedirect = null;
	      this._beforeEachHooks = [];
	      this._afterEachHooks = [];
	
	      // trigger transition on initial render?
	      this._rendered = false;
	      this._transitionOnLoad = transitionOnLoad;
	
	      // history mode
	      this._root = root;
	      this._abstract = abstract;
	      this._hashbang = hashbang;
	
	      // check if HTML5 history is available
	      var hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;
	      this._history = history && hasPushState;
	      this._historyFallback = history && !hasPushState;
	
	      // create history object
	      var inBrowser = Vue.util.inBrowser;
	      this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';
	
	      var History = historyBackends[this.mode];
	      this.history = new History({
	        root: root,
	        hashbang: this._hashbang,
	        onChange: function onChange(path, state, anchor) {
	          _this._match(path, state, anchor);
	        }
	      });
	
	      // other options
	      this._saveScrollPosition = saveScrollPosition;
	      this._linkActiveClass = linkActiveClass;
	      this._suppress = suppressTransitionError;
	    }
	
	    /**
	     * Allow directly passing components to a route
	     * definition.
	     *
	     * @param {String} path
	     * @param {Object} handler
	     */
	
	    // API ===================================================
	
	    /**
	    * Register a map of top-level paths.
	    *
	    * @param {Object} map
	    */
	
	    Router.prototype.map = function map(_map) {
	      for (var route in _map) {
	        this.on(route, _map[route]);
	      }
	      return this;
	    };
	
	    /**
	     * Register a single root-level path
	     *
	     * @param {String} rootPath
	     * @param {Object} handler
	     *                 - {String} component
	     *                 - {Object} [subRoutes]
	     *                 - {Boolean} [forceRefresh]
	     *                 - {Function} [before]
	     *                 - {Function} [after]
	     */
	
	    Router.prototype.on = function on(rootPath, handler) {
	      if (rootPath === '*') {
	        this._notFound(handler);
	      } else {
	        this._addRoute(rootPath, handler, []);
	      }
	      return this;
	    };
	
	    /**
	     * Set redirects.
	     *
	     * @param {Object} map
	     */
	
	    Router.prototype.redirect = function redirect(map) {
	      for (var path in map) {
	        this._addRedirect(path, map[path]);
	      }
	      return this;
	    };
	
	    /**
	     * Set aliases.
	     *
	     * @param {Object} map
	     */
	
	    Router.prototype.alias = function alias(map) {
	      for (var path in map) {
	        this._addAlias(path, map[path]);
	      }
	      return this;
	    };
	
	    /**
	     * Set global before hook.
	     *
	     * @param {Function} fn
	     */
	
	    Router.prototype.beforeEach = function beforeEach(fn) {
	      this._beforeEachHooks.push(fn);
	      return this;
	    };
	
	    /**
	     * Set global after hook.
	     *
	     * @param {Function} fn
	     */
	
	    Router.prototype.afterEach = function afterEach(fn) {
	      this._afterEachHooks.push(fn);
	      return this;
	    };
	
	    /**
	     * Navigate to a given path.
	     * The path can be an object describing a named path in
	     * the format of { name: '...', params: {}, query: {}}
	     * The path is assumed to be already decoded, and will
	     * be resolved against root (if provided)
	     *
	     * @param {String|Object} path
	     * @param {Boolean} [replace]
	     */
	
	    Router.prototype.go = function go(path) {
	      var replace = false;
	      var append = false;
	      if (Vue.util.isObject(path)) {
	        replace = path.replace;
	        append = path.append;
	      }
	      path = this.stringifyPath(path);
	      if (path) {
	        this.history.go(path, replace, append);
	      }
	    };
	
	    /**
	     * Short hand for replacing current path
	     *
	     * @param {String} path
	     */
	
	    Router.prototype.replace = function replace(path) {
	      if (typeof path === 'string') {
	        path = { path: path };
	      }
	      path.replace = true;
	      this.go(path);
	    };
	
	    /**
	     * Start the router.
	     *
	     * @param {VueConstructor} App
	     * @param {String|Element} container
	     * @param {Function} [cb]
	     */
	
	    Router.prototype.start = function start(App, container, cb) {
	      /* istanbul ignore if */
	      if (this._started) {
	        warn$1('already started.');
	        return;
	      }
	      this._started = true;
	      this._startCb = cb;
	      if (!this.app) {
	        /* istanbul ignore if */
	        if (!App || !container) {
	          throw new Error('Must start vue-router with a component and a ' + 'root container.');
	        }
	        /* istanbul ignore if */
	        if (App instanceof Vue) {
	          throw new Error('Must start vue-router with a component, not a ' + 'Vue instance.');
	        }
	        this._appContainer = container;
	        var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);
	        // give it a name for better debugging
	        Ctor.options.name = Ctor.options.name || 'RouterApp';
	      }
	
	      // handle history fallback in browsers that do not
	      // support HTML5 history API
	      if (this._historyFallback) {
	        var _location = window.location;
	        var _history = new HTML5History({ root: this._root });
	        var path = _history.root ? _location.pathname.replace(_history.rootRE, '') : _location.pathname;
	        if (path && path !== '/') {
	          _location.assign((_history.root || '') + '/' + this.history.formatPath(path) + _location.search);
	          return;
	        }
	      }
	
	      this.history.start();
	    };
	
	    /**
	     * Stop listening to route changes.
	     */
	
	    Router.prototype.stop = function stop() {
	      this.history.stop();
	      this._started = false;
	    };
	
	    /**
	     * Normalize named route object / string paths into
	     * a string.
	     *
	     * @param {Object|String|Number} path
	     * @return {String}
	     */
	
	    Router.prototype.stringifyPath = function stringifyPath(path) {
	      var generatedPath = '';
	      if (path && typeof path === 'object') {
	        if (path.name) {
	          var extend = Vue.util.extend;
	          var currentParams = this._currentTransition && this._currentTransition.to.params;
	          var targetParams = path.params || {};
	          var params = currentParams ? extend(extend({}, currentParams), targetParams) : targetParams;
	          generatedPath = encodeURI(this._recognizer.generate(path.name, params));
	        } else if (path.path) {
	          generatedPath = encodeURI(path.path);
	        }
	        if (path.query) {
	          // note: the generated query string is pre-URL-encoded by the recognizer
	          var query = this._recognizer.generateQueryString(path.query);
	          if (generatedPath.indexOf('?') > -1) {
	            generatedPath += '&' + query.slice(1);
	          } else {
	            generatedPath += query;
	          }
	        }
	      } else {
	        generatedPath = encodeURI(path ? path + '' : '');
	      }
	      return generatedPath;
	    };
	
	    // Internal methods ======================================
	
	    /**
	    * Add a route containing a list of segments to the internal
	    * route recognizer. Will be called recursively to add all
	    * possible sub-routes.
	    *
	    * @param {String} path
	    * @param {Object} handler
	    * @param {Array} segments
	    */
	
	    Router.prototype._addRoute = function _addRoute(path, handler, segments) {
	      guardComponent(path, handler);
	      handler.path = path;
	      handler.fullPath = (segments.reduce(function (path, segment) {
	        return path + segment.path;
	      }, '') + path).replace('//', '/');
	      segments.push({
	        path: path,
	        handler: handler
	      });
	      this._recognizer.add(segments, {
	        as: handler.name
	      });
	      // add sub routes
	      if (handler.subRoutes) {
	        for (var subPath in handler.subRoutes) {
	          // recursively walk all sub routes
	          this._addRoute(subPath, handler.subRoutes[subPath],
	          // pass a copy in recursion to avoid mutating
	          // across branches
	          segments.slice());
	        }
	      }
	    };
	
	    /**
	     * Set the notFound route handler.
	     *
	     * @param {Object} handler
	     */
	
	    Router.prototype._notFound = function _notFound(handler) {
	      guardComponent('*', handler);
	      this._notFoundHandler = [{ handler: handler }];
	    };
	
	    /**
	     * Add a redirect record.
	     *
	     * @param {String} path
	     * @param {String} redirectPath
	     */
	
	    Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {
	      if (path === '*') {
	        this._notFoundRedirect = redirectPath;
	      } else {
	        this._addGuard(path, redirectPath, this.replace);
	      }
	    };
	
	    /**
	     * Add an alias record.
	     *
	     * @param {String} path
	     * @param {String} aliasPath
	     */
	
	    Router.prototype._addAlias = function _addAlias(path, aliasPath) {
	      this._addGuard(path, aliasPath, this._match);
	    };
	
	    /**
	     * Add a path guard.
	     *
	     * @param {String} path
	     * @param {String} mappedPath
	     * @param {Function} handler
	     */
	
	    Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {
	      var _this2 = this;
	
	      this._guardRecognizer.add([{
	        path: path,
	        handler: function handler(match, query) {
	          var realPath = mapParams(mappedPath, match.params, query);
	          _handler.call(_this2, realPath);
	        }
	      }]);
	    };
	
	    /**
	     * Check if a path matches any redirect records.
	     *
	     * @param {String} path
	     * @return {Boolean} - if true, will skip normal match.
	     */
	
	    Router.prototype._checkGuard = function _checkGuard(path) {
	      var matched = this._guardRecognizer.recognize(path, true);
	      if (matched) {
	        matched[0].handler(matched[0], matched.queryParams);
	        return true;
	      } else if (this._notFoundRedirect) {
	        matched = this._recognizer.recognize(path);
	        if (!matched) {
	          this.replace(this._notFoundRedirect);
	          return true;
	        }
	      }
	    };
	
	    /**
	     * Match a URL path and set the route context on vm,
	     * triggering view updates.
	     *
	     * @param {String} path
	     * @param {Object} [state]
	     * @param {String} [anchor]
	     */
	
	    Router.prototype._match = function _match(path, state, anchor) {
	      var _this3 = this;
	
	      if (this._checkGuard(path)) {
	        return;
	      }
	
	      var currentRoute = this._currentRoute;
	      var currentTransition = this._currentTransition;
	
	      if (currentTransition) {
	        if (currentTransition.to.path === path) {
	          // do nothing if we have an active transition going to the same path
	          return;
	        } else if (currentRoute.path === path) {
	          // We are going to the same path, but we also have an ongoing but
	          // not-yet-validated transition. Abort that transition and reset to
	          // prev transition.
	          currentTransition.aborted = true;
	          this._currentTransition = this._prevTransition;
	          return;
	        } else {
	          // going to a totally different path. abort ongoing transition.
	          currentTransition.aborted = true;
	        }
	      }
	
	      // construct new route and transition context
	      var route = new Route(path, this);
	      var transition = new RouteTransition(this, route, currentRoute);
	
	      // current transition is updated right now.
	      // however, current route will only be updated after the transition has
	      // been validated.
	      this._prevTransition = currentTransition;
	      this._currentTransition = transition;
	
	      if (!this.app) {
	        (function () {
	          // initial render
	          var router = _this3;
	          _this3.app = new _this3._appConstructor({
	            el: _this3._appContainer,
	            created: function created() {
	              this.$router = router;
	            },
	            _meta: {
	              $route: route
	            }
	          });
	        })();
	      }
	
	      // check global before hook
	      var beforeHooks = this._beforeEachHooks;
	      var startTransition = function startTransition() {
	        transition.start(function () {
	          _this3._postTransition(route, state, anchor);
	        });
	      };
	
	      if (beforeHooks.length) {
	        transition.runQueue(beforeHooks, function (hook, _, next) {
	          if (transition === _this3._currentTransition) {
	            transition.callHook(hook, null, next, {
	              expectBoolean: true
	            });
	          }
	        }, startTransition);
	      } else {
	        startTransition();
	      }
	
	      if (!this._rendered && this._startCb) {
	        this._startCb.call(null);
	      }
	
	      // HACK:
	      // set rendered to true after the transition start, so
	      // that components that are acitvated synchronously know
	      // whether it is the initial render.
	      this._rendered = true;
	    };
	
	    /**
	     * Set current to the new transition.
	     * This is called by the transition object when the
	     * validation of a route has succeeded.
	     *
	     * @param {Transition} transition
	     */
	
	    Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {
	      // set current route
	      var route = this._currentRoute = transition.to;
	      // update route context for all children
	      if (this.app.$route !== route) {
	        this.app.$route = route;
	        this._children.forEach(function (child) {
	          child.$route = route;
	        });
	      }
	      // call global after hook
	      if (this._afterEachHooks.length) {
	        this._afterEachHooks.forEach(function (hook) {
	          return hook.call(null, {
	            to: transition.to,
	            from: transition.from
	          });
	        });
	      }
	      this._currentTransition.done = true;
	    };
	
	    /**
	     * Handle stuff after the transition.
	     *
	     * @param {Route} route
	     * @param {Object} [state]
	     * @param {String} [anchor]
	     */
	
	    Router.prototype._postTransition = function _postTransition(route, state, anchor) {
	      // handle scroll positions
	      // saved scroll positions take priority
	      // then we check if the path has an anchor
	      var pos = state && state.pos;
	      if (pos && this._saveScrollPosition) {
	        Vue.nextTick(function () {
	          window.scrollTo(pos.x, pos.y);
	        });
	      } else if (anchor) {
	        Vue.nextTick(function () {
	          var el = document.getElementById(anchor.slice(1));
	          if (el) {
	            window.scrollTo(window.scrollX, el.offsetTop);
	          }
	        });
	      }
	    };
	
	    return Router;
	  })();
	
	  function guardComponent(path, handler) {
	    var comp = handler.component;
	    if (Vue.util.isPlainObject(comp)) {
	      comp = handler.component = Vue.extend(comp);
	    }
	    /* istanbul ignore if */
	    if (typeof comp !== 'function') {
	      handler.component = null;
	      warn$1('invalid component for route "' + path + '".');
	    }
	  }
	
	  /* Installation */
	
	  Router.installed = false;
	
	  /**
	   * Installation interface.
	   * Install the necessary directives.
	   */
	
	  Router.install = function (externalVue) {
	    /* istanbul ignore if */
	    if (Router.installed) {
	      warn$1('already installed.');
	      return;
	    }
	    Vue = externalVue;
	    applyOverride(Vue);
	    View(Vue);
	    Link(Vue);
	    exports$1.Vue = Vue;
	    Router.installed = true;
	  };
	
	  // auto install
	  /* istanbul ignore if */
	  if (typeof window !== 'undefined' && window.Vue) {
	    window.Vue.use(Router);
	  }
	
	  return Router;
	
	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Install plugin.
	 */
	
	function install(Vue) {
	
	    var _ = __webpack_require__(7);
	
	    _.config = Vue.config;
	    _.warning = Vue.util.warn;
	    _.nextTick = Vue.util.nextTick;
	
	    Vue.url = __webpack_require__(8);
	    Vue.http = __webpack_require__(14);
	    Vue.resource = __webpack_require__(29);
	    Vue.Promise = __webpack_require__(16);
	
	    Object.defineProperties(Vue.prototype, {
	
	        $url: {
	            get: function () {
	                return _.options(Vue.url, this, this.$options.url);
	            }
	        },
	
	        $http: {
	            get: function () {
	                return _.options(Vue.http, this, this.$options.http);
	            }
	        },
	
	        $resource: {
	            get: function () {
	                return Vue.resource.bind(this);
	            }
	        },
	
	        $promise: {
	            get: function () {
	                return function (executor) {
	                    return new Vue.Promise(executor, this);
	                }.bind(this);
	            }
	        }
	
	    });
	}
	
	if (window.Vue) {
	    Vue.use(install);
	}
	
	module.exports = install;


/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Utility functions.
	 */
	
	var _ = exports, array = [], console = window.console;
	
	_.warn = function (msg) {
	    if (console && _.warning && (!_.config.silent || _.config.debug)) {
	        console.warn('[VueResource warn]: ' + msg);
	    }
	};
	
	_.error = function (msg) {
	    if (console) {
	        console.error(msg);
	    }
	};
	
	_.trim = function (str) {
	    return str.replace(/^\s*|\s*$/g, '');
	};
	
	_.toLower = function (str) {
	    return str ? str.toLowerCase() : '';
	};
	
	_.isArray = Array.isArray;
	
	_.isString = function (val) {
	    return typeof val === 'string';
	};
	
	_.isFunction = function (val) {
	    return typeof val === 'function';
	};
	
	_.isObject = function (obj) {
	    return obj !== null && typeof obj === 'object';
	};
	
	_.isPlainObject = function (obj) {
	    return _.isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
	};
	
	_.options = function (fn, obj, options) {
	
	    options = options || {};
	
	    if (_.isFunction(options)) {
	        options = options.call(obj);
	    }
	
	    return _.merge(fn.bind({$vm: obj, $options: options}), fn, {$options: options});
	};
	
	_.each = function (obj, iterator) {
	
	    var i, key;
	
	    if (typeof obj.length == 'number') {
	        for (i = 0; i < obj.length; i++) {
	            iterator.call(obj[i], obj[i], i);
	        }
	    } else if (_.isObject(obj)) {
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                iterator.call(obj[key], obj[key], key);
	            }
	        }
	    }
	
	    return obj;
	};
	
	_.defaults = function (target, source) {
	
	    for (var key in source) {
	        if (target[key] === undefined) {
	            target[key] = source[key];
	        }
	    }
	
	    return target;
	};
	
	_.extend = function (target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (arg) {
	        merge(target, arg);
	    });
	
	    return target;
	};
	
	_.merge = function (target) {
	
	    var args = array.slice.call(arguments, 1);
	
	    args.forEach(function (arg) {
	        merge(target, arg, true);
	    });
	
	    return target;
	};
	
	function merge(target, source, deep) {
	    for (var key in source) {
	        if (deep && (_.isPlainObject(source[key]) || _.isArray(source[key]))) {
	            if (_.isPlainObject(source[key]) && !_.isPlainObject(target[key])) {
	                target[key] = {};
	            }
	            if (_.isArray(source[key]) && !_.isArray(target[key])) {
	                target[key] = [];
	            }
	            merge(target[key], source[key], deep);
	        } else if (source[key] !== undefined) {
	            target[key] = source[key];
	        }
	    }
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Service for URL templating.
	 */
	
	var _ = __webpack_require__(7);
	var ie = document.documentMode;
	var el = document.createElement('a');
	
	function Url(url, params) {
	
	    var options = url, transform;
	
	    if (_.isString(url)) {
	        options = {url: url, params: params};
	    }
	
	    options = _.merge({}, Url.options, this.$options, options);
	
	    Url.transforms.forEach(function (handler) {
	        transform = factory(handler, transform, this.$vm);
	    }, this);
	
	    return transform(options);
	};
	
	/**
	 * Url options.
	 */
	
	Url.options = {
	    url: '',
	    root: null,
	    params: {}
	};
	
	/**
	 * Url transforms.
	 */
	
	Url.transforms = [
	    __webpack_require__(9),
	    __webpack_require__(11),
	    __webpack_require__(12),
	    __webpack_require__(13)
	];
	
	/**
	 * Encodes a Url parameter string.
	 *
	 * @param {Object} obj
	 */
	
	Url.params = function (obj) {
	
	    var params = [], escape = encodeURIComponent;
	
	    params.add = function (key, value) {
	
	        if (_.isFunction(value)) {
	            value = value();
	        }
	
	        if (value === null) {
	            value = '';
	        }
	
	        this.push(escape(key) + '=' + escape(value));
	    };
	
	    serialize(params, obj);
	
	    return params.join('&').replace(/%20/g, '+');
	};
	
	/**
	 * Parse a URL and return its components.
	 *
	 * @param {String} url
	 */
	
	Url.parse = function (url) {
	
	    if (ie) {
	        el.href = url;
	        url = el.href;
	    }
	
	    el.href = url;
	
	    return {
	        href: el.href,
	        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
	        port: el.port,
	        host: el.host,
	        hostname: el.hostname,
	        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
	        search: el.search ? el.search.replace(/^\?/, '') : '',
	        hash: el.hash ? el.hash.replace(/^#/, '') : ''
	    };
	};
	
	function factory(handler, next, vm) {
	    return function (options) {
	        return handler.call(vm, options, next);
	    };
	}
	
	function serialize(params, obj, scope) {
	
	    var array = _.isArray(obj), plain = _.isPlainObject(obj), hash;
	
	    _.each(obj, function (value, key) {
	
	        hash = _.isObject(value) || _.isArray(value);
	
	        if (scope) {
	            key = scope + '[' + (plain || hash ? key : '') + ']';
	        }
	
	        if (!scope && array) {
	            params.add(value.name, value.value);
	        } else if (hash) {
	            serialize(params, value, key);
	        } else {
	            params.add(key, value);
	        }
	    });
	}
	
	module.exports = _.url = Url;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * URL Template (RFC 6570) Transform.
	 */
	
	var UrlTemplate = __webpack_require__(10);
	
	module.exports = function (options) {
	
	    var variables = [], url = UrlTemplate.expand(options.url, options.params, variables);
	
	    variables.forEach(function (key) {
	        delete options.params[key];
	    });
	
	    return url;
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
	 */
	
	exports.expand = function (url, params, variables) {
	
	    var tmpl = this.parse(url), expanded = tmpl.expand(params);
	
	    if (variables) {
	        variables.push.apply(variables, tmpl.vars);
	    }
	
	    return expanded;
	};
	
	exports.parse = function (template) {
	
	    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];
	
	    return {
	        vars: variables,
	        expand: function (context) {
	            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
	                if (expression) {
	
	                    var operator = null, values = [];
	
	                    if (operators.indexOf(expression.charAt(0)) !== -1) {
	                        operator = expression.charAt(0);
	                        expression = expression.substr(1);
	                    }
	
	                    expression.split(/,/g).forEach(function (variable) {
	                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
	                        values.push.apply(values, exports.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
	                        variables.push(tmp[1]);
	                    });
	
	                    if (operator && operator !== '+') {
	
	                        var separator = ',';
	
	                        if (operator === '?') {
	                            separator = '&';
	                        } else if (operator !== '#') {
	                            separator = operator;
	                        }
	
	                        return (values.length !== 0 ? operator : '') + values.join(separator);
	                    } else {
	                        return values.join(',');
	                    }
	
	                } else {
	                    return exports.encodeReserved(literal);
	                }
	            });
	        }
	    };
	};
	
	exports.getValues = function (context, operator, key, modifier) {
	
	    var value = context[key], result = [];
	
	    if (this.isDefined(value) && value !== '') {
	        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	            value = value.toString();
	
	            if (modifier && modifier !== '*') {
	                value = value.substring(0, parseInt(modifier, 10));
	            }
	
	            result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));
	        } else {
	            if (modifier === '*') {
	                if (Array.isArray(value)) {
	                    value.filter(this.isDefined).forEach(function (value) {
	                        result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));
	                    }, this);
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (this.isDefined(value[k])) {
	                            result.push(this.encodeValue(operator, value[k], k));
	                        }
	                    }, this);
	                }
	            } else {
	                var tmp = [];
	
	                if (Array.isArray(value)) {
	                    value.filter(this.isDefined).forEach(function (value) {
	                        tmp.push(this.encodeValue(operator, value));
	                    }, this);
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (this.isDefined(value[k])) {
	                            tmp.push(encodeURIComponent(k));
	                            tmp.push(this.encodeValue(operator, value[k].toString()));
	                        }
	                    }, this);
	                }
	
	                if (this.isKeyOperator(operator)) {
	                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
	                } else if (tmp.length !== 0) {
	                    result.push(tmp.join(','));
	                }
	            }
	        }
	    } else {
	        if (operator === ';') {
	            result.push(encodeURIComponent(key));
	        } else if (value === '' && (operator === '&' || operator === '?')) {
	            result.push(encodeURIComponent(key) + '=');
	        } else if (value === '') {
	            result.push('');
	        }
	    }
	
	    return result;
	};
	
	exports.isDefined = function (value) {
	    return value !== undefined && value !== null;
	};
	
	exports.isKeyOperator = function (operator) {
	    return operator === ';' || operator === '&' || operator === '?';
	};
	
	exports.encodeValue = function (operator, value, key) {
	
	    value = (operator === '+' || operator === '#') ? this.encodeReserved(value) : encodeURIComponent(value);
	
	    if (key) {
	        return encodeURIComponent(key) + '=' + value;
	    } else {
	        return value;
	    }
	};
	
	exports.encodeReserved = function (str) {
	    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
	        if (!/%[0-9A-Fa-f]/.test(part)) {
	            part = encodeURI(part);
	        }
	        return part;
	    }).join('');
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Legacy Transform.
	 */
	
	var _ = __webpack_require__(7);
	
	module.exports = function (options, next) {
	
	    var variables = [], url = next(options);
	
	    url = url.replace(/(\/?):([a-z]\w*)/gi, function (match, slash, name) {
	
	        _.warn('The `:' + name + '` parameter syntax has been deprecated. Use the `{' + name + '}` syntax instead.');
	
	        if (options.params[name]) {
	            variables.push(name);
	            return slash + encodeUriSegment(options.params[name]);
	        }
	
	        return '';
	    });
	
	    variables.forEach(function (key) {
	        delete options.params[key];
	    });
	
	    return url;
	};
	
	function encodeUriSegment(value) {
	
	    return encodeUriQuery(value, true).
	        replace(/%26/gi, '&').
	        replace(/%3D/gi, '=').
	        replace(/%2B/gi, '+');
	}
	
	function encodeUriQuery(value, spaces) {
	
	    return encodeURIComponent(value).
	        replace(/%40/gi, '@').
	        replace(/%3A/gi, ':').
	        replace(/%24/g, '$').
	        replace(/%2C/gi, ',').
	        replace(/%20/g, (spaces ? '%20' : '+'));
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Query Parameter Transform.
	 */
	
	var _ = __webpack_require__(7);
	
	module.exports = function (options, next) {
	
	    var urlParams = Object.keys(_.url.options.params), query = {}, url = next(options);
	
	   _.each(options.params, function (value, key) {
	        if (urlParams.indexOf(key) === -1) {
	            query[key] = value;
	        }
	    });
	
	    query = _.url.params(query);
	
	    if (query) {
	        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
	    }
	
	    return url;
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Root Prefix Transform.
	 */
	
	var _ = __webpack_require__(7);
	
	module.exports = function (options, next) {
	
	    var url = next(options);
	
	    if (_.isString(options.root) && !url.match(/^(https?:)?\//)) {
	        url = options.root + '/' + url;
	    }
	
	    return url;
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Service for sending network requests.
	 */
	
	var _ = __webpack_require__(7);
	var Client = __webpack_require__(15);
	var Promise = __webpack_require__(16);
	var interceptor = __webpack_require__(19);
	var jsonType = {'Content-Type': 'application/json'};
	
	function Http(url, options) {
	
	    var client = Client, request, promise;
	
	    Http.interceptors.forEach(function (handler) {
	        client = interceptor(handler, this.$vm)(client);
	    }, this);
	
	    options = _.isObject(url) ? url : _.extend({url: url}, options);
	    request = _.merge({}, Http.options, this.$options, options);
	    promise = client(request).bind(this.$vm).then(function (response) {
	
	        return response.ok ? response : Promise.reject(response);
	
	    }, function (response) {
	
	        if (response instanceof Error) {
	            _.error(response);
	        }
	
	        return Promise.reject(response);
	    });
	
	    if (request.success) {
	        promise.success(request.success);
	    }
	
	    if (request.error) {
	        promise.error(request.error);
	    }
	
	    return promise;
	}
	
	Http.options = {
	    method: 'get',
	    data: '',
	    params: {},
	    headers: {},
	    xhr: null,
	    upload: null,
	    jsonp: 'callback',
	    beforeSend: null,
	    crossOrigin: null,
	    emulateHTTP: false,
	    emulateJSON: false,
	    timeout: 0
	};
	
	Http.interceptors = [
	    __webpack_require__(20),
	    __webpack_require__(21),
	    __webpack_require__(22),
	    __webpack_require__(24),
	    __webpack_require__(25),
	    __webpack_require__(26),
	    __webpack_require__(27)
	];
	
	Http.headers = {
	    put: jsonType,
	    post: jsonType,
	    patch: jsonType,
	    delete: jsonType,
	    common: {'Accept': 'application/json, text/plain, */*'},
	    custom: {'X-Requested-With': 'XMLHttpRequest'}
	};
	
	['get', 'put', 'post', 'patch', 'delete', 'jsonp'].forEach(function (method) {
	
	    Http[method] = function (url, data, success, options) {
	
	        if (_.isFunction(data)) {
	            options = success;
	            success = data;
	            data = undefined;
	        }
	
	        if (_.isObject(success)) {
	            options = success;
	            success = undefined;
	        }
	
	        return this(url, _.extend({method: method, data: data, success: success}, options));
	    };
	});
	
	module.exports = _.http = Http;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Base client.
	 */
	
	var _ = __webpack_require__(7);
	var Promise = __webpack_require__(16);
	var xhrClient = __webpack_require__(18);
	
	module.exports = function (request) {
	
	    var response = (request.client || xhrClient)(request);
	
	    return Promise.resolve(response).then(function (response) {
	
	        if (response.headers) {
	
	            var headers = parseHeaders(response.headers);
	
	            response.headers = function (name) {
	
	                if (name) {
	                    return headers[_.toLower(name)];
	                }
	
	                return headers;
	            };
	
	        }
	
	        response.ok = response.status >= 200 && response.status < 300;
	
	        return response;
	    });
	
	};
	
	function parseHeaders(str) {
	
	    var headers = {}, value, name, i;
	
	    if (_.isString(str)) {
	        _.each(str.split('\n'), function (row) {
	
	            i = row.indexOf(':');
	            name = _.trim(_.toLower(row.slice(0, i)));
	            value = _.trim(row.slice(i + 1));
	
	            if (headers[name]) {
	
	                if (_.isArray(headers[name])) {
	                    headers[name].push(value);
	                } else {
	                    headers[name] = [headers[name], value];
	                }
	
	            } else {
	
	                headers[name] = value;
	            }
	
	        });
	    }
	
	    return headers;
	}


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Promise adapter.
	 */
	
	var _ = __webpack_require__(7);
	var PromiseObj = window.Promise || __webpack_require__(17);
	
	function Promise(executor, context) {
	
	    if (executor instanceof PromiseObj) {
	        this.promise = executor;
	    } else {
	        this.promise = new PromiseObj(executor.bind(context));
	    }
	
	    this.context = context;
	}
	
	Promise.all = function (iterable, context) {
	    return new Promise(PromiseObj.all(iterable), context);
	};
	
	Promise.resolve = function (value, context) {
	    return new Promise(PromiseObj.resolve(value), context);
	};
	
	Promise.reject = function (reason, context) {
	    return new Promise(PromiseObj.reject(reason), context);
	};
	
	Promise.race = function (iterable, context) {
	    return new Promise(PromiseObj.race(iterable), context);
	};
	
	var p = Promise.prototype;
	
	p.bind = function (context) {
	    this.context = context;
	    return this;
	};
	
	p.then = function (fulfilled, rejected) {
	
	    if (fulfilled && fulfilled.bind && this.context) {
	        fulfilled = fulfilled.bind(this.context);
	    }
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    this.promise = this.promise.then(fulfilled, rejected);
	
	    return this;
	};
	
	p.catch = function (rejected) {
	
	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }
	
	    this.promise = this.promise.catch(rejected);
	
	    return this;
	};
	
	p.finally = function (callback) {
	
	    return this.then(function (value) {
	            callback.call(this);
	            return value;
	        }, function (reason) {
	            callback.call(this);
	            return PromiseObj.reject(reason);
	        }
	    );
	};
	
	p.success = function (callback) {
	
	    _.warn('The `success` method has been deprecated. Use the `then` method instead.');
	
	    return this.then(function (response) {
	        return callback.call(this, response.data, response.status, response) || response;
	    });
	};
	
	p.error = function (callback) {
	
	    _.warn('The `error` method has been deprecated. Use the `catch` method instead.');
	
	    return this.catch(function (response) {
	        return callback.call(this, response.data, response.status, response) || response;
	    });
	};
	
	p.always = function (callback) {
	
	    _.warn('The `always` method has been deprecated. Use the `finally` method instead.');
	
	    var cb = function (response) {
	        return callback.call(this, response.data, response.status, response) || response;
	    };
	
	    return this.then(cb, cb);
	};
	
	module.exports = Promise;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	 */
	
	var _ = __webpack_require__(7);
	
	var RESOLVED = 0;
	var REJECTED = 1;
	var PENDING  = 2;
	
	function Promise(executor) {
	
	    this.state = PENDING;
	    this.value = undefined;
	    this.deferred = [];
	
	    var promise = this;
	
	    try {
	        executor(function (x) {
	            promise.resolve(x);
	        }, function (r) {
	            promise.reject(r);
	        });
	    } catch (e) {
	        promise.reject(e);
	    }
	}
	
	Promise.reject = function (r) {
	    return new Promise(function (resolve, reject) {
	        reject(r);
	    });
	};
	
	Promise.resolve = function (x) {
	    return new Promise(function (resolve, reject) {
	        resolve(x);
	    });
	};
	
	Promise.all = function all(iterable) {
	    return new Promise(function (resolve, reject) {
	        var count = 0, result = [];
	
	        if (iterable.length === 0) {
	            resolve(result);
	        }
	
	        function resolver(i) {
	            return function (x) {
	                result[i] = x;
	                count += 1;
	
	                if (count === iterable.length) {
	                    resolve(result);
	                }
	            };
	        }
	
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise.resolve(iterable[i]).then(resolver(i), reject);
	        }
	    });
	};
	
	Promise.race = function race(iterable) {
	    return new Promise(function (resolve, reject) {
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise.resolve(iterable[i]).then(resolve, reject);
	        }
	    });
	};
	
	var p = Promise.prototype;
	
	p.resolve = function resolve(x) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (x === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        var called = false;
	
	        try {
	            var then = x && x['then'];
	
	            if (x !== null && typeof x === 'object' && typeof then === 'function') {
	                then.call(x, function (x) {
	                    if (!called) {
	                        promise.resolve(x);
	                    }
	                    called = true;
	
	                }, function (r) {
	                    if (!called) {
	                        promise.reject(r);
	                    }
	                    called = true;
	                });
	                return;
	            }
	        } catch (e) {
	            if (!called) {
	                promise.reject(e);
	            }
	            return;
	        }
	
	        promise.state = RESOLVED;
	        promise.value = x;
	        promise.notify();
	    }
	};
	
	p.reject = function reject(reason) {
	    var promise = this;
	
	    if (promise.state === PENDING) {
	        if (reason === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }
	
	        promise.state = REJECTED;
	        promise.value = reason;
	        promise.notify();
	    }
	};
	
	p.notify = function notify() {
	    var promise = this;
	
	    _.nextTick(function () {
	        if (promise.state !== PENDING) {
	            while (promise.deferred.length) {
	                var deferred = promise.deferred.shift(),
	                    onResolved = deferred[0],
	                    onRejected = deferred[1],
	                    resolve = deferred[2],
	                    reject = deferred[3];
	
	                try {
	                    if (promise.state === RESOLVED) {
	                        if (typeof onResolved === 'function') {
	                            resolve(onResolved.call(undefined, promise.value));
	                        } else {
	                            resolve(promise.value);
	                        }
	                    } else if (promise.state === REJECTED) {
	                        if (typeof onRejected === 'function') {
	                            resolve(onRejected.call(undefined, promise.value));
	                        } else {
	                            reject(promise.value);
	                        }
	                    }
	                } catch (e) {
	                    reject(e);
	                }
	            }
	        }
	    });
	};
	
	p.then = function then(onResolved, onRejected) {
	    var promise = this;
	
	    return new Promise(function (resolve, reject) {
	        promise.deferred.push([onResolved, onRejected, resolve, reject]);
	        promise.notify();
	    });
	};
	
	p.catch = function (onRejected) {
	    return this.then(undefined, onRejected);
	};
	
	module.exports = Promise;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * XMLHttp client.
	 */
	
	var _ = __webpack_require__(7);
	var Promise = __webpack_require__(16);
	
	module.exports = function (request) {
	    return new Promise(function (resolve) {
	
	        var xhr = new XMLHttpRequest(), response = {request: request}, handler;
	
	        request.cancel = function () {
	            xhr.abort();
	        };
	
	        xhr.open(request.method, _.url(request), true);
	
	        handler = function (event) {
	
	            response.data = xhr.responseText;
	            response.status = xhr.status;
	            response.statusText = xhr.statusText;
	            response.headers = xhr.getAllResponseHeaders();
	
	            resolve(response);
	        };
	
	        xhr.timeout = 0;
	        xhr.onload = handler;
	        xhr.onabort = handler;
	        xhr.onerror = handler;
	        xhr.ontimeout = function () {};
	        xhr.onprogress = function () {};
	
	        if (_.isPlainObject(request.xhr)) {
	            _.extend(xhr, request.xhr);
	        }
	
	        if (_.isPlainObject(request.upload)) {
	            _.extend(xhr.upload, request.upload);
	        }
	
	        _.each(request.headers || {}, function (value, header) {
	            xhr.setRequestHeader(header, value);
	        });
	
	        xhr.send(request.data);
	    });
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Interceptor factory.
	 */
	
	var _ = __webpack_require__(7);
	var Promise = __webpack_require__(16);
	
	module.exports = function (handler, vm) {
	
	    return function (client) {
	
	        if (_.isFunction(handler)) {
	            handler = handler.call(vm, Promise);
	        }
	
	        return function (request) {
	
	            if (_.isFunction(handler.request)) {
	                request = handler.request.call(vm, request);
	            }
	
	            return when(request, function (request) {
	                return when(client(request), function (response) {
	
	                    if (_.isFunction(handler.response)) {
	                        response = handler.response.call(vm, response);
	                    }
	
	                    return response;
	                });
	            });
	        };
	    };
	};
	
	function when(value, fulfilled, rejected) {
	
	    var promise = Promise.resolve(value);
	
	    if (arguments.length < 2) {
	        return promise;
	    }
	
	    return promise.then(fulfilled, rejected);
	}


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Before Interceptor.
	 */
	
	var _ = __webpack_require__(7);
	
	module.exports = {
	
	    request: function (request) {
	
	        if (_.isFunction(request.beforeSend)) {
	            request.beforeSend.call(this, request);
	        }
	
	        return request;
	    }
	
	};


/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Timeout Interceptor.
	 */
	
	module.exports = function () {
	
	    var timeout;
	
	    return {
	
	        request: function (request) {
	
	            if (request.timeout) {
	                timeout = setTimeout(function () {
	                    request.cancel();
	                }, request.timeout);
	            }
	
	            return request;
	        },
	
	        response: function (response) {
	
	            clearTimeout(timeout);
	
	            return response;
	        }
	
	    };
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * JSONP Interceptor.
	 */
	
	var jsonpClient = __webpack_require__(23);
	
	module.exports = {
	
	    request: function (request) {
	
	        if (request.method == 'JSONP') {
	            request.client = jsonpClient;
	        }
	
	        return request;
	    }
	
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * JSONP client.
	 */
	
	var _ = __webpack_require__(7);
	var Promise = __webpack_require__(16);
	
	module.exports = function (request) {
	    return new Promise(function (resolve) {
	
	        var callback = '_jsonp' + Math.random().toString(36).substr(2), response = {request: request, data: null}, handler, script;
	
	        request.params[request.jsonp] = callback;
	        request.cancel = function () {
	            handler({type: 'cancel'});
	        };
	
	        script = document.createElement('script');
	        script.src = _.url(request);
	        script.type = 'text/javascript';
	        script.async = true;
	
	        window[callback] = function (data) {
	            response.data = data;
	        };
	
	        handler = function (event) {
	
	            if (event.type === 'load' && response.data !== null) {
	                response.status = 200;
	            } else if (event.type === 'error') {
	                response.status = 404;
	            } else {
	                response.status = 0;
	            }
	
	            resolve(response);
	
	            delete window[callback];
	            document.body.removeChild(script);
	        };
	
	        script.onload = handler;
	        script.onerror = handler;
	
	        document.body.appendChild(script);
	    });
	};


/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * HTTP method override Interceptor.
	 */
	
	module.exports = {
	
	    request: function (request) {
	
	        if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
	            request.headers['X-HTTP-Method-Override'] = request.method;
	            request.method = 'POST';
	        }
	
	        return request;
	    }
	
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Mime Interceptor.
	 */
	
	var _ = __webpack_require__(7);
	
	module.exports = {
	
	    request: function (request) {
	
	        if (request.emulateJSON && _.isPlainObject(request.data)) {
	            request.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	            request.data = _.url.params(request.data);
	        }
	
	        if (_.isObject(request.data) && /FormData/i.test(request.data.toString())) {
	            delete request.headers['Content-Type'];
	        }
	
	        if (_.isPlainObject(request.data)) {
	            request.data = JSON.stringify(request.data);
	        }
	
	        return request;
	    },
	
	    response: function (response) {
	
	        try {
	            response.data = JSON.parse(response.data);
	        } catch (e) {}
	
	        return response;
	    }
	
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Header Interceptor.
	 */
	
	var _ = __webpack_require__(7);
	
	module.exports = {
	
	    request: function (request) {
	
	        request.method = request.method.toUpperCase();
	        request.headers = _.extend({}, _.http.headers.common,
	            !request.crossOrigin ? _.http.headers.custom : {},
	            _.http.headers[request.method.toLowerCase()],
	            request.headers
	        );
	
	        if (_.isPlainObject(request.data) && /^(GET|JSONP)$/i.test(request.method)) {
	            _.extend(request.params, request.data);
	            delete request.data;
	        }
	
	        return request;
	    }
	
	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * CORS Interceptor.
	 */
	
	var _ = __webpack_require__(7);
	var xdrClient = __webpack_require__(28);
	var xhrCors = 'withCredentials' in new XMLHttpRequest();
	var originUrl = _.url.parse(location.href);
	
	module.exports = {
	
	    request: function (request) {
	
	        if (request.crossOrigin === null) {
	            request.crossOrigin = crossOrigin(request);
	        }
	
	        if (request.crossOrigin) {
	
	            if (!xhrCors) {
	                request.client = xdrClient;
	            }
	
	            request.emulateHTTP = false;
	        }
	
	        return request;
	    }
	
	};
	
	function crossOrigin(request) {
	
	    var requestUrl = _.url.parse(_.url(request));
	
	    return (requestUrl.protocol !== originUrl.protocol || requestUrl.host !== originUrl.host);
	}


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * XDomain client (Internet Explorer).
	 */
	
	var _ = __webpack_require__(7);
	var Promise = __webpack_require__(16);
	
	module.exports = function (request) {
	    return new Promise(function (resolve) {
	
	        var xdr = new XDomainRequest(), response = {request: request}, handler;
	
	        request.cancel = function () {
	            xdr.abort();
	        };
	
	        xdr.open(request.method, _.url(request), true);
	
	        handler = function (event) {
	
	            response.data = xdr.responseText;
	            response.status = xdr.status;
	            response.statusText = xdr.statusText;
	
	            resolve(response);
	        };
	
	        xdr.timeout = 0;
	        xdr.onload = handler;
	        xdr.onabort = handler;
	        xdr.onerror = handler;
	        xdr.ontimeout = function () {};
	        xdr.onprogress = function () {};
	
	        xdr.send(request.data);
	    });
	};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Service for interacting with RESTful services.
	 */
	
	var _ = __webpack_require__(7);
	
	function Resource(url, params, actions, options) {
	
	    var self = this, resource = {};
	
	    actions = _.extend({},
	        Resource.actions,
	        actions
	    );
	
	    _.each(actions, function (action, name) {
	
	        action = _.merge({url: url, params: params || {}}, options, action);
	
	        resource[name] = function () {
	            return (self.$http || _.http)(opts(action, arguments));
	        };
	    });
	
	    return resource;
	}
	
	function opts(action, args) {
	
	    var options = _.extend({}, action), params = {}, data, success, error;
	
	    switch (args.length) {
	
	        case 4:
	
	            error = args[3];
	            success = args[2];
	
	        case 3:
	        case 2:
	
	            if (_.isFunction(args[1])) {
	
	                if (_.isFunction(args[0])) {
	
	                    success = args[0];
	                    error = args[1];
	
	                    break;
	                }
	
	                success = args[1];
	                error = args[2];
	
	            } else {
	
	                params = args[0];
	                data = args[1];
	                success = args[2];
	
	                break;
	            }
	
	        case 1:
	
	            if (_.isFunction(args[0])) {
	                success = args[0];
	            } else if (/^(POST|PUT|PATCH)$/i.test(options.method)) {
	                data = args[0];
	            } else {
	                params = args[0];
	            }
	
	            break;
	
	        case 0:
	
	            break;
	
	        default:
	
	            throw 'Expected up to 4 arguments [params, data, success, error], got ' + args.length + ' arguments';
	    }
	
	    options.data = data;
	    options.params = _.extend({}, options.params, params);
	
	    if (success) {
	        options.success = success;
	    }
	
	    if (error) {
	        options.error = error;
	    }
	
	    return options;
	}
	
	Resource.actions = {
	
	    get: {method: 'GET'},
	    save: {method: 'POST'},
	    query: {method: 'GET'},
	    update: {method: 'PUT'},
	    remove: {method: 'DELETE'},
	    delete: {method: 'DELETE'}
	
	};
	
	module.exports = _.resource = Resource;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __vue_script__, __vue_template__
	__webpack_require__(31)
	__vue_template__ = __webpack_require__(35)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/charlie/Charlie/Mywork/side-project/openVenue/openVenue-frontend/vue/app.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(32);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(34)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js?sourceMap!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./app.vue", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js?sourceMap!./../node_modules/vue-loader/lib/style-rewriter.js!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./app.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(33)();
	// imports
	
	
	// module
	exports.push([module.id, "\n.index-search-box .mdl-textfield__input {\n    color: rgba(0, 0, 0, 0.87);\n}\n\n.index-header .mdl-menu__container {\n    z-index: 50;\n    margin: 0 !important;\n}\n\n.mdl-textfield--expandable {\n    width: auto;\n}\n\n\n.index-mobile-title {\n    display: none !important;\n}\n\n.index-logo-image {\n    height: 28px;\n    width: 140px;\n}\n\n.index-header {\n    overflow: visible;\n    background-color: rgba(255, 255, 255, 0.52);\n}\n\n.index-header .material-icons {\n    color: #767777 !important;\n}\n\n.index-header .mdl-layout__drawer-button {\n    background: transparent;\n    color: #767777;\n}\n\n.index-header .mdl-navigation__link {\n    color: #757575;\n    font-weight: 700;\n    font-size: 14px;\n}\n\n.index-navigation-container {\n    /* Simple hack to make the overflow happen to the left instead... */\n    direction: rtl;\n    -webkit-box-ordinal-group: 2;\n    -webkit-order: 1;\n    -ms-flex-order: 1;\n    order: 1;\n    width: 500px;\n    -webkit-transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), width 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n    transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), width 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.index-navigation {\n    /* ... and now make sure the content is actually LTR */\n    direction: ltr;\n    -webkit-box-pack: end;\n    -webkit-justify-content: flex-end;\n    -ms-flex-pack: end;\n    justify-content: flex-end;\n    width: 800px;\n}\n\n.index-search-box.is-focused + .index-navigation-container {\n    opacity: 0;\n    width: 100px;\n}\n\n.index-navigation .mdl-navigation__link {\n    display: inline-block;\n    height: 60px;\n    line-height: 68px;\n    background-color: transparent !important;\n    border-bottom: 4px solid transparent;\n}\n\n.index-navigation .mdl-navigation__link:hover {\n    border-bottom: 4px solid #8bc34a;\n}\n\n.index-search-box {\n    -webkit-box-ordinal-group: 3;\n    -webkit-order: 2;\n    -ms-flex-order: 2;\n    order: 2;\n    margin-left: 16px;\n    margin-right: 16px;\n}\n\n.index-more-button {\n    -webkit-box-ordinal-group: 4;\n    -webkit-order: 3;\n    -ms-flex-order: 3;\n    order: 3;\n}\n\n.index-drawer {\n    border-right: none;\n}\n\n.index-drawer-separator {\n    height: 1px;\n    background-color: #dcdcdc;\n    margin: 8px 0;\n}\n\n.index-drawer .mdl-navigation__link.mdl-navigation__link {\n    font-size: 14px;\n    color: #757575;\n}\n\n.index-drawer span.mdl-navigation__link.mdl-navigation__link {\n    color: #8bc34a;\n}\n\n.index-drawer .mdl-layout-title {\n    position: relative;\n    background: #6ab344;\n    height: 160px;\n}\n\n.index-drawer .index-logo-image {\n    position: absolute;\n    bottom: 16px;\n}\n\n.view {\n  /*position: absolute;*/\n  /*background-color: #f6f6ef;*/\n  width: 100%;\n  -webkit-transition: opacity .2s ease;\n  transition: opacity .2s ease;\n  box-sizing: border-box;\n}\n\n.expand-transition {\n  -webkit-transition: all .2s ease;\n  transition: all .2s ease;\n  /*background-color: #eee;*/\n  /*overflow: hidden;*/\n}\n\n.expand-enter, .expand-leave {\n  height: 0;\n  opacity: 0;\n}\n  \n", "", {"version":3,"sources":["/./vue/app.vue?448e084b"],"names":[],"mappings":";AA0DA;IACA,2BAAA;CACA;;AAEA;IACA,YAAA;IACA,qBAAA;CACA;;AAEA;IACA,YAAA;CACA;;;AAGA;IACA,yBAAA;CACA;;AAEA;IACA,aAAA;IACA,aAAA;CACA;;AAEA;IACA,kBAAA;IACA,4CAAA;CACA;;AAEA;IACA,0BAAA;CACA;;AAEA;IACA,wBAAA;IACA,eAAA;CACA;;AAEA;IACA,eAAA;IACA,iBAAA;IACA,gBAAA;CACA;;AAEA;IACA,oEAAA;IACA,eAAA;IACA,6BAAA;IACA,iBAAA;IACA,kBAAA;IACA,SAAA;IACA,aAAA;IACA,uGAAA;IACA,+FAAA;CACA;;AAEA;IACA,uDAAA;IACA,eAAA;IACA,sBAAA;IACA,kCAAA;IACA,mBAAA;IACA,0BAAA;IACA,aAAA;CACA;;AAEA;IACA,WAAA;IACA,aAAA;CACA;;AAEA;IACA,sBAAA;IACA,aAAA;IACA,kBAAA;IACA,yCAAA;IACA,qCAAA;CACA;;AAEA;IACA,iCAAA;CACA;;AAEA;IACA,6BAAA;IACA,iBAAA;IACA,kBAAA;IACA,SAAA;IACA,kBAAA;IACA,mBAAA;CACA;;AAEA;IACA,6BAAA;IACA,iBAAA;IACA,kBAAA;IACA,SAAA;CACA;;AAEA;IACA,mBAAA;CACA;;AAEA;IACA,YAAA;IACA,0BAAA;IACA,cAAA;CACA;;AAEA;IACA,gBAAA;IACA,eAAA;CACA;;AAEA;IACA,eAAA;CACA;;AAEA;IACA,mBAAA;IACA,oBAAA;IACA,cAAA;CACA;;AAEA;IACA,mBAAA;IACA,aAAA;CACA;;AAEA;EACA,uBAAA;EACA,8BAAA;EACA,YAAA;EACA,qCAAA;EAAA,6BAAA;EACA,uBAAA;CACA;;AAEA;EACA,iCAAA;EAAA,yBAAA;EACA,2BAAA;EACA,qBAAA;CACA;;AAEA;EACA,UAAA;EACA,WAAA;CACA","file":"app.vue","sourcesContent":["<template>\n    <div class=\"mdl-layout mdl-js-layout mdl-layout--fixed-header\">\n        <div class=\"index-header mdl-layout__header mdl-layout__header--waterfall\">\n            <div class=\"mdl-layout__header-row\">\n                <span class=\"index-title mdl-layout-title\">\n                OpenVenues\n                  <!-- <img class=\"index-logo-image\" src=\"assets/index-logo.png\"> -->\n                </span>\n                <!-- Add spacer, to align navigation to the right in desktop -->\n                <div class=\"index-header-spacer mdl-layout-spacer\"></div>\n                <!-- <div class=\"index-search-box mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right mdl-textfield--full-width\">\n                    <label class=\"mdl-button mdl-js-button mdl-button--icon\" for=\"search-field\">\n                        <i class=\"material-icons\">search</i>\n                    </label>\n                    <div class=\"mdl-textfield__expandable-holder\">\n                        <input class=\"mdl-textfield__input\" type=\"text\" id=\"search-field\">\n                    </div>\n                </div> -->\n                <!-- Navigation -->\n                <div class=\"index-navigation-container\">\n                    <nav class=\"index-navigation mdl-navigation\">\n                        <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/about' }\">About</a>\n                        <!-- <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/listVenue' }\">List Venues</a> -->\n                        <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/map' }\">Find on Map</a>\n                        <!-- <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/weather' }\">Weather</a> -->\n                    </nav>\n                </div>\n                <span class=\"index-mobile-title mdl-layout-title\">\n                  <!-- <img class=\"index-logo-image\" src=\"assets/index-logo.png\"> -->\n                </span>\n            </div>\n        </div>\n        <div class=\"index-drawer mdl-layout__drawer\">\n            <span class=\"mdl-layout-title\">\n            OpenVenues\n              <!-- <img class=\"index-logo-image\" src=\"assets/index-logo-white.png\"> -->\n            </span>\n            <nav class=\"mdl-navigation\">\n                <a class=\"mdl-navigation__link\" v-link=\"{ path: '/about' }\">About</a>\n            <!--     <a class=\"mdl-navigation__link\" v-link=\"{ path: '/listVenue' }\">List Venues</a> -->\n                <a class=\"mdl-navigation__link\" v-link=\"{ path: '/map' }\">Find on Map</a>\n                <!-- <a class=\"mdl-navigation__link\" v-link=\"{ path: '/weather' }\">Weather</a> -->\n                <div class=\"index-drawer-separator\"></div>\n            </nav>\n        </div>\n        <main class=\"index-content mdl-layout__content\">\n            <a name=\"top\"></a>\n            <!-- main view -->\n            <router-view\n              class=\"view\"\n              keep-alive\n              >\n            </router-view>\n        </main>\n    </div>\n</template>\n\n<style type=\"text/css\">\n  .index-search-box .mdl-textfield__input {\n      color: rgba(0, 0, 0, 0.87);\n  }\n\n  .index-header .mdl-menu__container {\n      z-index: 50;\n      margin: 0 !important;\n  }\n\n  .mdl-textfield--expandable {\n      width: auto;\n  }\n\n\n  .index-mobile-title {\n      display: none !important;\n  }\n\n  .index-logo-image {\n      height: 28px;\n      width: 140px;\n  }\n\n  .index-header {\n      overflow: visible;\n      background-color: rgba(255, 255, 255, 0.52);\n  }\n\n  .index-header .material-icons {\n      color: #767777 !important;\n  }\n\n  .index-header .mdl-layout__drawer-button {\n      background: transparent;\n      color: #767777;\n  }\n\n  .index-header .mdl-navigation__link {\n      color: #757575;\n      font-weight: 700;\n      font-size: 14px;\n  }\n\n  .index-navigation-container {\n      /* Simple hack to make the overflow happen to the left instead... */\n      direction: rtl;\n      -webkit-box-ordinal-group: 2;\n      -webkit-order: 1;\n      -ms-flex-order: 1;\n      order: 1;\n      width: 500px;\n      -webkit-transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), width 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n      transition: opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), width 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  }\n\n  .index-navigation {\n      /* ... and now make sure the content is actually LTR */\n      direction: ltr;\n      -webkit-box-pack: end;\n      -webkit-justify-content: flex-end;\n      -ms-flex-pack: end;\n      justify-content: flex-end;\n      width: 800px;\n  }\n\n  .index-search-box.is-focused + .index-navigation-container {\n      opacity: 0;\n      width: 100px;\n  }\n\n  .index-navigation .mdl-navigation__link {\n      display: inline-block;\n      height: 60px;\n      line-height: 68px;\n      background-color: transparent !important;\n      border-bottom: 4px solid transparent;\n  }\n\n  .index-navigation .mdl-navigation__link:hover {\n      border-bottom: 4px solid #8bc34a;\n  }\n\n  .index-search-box {\n      -webkit-box-ordinal-group: 3;\n      -webkit-order: 2;\n      -ms-flex-order: 2;\n      order: 2;\n      margin-left: 16px;\n      margin-right: 16px;\n  }\n\n  .index-more-button {\n      -webkit-box-ordinal-group: 4;\n      -webkit-order: 3;\n      -ms-flex-order: 3;\n      order: 3;\n  }\n\n  .index-drawer {\n      border-right: none;\n  }\n\n  .index-drawer-separator {\n      height: 1px;\n      background-color: #dcdcdc;\n      margin: 8px 0;\n  }\n\n  .index-drawer .mdl-navigation__link.mdl-navigation__link {\n      font-size: 14px;\n      color: #757575;\n  }\n\n  .index-drawer span.mdl-navigation__link.mdl-navigation__link {\n      color: #8bc34a;\n  }\n\n  .index-drawer .mdl-layout-title {\n      position: relative;\n      background: #6ab344;\n      height: 160px;\n  }\n\n  .index-drawer .index-logo-image {\n      position: absolute;\n      bottom: 16px;\n  }\n\n  .view {\n    /*position: absolute;*/\n    /*background-color: #f6f6ef;*/\n    width: 100%;\n    transition: opacity .2s ease;\n    box-sizing: border-box;\n  }\n\n  .expand-transition {\n    transition: all .2s ease;\n    /*background-color: #eee;*/\n    /*overflow: hidden;*/\n  }\n\n  .expand-enter, .expand-leave {\n    height: 0;\n    opacity: 0;\n  }\n    \n</style>\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 33 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if (media) {
			styleElement.setAttribute("media", media);
		}
	
		if (sourceMap) {
			// https://developer.chrome.com/devtools/docs/javascript-debugging
			// this makes source maps inside style tags work properly in Chrome
			css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */';
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"mdl-layout mdl-js-layout mdl-layout--fixed-header\">\n    <div class=\"index-header mdl-layout__header mdl-layout__header--waterfall\">\n        <div class=\"mdl-layout__header-row\">\n            <span class=\"index-title mdl-layout-title\">\n            OpenVenues\n              <!-- <img class=\"index-logo-image\" src=\"assets/index-logo.png\"> -->\n            </span>\n            <!-- Add spacer, to align navigation to the right in desktop -->\n            <div class=\"index-header-spacer mdl-layout-spacer\"></div>\n            <!-- <div class=\"index-search-box mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right mdl-textfield--full-width\">\n                <label class=\"mdl-button mdl-js-button mdl-button--icon\" for=\"search-field\">\n                    <i class=\"material-icons\">search</i>\n                </label>\n                <div class=\"mdl-textfield__expandable-holder\">\n                    <input class=\"mdl-textfield__input\" type=\"text\" id=\"search-field\">\n                </div>\n            </div> -->\n            <!-- Navigation -->\n            <div class=\"index-navigation-container\">\n                <nav class=\"index-navigation mdl-navigation\">\n                    <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/about' }\">About</a>\n                    <!-- <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/listVenue' }\">List Venues</a> -->\n                    <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/map' }\">Find on Map</a>\n                    <!-- <a class=\"mdl-navigation__link mdl-typography--text-uppercase\" v-link=\"{ path: '/weather' }\">Weather</a> -->\n                </nav>\n            </div>\n            <span class=\"index-mobile-title mdl-layout-title\">\n              <!-- <img class=\"index-logo-image\" src=\"assets/index-logo.png\"> -->\n            </span>\n        </div>\n    </div>\n    <div class=\"index-drawer mdl-layout__drawer\">\n        <span class=\"mdl-layout-title\">\n        OpenVenues\n          <!-- <img class=\"index-logo-image\" src=\"assets/index-logo-white.png\"> -->\n        </span>\n        <nav class=\"mdl-navigation\">\n            <a class=\"mdl-navigation__link\" v-link=\"{ path: '/about' }\">About</a>\n        <!--     <a class=\"mdl-navigation__link\" v-link=\"{ path: '/listVenue' }\">List Venues</a> -->\n            <a class=\"mdl-navigation__link\" v-link=\"{ path: '/map' }\">Find on Map</a>\n            <!-- <a class=\"mdl-navigation__link\" v-link=\"{ path: '/weather' }\">Weather</a> -->\n            <div class=\"index-drawer-separator\"></div>\n        </nav>\n    </div>\n    <main class=\"index-content mdl-layout__content\">\n        <a name=\"top\"></a>\n        <!-- main view -->\n        <router-view\n          class=\"view\"\n          keep-alive\n          >\n        </router-view>\n    </main>\n</div>\n";

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _main = __webpack_require__(1);
	
	var _main2 = _interopRequireDefault(_main);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var API_URL = 'http://0.0.0.0:3000/';
	var ADD_VENUE = API_URL + 'venues/addvenue/';
	var FIND_ONE = API_URL + 'venues/findvenue/';
	var FIND_ALL = API_URL + 'venues/findallvenues/';
	var DEL_ONE = API_URL + 'venues/deletevenue/';
	
	exports.default = {
	
	  user: {
	    authenticated: false
	  },
	
	  addVenue: function addVenue(context, creds, redirect) {
	    return context.$http.post(ADD_VENUE, creds).then(function (data) {
	      if (data.status !== 200) {
	        return data.status;
	      }
	      if (redirect) {
	        _main2.default.go(redirect);
	      }
	    }).catch(function (err) {
	      if (err.status === 409) {
	        return 'Venue name already occupied.';
	      } else {
	        return 'Submit error.';
	      }
	    });
	  },
	  findVenue: function findVenue(context, creds, redirect) {
	    return context.$http.post(FIND_ONE, creds).then(function (data) {
	      if (data.status !== 200) {
	        return data.status;
	      }
	      return data.data.data;
	    }).catch(function (err) {
	      window.console.log(err);
	    });
	  },
	  findAllVenues: function findAllVenues(context) {
	    return context.$http.get(FIND_ALL).then(function (data) {
	      if (data.status !== 200) {
	        return data.status;
	      }
	      return data.data.data;
	    }).catch(function (err) {
	      window.console.log(err);
	    });
	  },
	  deleteVenue: function deleteVenue(context, creds, redirect) {
	    return context.$http.post(DEL_ONE, creds).then(function (data) {
	      if (data.status !== 200) {
	        return data.status;
	      }
	      if (redirect) {
	        _main2.default.go(redirect);
	      }
	    }).catch(function (err) {
	      return err;
	    });
	  },
	  getAuthHeader: function getAuthHeader() {
	    return {
	      'Authorization': 'Bearer ' + localStorage.getItem('id_token')
	    };
	  }
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {var __vue_script__, __vue_template__
	__webpack_require__(38)
	__vue_script__ = __webpack_require__(41)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] vue/components/map.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(332)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/charlie/Charlie/Mywork/side-project/openVenue/openVenue-frontend/vue/components/map.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(39);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(34)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./map.vue", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./map.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(33)();
	// imports
	
	
	// module
	exports.push([module.id, "\n#map { position:fixed; top:0px; bottom:0px; width:100%;  }\n\n#menu {\n    background: #fff;\n    position: absolute;\n    z-index: 10;\n    top: 10px;\n    right: 10px;\n    border-radius: 3px;\n    width: 120px;\n    border: 1px solid rgba(0,0,0,0.4);\n    font-family: 'Open Sans', sans-serif;\n}\n\n#menu a,#menu select{\n    font-size: 13px;\n    color: #404040;\n    display: block;\n    margin: 0;\n    padding: 0;\n    padding: 10px;\n    text-decoration: none;\n    border-bottom: 1px solid rgba(0,0,0,0.25);\n    text-align: center;\n}\n\n#menu a:last-child {\n    border: none;\n}\n\n#menu a:hover {\n    background-color: #f8f8f8;\n    color: #404040;\n}\n\n#menu a.active {\n    background-color: #3887be;\n    color: #ffffff;\n}\n\n#menu a.active:hover {\n    background: #3074a4;\n}\n\n.demo-card-wide.mdl-card {\n  width: 312px;\n}\n.demo-card-wide > .mdl-card__title {\n  color: #fff;\n  height: 156px;\n  background: url(" + __webpack_require__(40) + ") center / cover;\n}\n.demo-card-wide > .mdl-card__menu {\n  color: #fff;\n}\n", "", {"version":3,"sources":["/./vue/components/map.vue?b6585108"],"names":[],"mappings":";AAsMA,OAAA,eAAA,CAAA,QAAA,CAAA,WAAA,CAAA,WAAA,GAAA;;AAEA;IACA,iBAAA;IACA,mBAAA;IACA,YAAA;IACA,UAAA;IACA,YAAA;IACA,mBAAA;IACA,aAAA;IACA,kCAAA;IACA,qCAAA;CACA;;AAEA;IACA,gBAAA;IACA,eAAA;IACA,eAAA;IACA,UAAA;IACA,WAAA;IACA,cAAA;IACA,sBAAA;IACA,0CAAA;IACA,mBAAA;CACA;;AAEA;IACA,aAAA;CACA;;AAEA;IACA,0BAAA;IACA,eAAA;CACA;;AAEA;IACA,0BAAA;IACA,eAAA;CACA;;AAEA;IACA,oBAAA;CACA;;AAEA;EACA,aAAA;CACA;AACA;EACA,YAAA;EACA,cAAA;EACA,yDAAA;CACA;AACA;EACA,YAAA;CACA","file":"map.vue","sourcesContent":["<template>\n  <div>\n    <nav id=\"menu\">\n      <a :class=\"{'active' : addFlag}\" @click.prevent.stop=\"onFlag\"></a>\n    </nav>\n    <div id=\"map\"></div>\n    <div id=\"snackbar\" class=\"mdl-js-snackbar mdl-snackbar\">\n      <div class=\"mdl-snackbar__text\"></div>\n      <button class=\"mdl-snackbar__action\" type=\"button\"></button>\n    </div>\n  </div>\n</template>\n\n<script>\n  import DataAPI from '../data/data';\n  import mdl from 'material-design-lite/material.js';\n  import geo from 'gps-util';\n  import auth from '../auth';\n  let clickFlag = false;\n\n  export default {\n    name: 'MapView',\n    data () {\n      return {\n        Map : Object.create(null),\n        Markers: {\n          type: 'FeatureCollection',\n          features: []\n        },\n        Source: {\n          setData () {}\n        },\n        geoHash: '',\n        addFlag: false\n      };\n    },\n    watch: {\n      'Markers.features' () {\n        this.Source.setData(this.Markers);\n      }\n    },\n    route: { \n      data ({ to }) {\n        clickFlag = false;\n        this.getVenues();\n      }\n    },\n    created () {},\n    ready () {\n      // MDL\n      this.$nextTick(function(){\n        componentHandler.upgradeAllRegistered();\n      })\n\n      // Map Source\n      let source;\n      this.Map = new DataAPI.MapBox.Map({\n        container: 'map',\n        style: 'mapbox://styles/ccharlieli/cio8phh7x001sadnmu988hd91',\n        center: [121.4691603379, 31.2223104171],\n        zoom: 13\n      });\n\n      this.Map.on('load', () => {\n        this.Source = new DataAPI.MapBox.GeoJSONSource({\n          data: this.Markers,\n          cluster: true,\n          clusterMaxZoom: 14, // Max zoom to cluster points on\n          clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)\n        });\n        this.Map.addSource('markers', this.Source);\n        this.Map.addLayer({\n          'id': 'markers',\n          'type': 'symbol',\n          'source': 'markers',\n          'layout': {\n            'icon-image': '{marker-symbol}-15',\n            'icon-allow-overlap': true\n          }\n        });\n\n        let layers = [\n          [150, '#f28cb1'],\n          [20, '#f1f075'],\n          [0, '#6ab344']\n        ];\n        layers.forEach((layer, i) => {\n          this.Map.addLayer({\n            \"id\": \"cluster-\" + i,\n            \"type\": \"circle\",\n            \"source\": \"markers\",\n            \"paint\": {\n              \"circle-color\": layer[1],\n              \"circle-radius\": 18\n            },\n            \"filter\": i == 0 ?\n              [\">=\", \"point_count\", layer[0]] :\n              [\"all\",\n                [\">=\", \"point_count\", layer[0]],\n                [\"<\", \"point_count\", layers[i - 1][0]]]\n          });\n        });\n        // Add a layer for the clusters' count labels\n        this.Map.addLayer({\n          \"id\": \"cluster-count\",\n          \"type\": \"symbol\",\n          \"source\": \"markers\",\n          \"layout\": {\n            \"text-field\": \"{point_count}\",\n            \"text-font\": [\n              \"DIN Offc Pro Medium\",\n              \"Arial Unicode MS Bold\"\n            ],\n            \"text-size\": 12\n          }\n        });\n      });\n\n      this.Map.on('click', (e) => {\n        if(this.addFlag) {\n          if (clickFlag){\n            this.Markers.features.pop();\n          }\n          this.geoHash = geo.geohashEncode(e.lngLat.lat, e.lngLat.lng, 7);\n          this.Markers.features.push({\n            'type': 'Feature',\n            'properties': {\n              'description': '<div class=\"demo-card-wide mdl-card mdl-shadow--2dp\"><div class=\"mdl-card__title\"><h2 class=\"mdl-card__title-text\">[]</h2></div><div class=\"mdl-card__supporting-text\">[]</div><div class=\"mdl-card__actions mdl-card--border\"><a href=\"#!/venue/' + this.geoHash + '\" class=\"mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect\"></a></div><div class=\"mdl-card__menu\"></div></div>',\n              'marker-symbol': 'star'\n            },\n            'geometry': {\n              'type': 'Point',\n              'coordinates': [e.lngLat.lng, e.lngLat.lat]\n            }\n          });\n          clickFlag = true;\n        }\n      });\n\n      // Pop up\n      var popup = new DataAPI.MapBox.Popup({\n        closeButton: false,\n        closeOnClick: false\n      });\n      this.Map.on('mousemove', (e) => {\n        var features = this.Map.queryRenderedFeatures(e.point, { layers: ['markers'] });\n        this.Map.getCanvas().style.cursor = (features.length) ? 'pointer' : '';\n        if (!features.length) {\n          popup.remove();\n          return;\n        }\n        var feature = features[0];\n        popup.setLngLat(feature.geometry.coordinates)\n          .setHTML(feature.properties.description)\n          .addTo(this.Map);\n      });\n    },\n    destroyed () {},\n    methods: {\n      onDetail () {\n        window.console.log(123);\n      },\n      popUp (msg) {\n        let snackbarContainer = document.querySelector('#snackbar');\n        let data = {message: msg};\n        snackbarContainer.MaterialSnackbar.showSnackbar(data);\n      },\n      getVenues () {\n        // Venue Source\n        this.Markers.features = [];\n        auth.findAllVenues(this).then((res) => {\n          res.forEach((re) => {\n            this.Markers.features.push({\n              'type': 'Feature',\n              'properties': {\n                'description': '<div class=\"demo-card-wide mdl-card mdl-shadow--2dp\"><div class=\"mdl-card__title\"><h2 class=\"mdl-card__title-text\">'+ re.venueName +'</h2></div><div class=\"mdl-card__supporting-text\">'+ re.other +'</div><div class=\"mdl-card__actions mdl-card--border\"><a href=\"#!/venue/' + re.geoHash + '\" class=\"mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect\"></a></div><div class=\"mdl-card__menu\"></div></div>',\n                'marker-symbol': 'star'\n              },\n              'geometry': {\n                'type': 'Point',\n                'coordinates': [re.coordinate.lng, re.coordinate.lat]\n              }\n            });\n          });\n        });\n      },\n      onFlag () {\n        this.addFlag = !this.addFlag;\n        if(!this.addFlag){\n          clickFlag = false;\n        }\n      }\n    },\n    filters: {}\n  }\n</script>\n\n<style type='text/css'>\n  #map { position:fixed; top:0px; bottom:0px; width:100%;  }\n\n  #menu {\n      background: #fff;\n      position: absolute;\n      z-index: 10;\n      top: 10px;\n      right: 10px;\n      border-radius: 3px;\n      width: 120px;\n      border: 1px solid rgba(0,0,0,0.4);\n      font-family: 'Open Sans', sans-serif;\n  }\n\n  #menu a,#menu select{\n      font-size: 13px;\n      color: #404040;\n      display: block;\n      margin: 0;\n      padding: 0;\n      padding: 10px;\n      text-decoration: none;\n      border-bottom: 1px solid rgba(0,0,0,0.25);\n      text-align: center;\n  }\n\n  #menu a:last-child {\n      border: none;\n  }\n\n  #menu a:hover {\n      background-color: #f8f8f8;\n      color: #404040;\n  }\n\n  #menu a.active {\n      background-color: #3887be;\n      color: #ffffff;\n  }\n\n  #menu a.active:hover {\n      background: #3074a4;\n  }\n\n  .demo-card-wide.mdl-card {\n    width: 312px;\n  }\n  .demo-card-wide > .mdl-card__title {\n    color: #fff;\n    height: 156px;\n    background: url('../assets/welcome_card.jpg') center / cover;\n  }\n  .demo-card-wide > .mdl-card__menu {\n    color: #fff;\n  }\n</style>"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "810f0185586b37951e07c25376663834.jpg";

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(42);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _data = __webpack_require__(78);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _material = __webpack_require__(261);
	
	var _material2 = _interopRequireDefault(_material);
	
	var _gpsUtil = __webpack_require__(262);
	
	var _gpsUtil2 = _interopRequireDefault(_gpsUtil);
	
	var _auth = __webpack_require__(36);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// <template>
	//   <div>
	//     <nav id="menu">
	//       <a :class="{'active' : addFlag}" @click.prevent.stop="onFlag"></a>
	//     </nav>
	//     <div id="map"></div>
	//     <div id="snackbar" class="mdl-js-snackbar mdl-snackbar">
	//       <div class="mdl-snackbar__text"></div>
	//       <button class="mdl-snackbar__action" type="button"></button>
	//     </div>
	//   </div>
	// </template>
	//
	// <script>
	
	var clickFlag = false;
	
	exports.default = {
	  name: 'MapView',
	  data: function data() {
	    return {
	      Map: (0, _create2.default)(null),
	      Markers: {
	        type: 'FeatureCollection',
	        features: []
	      },
	      Source: {
	        setData: function setData() {}
	      },
	      geoHash: '',
	      addFlag: false
	    };
	  },
	
	  watch: {
	    'Markers.features': function MarkersFeatures() {
	      this.Source.setData(this.Markers);
	    }
	  },
	  route: {
	    data: function data(_ref) {
	      var to = _ref.to;
	
	      clickFlag = false;
	      this.getVenues();
	    }
	  },
	  created: function created() {},
	  ready: function ready() {
	    var _this = this;
	
	    // MDL
	    this.$nextTick(function () {
	      componentHandler.upgradeAllRegistered();
	    });
	
	    // Map Source
	    var source = void 0;
	    this.Map = new _data2.default.MapBox.Map({
	      container: 'map',
	      style: 'mapbox://styles/ccharlieli/cio8phh7x001sadnmu988hd91',
	      center: [121.4691603379, 31.2223104171],
	      zoom: 13
	    });
	
	    this.Map.on('load', function () {
	      _this.Source = new _data2.default.MapBox.GeoJSONSource({
	        data: _this.Markers,
	        cluster: true,
	        clusterMaxZoom: 14, // Max zoom to cluster points on
	        clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
	      });
	      _this.Map.addSource('markers', _this.Source);
	      _this.Map.addLayer({
	        'id': 'markers',
	        'type': 'symbol',
	        'source': 'markers',
	        'layout': {
	          'icon-image': '{marker-symbol}-15',
	          'icon-allow-overlap': true
	        }
	      });
	
	      var layers = [[150, '#f28cb1'], [20, '#f1f075'], [0, '#6ab344']];
	      layers.forEach(function (layer, i) {
	        _this.Map.addLayer({
	          "id": "cluster-" + i,
	          "type": "circle",
	          "source": "markers",
	          "paint": {
	            "circle-color": layer[1],
	            "circle-radius": 18
	          },
	          "filter": i == 0 ? [">=", "point_count", layer[0]] : ["all", [">=", "point_count", layer[0]], ["<", "point_count", layers[i - 1][0]]]
	        });
	      });
	      // Add a layer for the clusters' count labels
	      _this.Map.addLayer({
	        "id": "cluster-count",
	        "type": "symbol",
	        "source": "markers",
	        "layout": {
	          "text-field": "{point_count}",
	          "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
	          "text-size": 12
	        }
	      });
	    });
	
	    this.Map.on('click', function (e) {
	      if (_this.addFlag) {
	        if (clickFlag) {
	          _this.Markers.features.pop();
	        }
	        _this.geoHash = _gpsUtil2.default.geohashEncode(e.lngLat.lat, e.lngLat.lng, 7);
	        _this.Markers.features.push({
	          'type': 'Feature',
	          'properties': {
	            'description': '<div class="demo-card-wide mdl-card mdl-shadow--2dp"><div class="mdl-card__title"><h2 class="mdl-card__title-text">[]</h2></div><div class="mdl-card__supporting-text">[]</div><div class="mdl-card__actions mdl-card--border"><a href="#!/venue/' + _this.geoHash + '" class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"></a></div><div class="mdl-card__menu"></div></div>',
	            'marker-symbol': 'star'
	          },
	          'geometry': {
	            'type': 'Point',
	            'coordinates': [e.lngLat.lng, e.lngLat.lat]
	          }
	        });
	        clickFlag = true;
	      }
	    });
	
	    // Pop up
	    var popup = new _data2.default.MapBox.Popup({
	      closeButton: false,
	      closeOnClick: false
	    });
	    this.Map.on('mousemove', function (e) {
	      var features = _this.Map.queryRenderedFeatures(e.point, { layers: ['markers'] });
	      _this.Map.getCanvas().style.cursor = features.length ? 'pointer' : '';
	      if (!features.length) {
	        popup.remove();
	        return;
	      }
	      var feature = features[0];
	      popup.setLngLat(feature.geometry.coordinates).setHTML(feature.properties.description).addTo(_this.Map);
	    });
	  },
	  destroyed: function destroyed() {},
	
	  methods: {
	    onDetail: function onDetail() {
	      window.console.log(123);
	    },
	    popUp: function popUp(msg) {
	      var snackbarContainer = document.querySelector('#snackbar');
	      var data = { message: msg };
	      snackbarContainer.MaterialSnackbar.showSnackbar(data);
	    },
	    getVenues: function getVenues() {
	      var _this2 = this;
	
	      // Venue Source
	      this.Markers.features = [];
	      _auth2.default.findAllVenues(this).then(function (res) {
	        res.forEach(function (re) {
	          _this2.Markers.features.push({
	            'type': 'Feature',
	            'properties': {
	              'description': '<div class="demo-card-wide mdl-card mdl-shadow--2dp"><div class="mdl-card__title"><h2 class="mdl-card__title-text">' + re.venueName + '</h2></div><div class="mdl-card__supporting-text">' + re.other + '</div><div class="mdl-card__actions mdl-card--border"><a href="#!/venue/' + re.geoHash + '" class="mdl-button mdl-button--colored mdl-js-button mdl-js-ripple-effect"></a></div><div class="mdl-card__menu"></div></div>',
	              'marker-symbol': 'star'
	            },
	            'geometry': {
	              'type': 'Point',
	              'coordinates': [re.coordinate.lng, re.coordinate.lat]
	            }
	          });
	        });
	      });
	    },
	    onFlag: function onFlag() {
	      this.addFlag = !this.addFlag;
	      if (!this.addFlag) {
	        clickFlag = false;
	      }
	    }
	  },
	  filters: {}
	};
	// </script>
	//
	// <style type='text/css'>
	//   #map { position:fixed; top:0px; bottom:0px; width:100%;  }
	//
	//   #menu {
	//       background: #fff;
	//       position: absolute;
	//       z-index: 10;
	//       top: 10px;
	//       right: 10px;
	//       border-radius: 3px;
	//       width: 120px;
	//       border: 1px solid rgba(0,0,0,0.4);
	//       font-family: 'Open Sans', sans-serif;
	//   }
	//
	//   #menu a,#menu select{
	//       font-size: 13px;
	//       color: #404040;
	//       display: block;
	//       margin: 0;
	//       padding: 0;
	//       padding: 10px;
	//       text-decoration: none;
	//       border-bottom: 1px solid rgba(0,0,0,0.25);
	//       text-align: center;
	//   }
	//
	//   #menu a:last-child {
	//       border: none;
	//   }
	//
	//   #menu a:hover {
	//       background-color: #f8f8f8;
	//       color: #404040;
	//   }
	//
	//   #menu a.active {
	//       background-color: #3887be;
	//       color: #ffffff;
	//   }
	//
	//   #menu a.active:hover {
	//       background: #3074a4;
	//   }
	//
	//   .demo-card-wide.mdl-card {
	//     width: 312px;
	//   }
	//   .demo-card-wide > .mdl-card__title {
	//     color: #fff;
	//     height: 156px;
	//     background: url('../assets/welcome_card.jpg') center / cover;
	//   }
	//   .demo-card-wide > .mdl-card__menu {
	//     color: #fff;
	//   }
	// </style>
	/* generated by vue-loader */

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(43), __esModule: true };

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(44);
	var $Object = __webpack_require__(47).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(45)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(60)});

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(46)
	  , core      = __webpack_require__(47)
	  , ctx       = __webpack_require__(48)
	  , hide      = __webpack_require__(50)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 46 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 47 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(49);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(51)
	  , createDesc = __webpack_require__(59);
	module.exports = __webpack_require__(55) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(52)
	  , IE8_DOM_DEFINE = __webpack_require__(54)
	  , toPrimitive    = __webpack_require__(58)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(55) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(53);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(55) && !__webpack_require__(56)(function(){
	  return Object.defineProperty(__webpack_require__(57)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(56)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(53)
	  , document = __webpack_require__(46).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(53);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(52)
	  , dPs         = __webpack_require__(61)
	  , enumBugKeys = __webpack_require__(76)
	  , IE_PROTO    = __webpack_require__(73)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(57)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(77).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(51)
	  , anObject = __webpack_require__(52)
	  , getKeys  = __webpack_require__(62);
	
	module.exports = __webpack_require__(55) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(63)
	  , enumBugKeys = __webpack_require__(76);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(64)
	  , toIObject    = __webpack_require__(65)
	  , arrayIndexOf = __webpack_require__(69)(false)
	  , IE_PROTO     = __webpack_require__(73)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 64 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(66)
	  , defined = __webpack_require__(68);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(67);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 67 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 68 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(65)
	  , toLength  = __webpack_require__(70)
	  , toIndex   = __webpack_require__(72);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(71)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 71 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(71)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(74)('keys')
	  , uid    = __webpack_require__(75);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(46)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(46).document && document.documentElement;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(42);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _mapboxGl = __webpack_require__(79);
	
	var _mapboxGl2 = _interopRequireDefault(_mapboxGl);
	
	var _bluebird = __webpack_require__(259);
	
	var _bluebird2 = _interopRequireDefault(_bluebird);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DataAPI = (0, _create2.default)(null);
	//mapboxgl.accessToken = 'sk.eyJ1IjoiY2NoYXJsaWVsaSIsImEiOiJjaW4yeGZ1bTQwYnU0dmhtNGw3cmMydXV4In0.uNjLygXz-J3nCA714HTRig';
	_mapboxGl2.default.accessToken = 'pk.eyJ1IjoiY2NoYXJsaWVsaSIsImEiOiJjaW4wMmR0ZXkwNnM0dXBra2tlN2hncmN0In0.yyZJ5tdX4SfGZg8teA_3IA';
	
	DataAPI.MapBox = _mapboxGl2.default;
	DataAPI.Source = function (url) {
	  return new _mapboxGl2.default.GeoJSONSource({
	    data: url
	  });
	};
	
	exports.default = DataAPI;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * mapboxgl is a A WebGL JavaScript interactive maps library that can render
	 * [Mapbox vector tiles](https://www.mapbox.com/blog/vector-tiles/).
	 *
	 * @module mapboxgl
	 * @summary WebGL JavaScript map library
	 */
	
	// jshint -W079
	var mapboxgl = module.exports = {};
	
	mapboxgl.Map = __webpack_require__(80);
	mapboxgl.Control = __webpack_require__(255);
	mapboxgl.Navigation = __webpack_require__(256);
	mapboxgl.Geolocate = __webpack_require__(257);
	mapboxgl.Attribution = __webpack_require__(254);
	mapboxgl.Popup = __webpack_require__(258);
	
	mapboxgl.GeoJSONSource = __webpack_require__(213);
	mapboxgl.VideoSource = __webpack_require__(215);
	mapboxgl.ImageSource = __webpack_require__(217);
	
	mapboxgl.Style = __webpack_require__(89);
	
	mapboxgl.LngLat = __webpack_require__(216);
	mapboxgl.LngLatBounds = __webpack_require__(247);
	mapboxgl.Point = __webpack_require__(88);
	
	mapboxgl.Evented = __webpack_require__(86);
	mapboxgl.util = __webpack_require__(82);
	
	mapboxgl.supported = __webpack_require__(85).supported;
	
	var ajax = __webpack_require__(135);
	mapboxgl.util.getJSON = ajax.getJSON;
	mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;
	
	var config = __webpack_require__(137);
	mapboxgl.config = config;
	
	Object.defineProperty(mapboxgl, 'accessToken', {
	    get: function() { return config.ACCESS_TOKEN; },
	    set: function(token) { config.ACCESS_TOKEN = token; }
	});


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	var Canvas = __webpack_require__(81);
	var util = __webpack_require__(82);
	var browser = __webpack_require__(85);
	var Evented = __webpack_require__(86);
	var DOM = __webpack_require__(87);
	
	var Style = __webpack_require__(89);
	var AnimationLoop = __webpack_require__(205);
	var Painter = __webpack_require__(218);
	
	var Transform = __webpack_require__(242);
	var Hash = __webpack_require__(243);
	
	var Interaction = __webpack_require__(244);
	
	var Camera = __webpack_require__(253);
	var LngLat = __webpack_require__(216);
	var LngLatBounds = __webpack_require__(247);
	var Point = __webpack_require__(88);
	var Attribution = __webpack_require__(254);
	
	var defaultMinZoom = 0;
	var defaultMaxZoom = 20;
	/**
	 * Options common to Map#addClass, Map#removeClass, and Map#setClasses, controlling
	 * whether or not to smoothly transition property changes triggered by the class change.
	 *
	 * @typedef {Object} StyleOptions
	 * @property {boolean} transition
	 */
	
	/**
	 * Creates a map instance.
	 * @class Map
	 * @param {Object} options
	 * @param {string|Element} options.container HTML element to initialize the map in (or element id as string)
	 * @param {number} [options.minZoom=0] Minimum zoom of the map
	 * @param {number} [options.maxZoom=20] Maximum zoom of the map
	 * @param {Object|string} [options.style] Map style. This must be an an object conforming to the schema described in the [style reference](https://mapbox.com/mapbox-gl-style-spec/), or a URL to a JSON style. To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`, where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the predefined Mapbox styles:
	 *   * `mapbox://styles/mapbox/basic-v8` - Simple and flexible starting template.
	 *   * `mapbox://styles/mapbox/bright-v8` - Template for complex custom basemaps.
	 *   * `mapbox://styles/mapbox/streets-v8` - A ready-to-use basemap, perfect for minor customization or incorporating your own data.
	 *   * `mapbox://styles/mapbox/light-v8` - Subtle light backdrop for data vizualizations.
	 *   * `mapbox://styles/mapbox/dark-v8` - Subtle dark backdrop for data vizualizations.
	 * @param {boolean} [options.hash=false] If `true`, the map will track and update the page URL according to map position
	 * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input
	 * @param {number} [options.bearingSnap=7] Snap to north threshold in degrees.
	 * @param {Array} [options.classes] Style class names with which to initialize the map
	 * @param {boolean} [options.attributionControl=true] If `true`, an attribution control will be added to the map.
	 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
	 * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, The maps canvas can be exported to a PNG using `map.getCanvas().toDataURL();`. This is false by default as a performance optimization.
	 * @param {LngLatBounds|Array<Array<number>>} [options.maxBounds] If set, the map is constrained to the given bounds.
	 * @param {boolean} [options.scrollZoom=true] If `true`, enable the "scroll to zoom" interaction (see `ScrollZoomHandler`)
	 * @param {boolean} [options.boxZoom=true] If `true`, enable the "box zoom" interaction (see `BoxZoomHandler`)
	 * @param {boolean} [options.dragRotate=true] If `true`, enable the "drag to rotate" interaction (see `DragRotateHandler`).
	 * @param {boolean} [options.dragPan=true] If `true`, enable the "drag to pan" interaction (see `DragPanHandler`).
	 * @param {boolean} [options.keyboard=true] If `true`, enable keyboard shortcuts (see `KeyboardHandler`).
	 * @param {boolean} [options.doubleClickZoom=true] If `true`, enable the "double click to zoom" interaction (see `DoubleClickZoomHandler`).
	 * @param {boolean} [options.touchZoomRotate=true] If `true`, enable the "pinch to rotate and zoom" interaction (see `TouchZoomRotateHandler`).
	 * @example
	 * var map = new mapboxgl.Map({
	 *   container: 'map',
	 *   center: [-122.420679, 37.772537],
	 *   zoom: 13,
	 *   style: style_object,
	 *   hash: true
	 * });
	 */
	var Map = module.exports = function(options) {
	
	    options = util.inherit(this.options, options);
	    this._interactive = options.interactive;
	    this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;
	    this._preserveDrawingBuffer = options.preserveDrawingBuffer;
	
	    if (typeof options.container === 'string') {
	        this._container = document.getElementById(options.container);
	    } else {
	        this._container = options.container;
	    }
	
	    this.animationLoop = new AnimationLoop();
	    this.transform = new Transform(options.minZoom, options.maxZoom);
	
	    if (options.maxBounds) {
	        this.setMaxBounds(options.maxBounds);
	    }
	
	    util.bindAll([
	        '_forwardStyleEvent',
	        '_forwardSourceEvent',
	        '_forwardLayerEvent',
	        '_forwardTileEvent',
	        '_onStyleLoad',
	        '_onStyleChange',
	        '_onSourceAdd',
	        '_onSourceRemove',
	        '_onSourceUpdate',
	        '_onWindowResize',
	        'onError',
	        '_update',
	        '_render'
	    ], this);
	
	    this._setupContainer();
	    this._setupPainter();
	
	    this.on('move', this._update.bind(this, false));
	    this.on('zoom', this._update.bind(this, true));
	    this.on('moveend', function() {
	        this.animationLoop.set(300); // text fading
	        this._rerender();
	    }.bind(this));
	
	    if (typeof window !== 'undefined') {
	        window.addEventListener('resize', this._onWindowResize, false);
	    }
	
	    this.interaction = new Interaction(this);
	
	    if (options.interactive) {
	        this.interaction.enable();
	    }
	
	    this._hash = options.hash && (new Hash()).addTo(this);
	    // don't set position from options if set through hash
	    if (!this._hash || !this._hash._onHashChange()) {
	        this.jumpTo(options);
	    }
	
	    this.stacks = {};
	    this._classes = [];
	
	    this.resize();
	
	    if (options.classes) this.setClasses(options.classes);
	    if (options.style) this.setStyle(options.style);
	    if (options.attributionControl) this.addControl(new Attribution(options.attributionControl));
	
	    this.on('style.error', this.onError);
	    this.on('source.error', this.onError);
	    this.on('tile.error', this.onError);
	    this.on('layer.error', this.onError);
	};
	
	util.extend(Map.prototype, Evented);
	util.extend(Map.prototype, Camera.prototype);
	util.extend(Map.prototype, /** @lends Map.prototype */{
	
	    options: {
	        center: [0, 0],
	        zoom: 0,
	        bearing: 0,
	        pitch: 0,
	
	        minZoom: defaultMinZoom,
	        maxZoom: defaultMaxZoom,
	
	        interactive: true,
	
	        scrollZoom: true,
	        boxZoom: true,
	        dragRotate: true,
	        dragPan: true,
	        keyboard: true,
	        doubleClickZoom: true,
	        touchZoomRotate: true,
	
	        bearingSnap: 7,
	
	        hash: false,
	
	        attributionControl: true,
	
	        failIfMajorPerformanceCaveat: false,
	        preserveDrawingBuffer: false
	    },
	
	    /**
	     * Adds a control to the map, calling `control.addTo(this)`.
	     *
	     * @param {Control} control
	     * @returns {Map} `this`
	     */
	    addControl: function(control) {
	        control.addTo(this);
	        return this;
	    },
	
	    /**
	     * Adds a style class to a map
	     *
	     * @param {string} klass name of style class
	     * @param {StyleOptions} [options]
	     * @fires change
	     * @returns {Map} `this`
	     */
	    addClass: function(klass, options) {
	        if (this._classes.indexOf(klass) >= 0 || klass === '') return this;
	        this._classes.push(klass);
	        this._classOptions = options;
	
	        if (this.style) this.style.updateClasses();
	        return this._update(true);
	    },
	
	    /**
	     * Removes a style class from a map
	     *
	     * @param {string} klass name of style class
	     * @param {StyleOptions} [options]
	     * @fires change
	     * @returns {Map} `this`
	     */
	    removeClass: function(klass, options) {
	        var i = this._classes.indexOf(klass);
	        if (i < 0 || klass === '') return this;
	        this._classes.splice(i, 1);
	        this._classOptions = options;
	
	        if (this.style) this.style.updateClasses();
	        return this._update(true);
	    },
	
	    /**
	     * Helper method to add more than one class
	     *
	     * @param {Array<string>} klasses An array of class names
	     * @param {StyleOptions} [options]
	     * @fires change
	     * @returns {Map} `this`
	     */
	    setClasses: function(klasses, options) {
	        var uniqueClasses = {};
	        for (var i = 0; i < klasses.length; i++) {
	            if (klasses[i] !== '') uniqueClasses[klasses[i]] = true;
	        }
	        this._classes = Object.keys(uniqueClasses);
	        this._classOptions = options;
	
	        if (this.style) this.style.updateClasses();
	        return this._update(true);
	    },
	
	    /**
	     * Check whether a style class is active
	     *
	     * @param {string} klass Name of style class
	     * @returns {boolean}
	     */
	    hasClass: function(klass) {
	        return this._classes.indexOf(klass) >= 0;
	    },
	
	    /**
	     * Return an array of the current active style classes
	     *
	     * @returns {boolean}
	     */
	    getClasses: function() {
	        return this._classes;
	    },
	
	    /**
	     * Detect the map's new width and height and resize it.
	     *
	     * @returns {Map} `this`
	     */
	    resize: function() {
	        var width = 0, height = 0;
	
	        if (this._container) {
	            width = this._container.offsetWidth || 400;
	            height = this._container.offsetHeight || 300;
	        }
	
	        this._canvas.resize(width, height);
	        this.transform.resize(width, height);
	        this.painter.resize(width, height);
	
	        return this
	            .fire('movestart')
	            .fire('move')
	            .fire('resize')
	            .fire('moveend');
	    },
	
	    /**
	     * Get the map's geographical bounds.
	     *
	     * @returns {LngLatBounds}
	     */
	    getBounds: function() {
	        var bounds = new LngLatBounds(
	            this.transform.pointLocation(new Point(0, 0)),
	            this.transform.pointLocation(this.transform.size));
	
	        if (this.transform.angle || this.transform.pitch) {
	            bounds.extend(this.transform.pointLocation(new Point(this.transform.size.x, 0)));
	            bounds.extend(this.transform.pointLocation(new Point(0, this.transform.size.y)));
	        }
	
	        return bounds;
	    },
	
	    /**
	     * Set constraint on the map's geographical bounds. Pan or zoom operations that would result in
	     * displaying regions that fall outside of the bounds instead result in displaying the map at the
	     * closest point and/or zoom level of the requested operation that is within the max bounds.
	     *
	     * @param {LngLatBounds | Array<Array<number>> | null | undefined} lnglatbounds Desired max bounds of the map. If null or undefined, function removes any bounds constraints on the map.
	     * @returns {Map} `this`
	     */
	    setMaxBounds: function (lnglatbounds) {
	        if (lnglatbounds) {
	            var b = LngLatBounds.convert(lnglatbounds);
	            this.transform.lngRange = [b.getWest(), b.getEast()];
	            this.transform.latRange = [b.getSouth(), b.getNorth()];
	            this.transform._constrain();
	            this._update();
	        } else if (lnglatbounds === null || lnglatbounds === undefined) {
	            this.transform.lngRange = [];
	            this.transform.latRange = [];
	            this._update();
	        }
	        return this;
	
	    },
	    /**
	     * Set the map's minimum zoom level, and zooms map to that level if it is currently below it. If no parameter provided, unsets the current minimum zoom (sets it to 0)
	     * @param {number} minZoom Minimum zoom level. Must be between 0 and 20.
	     * @returns {Map} `this
	     */
	    setMinZoom: function(minZoom) {
	
	        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;
	
	        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
	            this.transform.minZoom = minZoom;
	            this._update();
	
	            if (this.getZoom() < minZoom) this.setZoom(minZoom);
	
	            return this;
	
	        } else throw new Error('minZoom must be between ' + defaultMinZoom + ' and the current maxZoom, inclusive');
	    },
	
	    /**
	     * Set the map's maximum zoom level, and zooms map to that level if it is currently above it. If no parameter provided, unsets the current maximum zoom (sets it to 20)
	     * @param {number} maxZoom Maximum zoom level. Must be between 0 and 20.
	     * @returns {Map} `this`
	     */
	    setMaxZoom: function(maxZoom) {
	
	        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;
	
	        if (maxZoom >= this.transform.minZoom && maxZoom <= defaultMaxZoom) {
	            this.transform.maxZoom = maxZoom;
	            this._update();
	
	            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);
	
	            return this;
	
	        } else throw new Error('maxZoom must be between the current minZoom and ' + defaultMaxZoom + ', inclusive');
	    },
	    /**
	     * Get pixel coordinates (relative to map container) given a geographical location
	     *
	     * @param {LngLat} lnglat
	     * @returns {Object} `x` and `y` coordinates
	     */
	    project: function(lnglat) {
	        return this.transform.locationPoint(LngLat.convert(lnglat));
	    },
	
	    /**
	     * Get geographical coordinates given pixel coordinates
	     *
	     * @param {Array<number>} point [x, y] pixel coordinates
	     * @returns {LngLat}
	     */
	    unproject: function(point) {
	        return this.transform.pointLocation(Point.convert(point));
	    },
	
	    /**
	     * Query rendered features within a point or rectangle.
	     *
	     * @param {Point|Array<number>|Array<Point>|Array<Array<number>>} [pointOrBox] Either [x, y] pixel coordinates of a point, or [[x1, y1], [x2, y2]] pixel coordinates of opposite corners of bounding rectangle. Optional: use entire viewport if omitted.
	     * @param {Object} params
	     * @param {Array<string>} [params.layers] Only query features from layers with these layer IDs.
	     * @param {Array} [params.filter] A mapbox-gl-style-spec filter.
	     *
	     * @returns {Array<Object>} features - An array of [GeoJSON](http://geojson.org/) features matching the query parameters. The GeoJSON properties of each feature are taken from the original source. Each feature object also contains a top-level `layer` property whose value is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
	     *
	     * @example
	     * var features = map.queryRenderedFeatures([20, 35], { layers: ['my-layer-name'] });
	     *
	     * @example
	     * var features = map.queryRenderedFeatures([[10, 20], [30, 50]], { layers: ['my-layer-name'] });
	     */
	    queryRenderedFeatures: function(pointOrBox, params) {
	        if (!(pointOrBox instanceof Point || Array.isArray(pointOrBox))) {
	            params = pointOrBox;
	            pointOrBox = undefined;
	        }
	        var queryGeometry = this._makeQueryGeometry(pointOrBox);
	        return this.style.queryRenderedFeatures(queryGeometry, params, this.transform.zoom, this.transform.angle);
	    },
	
	    _makeQueryGeometry: function(pointOrBox) {
	        if (pointOrBox === undefined) {
	            // bounds was omitted: use full viewport
	            pointOrBox = [
	                Point.convert([0, 0]),
	                Point.convert([this.transform.width, this.transform.height])
	            ];
	        }
	
	        var queryGeometry;
	        var isPoint = pointOrBox instanceof Point || typeof pointOrBox[0] === 'number';
	
	        if (isPoint) {
	            var point = Point.convert(pointOrBox);
	            queryGeometry = [point];
	        } else {
	            var box = [Point.convert(pointOrBox[0]), Point.convert(pointOrBox[1])];
	            queryGeometry = [
	                box[0],
	                new Point(box[1].x, box[0].y),
	                box[1],
	                new Point(box[0].x, box[1].y),
	                box[0]
	            ];
	        }
	
	        queryGeometry = queryGeometry.map(function(p) {
	            return this.transform.pointCoordinate(p);
	        }.bind(this));
	
	        return queryGeometry;
	    },
	
	    /**
	     * Get data from vector tiles as an array of GeoJSON Features.
	     *
	     * @param {string} sourceID source ID
	     * @param {Object} params
	     * @param {string} [params.sourceLayer] The name of the vector tile layer to get features from.
	     * @param {Array} [params.filter] A mapbox-gl-style-spec filter.
	     *
	     * @returns {Array<Object>} features - An array of [GeoJSON](http://geojson.org/) features matching the query parameters. The GeoJSON properties of each feature are taken from the original source. Each feature object also contains a top-level `layer` property whose value is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
	     */
	    querySourceFeatures: function(sourceID, params) {
	        return this.style.querySourceFeatures(sourceID, params);
	    },
	
	    /**
	     * Replaces the map's style object
	     *
	     * @param {Object} style A style object formatted as JSON
	     * @returns {Map} `this`
	     */
	    setStyle: function(style) {
	        if (this.style) {
	            this.style
	                .off('load', this._onStyleLoad)
	                .off('error', this._forwardStyleEvent)
	                .off('change', this._onStyleChange)
	                .off('source.add', this._onSourceAdd)
	                .off('source.remove', this._onSourceRemove)
	                .off('source.load', this._onSourceUpdate)
	                .off('source.error', this._forwardSourceEvent)
	                .off('source.change', this._onSourceUpdate)
	                .off('layer.add', this._forwardLayerEvent)
	                .off('layer.remove', this._forwardLayerEvent)
	                .off('layer.error', this._forwardLayerEvent)
	                .off('tile.add', this._forwardTileEvent)
	                .off('tile.remove', this._forwardTileEvent)
	                .off('tile.load', this._update)
	                .off('tile.error', this._forwardTileEvent)
	                .off('tile.stats', this._forwardTileEvent)
	                ._remove();
	
	            this.off('rotate', this.style._redoPlacement);
	            this.off('pitch', this.style._redoPlacement);
	        }
	
	        if (!style) {
	            this.style = null;
	            return this;
	        } else if (style instanceof Style) {
	            this.style = style;
	        } else {
	            this.style = new Style(style, this.animationLoop);
	        }
	
	        this.style
	            .on('load', this._onStyleLoad)
	            .on('error', this._forwardStyleEvent)
	            .on('change', this._onStyleChange)
	            .on('source.add', this._onSourceAdd)
	            .on('source.remove', this._onSourceRemove)
	            .on('source.load', this._onSourceUpdate)
	            .on('source.error', this._forwardSourceEvent)
	            .on('source.change', this._onSourceUpdate)
	            .on('layer.add', this._forwardLayerEvent)
	            .on('layer.remove', this._forwardLayerEvent)
	            .on('layer.error', this._forwardLayerEvent)
	            .on('tile.add', this._forwardTileEvent)
	            .on('tile.remove', this._forwardTileEvent)
	            .on('tile.load', this._update)
	            .on('tile.error', this._forwardTileEvent)
	            .on('tile.stats', this._forwardTileEvent);
	
	        this.on('rotate', this.style._redoPlacement);
	        this.on('pitch', this.style._redoPlacement);
	
	        return this;
	    },
	
	    /**
	     * Get a style object that can be used to recreate the map's style
	     *
	     * @returns {Object} style
	     */
	    getStyle: function() {
	        return this.style.serialize();
	    },
	
	    /**
	     * Add a source to the map style.
	     *
	     * @param {string} id ID of the source. Must not be used by any existing source.
	     * @param {Object} source source specification, following the
	     * [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/#sources)
	     * @fires source.add
	     * @returns {Map} `this`
	     */
	    addSource: function(id, source) {
	        this.style.addSource(id, source);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Remove an existing source from the map style.
	     *
	     * @param {string} id ID of the source to remove
	     * @fires source.remove
	     * @returns {Map} `this`
	     */
	    removeSource: function(id) {
	        this.style.removeSource(id);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Return the style source object with the given `id`.
	     *
	     * @param {string} id source ID
	     * @returns {Object}
	     */
	    getSource: function(id) {
	        return this.style.getSource(id);
	    },
	
	    /**
	     * Add a layer to the map style. The layer will be inserted before the layer with
	     * ID `before`, or appended if `before` is omitted.
	     * @param {StyleLayer|Object} layer
	     * @param {string=} before  ID of an existing layer to insert before
	     * @fires layer.add
	     * @returns {Map} `this`
	     */
	    addLayer: function(layer, before) {
	        this.style.addLayer(layer, before);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Remove the layer with the given `id` from the map. Any layers which refer to the
	     * specified layer via a `ref` property are also removed.
	     *
	     * @param {string} id layer id
	     * @throws {Error} if no layer with the given `id` exists
	     * @fires layer.remove
	     * @returns {Map} `this`
	     */
	    removeLayer: function(id) {
	        this.style.removeLayer(id);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Return the style layer object with the given `id`.
	     *
	     * @param {string} id layer id
	     * @returns {?Object} a layer, if one with the given `id` exists
	     */
	    getLayer: function(id) {
	        return this.style.getLayer(id);
	    },
	
	    /**
	     * Set the filter for a given style layer.
	     *
	     * @param {string} layer ID of a layer
	     * @param {Array} filter filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#types-filter)
	     * @returns {Map} `this`
	     */
	    setFilter: function(layer, filter) {
	        this.style.setFilter(layer, filter);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Set the zoom extent for a given style layer.
	     *
	     * @param {string} layerId ID of a layer
	     * @param {number} minzoom minimum zoom extent
	     * @param {number} maxzoom maximum zoom extent
	     * @returns {Map} `this`
	     */
	    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
	        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Get the filter for a given style layer.
	     *
	     * @param {string} layer ID of a layer
	     * @returns {Array} filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
	     */
	    getFilter: function(layer) {
	        return this.style.getFilter(layer);
	    },
	
	    /**
	     * Set the value of a paint property in a given style layer.
	     *
	     * @param {string} layer ID of a layer
	     * @param {string} name name of a paint property
	     * @param {*} value value for the paint propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
	     * @param {string=} klass optional class specifier for the property
	     * @returns {Map} `this`
	     */
	    setPaintProperty: function(layer, name, value, klass) {
	        this.style.setPaintProperty(layer, name, value, klass);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Get the value of a paint property in a given style layer.
	     *
	     * @param {string} layer ID of a layer
	     * @param {string} name name of a paint property
	     * @param {string=} klass optional class specifier for the property
	     * @returns {*} value for the paint propery
	     */
	    getPaintProperty: function(layer, name, klass) {
	        return this.style.getPaintProperty(layer, name, klass);
	    },
	
	    /**
	     * Set the value of a layout property in a given style layer.
	     *
	     * @param {string} layer ID of a layer
	     * @param {string} name name of a layout property
	     * @param {*} value value for the layout propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
	     * @returns {Map} `this`
	     */
	    setLayoutProperty: function(layer, name, value) {
	        this.style.setLayoutProperty(layer, name, value);
	        this._update(true);
	        return this;
	    },
	
	    /**
	     * Get the value of a layout property in a given style layer.
	     *
	     * @param {string} layer ID of a layer
	     * @param {string} name name of a layout property
	     * @param {string=} klass optional class specifier for the property
	     * @returns {*} value for the layout propery
	     */
	    getLayoutProperty: function(layer, name) {
	        return this.style.getLayoutProperty(layer, name);
	    },
	
	    /**
	     * Get the Map's container as an HTML element
	     * @returns {HTMLElement} container
	     */
	    getContainer: function() {
	        return this._container;
	    },
	
	    /**
	     * Get the container for the map `canvas` element.
	     *
	     * If you want to add non-GL overlays to the map, you should append them to this element. This
	     * is the element to which event bindings for map interactivity such as panning and zooming are
	     * attached. It will receive bubbled events for child elements such as the `canvas`, but not for
	     * map controls.
	     *
	     * @returns {HTMLElement} container
	     */
	    getCanvasContainer: function() {
	        return this._canvasContainer;
	    },
	
	    /**
	     * Get the Map's canvas as an HTML canvas
	     * @returns {HTMLElement} canvas
	     */
	    getCanvas: function() {
	        return this._canvas.getElement();
	    },
	
	    _setupContainer: function() {
	        var container = this._container;
	        container.classList.add('mapboxgl-map');
	
	        var canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
	        if (this._interactive) {
	            canvasContainer.classList.add('mapboxgl-interactive');
	        }
	        this._canvas = new Canvas(this, canvasContainer);
	
	        var controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
	        var corners = this._controlCorners = {};
	        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(function (pos) {
	            corners[pos] = DOM.create('div', 'mapboxgl-ctrl-' + pos, controlContainer);
	        });
	    },
	
	    _setupPainter: function() {
	        var gl = this._canvas.getWebGLContext({
	            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
	            preserveDrawingBuffer: this._preserveDrawingBuffer
	        });
	
	        if (!gl) {
	            console.error('Failed to initialize WebGL');
	            return;
	        }
	
	        this.painter = new Painter(gl, this.transform);
	    },
	
	    /**
	     * WebGL Context Lost event.
	     *
	     * @event webglcontextlost
	     * @memberof Map
	     * @instance
	     * @type {Object}
	     * @property {Event} originalEvent the original DOM event
	     */
	    _contextLost: function(event) {
	        event.preventDefault();
	        if (this._frameId) {
	            browser.cancelFrame(this._frameId);
	        }
	        this.fire("webglcontextlost", {originalEvent: event});
	    },
	
	    /**
	     * WebGL Context Restored event.
	     *
	     * @event webglcontextrestored
	     * @memberof Map
	     * @instance
	     * @type {Object}
	     */
	    _contextRestored: function(event) {
	        this._setupPainter();
	        this.resize();
	        this._update();
	        this.fire("webglcontextrestored", {originalEvent: event});
	    },
	
	    /**
	     * Is this map fully loaded? If the style isn't loaded
	     * or it has a change to the sources or style that isn't
	     * propagated to its style, return false.
	     *
	     * @returns {boolean} whether the map is loaded
	     */
	    loaded: function() {
	        if (this._styleDirty || this._sourcesDirty)
	            return false;
	        if (!this.style || !this.style.loaded())
	            return false;
	        return true;
	    },
	
	    /**
	     * Update this map's style and sources, and re-render the map.
	     *
	     * @param {boolean} updateStyle mark the map's style for reprocessing as
	     * well as its sources
	     * @returns {Map} this
	     * @private
	     */
	    _update: function(updateStyle) {
	        if (!this.style) return this;
	
	        this._styleDirty = this._styleDirty || updateStyle;
	        this._sourcesDirty = true;
	
	        this._rerender();
	
	        return this;
	    },
	
	    /**
	     * Call when a (re-)render of the map is required, e.g. when the
	     * user panned or zoomed,f or new data is available.
	     * @returns {Map} this
	     * @private
	     */
	    _render: function() {
	        if (this.style && this._styleDirty) {
	            this._styleDirty = false;
	            this.style.update(this._classes, this._classOptions);
	            this._classOptions = null;
	            this.style._recalculate(this.transform.zoom);
	        }
	
	        if (this.style && this._sourcesDirty) {
	            this._sourcesDirty = false;
	            this.style._updateSources(this.transform);
	        }
	
	        this.painter.render(this.style, {
	            debug: this.showTileBoundaries,
	            vertices: this.vertices,
	            rotating: this.rotating,
	            zooming: this.zooming
	        });
	
	        this.fire('render');
	
	        if (this.loaded() && !this._loaded) {
	            this._loaded = true;
	            this.fire('load');
	        }
	
	        this._frameId = null;
	
	        if (!this.animationLoop.stopped()) {
	            this._styleDirty = true;
	        }
	
	        if (this._sourcesDirty || this._repaint || !this.animationLoop.stopped()) {
	            this._rerender();
	        }
	
	        return this;
	    },
	
	    /**
	     * Destroys the map's underlying resources, including web workers and DOM elements. Afterwards,
	     * you must not call any further methods on this Map instance.
	     *
	     * @returns {undefined}
	     */
	    remove: function() {
	        if (this._hash) this._hash.remove();
	        browser.cancelFrame(this._frameId);
	        this.setStyle(null);
	        if (typeof window !== 'undefined') {
	            window.removeEventListener('resize', this._onWindowResize, false);
	        }
	        removeNode(this._canvasContainer);
	        removeNode(this._controlContainer);
	        this._container.classList.remove('mapboxgl-map');
	    },
	
	    /**
	     * A default error handler for `style.error`, `source.error`, `layer.error`,
	     * and `tile.error` events.
	     * It logs the error via `console.error`.
	     *
	     * @example
	     * // Disable the default error handler
	     * map.off('style.error', map.onError);
	     * map.off('source.error', map.onError);
	     * map.off('tile.error', map.onError);
	     * map.off('layer.error', map.onError);
	     */
	    onError: function(e) {
	        console.error(e.error);
	    },
	
	    _rerender: function() {
	        if (this.style && !this._frameId) {
	            this._frameId = browser.frame(this._render);
	        }
	    },
	
	    _forwardStyleEvent: function(e) {
	        this.fire('style.' + e.type, util.extend({style: e.target}, e));
	    },
	
	    _forwardSourceEvent: function(e) {
	        this.fire(e.type, util.extend({style: e.target}, e));
	    },
	
	    _forwardLayerEvent: function(e) {
	        this.fire(e.type, util.extend({style: e.target}, e));
	    },
	
	    _forwardTileEvent: function(e) {
	        this.fire(e.type, util.extend({style: e.target}, e));
	    },
	
	    _onStyleLoad: function(e) {
	        if (this.transform.unmodified) {
	            this.jumpTo(this.style.stylesheet);
	        }
	        this.style.update(this._classes, {transition: false});
	        this._forwardStyleEvent(e);
	    },
	
	    _onStyleChange: function(e) {
	        this._update(true);
	        this._forwardStyleEvent(e);
	    },
	
	    _onSourceAdd: function(e) {
	        var source = e.source;
	        if (source.onAdd)
	            source.onAdd(this);
	        this._forwardSourceEvent(e);
	    },
	
	    _onSourceRemove: function(e) {
	        var source = e.source;
	        if (source.onRemove)
	            source.onRemove(this);
	        this._forwardSourceEvent(e);
	    },
	
	    _onSourceUpdate: function(e) {
	        this._update();
	        this._forwardSourceEvent(e);
	    },
	
	    _onWindowResize: function() {
	        this.stop().resize()._update();
	    }
	});
	
	util.extendAll(Map.prototype, /** @lends Map.prototype */{
	
	    /**
	     * Draw an outline around each rendered tile for debugging.
	     *
	     * @name showTileBoundaries
	     * @type {boolean}
	     */
	    _showTileBoundaries: false,
	    get showTileBoundaries() { return this._showTileBoundaries; },
	    set showTileBoundaries(value) {
	        if (this._showTileBoundaries === value) return;
	        this._showTileBoundaries = value;
	        this._update();
	    },
	
	    /**
	     * Draw boxes around all symbols in the data source, showing which were
	     * rendered and which were hidden due to collisions with other symbols for
	     * style debugging.
	     *
	     * @name showCollisionBoxes
	     * @type {boolean}
	     */
	    _showCollisionBoxes: false,
	    get showCollisionBoxes() { return this._showCollisionBoxes; },
	    set showCollisionBoxes(value) {
	        if (this._showCollisionBoxes === value) return;
	        this._showCollisionBoxes = value;
	        this.style._redoPlacement();
	    },
	
	    /**
	     * Enable continuous repaint to analyze performance
	     *
	     * @name repaint
	     * @type {boolean}
	     */
	    _repaint: false,
	    get repaint() { return this._repaint; },
	    set repaint(value) { this._repaint = value; this._update(); },
	
	    // show vertices
	    _vertices: false,
	    get vertices() { return this._vertices; },
	    set vertices(value) { this._vertices = value; this._update(); }
	});
	
	function removeNode(node) {
	    if (node.parentNode) {
	        node.parentNode.removeChild(node);
	    }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	
	module.exports = Canvas;
	
	function Canvas(parent, container) {
	    this.canvas = document.createElement('canvas');
	
	    if (parent && container) {
	        this.canvas.style.position = 'absolute';
	        this.canvas.classList.add('mapboxgl-canvas');
	        this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
	        this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
	        this.canvas.setAttribute('tabindex', 0);
	        container.appendChild(this.canvas);
	    }
	}
	
	Canvas.prototype.resize = function(width, height) {
	    var pixelRatio = window.devicePixelRatio || 1;
	
	    // Request the required canvas size taking the pixelratio into account.
	    this.canvas.width = pixelRatio * width;
	    this.canvas.height = pixelRatio * height;
	
	    // Maintain the same canvas size, potentially downscaling it for HiDPI displays
	    this.canvas.style.width = width + 'px';
	    this.canvas.style.height = height + 'px';
	};
	
	var requiredContextAttributes = {
	    antialias: false,
	    alpha: true,
	    stencil: true,
	    depth: true
	};
	
	Canvas.prototype.getWebGLContext = function(attributes) {
	    attributes = util.extend({}, attributes, requiredContextAttributes);
	
	    return this.canvas.getContext('webgl', attributes) ||
	        this.canvas.getContext('experimental-webgl', attributes);
	};
	
	Canvas.prototype.supportsWebGLContext = function(failIfMajorPerformanceCaveat) {
	    var attributes = util.extend({
	        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
	    }, requiredContextAttributes);
	
	    if ('probablySupportsContext' in this.canvas) {
	        return this.canvas.probablySupportsContext('webgl', attributes) ||
	            this.canvas.probablySupportsContext('experimental-webgl', attributes);
	    } else if ('supportsContext' in this.canvas) {
	        return this.canvas.supportsContext('webgl', attributes) ||
	            this.canvas.supportsContext('experimental-webgl', attributes);
	    }
	
	    return !!window.WebGLRenderingContext && !!this.getWebGLContext(failIfMajorPerformanceCaveat);
	};
	
	Canvas.prototype.getElement = function() {
	    return this.canvas;
	};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var UnitBezier = __webpack_require__(83);
	var Coordinate = __webpack_require__(84);
	
	/**
	 * Given a value `t` that varies between 0 and 1, return
	 * an interpolation function that eases between 0 and 1 in a pleasing
	 * cubic in-out fashion.
	 *
	 * @param {number} t input
	 * @returns {number} input
	 * @private
	 */
	exports.easeCubicInOut = function (t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t,
	        t3 = t2 * t;
	    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
	};
	
	/**
	 * Given given (x, y), (x1, y1) control points for a bezier curve,
	 * return a function that interpolates along that curve.
	 *
	 * @param {number} p1x control point 1 x coordinate
	 * @param {number} p1y control point 1 y coordinate
	 * @param {number} p2x control point 2 x coordinate
	 * @param {number} p2y control point 2 y coordinate
	 * @returns {Function} interpolator: receives number value, returns
	 * number value.
	 * @private
	 */
	exports.bezier = function(p1x, p1y, p2x, p2y) {
	    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
	    return function(t) {
	        return bezier.solve(t);
	    };
	};
	
	/**
	 * A default bezier-curve powered easing function with
	 * control points (0.25, 0.1) and (0.25, 1)
	 *
	 * @param {number} t
	 * @returns {number} output
	 * @private
	 */
	exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);
	
	/**
	 * Given a four-element array of numbers that represents a color in
	 * RGBA, return a version for which the RGB components are multiplied
	 * by the A (alpha) component
	 *
	 * @param {Array<number>} color color array
	 * @returns {Array<number>} premultiplied color array
	 * @private
	 */
	exports.premultiply = function (color) {
	    if (!color) return null;
	    var opacity = color[3];
	    return [
	        color[0] * opacity,
	        color[1] * opacity,
	        color[2] * opacity,
	        opacity
	    ];
	};
	
	/**
	 * constrain n to the given range via min + max
	 *
	 * @param {number} n value
	 * @param {number} min the minimum value to be returned
	 * @param {number} max the maximum value to be returned
	 * @returns {number} the clamped value
	 * @private
	 */
	exports.clamp = function (n, min, max) {
	    return Math.min(max, Math.max(min, n));
	};
	
	/*
	 * constrain n to the given range, excluding the minimum, via modular arithmetic
	 * @param {number} n value
	 * @param {number} min the minimum value to be returned, exclusive
	 * @param {number} max the maximum value to be returned, inclusive
	 * @returns {number} constrained number
	 * @private
	 */
	exports.wrap = function (n, min, max) {
	    var d = max - min;
	    var w = ((n - min) % d + d) % d + min;
	    return (w === min) ? max : w;
	};
	
	/*
	 * return the first non-null and non-undefined argument to this function.
	 * @returns {*} argument
	 * @private
	 */
	exports.coalesce = function() {
	    for (var i = 0; i < arguments.length; i++) {
	        var arg = arguments[i];
	        if (arg !== null && arg !== undefined)
	            return arg;
	    }
	};
	
	/*
	 * Call an asynchronous function on an array of arguments,
	 * calling `callback` with the completed results of all calls.
	 *
	 * @param {Array<*>} array input to each call of the async function.
	 * @param {Function} fn an async function with signature (data, callback)
	 * @param {Function} callback a callback run after all async work is done.
	 * called with an array, containing the results of each async call.
	 * @returns {undefined}
	 * @private
	 */
	exports.asyncAll = function (array, fn, callback) {
	    if (!array.length) { return callback(null, []); }
	    var remaining = array.length;
	    var results = new Array(array.length);
	    var error = null;
	    array.forEach(function (item, i) {
	        fn(item, function (err, result) {
	            if (err) error = err;
	            results[i] = result;
	            if (--remaining === 0) callback(error, results);
	        });
	    });
	};
	
	/*
	 * Compute the difference between the keys in one object and the keys
	 * in another object.
	 *
	 * @param {Object} obj
	 * @param {Object} other
	 * @returns {Array<string>} keys difference
	 * @private
	 */
	exports.keysDifference = function (obj, other) {
	    var difference = [];
	    for (var i in obj) {
	        if (!(i in other)) {
	            difference.push(i);
	        }
	    }
	    return difference;
	};
	
	/**
	 * Given a destination object and optionally many source objects,
	 * copy all properties from the source objects into the destination.
	 * The last source object given overrides properties from previous
	 * source objects.
	 * @param {Object} dest destination object
	 * @param {...Object} sources sources from which properties are pulled
	 * @returns {Object} dest
	 * @private
	 */
	exports.extend = function (dest) {
	    for (var i = 1; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var k in src) {
	            dest[k] = src[k];
	        }
	    }
	    return dest;
	};
	
	/**
	 * Extend a destination object with all properties of the src object,
	 * using defineProperty instead of simple assignment.
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 * @private
	 */
	exports.extendAll = function (dest, src) {
	    for (var i in src) {
	        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
	    }
	    return dest;
	};
	
	/**
	 * Extend a parent's prototype with all properties in a properties
	 * object.
	 *
	 * @param {Object} parent
	 * @param {Object} props
	 * @returns {Object}
	 * @private
	 */
	exports.inherit = function (parent, props) {
	    var parentProto = typeof parent === 'function' ? parent.prototype : parent,
	        proto = Object.create(parentProto);
	    exports.extendAll(proto, props);
	    return proto;
	};
	
	/**
	 * Given an object and a number of properties as strings, return version
	 * of that object with only those properties.
	 *
	 * @param {Object} src the object
	 * @param {Array<string>} properties an array of property names chosen
	 * to appear on the resulting object.
	 * @returns {Object} object with limited properties.
	 * @example
	 * var foo = { name: 'Charlie', age: 10 };
	 * var justName = pick(foo, ['name']);
	 * // justName = { name: 'Charlie' }
	 * @private
	 */
	exports.pick = function (src, properties) {
	    var result = {};
	    for (var i = 0; i < properties.length; i++) {
	        var k = properties[i];
	        if (k in src) {
	            result[k] = src[k];
	        }
	    }
	    return result;
	};
	
	var id = 1;
	
	/**
	 * Return a unique numeric id, starting at 1 and incrementing with
	 * each call.
	 *
	 * @returns {number} unique numeric id.
	 * @private
	 */
	exports.uniqueId = function () {
	    return id++;
	};
	
	/**
	 * Create a version of `fn` that is only called `time` milliseconds
	 * after its last invocation
	 *
	 * @param {Function} fn the function to be debounced
	 * @param {number} time millseconds after which the function will be invoked
	 * @returns {Function} debounced function
	 * @private
	 */
	exports.debounce = function(fn, time) {
	    var timer, args;
	
	    return function() {
	        args = arguments;
	        clearTimeout(timer);
	
	        timer = setTimeout(function() {
	            fn.apply(null, args);
	        }, time);
	    };
	};
	
	/**
	 * Given an array of member function names as strings, replace all of them
	 * with bound versions that will always refer to `context` as `this`. This
	 * is useful for classes where otherwise event bindings would reassign
	 * `this` to the evented object or some other value: this lets you ensure
	 * the `this` value always.
	 *
	 * @param {Array<string>} fns list of member function names
	 * @param {*} context the context value
	 * @returns {undefined} changes functions in-place
	 * @example
	 * function MyClass() {
	 *   bindAll(['ontimer'], this);
	 *   this.name = 'Tom';
	 * }
	 * MyClass.prototype.ontimer = function() {
	 *   alert(this.name);
	 * };
	 * var myClass = new MyClass();
	 * setTimeout(myClass.ontimer, 100);
	 * @private
	 */
	exports.bindAll = function(fns, context) {
	    fns.forEach(function(fn) {
	        context[fn] = context[fn].bind(context);
	    });
	};
	
	/**
	 * Given a class, bind all of the methods that look like handlers: that
	 * begin with _on, and bind them to the class.
	 *
	 * @param {Object} context an object with methods
	 * @private
	 */
	exports.bindHandlers = function(context) {
	    for (var i in context) {
	        if (typeof context[i] === 'function' && i.indexOf('_on') === 0) {
	            context[i] = context[i].bind(context);
	        }
	    }
	};
	
	/**
	 * Set the 'options' property on `obj` with properties
	 * from the `options` argument. Properties in the `options`
	 * object will override existing properties.
	 *
	 * @param {Object} obj destination object
	 * @param {Object} options object of override options
	 * @returns {Object} derived options object.
	 * @private
	 */
	exports.setOptions = function(obj, options) {
	    if (!obj.hasOwnProperty('options')) {
	        obj.options = obj.options ? Object.create(obj.options) : {};
	    }
	    for (var i in options) {
	        obj.options[i] = options[i];
	    }
	    return obj.options;
	};
	
	/**
	 * Given a list of coordinates, get their center as a coordinate.
	 * @param {Array<Coordinate>} coords
	 * @returns {Coordinate} centerpoint
	 * @private
	 */
	exports.getCoordinatesCenter = function(coords) {
	    var minX = Infinity;
	    var minY = Infinity;
	    var maxX = -Infinity;
	    var maxY = -Infinity;
	
	    for (var i = 0; i < coords.length; i++) {
	        minX = Math.min(minX, coords[i].column);
	        minY = Math.min(minY, coords[i].row);
	        maxX = Math.max(maxX, coords[i].column);
	        maxY = Math.max(maxY, coords[i].row);
	    }
	
	    var dx = maxX - minX;
	    var dy = maxY - minY;
	    var dMax = Math.max(dx, dy);
	    return new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0)
	        .zoomTo(Math.floor(-Math.log(dMax) / Math.LN2));
	};
	
	/**
	 * Determine if a string ends with a particular substring
	 * @param {string} string
	 * @param {string} suffix
	 * @returns {boolean}
	 * @private
	 */
	exports.endsWith = function(string, suffix) {
	    return string.indexOf(suffix, string.length - suffix.length) !== -1;
	};
	
	/**
	 * Determine if a string starts with a particular substring
	 * @param {string} string
	 * @param {string} prefix
	 * @returns {boolean}
	 * @private
	 */
	exports.startsWith = function(string, prefix) {
	    return string.indexOf(prefix) === 0;
	};
	
	/**
	 * Create an object by mapping all the values of an existing object while
	 * preserving their keys.
	 * @param {Object} input
	 * @param {Function} iterator
	 * @returns {Object}
	 * @private
	 */
	exports.mapObject = function(input, iterator, context) {
	    var output = {};
	    for (var key in input) {
	        output[key] = iterator.call(context || this, input[key], key, input);
	    }
	    return output;
	};
	
	/**
	 * Create an object by filtering out values of an existing object
	 * @param {Object} input
	 * @param {Function} iterator
	 * @returns {Object}
	 * @private
	 */
	exports.filterObject = function(input, iterator, context) {
	    var output = {};
	    for (var key in input) {
	        if (iterator.call(context || this, input[key], key, input)) {
	            output[key] = input[key];
	        }
	    }
	    return output;
	};
	
	/**
	 * Deeply compares two object literals.
	 * @param {Object} obj1
	 * @param {Object} obj2
	 * @returns {boolean}
	 * @private
	 */
	exports.deepEqual = function deepEqual(a, b) {
	    if (Array.isArray(a)) {
	        if (!Array.isArray(b) || a.length !== b.length) return false;
	        for (var i = 0; i < a.length; i++) {
	            if (!deepEqual(a[i], b[i])) return false;
	        }
	        return true;
	    }
	    if (typeof a === 'object') {
	        if (!(typeof b === 'object')) return false;
	        var keys = Object.keys(a);
	        if (keys.length !== Object.keys(b).length) return false;
	        for (var key in a) {
	            if (!deepEqual(a[key], b[key])) return false;
	        }
	        return true;
	    }
	    return a === b;
	};
	
	/**
	 * Check if two arrays have at least one common element.
	 * @param {Array} a
	 * @param {Array} b
	 * @returns {boolean}
	 * @private
	 */
	exports.arraysIntersect = function(a, b) {
	    for (var l = 0; l < a.length; l++) {
	        if (b.indexOf(a[l]) >= 0) return true;
	    }
	    return false;
	};


/***/ },
/* 83 */
/***/ function(module, exports) {

	/*
	 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
	 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * Ported from Webkit
	 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
	 */
	
	module.exports = UnitBezier;
	
	function UnitBezier(p1x, p1y, p2x, p2y) {
	    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
	    this.cx = 3.0 * p1x;
	    this.bx = 3.0 * (p2x - p1x) - this.cx;
	    this.ax = 1.0 - this.cx - this.bx;
	
	    this.cy = 3.0 * p1y;
	    this.by = 3.0 * (p2y - p1y) - this.cy;
	    this.ay = 1.0 - this.cy - this.by;
	
	    this.p1x = p1x;
	    this.p1y = p2y;
	    this.p2x = p2x;
	    this.p2y = p2y;
	}
	
	UnitBezier.prototype.sampleCurveX = function(t) {
	    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
	    return ((this.ax * t + this.bx) * t + this.cx) * t;
	};
	
	UnitBezier.prototype.sampleCurveY = function(t) {
	    return ((this.ay * t + this.by) * t + this.cy) * t;
	};
	
	UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
	    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
	};
	
	UnitBezier.prototype.solveCurveX = function(x, epsilon) {
	    if (typeof epsilon === 'undefined') epsilon = 1e-6;
	
	    var t0, t1, t2, x2, i;
	
	    // First try a few iterations of Newton's method -- normally very fast.
	    for (t2 = x, i = 0; i < 8; i++) {
	
	        x2 = this.sampleCurveX(t2) - x;
	        if (Math.abs(x2) < epsilon) return t2;
	
	        var d2 = this.sampleCurveDerivativeX(t2);
	        if (Math.abs(d2) < 1e-6) break;
	
	        t2 = t2 - x2 / d2;
	    }
	
	    // Fall back to the bisection method for reliability.
	    t0 = 0.0;
	    t1 = 1.0;
	    t2 = x;
	
	    if (t2 < t0) return t0;
	    if (t2 > t1) return t1;
	
	    while (t0 < t1) {
	
	        x2 = this.sampleCurveX(t2);
	        if (Math.abs(x2 - x) < epsilon) return t2;
	
	        if (x > x2) {
	            t0 = t2;
	        } else {
	            t1 = t2;
	        }
	
	        t2 = (t1 - t0) * 0.5 + t0;
	    }
	
	    // Failure.
	    return t2;
	};
	
	UnitBezier.prototype.solve = function(x, epsilon) {
	    return this.sampleCurveY(this.solveCurveX(x, epsilon));
	};


/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = Coordinate;
	
	/**
	 * A coordinate is a column, row, zoom combination, often used
	 * as the data component of a tile.
	 *
	 * @param {number} column
	 * @param {number} row
	 * @param {number} zoom
	 * @private
	 */
	function Coordinate(column, row, zoom) {
	    this.column = column;
	    this.row = row;
	    this.zoom = zoom;
	}
	
	Coordinate.prototype = {
	
	    /**
	     * Create a clone of this coordinate that can be mutated without
	     * changing the original coordinate
	     *
	     * @returns {Coordinate} clone
	     * @private
	     * var coord = new Coordinate(0, 0, 0);
	     * var c2 = coord.clone();
	     * // since coord is cloned, modifying a property of c2 does
	     * // not modify it.
	     * c2.zoom = 2;
	     */
	    clone: function() {
	        return new Coordinate(this.column, this.row, this.zoom);
	    },
	
	    /**
	     * Zoom this coordinate to a given zoom level. This returns a new
	     * coordinate object, not mutating the old one.
	     *
	     * @param {number} zoom
	     * @returns {Coordinate} zoomed coordinate
	     * @private
	     * @example
	     * var coord = new Coordinate(0, 0, 0);
	     * var c2 = coord.zoomTo(1);
	     * c2 // equals new Coordinate(0, 0, 1);
	     */
	    zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },
	
	    /**
	     * Subtract the column and row values of this coordinate from those
	     * of another coordinate. The other coordinat will be zoomed to the
	     * same level as `this` before the subtraction occurs
	     *
	     * @param {Coordinate} c other coordinate
	     * @returns {Coordinate} result
	     * @private
	     */
	    sub: function(c) { return this.clone()._sub(c); },
	
	    _zoomTo: function(zoom) {
	        var scale = Math.pow(2, zoom - this.zoom);
	        this.column *= scale;
	        this.row *= scale;
	        this.zoom = zoom;
	        return this;
	    },
	
	    _sub: function(c) {
	        c = c.zoomTo(this.zoom);
	        this.column -= c.column;
	        this.row -= c.row;
	        return this;
	    }
	};


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Canvas = __webpack_require__(81);
	
	/**
	 * Unlike js/util/browser.js, this code is written with the expectation
	 * of a browser environment with a global 'window' object
	 * @module browser
	 * @private
	 */
	
	/**
	 * Provides a function that outputs milliseconds: either performance.now()
	 * or a fallback to Date.now()
	 */
	module.exports.now = (function() {
	    if (window.performance &&
	        window.performance.now) {
	        return window.performance.now.bind(window.performance);
	    } else {
	        return Date.now.bind(Date);
	    }
	}());
	
	var frame = window.requestAnimationFrame ||
	    window.mozRequestAnimationFrame ||
	    window.webkitRequestAnimationFrame ||
	    window.msRequestAnimationFrame;
	
	exports.frame = function(fn) {
	    return frame(fn);
	};
	
	var cancel = window.cancelAnimationFrame ||
	    window.mozCancelAnimationFrame ||
	    window.webkitCancelAnimationFrame ||
	    window.msCancelAnimationFrame;
	
	exports.cancelFrame = function(id) {
	    cancel(id);
	};
	
	exports.timed = function (fn, dur, ctx) {
	    if (!dur) {
	        fn.call(ctx, 1);
	        return null;
	    }
	
	    var abort = false,
	        start = module.exports.now();
	
	    function tick(now) {
	        if (abort) return;
	        now = module.exports.now();
	
	        if (now >= start + dur) {
	            fn.call(ctx, 1);
	        } else {
	            fn.call(ctx, (now - start) / dur);
	            exports.frame(tick);
	        }
	    }
	
	    exports.frame(tick);
	
	    return function() { abort = true; };
	};
	
	exports.supportsWebGL = {};
	
	/**
	 * Test whether the basic JavaScript and DOM features required for Mapbox GL are present.
	 * @param {Object} options
	 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
	 * @return {boolean} Returns true if Mapbox GL should be expected to work, and false if not.
	 * @memberof mapboxgl
	 * @static
	 */
	exports.supported = function(options) {
	
	    var supports = [
	
	        function() { return typeof window !== 'undefined'; },
	
	        function() { return typeof document !== 'undefined'; },
	
	        function () {
	            return !!(Array.prototype &&
	                Array.prototype.every &&
	                Array.prototype.filter &&
	                Array.prototype.forEach &&
	                Array.prototype.indexOf &&
	                Array.prototype.lastIndexOf &&
	                Array.prototype.map &&
	                Array.prototype.some &&
	                Array.prototype.reduce &&
	                Array.prototype.reduceRight &&
	                Array.isArray);
	        },
	
	        function() {
	            return !!(Function.prototype && Function.prototype.bind) &&
	                !!(Object.keys &&
	                    Object.create &&
	                    Object.getPrototypeOf &&
	                    Object.getOwnPropertyNames &&
	                    Object.isSealed &&
	                    Object.isFrozen &&
	                    Object.isExtensible &&
	                    Object.getOwnPropertyDescriptor &&
	                    Object.defineProperty &&
	                    Object.defineProperties &&
	                    Object.seal &&
	                    Object.freeze &&
	                    Object.preventExtensions);
	        },
	
	        function() {
	            return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
	        },
	
	        function() {
	            var opt = (options && options.failIfMajorPerformanceCaveat) || false,
	                fimpc = 'fimpc_' + String(opt);
	            if (exports.supportsWebGL[fimpc] === undefined) {
	                var canvas = new Canvas();
	                exports.supportsWebGL[fimpc] = canvas.supportsWebGLContext(opt);
	            }
	            return exports.supportsWebGL[fimpc];
	        },
	
	        function() { return 'Worker' in window; }
	    ];
	
	    for (var i = 0; i < supports.length; i++) {
	        if (!supports[i]()) return false;
	    }
	    return true;
	};
	
	exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;
	
	Object.defineProperty(exports, 'devicePixelRatio', {
	    get: function() { return window.devicePixelRatio; }
	});
	
	exports.supportsWebp = false;
	
	var webpImgTest = document.createElement('img');
	webpImgTest.onload = function() {
	    exports.supportsWebp = true;
	};
	webpImgTest.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=';
	
	exports.supportsGeolocation = !!navigator.geolocation;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	
	/**
	 * Methods mixed in to other classes for event capabilities.
	 * @mixin Evented
	 */
	var Evented = {
	
	    /**
	     * Subscribe to a specified event with a listener function the latter gets the data object that was passed to `fire` and additionally `target` and `type` properties
	     *
	     * @param {string} type Event type
	     * @param {Function} listener Function to be called when the event is fired
	     */
	    on: function(type, fn) {
	        this._events = this._events || {};
	        this._events[type] = this._events[type] || [];
	        this._events[type].push(fn);
	
	        return this;
	    },
	
	    /**
	     * Remove a event listener
	     *
	     * @param {string} [type] Event type. If none is specified, remove all listeners
	     * @param {Function} [listener] Function to be called when the event is fired. If none is specified all listeners are removed
	     */
	    off: function(type, fn) {
	        if (!type) {
	            // clear all listeners if no arguments specified
	            delete this._events;
	            return this;
	        }
	
	        if (!this.listens(type)) return this;
	
	        if (fn) {
	            var idx = this._events[type].indexOf(fn);
	            if (idx >= 0) {
	                this._events[type].splice(idx, 1);
	            }
	            if (!this._events[type].length) {
	                delete this._events[type];
	            }
	        } else {
	            delete this._events[type];
	        }
	
	        return this;
	    },
	
	    /**
	     * Call a function once when an event has fired
	     *
	     * @param {string} type Event type.
	     * @param {Function} listener Function to be called once when the event is fired
	     */
	    once: function(type, fn) {
	        var wrapper = function(data) {
	            this.off(type, wrapper);
	            fn.call(this, data);
	        }.bind(this);
	        this.on(type, wrapper);
	        return this;
	    },
	
	    /**
	     * Fire event of a given string type with the given data object
	     *
	     * @param {string} type Event type
	     * @param {Object} [data] Optional data passed to the event receiver (e.g. {@link #EventData})
	     * @returns {Object} `this`
	     */
	    fire: function(type, data) {
	        if (!this.listens(type)) return this;
	
	        data = util.extend({}, data);
	        util.extend(data, {type: type, target: this});
	
	        // make sure adding/removing listeners inside other listeners won't cause infinite loop
	        var listeners = this._events[type].slice();
	
	        for (var i = 0; i < listeners.length; i++) {
	            listeners[i].call(this, data);
	        }
	
	        return this;
	    },
	
	    /**
	     * Check if an event is registered to a type
	     * @param {string} type Event type
	     * @returns {boolean} `true` if there is at least one registered listener for events of type `type`
	     */
	    listens: function(type) {
	        return !!(this._events && this._events[type]);
	    }
	};
	
	module.exports = Evented;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	
	exports.create = function (tagName, className, container) {
	    var el = document.createElement(tagName);
	    if (className) el.className = className;
	    if (container) container.appendChild(el);
	    return el;
	};
	
	var docStyle = document.documentElement.style;
	
	function testProp(props) {
	    for (var i = 0; i < props.length; i++) {
	        if (props[i] in docStyle) {
	            return props[i];
	        }
	    }
	}
	
	var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
	    userSelect;
	exports.disableDrag = function () {
	    if (selectProp) {
	        userSelect = docStyle[selectProp];
	        docStyle[selectProp] = 'none';
	    }
	};
	exports.enableDrag = function () {
	    if (selectProp) {
	        docStyle[selectProp] = userSelect;
	    }
	};
	
	var transformProp = testProp(['transform', 'WebkitTransform']);
	exports.setTransform = function(el, value) {
	    el.style[transformProp] = value;
	};
	
	// Suppress the next click, but only if it's immediate.
	function suppressClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    window.removeEventListener('click', suppressClick, true);
	}
	exports.suppressClick = function() {
	    window.addEventListener('click', suppressClick, true);
	    window.setTimeout(function() {
	        window.removeEventListener('click', suppressClick, true);
	    }, 0);
	};
	
	exports.mousePos = function (el, e) {
	    var rect = el.getBoundingClientRect();
	    e = e.touches ? e.touches[0] : e;
	    return new Point(
	        e.clientX - rect.left - el.clientLeft,
	        e.clientY - rect.top - el.clientTop
	    );
	};
	
	exports.touchPos = function (el, e) {
	    var rect = el.getBoundingClientRect(),
	        points = [];
	    for (var i = 0; i < e.touches.length; i++) {
	        points.push(new Point(
	            e.touches[i].clientX - rect.left - el.clientLeft,
	            e.touches[i].clientY - rect.top - el.clientTop
	        ));
	    }
	    return points;
	};


/***/ },
/* 88 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = Point;
	
	function Point(x, y) {
	    this.x = x;
	    this.y = y;
	}
	
	Point.prototype = {
	    clone: function() { return new Point(this.x, this.y); },
	
	    add:     function(p) { return this.clone()._add(p);     },
	    sub:     function(p) { return this.clone()._sub(p);     },
	    mult:    function(k) { return this.clone()._mult(k);    },
	    div:     function(k) { return this.clone()._div(k);     },
	    rotate:  function(a) { return this.clone()._rotate(a);  },
	    matMult: function(m) { return this.clone()._matMult(m); },
	    unit:    function() { return this.clone()._unit(); },
	    perp:    function() { return this.clone()._perp(); },
	    round:   function() { return this.clone()._round(); },
	
	    mag: function() {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    },
	
	    equals: function(p) {
	        return this.x === p.x &&
	               this.y === p.y;
	    },
	
	    dist: function(p) {
	        return Math.sqrt(this.distSqr(p));
	    },
	
	    distSqr: function(p) {
	        var dx = p.x - this.x,
	            dy = p.y - this.y;
	        return dx * dx + dy * dy;
	    },
	
	    angle: function() {
	        return Math.atan2(this.y, this.x);
	    },
	
	    angleTo: function(b) {
	        return Math.atan2(this.y - b.y, this.x - b.x);
	    },
	
	    angleWith: function(b) {
	        return this.angleWithSep(b.x, b.y);
	    },
	
	    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin() for .
	    angleWithSep: function(x, y) {
	        return Math.atan2(
	            this.x * y - this.y * x,
	            this.x * x + this.y * y);
	    },
	
	    _matMult: function(m) {
	        var x = m[0] * this.x + m[1] * this.y,
	            y = m[2] * this.x + m[3] * this.y;
	        this.x = x;
	        this.y = y;
	        return this;
	    },
	
	    _add: function(p) {
	        this.x += p.x;
	        this.y += p.y;
	        return this;
	    },
	
	    _sub: function(p) {
	        this.x -= p.x;
	        this.y -= p.y;
	        return this;
	    },
	
	    _mult: function(k) {
	        this.x *= k;
	        this.y *= k;
	        return this;
	    },
	
	    _div: function(k) {
	        this.x /= k;
	        this.y /= k;
	        return this;
	    },
	
	    _unit: function() {
	        this._div(this.mag());
	        return this;
	    },
	
	    _perp: function() {
	        var y = this.y;
	        this.y = this.x;
	        this.x = -y;
	        return this;
	    },
	
	    _rotate: function(angle) {
	        var cos = Math.cos(angle),
	            sin = Math.sin(angle),
	            x = cos * this.x - sin * this.y,
	            y = sin * this.x + cos * this.y;
	        this.x = x;
	        this.y = y;
	        return this;
	    },
	
	    _round: function() {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        return this;
	    }
	};
	
	// constructs Point from an array if necessary
	Point.convert = function (a) {
	    if (a instanceof Point) {
	        return a;
	    }
	    if (Array.isArray(a)) {
	        return new Point(a[0], a[1]);
	    }
	    return a;
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	var Evented = __webpack_require__(86);
	var StyleLayer = __webpack_require__(90);
	var ImageSprite = __webpack_require__(134);
	var GlyphSource = __webpack_require__(138);
	var SpriteAtlas = __webpack_require__(148);
	var LineAtlas = __webpack_require__(149);
	var util = __webpack_require__(82);
	var ajax = __webpack_require__(135);
	var normalizeURL = __webpack_require__(136).normalizeStyleURL;
	var browser = __webpack_require__(85);
	var Dispatcher = __webpack_require__(150);
	var AnimationLoop = __webpack_require__(205);
	var validateStyle = __webpack_require__(101);
	var Source = __webpack_require__(206);
	var styleSpec = __webpack_require__(98);
	var StyleFunction = __webpack_require__(94);
	
	module.exports = Style;
	
	function Style(stylesheet, animationLoop) {
	    this.animationLoop = animationLoop || new AnimationLoop();
	    this.dispatcher = new Dispatcher(Math.max(browser.hardwareConcurrency - 1, 1), this);
	    this.spriteAtlas = new SpriteAtlas(512, 512);
	    this.lineAtlas = new LineAtlas(256, 512);
	
	    this._layers = {};
	    this._order  = [];
	    this._groups = [];
	    this.sources = {};
	    this.zoomHistory = {};
	
	    util.bindAll([
	        '_forwardSourceEvent',
	        '_forwardTileEvent',
	        '_forwardLayerEvent',
	        '_redoPlacement'
	    ], this);
	
	    this._resetUpdates();
	
	    var loaded = function(err, stylesheet) {
	        if (err) {
	            this.fire('error', {error: err});
	            return;
	        }
	
	        if (validateStyle.emitErrors(this, validateStyle(stylesheet))) return;
	
	        this._loaded = true;
	        this.stylesheet = stylesheet;
	
	        this.updateClasses();
	
	        var sources = stylesheet.sources;
	        for (var id in sources) {
	            this.addSource(id, sources[id]);
	        }
	
	        if (stylesheet.sprite) {
	            this.sprite = new ImageSprite(stylesheet.sprite);
	            this.sprite.on('load', this.fire.bind(this, 'change'));
	        }
	
	        this.glyphSource = new GlyphSource(stylesheet.glyphs);
	        this._resolve();
	        this.fire('load');
	    }.bind(this);
	
	    if (typeof stylesheet === 'string') {
	        ajax.getJSON(normalizeURL(stylesheet), loaded);
	    } else {
	        browser.frame(loaded.bind(this, null, stylesheet));
	    }
	
	    this.on('source.load', function(event) {
	        var source = event.source;
	        if (source && source.vectorLayerIds) {
	            for (var layerId in this._layers) {
	                var layer = this._layers[layerId];
	                if (layer.source === source.id) {
	                    this._validateLayer(layer);
	                }
	            }
	        }
	    });
	}
	
	Style.prototype = util.inherit(Evented, {
	    _loaded: false,
	
	    _validateLayer: function(layer) {
	        var source = this.sources[layer.source];
	
	        if (!layer.sourceLayer) return;
	        if (!source) return;
	        if (!source.vectorLayerIds) return;
	
	        if (source.vectorLayerIds.indexOf(layer.sourceLayer) === -1) {
	            this.fire('error', {
	                error: new Error(
	                    'Source layer "' + layer.sourceLayer + '" ' +
	                    'does not exist on source "' + source.id + '" ' +
	                    'as specified by style layer "' + layer.id + '"'
	                )
	            });
	        }
	    },
	
	    loaded: function() {
	        if (!this._loaded)
	            return false;
	
	        for (var id in this.sources)
	            if (!this.sources[id].loaded())
	                return false;
	
	        if (this.sprite && !this.sprite.loaded())
	            return false;
	
	        return true;
	    },
	
	    _resolve: function() {
	        var layer, layerJSON;
	
	        this._layers = {};
	        this._order  = this.stylesheet.layers.map(function(layer) {
	            return layer.id;
	        });
	
	        // resolve all layers WITHOUT a ref
	        for (var i = 0; i < this.stylesheet.layers.length; i++) {
	            layerJSON = this.stylesheet.layers[i];
	            if (layerJSON.ref) continue;
	            layer = StyleLayer.create(layerJSON);
	            this._layers[layer.id] = layer;
	            layer.on('error', this._forwardLayerEvent);
	        }
	
	        // resolve all layers WITH a ref
	        for (var j = 0; j < this.stylesheet.layers.length; j++) {
	            layerJSON = this.stylesheet.layers[j];
	            if (!layerJSON.ref) continue;
	            var refLayer = this.getLayer(layerJSON.ref);
	            layer = StyleLayer.create(layerJSON, refLayer);
	            this._layers[layer.id] = layer;
	            layer.on('error', this._forwardLayerEvent);
	        }
	
	        this._groupLayers();
	        this._updateWorkerLayers();
	    },
	
	    _groupLayers: function() {
	        var group;
	
	        this._groups = [];
	
	        // Split into groups of consecutive top-level layers with the same source.
	        for (var i = 0; i < this._order.length; ++i) {
	            var layer = this._layers[this._order[i]];
	
	            if (!group || layer.source !== group.source) {
	                group = [];
	                group.source = layer.source;
	                this._groups.push(group);
	            }
	
	            group.push(layer);
	        }
	    },
	
	    _updateWorkerLayers: function(ids) {
	        this.dispatcher.broadcast(ids ? 'update layers' : 'set layers', this._serializeLayers(ids));
	    },
	
	    _serializeLayers: function(ids) {
	        ids = ids || this._order;
	        var serialized = [];
	        var options = {includeRefProperties: true};
	        for (var i = 0; i < ids.length; i++) {
	            serialized.push(this._layers[ids[i]].serialize(options));
	        }
	        return serialized;
	    },
	
	    _applyClasses: function(classes, options) {
	        if (!this._loaded) return;
	
	        classes = classes || [];
	        options = options || {transition: true};
	        var transition = this.stylesheet.transition || {};
	
	        var layers = this._updates.allPaintProps ? this._layers : this._updates.paintProps;
	
	        for (var id in layers) {
	            var layer = this._layers[id];
	            var props = this._updates.paintProps[id];
	
	            if (this._updates.allPaintProps || props.all) {
	                layer.updatePaintTransitions(classes, options, transition, this.animationLoop);
	            } else {
	                for (var paintName in props) {
	                    this._layers[id].updatePaintTransition(paintName, classes, options, transition, this.animationLoop);
	                }
	            }
	        }
	    },
	
	    _recalculate: function(z) {
	        for (var sourceId in this.sources)
	            this.sources[sourceId].used = false;
	
	        this._updateZoomHistory(z);
	
	        this.rasterFadeDuration = 300;
	        for (var layerId in this._layers) {
	            var layer = this._layers[layerId];
	
	            layer.recalculate(z, this.zoomHistory);
	            if (!layer.isHidden(z) && layer.source) {
	                this.sources[layer.source].used = true;
	            }
	        }
	
	        var maxZoomTransitionDuration = 300;
	        if (Math.floor(this.z) !== Math.floor(z)) {
	            this.animationLoop.set(maxZoomTransitionDuration);
	        }
	
	        this.z = z;
	        this.fire('zoom');
	    },
	
	    _updateZoomHistory: function(z) {
	
	        var zh = this.zoomHistory;
	
	        if (zh.lastIntegerZoom === undefined) {
	            // first time
	            zh.lastIntegerZoom = Math.floor(z);
	            zh.lastIntegerZoomTime = 0;
	            zh.lastZoom = z;
	        }
	
	        // check whether an integer zoom level as passed since the last frame
	        // and if yes, record it with the time. Used for transitioning patterns.
	        if (Math.floor(zh.lastZoom) < Math.floor(z)) {
	            zh.lastIntegerZoom = Math.floor(z);
	            zh.lastIntegerZoomTime = Date.now();
	
	        } else if (Math.floor(zh.lastZoom) > Math.floor(z)) {
	            zh.lastIntegerZoom = Math.floor(z + 1);
	            zh.lastIntegerZoomTime = Date.now();
	        }
	
	        zh.lastZoom = z;
	    },
	
	    _checkLoaded: function () {
	        if (!this._loaded) {
	            throw new Error('Style is not done loading');
	        }
	    },
	
	    /**
	     * Apply queued style updates in a batch
	     * @private
	     */
	    update: function(classes, options) {
	        if (!this._updates.changed) return this;
	
	        if (this._updates.allLayers) {
	            this._groupLayers();
	            this._updateWorkerLayers();
	        } else {
	            var updatedIds = Object.keys(this._updates.layers);
	            if (updatedIds.length) {
	                this._updateWorkerLayers(updatedIds);
	            }
	        }
	
	        var updatedSourceIds = Object.keys(this._updates.sources);
	        var i;
	        for (i = 0; i < updatedSourceIds.length; i++) {
	            this._reloadSource(updatedSourceIds[i]);
	        }
	
	        for (i = 0; i < this._updates.events.length; i++) {
	            var args = this._updates.events[i];
	            this.fire(args[0], args[1]);
	        }
	
	        this._applyClasses(classes, options);
	
	        if (this._updates.changed) {
	            this.fire('change');
	        }
	
	        this._resetUpdates();
	
	        return this;
	    },
	
	    _resetUpdates: function() {
	        this._updates = {
	            events: [],
	            layers: {},
	            sources: {},
	            paintProps: {}
	        };
	    },
	
	    addSource: function(id, source) {
	        this._checkLoaded();
	        if (this.sources[id] !== undefined) {
	            throw new Error('There is already a source with this ID');
	        }
	        if (!Source.is(source) && this._handleErrors(validateStyle.source, 'sources.' + id, source)) return this;
	
	        source = Source.create(source);
	        this.sources[id] = source;
	        source.id = id;
	        source.style = this;
	        source.dispatcher = this.dispatcher;
	        source
	            .on('load', this._forwardSourceEvent)
	            .on('error', this._forwardSourceEvent)
	            .on('change', this._forwardSourceEvent)
	            .on('tile.add', this._forwardTileEvent)
	            .on('tile.load', this._forwardTileEvent)
	            .on('tile.error', this._forwardTileEvent)
	            .on('tile.remove', this._forwardTileEvent)
	            .on('tile.stats', this._forwardTileEvent);
	
	        this._updates.events.push(['source.add', {source: source}]);
	        this._updates.changed = true;
	
	        return this;
	    },
	
	    /**
	     * Remove a source from this stylesheet, given its id.
	     * @param {string} id id of the source to remove
	     * @returns {Style} this style
	     * @throws {Error} if no source is found with the given ID
	     * @private
	     */
	    removeSource: function(id) {
	        this._checkLoaded();
	
	        if (this.sources[id] === undefined) {
	            throw new Error('There is no source with this ID');
	        }
	        var source = this.sources[id];
	        delete this.sources[id];
	        source
	            .off('load', this._forwardSourceEvent)
	            .off('error', this._forwardSourceEvent)
	            .off('change', this._forwardSourceEvent)
	            .off('tile.add', this._forwardTileEvent)
	            .off('tile.load', this._forwardTileEvent)
	            .off('tile.error', this._forwardTileEvent)
	            .off('tile.remove', this._forwardTileEvent)
	            .off('tile.stats', this._forwardTileEvent);
	
	        this._updates.events.push(['source.remove', {source: source}]);
	        this._updates.changed = true;
	
	        return this;
	    },
	
	    /**
	     * Get a source by id.
	     * @param {string} id id of the desired source
	     * @returns {Object} source
	     * @private
	     */
	    getSource: function(id) {
	        return this.sources[id];
	    },
	
	    /**
	     * Add a layer to the map style. The layer will be inserted before the layer with
	     * ID `before`, or appended if `before` is omitted.
	     * @param {StyleLayer|Object} layer
	     * @param {string=} before  ID of an existing layer to insert before
	     * @fires layer.add
	     * @returns {Style} `this`
	     * @private
	     */
	    addLayer: function(layer, before) {
	        this._checkLoaded();
	
	        if (!(layer instanceof StyleLayer)) {
	            // this layer is not in the style.layers array, so we pass an impossible array index
	            if (this._handleErrors(validateStyle.layer,
	                    'layers.' + layer.id, layer, false, {arrayIndex: -1})) return this;
	
	            var refLayer = layer.ref && this.getLayer(layer.ref);
	            layer = StyleLayer.create(layer, refLayer);
	        }
	        this._validateLayer(layer);
	
	        layer.on('error', this._forwardLayerEvent);
	
	        this._layers[layer.id] = layer;
	        this._order.splice(before ? this._order.indexOf(before) : Infinity, 0, layer.id);
	
	        this._updates.allLayers = true;
	        if (layer.source) {
	            this._updates.sources[layer.source] = true;
	        }
	        this._updates.events.push(['layer.add', {layer: layer}]);
	
	        return this.updateClasses(layer.id);
	    },
	
	    /**
	     * Remove a layer from this stylesheet, given its id.
	     * @param {string} id id of the layer to remove
	     * @returns {Style} this style
	     * @throws {Error} if no layer is found with the given ID
	     * @private
	     */
	    removeLayer: function(id) {
	        this._checkLoaded();
	
	        var layer = this._layers[id];
	        if (layer === undefined) {
	            throw new Error('There is no layer with this ID');
	        }
	        for (var i in this._layers) {
	            if (this._layers[i].ref === id) {
	                this.removeLayer(i);
	            }
	        }
	
	        layer.off('error', this._forwardLayerEvent);
	
	        delete this._layers[id];
	        this._order.splice(this._order.indexOf(id), 1);
	
	        this._updates.allLayers = true;
	        this._updates.events.push(['layer.remove', {layer: layer}]);
	        this._updates.changed = true;
	
	        return this;
	    },
	
	    /**
	     * Return the style layer object with the given `id`.
	     *
	     * @param {string} id - id of the desired layer
	     * @returns {?Object} a layer, if one with the given `id` exists
	     * @private
	     */
	    getLayer: function(id) {
	        return this._layers[id];
	    },
	
	    /**
	     * If a layer has a `ref` property that makes it derive some values
	     * from another layer, return that referent layer. Otherwise,
	     * returns the layer itself.
	     * @param {string} id the layer's id
	     * @returns {Layer} the referent layer or the layer itself
	     * @private
	     */
	    getReferentLayer: function(id) {
	        var layer = this.getLayer(id);
	        if (layer.ref) {
	            layer = this.getLayer(layer.ref);
	        }
	        return layer;
	    },
	
	    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
	        this._checkLoaded();
	
	        var layer = this.getReferentLayer(layerId);
	
	        if (layer.minzoom === minzoom && layer.maxzoom === maxzoom) return this;
	
	        if (minzoom != null) {
	            layer.minzoom = minzoom;
	        }
	        if (maxzoom != null) {
	            layer.maxzoom = maxzoom;
	        }
	        return this._updateLayer(layer);
	    },
	
	    setFilter: function(layerId, filter) {
	        this._checkLoaded();
	
	        var layer = this.getReferentLayer(layerId);
	
	        if (this._handleErrors(validateStyle.filter, 'layers.' + layer.id + '.filter', filter)) return this;
	
	        if (util.deepEqual(layer.filter, filter)) return this;
	        layer.filter = filter;
	
	        return this._updateLayer(layer);
	    },
	
	    /**
	     * Get a layer's filter object
	     * @param {string} layer the layer to inspect
	     * @returns {*} the layer's filter, if any
	     * @private
	     */
	    getFilter: function(layer) {
	        return this.getReferentLayer(layer).filter;
	    },
	
	    setLayoutProperty: function(layerId, name, value) {
	        this._checkLoaded();
	
	        var layer = this.getReferentLayer(layerId);
	
	        if (util.deepEqual(layer.getLayoutProperty(name), value)) return this;
	
	        layer.setLayoutProperty(name, value);
	        return this._updateLayer(layer);
	    },
	
	    /**
	     * Get a layout property's value from a given layer
	     * @param {string} layer the layer to inspect
	     * @param {string} name the name of the layout property
	     * @returns {*} the property value
	     * @private
	     */
	    getLayoutProperty: function(layer, name) {
	        return this.getReferentLayer(layer).getLayoutProperty(name);
	    },
	
	    setPaintProperty: function(layerId, name, value, klass) {
	        this._checkLoaded();
	
	        var layer = this.getLayer(layerId);
	
	        if (util.deepEqual(layer.getPaintProperty(name, klass), value)) return this;
	
	        var wasFeatureConstant = layer.isPaintValueFeatureConstant(name);
	        layer.setPaintProperty(name, value, klass);
	
	        var isFeatureConstant = !(StyleFunction.isFunctionDefinition(value) && value.property !== '$zoom' && value.property !== undefined);
	
	        if (!isFeatureConstant || !wasFeatureConstant) {
	            this._updates.layers[layerId] = true;
	            if (layer.source) {
	                this._updates.sources[layer.source] = true;
	            }
	        }
	
	        return this.updateClasses(layerId, name);
	    },
	
	    getPaintProperty: function(layer, name, klass) {
	        return this.getLayer(layer).getPaintProperty(name, klass);
	    },
	
	    updateClasses: function (layerId, paintName) {
	        this._updates.changed = true;
	        if (!layerId) {
	            this._updates.allPaintProps = true;
	        } else {
	            var props = this._updates.paintProps;
	            if (!props[layerId]) props[layerId] = {};
	            props[layerId][paintName || 'all'] = true;
	        }
	        return this;
	    },
	
	    serialize: function() {
	        return util.filterObject({
	            version: this.stylesheet.version,
	            name: this.stylesheet.name,
	            metadata: this.stylesheet.metadata,
	            center: this.stylesheet.center,
	            zoom: this.stylesheet.zoom,
	            bearing: this.stylesheet.bearing,
	            pitch: this.stylesheet.pitch,
	            sprite: this.stylesheet.sprite,
	            glyphs: this.stylesheet.glyphs,
	            transition: this.stylesheet.transition,
	            sources: util.mapObject(this.sources, function(source) {
	                return source.serialize();
	            }),
	            layers: this._order.map(function(id) {
	                return this._layers[id].serialize();
	            }, this)
	        }, function(value) { return value !== undefined; });
	    },
	
	    _updateLayer: function (layer) {
	        this._updates.layers[layer.id] = true;
	        if (layer.source) {
	            this._updates.sources[layer.source] = true;
	        }
	        this._updates.changed = true;
	        return this;
	    },
	
	    _flattenRenderedFeatures: function(sourceResults) {
	        var features = [];
	        for (var l = this._order.length - 1; l >= 0; l--) {
	            var layerID = this._order[l];
	            for (var s = 0; s < sourceResults.length; s++) {
	                var layerFeatures = sourceResults[s][layerID];
	                if (layerFeatures) {
	                    for (var f = 0; f < layerFeatures.length; f++) {
	                        features.push(layerFeatures[f]);
	                    }
	                }
	            }
	        }
	        return features;
	    },
	
	    queryRenderedFeatures: function(queryGeometry, params, zoom, bearing) {
	        if (params && params.filter) {
	            this._handleErrors(validateStyle.filter, 'queryRenderedFeatures.filter', params.filter, true);
	        }
	
	        var sourceResults = [];
	        for (var id in this.sources) {
	            var source = this.sources[id];
	            if (source.queryRenderedFeatures) {
	                sourceResults.push(source.queryRenderedFeatures(queryGeometry, params, zoom, bearing));
	            }
	        }
	        return this._flattenRenderedFeatures(sourceResults);
	    },
	
	    querySourceFeatures: function(sourceID, params) {
	        if (params && params.filter) {
	            this._handleErrors(validateStyle.filter, 'querySourceFeatures.filter', params.filter, true);
	        }
	        var source = this.getSource(sourceID);
	        return source && source.querySourceFeatures ? source.querySourceFeatures(params) : [];
	    },
	
	    _handleErrors: function(validate, key, value, throws, props) {
	        var action = throws ? validateStyle.throwErrors : validateStyle.emitErrors;
	        var result = validate.call(validateStyle, util.extend({
	            key: key,
	            style: this.serialize(),
	            value: value,
	            styleSpec: styleSpec
	        }, props));
	        return action.call(validateStyle, this, result);
	    },
	
	    _remove: function() {
	        this.dispatcher.remove();
	    },
	
	    _reloadSource: function(id) {
	        this.sources[id].reload();
	    },
	
	    _updateSources: function(transform) {
	        for (var id in this.sources) {
	            this.sources[id].update(transform);
	        }
	    },
	
	    _redoPlacement: function() {
	        for (var id in this.sources) {
	            if (this.sources[id].redoPlacement) this.sources[id].redoPlacement();
	        }
	    },
	
	    _forwardSourceEvent: function(e) {
	        this.fire('source.' + e.type, util.extend({source: e.target}, e));
	    },
	
	    _forwardTileEvent: function(e) {
	        this.fire(e.type, util.extend({source: e.target}, e));
	    },
	
	    _forwardLayerEvent: function(e) {
	        this.fire('layer.' + e.type, util.extend({layer: {id: e.target.id}}, e));
	    },
	
	    // Callbacks from web workers
	
	    'get sprite json': function(params, callback) {
	        var sprite = this.sprite;
	        if (sprite.loaded()) {
	            callback(null, { sprite: sprite.data, retina: sprite.retina });
	        } else {
	            sprite.on('load', function() {
	                callback(null, { sprite: sprite.data, retina: sprite.retina });
	            });
	        }
	    },
	
	    'get icons': function(params, callback) {
	        var sprite = this.sprite;
	        var spriteAtlas = this.spriteAtlas;
	        if (sprite.loaded()) {
	            spriteAtlas.setSprite(sprite);
	            spriteAtlas.addIcons(params.icons, callback);
	        } else {
	            sprite.on('load', function() {
	                spriteAtlas.setSprite(sprite);
	                spriteAtlas.addIcons(params.icons, callback);
	            });
	        }
	    },
	
	    'get glyphs': function(params, callback) {
	        var stacks = params.stacks,
	            remaining = Object.keys(stacks).length,
	            allGlyphs = {};
	
	        for (var fontName in stacks) {
	            this.glyphSource.getSimpleGlyphs(fontName, stacks[fontName], params.uid, done);
	        }
	
	        function done(err, glyphs, fontName) {
	            if (err) console.error(err);
	
	            allGlyphs[fontName] = glyphs;
	            remaining--;
	
	            if (remaining === 0)
	                callback(null, allGlyphs);
	        }
	    }
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var StyleTransition = __webpack_require__(91);
	var StyleDeclaration = __webpack_require__(93);
	var styleSpec = __webpack_require__(98);
	var validateStyle = __webpack_require__(101);
	var parseColor = __webpack_require__(96);
	var Evented = __webpack_require__(86);
	
	module.exports = StyleLayer;
	
	var TRANSITION_SUFFIX = '-transition';
	
	StyleLayer.create = function(layer, refLayer) {
	    var Classes = {
	        background: __webpack_require__(128),
	        circle: __webpack_require__(129),
	        fill: __webpack_require__(130),
	        line: __webpack_require__(131),
	        raster: __webpack_require__(132),
	        symbol: __webpack_require__(133)
	    };
	    return new Classes[(refLayer || layer).type](layer, refLayer);
	};
	
	function StyleLayer(layer, refLayer) {
	    this.set(layer, refLayer);
	}
	
	StyleLayer.prototype = util.inherit(Evented, {
	
	    set: function(layer, refLayer) {
	        this.id = layer.id;
	        this.ref = layer.ref;
	        this.metadata = layer.metadata;
	        this.type = (refLayer || layer).type;
	        this.source = (refLayer || layer).source;
	        this.sourceLayer = (refLayer || layer)['source-layer'];
	        this.minzoom = (refLayer || layer).minzoom;
	        this.maxzoom = (refLayer || layer).maxzoom;
	        this.filter = (refLayer || layer).filter;
	
	        this.paint = {};
	        this.layout = {};
	
	        this._paintSpecifications = styleSpec['paint_' + this.type];
	        this._layoutSpecifications = styleSpec['layout_' + this.type];
	
	        this._paintTransitions = {}; // {[propertyName]: StyleTransition}
	        this._paintTransitionOptions = {}; // {[className]: {[propertyName]: { duration:Number, delay:Number }}}
	        this._paintDeclarations = {}; // {[className]: {[propertyName]: StyleDeclaration}}
	        this._layoutDeclarations = {}; // {[propertyName]: StyleDeclaration}
	        this._layoutFunctions = {}; // {[propertyName]: Boolean}
	
	        var paintName, layoutName;
	
	        // Resolve paint declarations
	        for (var key in layer) {
	            var match = key.match(/^paint(?:\.(.*))?$/);
	            if (match) {
	                var klass = match[1] || '';
	                for (paintName in layer[key]) {
	                    this.setPaintProperty(paintName, layer[key][paintName], klass);
	                }
	            }
	        }
	
	        // Resolve layout declarations
	        if (this.ref) {
	            this._layoutDeclarations = refLayer._layoutDeclarations;
	        } else {
	            for (layoutName in layer.layout) {
	                this.setLayoutProperty(layoutName, layer.layout[layoutName]);
	            }
	        }
	
	        // set initial layout/paint values
	        for (paintName in this._paintSpecifications) {
	            this.paint[paintName] = this.getPaintValue(paintName);
	        }
	        for (layoutName in this._layoutSpecifications) {
	            this._updateLayoutValue(layoutName);
	        }
	    },
	
	    setLayoutProperty: function(name, value) {
	
	        if (value == null) {
	            delete this._layoutDeclarations[name];
	        } else {
	            var key = 'layers.' + this.id + '.layout.' + name;
	            if (this._handleErrors(validateStyle.layoutProperty, key, name, value)) return;
	            this._layoutDeclarations[name] = new StyleDeclaration(this._layoutSpecifications[name], value);
	        }
	        this._updateLayoutValue(name);
	    },
	
	    getLayoutProperty: function(name) {
	        return (
	            this._layoutDeclarations[name] &&
	            this._layoutDeclarations[name].value
	        );
	    },
	
	    getLayoutValue: function(name, globalProperties, featureProperties) {
	        var specification = this._layoutSpecifications[name];
	        var declaration = this._layoutDeclarations[name];
	
	        if (declaration) {
	            return declaration.calculate(globalProperties, featureProperties);
	        } else {
	            return specification.default;
	        }
	    },
	
	    setPaintProperty: function(name, value, klass) {
	        var validateStyleKey = 'layers.' + this.id + (klass ? '["paint.' + klass + '"].' : '.paint.') + name;
	
	        if (util.endsWith(name, TRANSITION_SUFFIX)) {
	            if (!this._paintTransitionOptions[klass || '']) {
	                this._paintTransitionOptions[klass || ''] = {};
	            }
	            if (value === null || value === undefined) {
	                delete this._paintTransitionOptions[klass || ''][name];
	            } else {
	                if (this._handleErrors(validateStyle.paintProperty, validateStyleKey, name, value)) return;
	                this._paintTransitionOptions[klass || ''][name] = value;
	            }
	        } else {
	            if (!this._paintDeclarations[klass || '']) {
	                this._paintDeclarations[klass || ''] = {};
	            }
	            if (value === null || value === undefined) {
	                delete this._paintDeclarations[klass || ''][name];
	            } else {
	                if (this._handleErrors(validateStyle.paintProperty, validateStyleKey, name, value)) return;
	                this._paintDeclarations[klass || ''][name] = new StyleDeclaration(this._paintSpecifications[name], value);
	            }
	        }
	    },
	
	    getPaintProperty: function(name, klass) {
	        klass = klass || '';
	        if (util.endsWith(name, TRANSITION_SUFFIX)) {
	            return (
	                this._paintTransitionOptions[klass] &&
	                this._paintTransitionOptions[klass][name]
	            );
	        } else {
	            return (
	                this._paintDeclarations[klass] &&
	                this._paintDeclarations[klass][name] &&
	                this._paintDeclarations[klass][name].value
	            );
	        }
	    },
	
	    getPaintValue: function(name, globalProperties, featureProperties) {
	        var specification = this._paintSpecifications[name];
	        var transition = this._paintTransitions[name];
	
	        if (transition) {
	            return transition.calculate(globalProperties, featureProperties);
	        } else if (specification.type === 'color' && specification.default) {
	            return parseColor(specification.default);
	        } else {
	            return specification.default;
	        }
	    },
	
	    isPaintValueFeatureConstant: function(name) {
	        var transition = this._paintTransitions[name];
	
	        if (transition) {
	            return transition.declaration.isFeatureConstant;
	        } else {
	            return true;
	        }
	    },
	
	    isHidden: function(zoom) {
	        if (this.minzoom && zoom < this.minzoom) return true;
	        if (this.maxzoom && zoom >= this.maxzoom) return true;
	        if (this.layout['visibility'] === 'none') return true;
	        if (this.paint[this.type + '-opacity'] === 0) return true;
	        return false;
	    },
	
	    updatePaintTransitions: function(classes, options, globalOptions, animationLoop) {
	        var declarations = util.extend({}, this._paintDeclarations['']);
	        for (var i = 0; i < classes.length; i++) {
	            util.extend(declarations, this._paintDeclarations[classes[i]]);
	        }
	
	        var name;
	        for (name in declarations) { // apply new declarations
	            this._applyPaintDeclaration(name, declarations[name], options, globalOptions, animationLoop);
	        }
	        for (name in this._paintTransitions) {
	            if (!(name in declarations)) // apply removed declarations
	                this._applyPaintDeclaration(name, null, options, globalOptions, animationLoop);
	        }
	    },
	
	    updatePaintTransition: function(name, classes, options, globalOptions, animationLoop) {
	        var declaration = this._paintDeclarations[''][name];
	        for (var i = 0; i < classes.length; i++) {
	            declaration = this._paintDeclarations[classes[i]][name] || declaration;
	        }
	        this._applyPaintDeclaration(name, declaration, options, globalOptions, animationLoop);
	    },
	
	    // update all zoom-dependent layout/paint values
	    recalculate: function(zoom, zoomHistory) {
	        for (var paintName in this._paintTransitions) {
	            this.paint[paintName] = this.getPaintValue(paintName, {zoom: zoom, zoomHistory: zoomHistory});
	        }
	        for (var layoutName in this._layoutFunctions) {
	            this.layout[layoutName] = this.getLayoutValue(layoutName, {zoom: zoom, zoomHistory: zoomHistory});
	        }
	    },
	
	    serialize: function(options) {
	        var output = {
	            'id': this.id,
	            'ref': this.ref,
	            'metadata': this.metadata,
	            'minzoom': this.minzoom,
	            'maxzoom': this.maxzoom
	        };
	
	        for (var klass in this._paintDeclarations) {
	            var key = klass === '' ? 'paint' : 'paint.' + klass;
	            output[key] = util.mapObject(this._paintDeclarations[klass], getDeclarationValue);
	        }
	
	        if (!this.ref || (options && options.includeRefProperties)) {
	            util.extend(output, {
	                'type': this.type,
	                'source': this.source,
	                'source-layer': this.sourceLayer,
	                'filter': this.filter,
	                'layout': util.mapObject(this._layoutDeclarations, getDeclarationValue)
	            });
	        }
	
	        return util.filterObject(output, function(value, key) {
	            return value !== undefined && !(key === 'layout' && !Object.keys(value).length);
	        });
	    },
	
	    // set paint transition based on a given paint declaration
	    _applyPaintDeclaration: function (name, declaration, options, globalOptions, animationLoop) {
	        var oldTransition = options.transition ? this._paintTransitions[name] : undefined;
	
	        if (declaration === null) {
	            var spec = this._paintSpecifications[name];
	            declaration = new StyleDeclaration(spec, spec.default);
	        }
	
	        if (oldTransition && oldTransition.declaration.json === declaration.json) return;
	
	        var transitionOptions = util.extend({
	            duration: 300,
	            delay: 0
	        }, globalOptions, this.getPaintProperty(name + TRANSITION_SUFFIX));
	
	        var newTransition = this._paintTransitions[name] =
	                new StyleTransition(declaration, oldTransition, transitionOptions);
	
	        if (!newTransition.instant()) {
	            newTransition.loopID = animationLoop.set(newTransition.endTime - Date.now());
	        }
	        if (oldTransition) {
	            animationLoop.cancel(oldTransition.loopID);
	        }
	    },
	
	    // update layout value if it's constant, or mark it as zoom-dependent
	    _updateLayoutValue: function(name) {
	        var declaration = this._layoutDeclarations[name];
	
	        if (declaration && declaration.isFunction) {
	            this._layoutFunctions[name] = true;
	        } else {
	            delete this._layoutFunctions[name];
	            this.layout[name] = this.getLayoutValue(name);
	        }
	    },
	
	    _handleErrors: function(validate, key, name, value) {
	        return validateStyle.emitErrors(this, validate.call(validateStyle, {
	            key: key,
	            layerType: this.type,
	            objectKey: name,
	            value: value,
	            styleSpec: styleSpec,
	            // Workaround for https://github.com/mapbox/mapbox-gl-js/issues/2407
	            style: {glyphs: true, sprite: true}
	        }));
	    }
	});
	
	function getDeclarationValue(declaration) {
	    return declaration.value;
	}


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var interpolate = __webpack_require__(92);
	
	module.exports = StyleTransition;
	
	/*
	 * Represents a transition between two declarations
	 */
	function StyleTransition(declaration, oldTransition, value) {
	
	    this.declaration = declaration;
	    this.startTime = this.endTime = (new Date()).getTime();
	
	    var type = declaration.type;
	    if ((type === 'string' || type === 'array') && declaration.transitionable) {
	        this.interp = interpZoomTransitioned;
	    } else {
	        this.interp = interpolate[type];
	    }
	
	    this.oldTransition = oldTransition;
	    this.duration = value.duration || 0;
	    this.delay = value.delay || 0;
	
	    if (!this.instant()) {
	        this.endTime = this.startTime + this.duration + this.delay;
	        this.ease = util.easeCubicInOut;
	    }
	
	    if (oldTransition && oldTransition.endTime <= this.startTime) {
	        // Old transition is done running, so we can
	        // delete its reference to its old transition.
	
	        delete oldTransition.oldTransition;
	    }
	}
	
	StyleTransition.prototype.instant = function() {
	    return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
	};
	
	/*
	 * Return the value of the transitioning property at zoom level `z` and optional time `t`
	 */
	StyleTransition.prototype.calculate = function(globalProperties, featureProperties) {
	    var value = this.declaration.calculate(
	        util.extend({}, globalProperties, {duration: this.duration}),
	        featureProperties
	    );
	
	    if (this.instant()) return value;
	
	    var t = globalProperties.time || Date.now();
	
	    if (t < this.endTime) {
	        var oldValue = this.oldTransition.calculate(
	            util.extend({}, globalProperties, {time: this.startTime}),
	            featureProperties
	        );
	        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
	        value = this.interp(oldValue, value, eased);
	    }
	
	    return value;
	
	};
	
	function interpZoomTransitioned(from, to, t) {
	    return {
	        from: from.to,
	        fromScale: from.toScale,
	        to: to.to,
	        toScale: to.toScale,
	        t: t
	    };
	}


/***/ },
/* 92 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = interpolate;
	
	function interpolate(a, b, t) {
	    return (a * (1 - t)) + (b * t);
	}
	
	interpolate.number = interpolate;
	
	interpolate.vec2 = function(from, to, t) {
	    return [
	        interpolate(from[0], to[0], t),
	        interpolate(from[1], to[1], t)
	    ];
	};
	
	/*
	 * Interpolate between two colors given as 4-element arrays.
	 *
	 * @param {Color} from
	 * @param {Color} to
	 * @param {number} t interpolation factor between 0 and 1
	 * @returns {Color} interpolated color
	 */
	interpolate.color = function(from, to, t) {
	    return [
	        interpolate(from[0], to[0], t),
	        interpolate(from[1], to[1], t),
	        interpolate(from[2], to[2], t),
	        interpolate(from[3], to[3], t)
	    ];
	};
	
	interpolate.array = function(from, to, t) {
	    return from.map(function(d, i) {
	        return interpolate(d, to[i], t);
	    });
	};


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var MapboxGLFunction = __webpack_require__(94);
	var parseColor = __webpack_require__(96);
	
	module.exports = StyleDeclaration;
	
	function StyleDeclaration(reference, value) {
	    this.type = reference.type;
	    this.transitionable = reference.transition;
	    this.value = value;
	    this.isFunction = !!value.stops;
	
	    // immutable representation of value. used for comparison
	    this.json = JSON.stringify(this.value);
	
	    var parsedValue = this.type === 'color' ? parseColor(this.value) : value;
	    this.calculate = MapboxGLFunction[reference.function || 'piecewise-constant'](parsedValue);
	    this.isFeatureConstant = this.calculate.isFeatureConstant;
	    this.isGlobalConstant = this.calculate.isGlobalConstant;
	
	    if (reference.function === 'piecewise-constant' && reference.transition) {
	        this.calculate = transitioned(this.calculate);
	    }
	}
	
	function transitioned(calculate) {
	    return function(globalProperties, featureProperties) {
	        var z = globalProperties.zoom;
	        var zh = globalProperties.zoomHistory;
	        var duration = globalProperties.duration;
	
	        var fraction = z % 1;
	        var t = Math.min((Date.now() - zh.lastIntegerZoomTime) / duration, 1);
	        var fromScale = 1;
	        var toScale = 1;
	        var mix, from, to;
	
	        if (z > zh.lastIntegerZoom) {
	            mix = fraction + (1 - fraction) * t;
	            fromScale *= 2;
	            from = calculate({zoom: z - 1}, featureProperties);
	            to = calculate({zoom: z}, featureProperties);
	        } else {
	            mix = 1 - (1 - t) * fraction;
	            to = calculate({zoom: z}, featureProperties);
	            from = calculate({zoom: z + 1}, featureProperties);
	            fromScale /= 2;
	        }
	
	        return {
	            from: from,
	            fromScale: fromScale,
	            to: to,
	            toScale: toScale,
	            t: mix
	        };
	    };
	}


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var MapboxGLFunction = __webpack_require__(95);
	
	exports.interpolated = function(parameters) {
	    var inner = MapboxGLFunction.interpolated(parameters);
	    var outer = function(globalProperties, featureProperties) {
	        return inner(globalProperties && globalProperties.zoom, featureProperties || {});
	    };
	    outer.isFeatureConstant = inner.isFeatureConstant;
	    outer.isGlobalConstant = inner.isGlobalConstant;
	    return outer;
	};
	
	exports['piecewise-constant'] = function(parameters) {
	    var inner = MapboxGLFunction['piecewise-constant'](parameters);
	    var outer = function(globalProperties, featureProperties) {
	        return inner(globalProperties && globalProperties.zoom, featureProperties || {});
	    };
	    outer.isFeatureConstant = inner.isFeatureConstant;
	    outer.isGlobalConstant = inner.isGlobalConstant;
	    return outer;
	};
	
	exports.isFunctionDefinition = MapboxGLFunction.isFunctionDefinition;


/***/ },
/* 95 */
/***/ function(module, exports) {

	'use strict';
	
	function createFunction(parameters, defaultType) {
	    var fun;
	
	    if (!isFunctionDefinition(parameters)) {
	        fun = function() { return parameters; };
	        fun.isFeatureConstant = true;
	        fun.isGlobalConstant = true;
	
	    } else {
	        var property = parameters.property === undefined ? '$zoom' : parameters.property;
	        var type = parameters.type || defaultType || 'exponential';
	
	        var innerFun;
	        if (type === 'exponential') {
	            innerFun = evaluateExponentialFunction;
	        } else if (type === 'interval') {
	            innerFun = evaluateIntervalFunction;
	        } else if (type === 'categorical') {
	            innerFun = evaluateCategoricalFunction;
	        } else {
	            throw new Error('Unknown function type "' + type + '"');
	        }
	
	        if (property === '$zoom') {
	            fun = function(zoom) {
	                return innerFun(parameters, zoom);
	            };
	            fun.isFeatureConstant = true;
	        } else {
	            fun = function(zoom, feature) {
	                return innerFun(parameters, feature[property]);
	            };
	        }
	    }
	
	    return fun;
	}
	
	function evaluateCategoricalFunction(parameters, input) {
	    for (var i = 0; i < parameters.stops.length; i++) {
	        if (input === parameters.stops[i][0]) {
	            return parameters.stops[i][1];
	        }
	    }
	    return parameters.stops[0][1];
	}
	
	function evaluateIntervalFunction(parameters, input) {
	    for (var i = 0; i < parameters.stops.length; i++) {
	        if (input < parameters.stops[i][0]) break;
	    }
	    return parameters.stops[Math.max(i - 1, 0)][1];
	}
	
	function evaluateExponentialFunction(parameters, input) {
	    var base = parameters.base !== undefined ? parameters.base : 1;
	
	    var i = 0;
	    while (true) {
	        if (i >= parameters.stops.length) break;
	        else if (input <= parameters.stops[i][0]) break;
	        else i++;
	    }
	
	    if (i === 0) {
	        return parameters.stops[i][1];
	
	    } else if (i === parameters.stops.length) {
	        return parameters.stops[i - 1][1];
	
	    } else {
	        return interpolate(
	            input,
	            base,
	            parameters.stops[i - 1][0],
	            parameters.stops[i][0],
	            parameters.stops[i - 1][1],
	            parameters.stops[i][1]
	        );
	    }
	}
	
	
	function interpolate(input, base, inputLower, inputUpper, outputLower, outputUpper) {
	    if (outputLower.length) {
	        return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);
	    } else {
	        return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);
	    }
	}
	
	function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {
	    var difference =  inputUpper - inputLower;
	    var progress = input - inputLower;
	
	    var ratio;
	    if (base === 1) {
	        ratio = progress / difference;
	    } else {
	        ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
	    }
	
	    return (outputLower * (1 - ratio)) + (outputUpper * ratio);
	}
	
	function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {
	    var output = [];
	    for (var i = 0; i < outputLower.length; i++) {
	        output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);
	    }
	    return output;
	}
	
	function isFunctionDefinition(value) {
	    return typeof value === 'object' && value.stops;
	}
	
	
	module.exports.isFunctionDefinition = isFunctionDefinition;
	
	module.exports.interpolated = function(parameters) {
	    return createFunction(parameters, 'exponential');
	};
	
	module.exports['piecewise-constant'] = function(parameters) {
	    return createFunction(parameters, 'interval');
	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var parseCSSColor = __webpack_require__(97).parseCSSColor;
	var util = __webpack_require__(82);
	
	var colorCache = {};
	
	function parseColor(input) {
	
	    if (colorCache[input]) {
	        return colorCache[input];
	
	    // RGBA array
	    } else if (Array.isArray(input)) {
	        return input;
	
	    // GL function
	    } else if (input && input.stops) {
	        return util.extend({}, input, {
	            stops: input.stops.map(parseFunctionStopColor)
	        });
	
	    // Color string
	    } else if (typeof input === 'string') {
	        var parsedColor = parseCSSColor(input);
	        if (!parsedColor) { throw new Error('Invalid color ' + input); }
	
	        var output = colorDowngrade(parsedColor);
	        colorCache[input] = output;
	        return output;
	
	    } else {
	        throw new Error('Invalid color ' + input);
	    }
	
	}
	
	function parseFunctionStopColor(stop) {
	    return [stop[0], parseColor(stop[1])];
	}
	
	function colorDowngrade(color) {
	    return [color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 1];
	}
	
	module.exports = parseColor;


/***/ },
/* 97 */
/***/ function(module, exports) {

	// (c) Dean McNamee <dean@gmail.com>, 2012.
	//
	// https://github.com/deanm/css-color-parser-js
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	// IN THE SOFTWARE.
	
	// http://www.w3.org/TR/css3-color/
	var kCSSColorTable = {
	  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
	  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
	  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
	  "beige": [245,245,220,1], "bisque": [255,228,196,1],
	  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
	  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
	  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
	  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
	  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
	  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
	  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
	  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
	  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
	  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
	  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
	  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
	  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
	  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
	  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
	  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
	  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
	  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
	  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
	  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
	  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
	  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
	  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
	  "gray": [128,128,128,1], "green": [0,128,0,1],
	  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
	  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
	  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
	  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
	  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
	  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
	  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
	  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
	  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
	  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
	  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
	  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
	  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
	  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
	  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
	  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
	  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
	  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
	  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
	  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
	  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
	  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
	  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
	  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
	  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
	  "orange": [255,165,0,1], "orangered": [255,69,0,1],
	  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
	  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
	  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
	  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
	  "pink": [255,192,203,1], "plum": [221,160,221,1],
	  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
	  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
	  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
	  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
	  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
	  "sienna": [160,82,45,1], "silver": [192,192,192,1],
	  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
	  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
	  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
	  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
	  "teal": [0,128,128,1], "thistle": [216,191,216,1],
	  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
	  "violet": [238,130,238,1], "wheat": [245,222,179,1],
	  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
	  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}
	
	function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
	  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	  return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	
	function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
	  return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	
	function parse_css_int(str) {  // int or percentage.
	  if (str[str.length - 1] === '%')
	    return clamp_css_byte(parseFloat(str) / 100 * 255);
	  return clamp_css_byte(parseInt(str));
	}
	
	function parse_css_float(str) {  // float or percentage.
	  if (str[str.length - 1] === '%')
	    return clamp_css_float(parseFloat(str) / 100);
	  return clamp_css_float(parseFloat(str));
	}
	
	function css_hue_to_rgb(m1, m2, h) {
	  if (h < 0) h += 1;
	  else if (h > 1) h -= 1;
	
	  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
	  if (h * 2 < 1) return m2;
	  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
	  return m1;
	}
	
	function parseCSSColor(css_str) {
	  // Remove all whitespace, not compliant, but should just be more accepting.
	  var str = css_str.replace(/ /g, '').toLowerCase();
	
	  // Color keywords (and transparent) lookup.
	  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.
	
	  // #abc and #abc123 syntax.
	  if (str[0] === '#') {
	    if (str.length === 4) {
	      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
	      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	              (iv & 0xf0) | ((iv & 0xf0) >> 4),
	              (iv & 0xf) | ((iv & 0xf) << 4),
	              1];
	    } else if (str.length === 7) {
	      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
	      return [(iv & 0xff0000) >> 16,
	              (iv & 0xff00) >> 8,
	              iv & 0xff,
	              1];
	    }
	
	    return null;
	  }
	
	  var op = str.indexOf('('), ep = str.indexOf(')');
	  if (op !== -1 && ep + 1 === str.length) {
	    var fname = str.substr(0, op);
	    var params = str.substr(op+1, ep-(op+1)).split(',');
	    var alpha = 1;  // To allow case fallthrough.
	    switch (fname) {
	      case 'rgba':
	        if (params.length !== 4) return null;
	        alpha = parse_css_float(params.pop());
	        // Fall through.
	      case 'rgb':
	        if (params.length !== 3) return null;
	        return [parse_css_int(params[0]),
	                parse_css_int(params[1]),
	                parse_css_int(params[2]),
	                alpha];
	      case 'hsla':
	        if (params.length !== 4) return null;
	        alpha = parse_css_float(params.pop());
	        // Fall through.
	      case 'hsl':
	        if (params.length !== 3) return null;
	        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parse_css_float(params[1]);
	        var l = parse_css_float(params[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
	                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
	                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
	                alpha];
	      default:
	        return null;
	    }
	  }
	
	  return null;
	}
	
	try { exports.parseCSSColor = parseCSSColor } catch(e) { }


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(99);


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(100);


/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = {
		"$version": 8,
		"$root": {
			"version": {
				"required": true,
				"type": "enum",
				"values": [
					8
				],
				"doc": "Stylesheet version number. Must be 8.",
				"example": 8
			},
			"name": {
				"type": "string",
				"doc": "A human-readable name for the style.",
				"example": "Bright"
			},
			"metadata": {
				"type": "*",
				"doc": "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
			},
			"center": {
				"type": "array",
				"value": "number",
				"doc": "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
				"example": [
					-73.9749,
					40.7736
				]
			},
			"zoom": {
				"type": "number",
				"doc": "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
				"example": 12.5
			},
			"bearing": {
				"type": "number",
				"default": 0,
				"period": 360,
				"units": "degrees",
				"doc": "Default bearing, in degrees.  The style bearing will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
				"example": 29
			},
			"pitch": {
				"type": "number",
				"default": 0,
				"units": "degrees",
				"doc": "Default pitch, in degrees. Zero is perpendicular to the surface.  The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",
				"example": 50
			},
			"sources": {
				"required": true,
				"type": "sources",
				"doc": "Data source specifications.",
				"example": {
					"mapbox-streets": {
						"type": "vector",
						"url": "mapbox://mapbox.mapbox-streets-v6"
					}
				}
			},
			"sprite": {
				"type": "string",
				"doc": "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the 'sprite-image' layout property.",
				"example": "mapbox://sprites/mapbox/bright-v8"
			},
			"glyphs": {
				"type": "string",
				"doc": "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the 'text-field' layout property.",
				"example": "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"
			},
			"transition": {
				"type": "transition",
				"doc": "A global transition definition to use as a default across properties.",
				"example": {
					"duration": 300,
					"delay": 0
				}
			},
			"layers": {
				"required": true,
				"type": "array",
				"value": "layer",
				"doc": "Layers will be drawn in the order of this array.",
				"example": [
					{
						"id": "water",
						"source": "mapbox-streets",
						"source-layer": "water",
						"type": "fill",
						"paint": {
							"fill-color": "#00ffff"
						}
					}
				]
			}
		},
		"sources": {
			"*": {
				"type": "source",
				"doc": "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."
			}
		},
		"source": [
			"source_tile",
			"source_geojson",
			"source_video",
			"source_image"
		],
		"source_tile": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"vector",
					"raster"
				],
				"doc": "The data type of the tile source."
			},
			"url": {
				"type": "string",
				"doc": "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."
			},
			"tiles": {
				"type": "array",
				"value": "string",
				"doc": "An array of one or more tile source URLs, as in the TileJSON spec."
			},
			"minzoom": {
				"type": "number",
				"default": 0,
				"doc": "Minimum zoom level for which tiles are available, as in the TileJSON spec."
			},
			"maxzoom": {
				"type": "number",
				"default": 22,
				"doc": "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."
			},
			"tileSize": {
				"type": "number",
				"default": 512,
				"units": "pixels",
				"doc": "The minimum visual size to display tiles for this layer. Only configurable for raster layers."
			},
			"*": {
				"type": "*",
				"doc": "Other keys to configure the data source."
			}
		},
		"source_geojson": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"geojson"
				],
				"doc": "The data type of the GeoJSON source."
			},
			"data": {
				"type": "*",
				"doc": "A URL to a GeoJSON file, or inline GeoJSON."
			},
			"maxzoom": {
				"type": "number",
				"default": 14,
				"doc": "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."
			},
			"buffer": {
				"type": "number",
				"default": 64,
				"doc": "Tile buffer size on each side (higher means fewer rendering artifacts near tile edges but slower performance)."
			},
			"tolerance": {
				"type": "number",
				"default": 3,
				"doc": "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."
			},
			"cluster": {
				"type": "boolean",
				"default": false,
				"doc": "If the data is a collection of point features, setting this to true clusters the points by radius into groups."
			},
			"clusterRadius": {
				"type": "number",
				"default": 400,
				"doc": "Radius of each cluster when clustering points, relative to 4096 tile."
			},
			"clusterMaxZoom": {
				"type": "number",
				"doc": "Max zoom to cluster points on. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."
			}
		},
		"source_video": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"video"
				],
				"doc": "The data type of the video source."
			},
			"urls": {
				"required": true,
				"type": "array",
				"value": "string",
				"doc": "URLs to video content in order of preferred format."
			},
			"coordinates": {
				"required": true,
				"doc": "Corners of video specified in longitude, latitude pairs.",
				"type": "array",
				"length": 4,
				"value": {
					"type": "array",
					"length": 2,
					"value": "number",
					"doc": "A single longitude, latitude pair."
				}
			}
		},
		"source_image": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"image"
				],
				"doc": "The data type of the image source."
			},
			"url": {
				"required": true,
				"type": "string",
				"doc": "URL that points to an image"
			},
			"coordinates": {
				"required": true,
				"doc": "Corners of image specified in longitude, latitude pairs.",
				"type": "array",
				"length": 4,
				"value": {
					"type": "array",
					"length": 2,
					"value": "number",
					"doc": "A single longitude, latitude pair."
				}
			}
		},
		"layer": {
			"id": {
				"type": "string",
				"doc": "Unique layer name.",
				"required": true
			},
			"type": {
				"type": "enum",
				"values": [
					"fill",
					"line",
					"symbol",
					"circle",
					"raster",
					"background"
				],
				"doc": "Rendering type of this layer."
			},
			"metadata": {
				"type": "*",
				"doc": "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."
			},
			"ref": {
				"type": "string",
				"doc": "References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."
			},
			"source": {
				"type": "string",
				"doc": "Name of a source description to be used for this layer."
			},
			"source-layer": {
				"type": "string",
				"doc": "Layer to use from a vector tile source. Required if the source supports multiple layers."
			},
			"minzoom": {
				"type": "number",
				"minimum": 0,
				"maximum": 22,
				"doc": "The minimum zoom level on which the layer gets parsed and appears on."
			},
			"maxzoom": {
				"type": "number",
				"minimum": 0,
				"maximum": 22,
				"doc": "The maximum zoom level on which the layer gets parsed and appears on."
			},
			"interactive": {
				"type": "boolean",
				"doc": "Enable querying of feature data from this layer for interactivity.",
				"default": false
			},
			"filter": {
				"type": "filter",
				"doc": "A expression specifying conditions on source features. Only features that match the filter are displayed."
			},
			"layout": {
				"type": "layout",
				"doc": "Layout properties for the layer."
			},
			"paint": {
				"type": "paint",
				"doc": "Default paint properties for this layer."
			},
			"paint.*": {
				"type": "paint",
				"doc": "Class-specific paint properties for this layer. The class name is the part after the first dot."
			}
		},
		"layout": [
			"layout_fill",
			"layout_line",
			"layout_circle",
			"layout_symbol",
			"layout_raster",
			"layout_background"
		],
		"layout_background": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible",
				"doc": "The display of this layer. `none` hides this layer."
			}
		},
		"layout_fill": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible",
				"doc": "The display of this layer. `none` hides this layer."
			}
		},
		"layout_circle": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible",
				"doc": "The display of this layer. `none` hides this layer."
			}
		},
		"layout_line": {
			"line-cap": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"butt",
					"round",
					"square"
				],
				"default": "butt",
				"doc": "The display of line endings."
			},
			"line-join": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"bevel",
					"round",
					"miter"
				],
				"default": "miter",
				"doc": "The display of lines when joining."
			},
			"line-miter-limit": {
				"type": "number",
				"default": 2,
				"function": "interpolated",
				"doc": "Used to automatically convert miter joins to bevel joins for sharp angles.",
				"requires": [
					{
						"line-join": "miter"
					}
				]
			},
			"line-round-limit": {
				"type": "number",
				"default": 1.05,
				"function": "interpolated",
				"doc": "Used to automatically convert round joins to miter joins for shallow angles.",
				"requires": [
					{
						"line-join": "round"
					}
				]
			},
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible",
				"doc": "The display of this layer. `none` hides this layer."
			}
		},
		"layout_symbol": {
			"symbol-placement": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"point",
					"line"
				],
				"default": "point",
				"doc": "Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons."
			},
			"symbol-spacing": {
				"type": "number",
				"default": 250,
				"minimum": 1,
				"function": "interpolated",
				"units": "pixels",
				"doc": "Distance between two symbol anchors.",
				"requires": [
					{
						"symbol-placement": "line"
					}
				]
			},
			"symbol-avoid-edges": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer."
			},
			"icon-allow-overlap": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, the icon will be visible even if it collides with other previously drawn symbols.",
				"requires": [
					"icon-image"
				]
			},
			"icon-ignore-placement": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, other symbols can be visible even if they collide with the icon.",
				"requires": [
					"icon-image"
				]
			},
			"icon-optional": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",
				"requires": [
					"icon-image",
					"text-field"
				]
			},
			"icon-rotation-alignment": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "viewport",
				"doc": "Orientation of icon when map is rotated.",
				"requires": [
					"icon-image"
				]
			},
			"icon-size": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"function": "interpolated",
				"doc": "Scale factor for icon. 1 is original size, 3 triples the size.",
				"requires": [
					"icon-image"
				]
			},
			"icon-image": {
				"type": "string",
				"function": "piecewise-constant",
				"doc": "A string with {tokens} replaced, referencing the data property to pull from.",
				"tokens": true
			},
			"icon-rotate": {
				"type": "number",
				"default": 0,
				"period": 360,
				"function": "interpolated",
				"units": "degrees",
				"doc": "Rotates the icon clockwise.",
				"requires": [
					"icon-image"
				]
			},
			"icon-padding": {
				"type": "number",
				"default": 2,
				"minimum": 0,
				"function": "interpolated",
				"units": "pixels",
				"doc": "Size of the additional area around the icon bounding box used for detecting symbol collisions.",
				"requires": [
					"icon-image"
				]
			},
			"icon-keep-upright": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, the icon may be flipped to prevent it from being rendered upside-down.",
				"requires": [
					"icon-image",
					{
						"icon-rotation-alignment": "map"
					},
					{
						"symbol-placement": "line"
					}
				]
			},
			"icon-offset": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"doc": "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
				"requires": [
					"icon-image"
				]
			},
			"text-rotation-alignment": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "viewport",
				"doc": "Orientation of text when map is rotated.",
				"requires": [
					"text-field"
				]
			},
			"text-field": {
				"type": "string",
				"function": "piecewise-constant",
				"default": "",
				"tokens": true,
				"doc": "Value to use for a text label. Feature properties are specified using tokens like {field_name}."
			},
			"text-font": {
				"type": "array",
				"value": "string",
				"function": "piecewise-constant",
				"default": [
					"Open Sans Regular",
					"Arial Unicode MS Regular"
				],
				"doc": "Font stack to use for displaying text.",
				"requires": [
					"text-field"
				]
			},
			"text-size": {
				"type": "number",
				"default": 16,
				"minimum": 0,
				"units": "pixels",
				"function": "interpolated",
				"doc": "Font size.",
				"requires": [
					"text-field"
				]
			},
			"text-max-width": {
				"type": "number",
				"default": 10,
				"minimum": 0,
				"units": "em",
				"function": "interpolated",
				"doc": "The maximum line width for text wrapping.",
				"requires": [
					"text-field"
				]
			},
			"text-line-height": {
				"type": "number",
				"default": 1.2,
				"units": "em",
				"function": "interpolated",
				"doc": "Text leading value for multi-line text.",
				"requires": [
					"text-field"
				]
			},
			"text-letter-spacing": {
				"type": "number",
				"default": 0,
				"units": "em",
				"function": "interpolated",
				"doc": "Text tracking amount.",
				"requires": [
					"text-field"
				]
			},
			"text-justify": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"left",
					"center",
					"right"
				],
				"default": "center",
				"doc": "Text justification options.",
				"requires": [
					"text-field"
				]
			},
			"text-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"center",
					"left",
					"right",
					"top",
					"bottom",
					"top-left",
					"top-right",
					"bottom-left",
					"bottom-right"
				],
				"default": "center",
				"doc": "Part of the text placed closest to the anchor.",
				"requires": [
					"text-field"
				]
			},
			"text-max-angle": {
				"type": "number",
				"default": 45,
				"units": "degrees",
				"function": "interpolated",
				"doc": "Maximum angle change between adjacent characters.",
				"requires": [
					"text-field",
					{
						"symbol-placement": "line"
					}
				]
			},
			"text-rotate": {
				"type": "number",
				"default": 0,
				"period": 360,
				"units": "degrees",
				"function": "interpolated",
				"doc": "Rotates the text clockwise.",
				"requires": [
					"text-field"
				]
			},
			"text-padding": {
				"type": "number",
				"default": 2,
				"minimum": 0,
				"units": "pixels",
				"function": "interpolated",
				"doc": "Size of the additional area around the text bounding box used for detecting symbol collisions.",
				"requires": [
					"text-field"
				]
			},
			"text-keep-upright": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": true,
				"doc": "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",
				"requires": [
					"text-field",
					{
						"text-rotation-alignment": "map"
					},
					{
						"symbol-placement": "line"
					}
				]
			},
			"text-transform": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"none",
					"uppercase",
					"lowercase"
				],
				"default": "none",
				"doc": "Specifies how to capitalize text, similar to the CSS `text-transform` property.",
				"requires": [
					"text-field"
				]
			},
			"text-offset": {
				"type": "array",
				"doc": "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up.",
				"value": "number",
				"units": "ems",
				"function": "interpolated",
				"length": 2,
				"default": [
					0,
					0
				],
				"requires": [
					"text-field"
				]
			},
			"text-allow-overlap": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, the text will be visible even if it collides with other previously drawn symbols.",
				"requires": [
					"text-field"
				]
			},
			"text-ignore-placement": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, other symbols can be visible even if they collide with the text.",
				"requires": [
					"text-field"
				]
			},
			"text-optional": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"doc": "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",
				"requires": [
					"text-field",
					"icon-image"
				]
			},
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible",
				"doc": "The display of this layer. `none` hides this layer."
			}
		},
		"layout_raster": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible",
				"doc": "The display of this layer. `none` hides this layer."
			}
		},
		"filter": {
			"type": "array",
			"value": "*",
			"doc": "A filter selects specific features from a layer."
		},
		"filter_operator": {
			"type": "enum",
			"values": [
				"==",
				"!=",
				">",
				">=",
				"<",
				"<=",
				"in",
				"!in",
				"all",
				"any",
				"none"
			],
			"doc": "The filter operator."
		},
		"geometry_type": {
			"type": "enum",
			"values": [
				"Point",
				"LineString",
				"Polygon"
			],
			"doc": "The geometry type for the filter to select."
		},
		"color_operation": {
			"type": "enum",
			"values": [
				"lighten",
				"saturate",
				"spin",
				"fade",
				"mix"
			],
			"doc": "A color operation to apply."
		},
		"function": {
			"stops": {
				"type": "array",
				"required": true,
				"doc": "An array of stops.",
				"value": "function_stop"
			},
			"base": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"doc": "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."
			},
			"property": {
				"type": "string",
				"doc": "The name of a global property or feature property to use as the function input.",
				"default": "$zoom"
			},
			"type": {
				"type": "enum",
				"values": [
					"exponential",
					"interval",
					"categorical"
				],
				"doc": "The interpolation strategy to use in function evaluation.",
				"default": "exponential"
			}
		},
		"function_stop": {
			"type": "array",
			"minimum": 0,
			"maximum": 22,
			"value": [
				"number",
				"color"
			],
			"length": 2,
			"doc": "Zoom level and value pair."
		},
		"paint": [
			"paint_fill",
			"paint_line",
			"paint_circle",
			"paint_symbol",
			"paint_raster",
			"paint_background"
		],
		"paint_fill": {
			"fill-antialias": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": true,
				"doc": "Whether or not the fill should be antialiased."
			},
			"fill-opacity": {
				"type": "number",
				"function": "interpolated",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"doc": "The opacity given to the fill color.",
				"transition": true
			},
			"fill-color": {
				"type": "color",
				"default": "#000000",
				"doc": "The color of the fill.",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "fill-pattern"
					}
				]
			},
			"fill-outline-color": {
				"type": "color",
				"doc": "The outline color of the fill. Matches the value of `fill-color` if unspecified.",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "fill-pattern"
					},
					{
						"fill-antialias": true
					}
				]
			},
			"fill-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
			},
			"fill-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
				"default": "map",
				"requires": [
					"fill-translate"
				]
			},
			"fill-pattern": {
				"type": "string",
				"function": "piecewise-constant",
				"transition": true,
				"doc": "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
			}
		},
		"paint_line": {
			"line-opacity": {
				"type": "number",
				"doc": "The opacity at which the line will be drawn.",
				"function": "interpolated",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"transition": true
			},
			"line-color": {
				"type": "color",
				"doc": "The color with which the line will be drawn.",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "line-pattern"
					}
				]
			},
			"line-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
			},
			"line-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
				"default": "map",
				"requires": [
					"line-translate"
				]
			},
			"line-width": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Stroke thickness."
			},
			"line-gap-width": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"doc": "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"line-offset": {
				"type": "number",
				"default": 0,
				"doc": "The line's offset perpendicular to its direction. Values may be positive or negative, where positive indicates \"rightwards\" (if you were moving in the direction of the line) and negative indicates \"leftwards.\"",
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"line-blur": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Blur applied to the line, in pixels."
			},
			"line-dasharray": {
				"type": "array",
				"value": "number",
				"function": "piecewise-constant",
				"doc": "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.",
				"minimum": 0,
				"transition": true,
				"units": "line widths",
				"requires": [
					{
						"!": "line-pattern"
					}
				]
			},
			"line-pattern": {
				"type": "string",
				"function": "piecewise-constant",
				"transition": true,
				"doc": "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512)."
			}
		},
		"paint_circle": {
			"circle-radius": {
				"type": "number",
				"default": 5,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Circle radius."
			},
			"circle-color": {
				"type": "color",
				"default": "#000000",
				"doc": "The color of the circle.",
				"function": "interpolated",
				"transition": true
			},
			"circle-blur": {
				"type": "number",
				"default": 0,
				"doc": "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",
				"function": "interpolated",
				"transition": true
			},
			"circle-opacity": {
				"type": "number",
				"doc": "The opacity at which the circle will be drawn.",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"circle-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."
			},
			"circle-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"doc": "Control whether the translation is relative to the map (north) or viewport (screen)",
				"default": "map",
				"requires": [
					"circle-translate"
				]
			}
		},
		"paint_symbol": {
			"icon-opacity": {
				"doc": "The opacity at which the icon will be drawn.",
				"type": "number",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true,
				"requires": [
					"icon-image"
				]
			},
			"icon-color": {
				"type": "color",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"doc": "The color of the icon. This can only be used with sdf icons.",
				"requires": [
					"icon-image"
				]
			},
			"icon-halo-color": {
				"type": "color",
				"default": "rgba(0, 0, 0, 0)",
				"function": "interpolated",
				"transition": true,
				"doc": "The color of the icon's halo. Icon halos can only be used with sdf icons.",
				"requires": [
					"icon-image"
				]
			},
			"icon-halo-width": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Distance of halo to the icon outline.",
				"requires": [
					"icon-image"
				]
			},
			"icon-halo-blur": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Fade out the halo towards the outside.",
				"requires": [
					"icon-image"
				]
			},
			"icon-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
				"requires": [
					"icon-image"
				]
			},
			"icon-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
				"default": "map",
				"requires": [
					"icon-image",
					"icon-translate"
				]
			},
			"text-opacity": {
				"type": "number",
				"doc": "The opacity at which the text will be drawn.",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true,
				"requires": [
					"text-field"
				]
			},
			"text-color": {
				"type": "color",
				"doc": "The color with which the text will be drawn.",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"requires": [
					"text-field"
				]
			},
			"text-halo-color": {
				"type": "color",
				"default": "rgba(0, 0, 0, 0)",
				"function": "interpolated",
				"transition": true,
				"doc": "The color of the text's halo, which helps it stand out from backgrounds.",
				"requires": [
					"text-field"
				]
			},
			"text-halo-width": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",
				"requires": [
					"text-field"
				]
			},
			"text-halo-blur": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "The halo's fadeout distance towards the outside.",
				"requires": [
					"text-field"
				]
			},
			"text-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"doc": "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
				"requires": [
					"text-field"
				]
			},
			"text-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"doc": "Control whether the translation is relative to the map (north) or viewport (screen).",
				"default": "map",
				"requires": [
					"text-field",
					"text-translate"
				]
			}
		},
		"paint_raster": {
			"raster-opacity": {
				"type": "number",
				"doc": "The opacity at which the image will be drawn.",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"raster-hue-rotate": {
				"type": "number",
				"default": 0,
				"period": 360,
				"function": "interpolated",
				"transition": true,
				"units": "degrees",
				"doc": "Rotates hues around the color wheel."
			},
			"raster-brightness-min": {
				"type": "number",
				"function": "interpolated",
				"doc": "Increase or reduce the brightness of the image. The value is the minimum brightness.",
				"default": 0,
				"minimum": 0,
				"maximum": 1,
				"transition": true
			},
			"raster-brightness-max": {
				"type": "number",
				"function": "interpolated",
				"doc": "Increase or reduce the brightness of the image. The value is the maximum brightness.",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"transition": true
			},
			"raster-saturation": {
				"type": "number",
				"doc": "Increase or reduce the saturation of the image.",
				"default": 0,
				"minimum": -1,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"raster-contrast": {
				"type": "number",
				"doc": "Increase or reduce the contrast of the image.",
				"default": 0,
				"minimum": -1,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"raster-fade-duration": {
				"type": "number",
				"default": 300,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "milliseconds",
				"doc": "Fade duration when a new tile is added."
			}
		},
		"paint_background": {
			"background-color": {
				"type": "color",
				"default": "#000000",
				"doc": "The color with which the background will be drawn.",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "background-pattern"
					}
				]
			},
			"background-pattern": {
				"type": "string",
				"function": "piecewise-constant",
				"transition": true,
				"doc": "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."
			},
			"background-opacity": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"doc": "The opacity at which the background will be drawn.",
				"function": "interpolated",
				"transition": true
			}
		},
		"transition": {
			"duration": {
				"type": "number",
				"default": 300,
				"minimum": 0,
				"units": "milliseconds",
				"doc": "Time allotted for transitions to complete."
			},
			"delay": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"units": "milliseconds",
				"doc": "Length of time before a transition begins."
			}
		}
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(102);
	
	module.exports.emitErrors = function throwErrors(emitter, errors) {
	    if (errors && errors.length) {
	        for (var i = 0; i < errors.length; i++) {
	            emitter.fire('error', { error: new Error(errors[i].message) });
	        }
	        return true;
	    } else {
	        return false;
	    }
	};
	
	module.exports.throwErrors = function throwErrors(emitter, errors) {
	    if (errors) {
	        for (var i = 0; i < errors.length; i++) {
	            throw new Error(errors[i].message);
	        }
	    }
	};


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var validateConstants = __webpack_require__(103);
	var validate = __webpack_require__(109);
	var latestStyleSpec = __webpack_require__(125);
	var validateGlyphsURL = __webpack_require__(127);
	
	/**
	 * Validate a Mapbox GL style against the style specification. This entrypoint,
	 * `mapbox-gl-style-spec/lib/validate_style.min`, is designed to produce as
	 * small a browserify bundle as possible by omitting unnecessary functionality
	 * and legacy style specifications.
	 *
	 * @param {Object} style The style to be validated.
	 * @param {Object} [styleSpec] The style specification to validate against.
	 *     If omitted, the latest style spec is used.
	 * @returns {Array<ValidationError>}
	 * @example
	 *   var validate = require('mapbox-gl-style-spec/lib/validate_style.min');
	 *   var errors = validate(style);
	 */
	function validateStyleMin(style, styleSpec) {
	    styleSpec = styleSpec || latestStyleSpec;
	
	    var errors = [];
	
	    errors = errors.concat(validate({
	        key: '',
	        value: style,
	        valueSpec: styleSpec.$root,
	        styleSpec: styleSpec,
	        style: style,
	        objectElementValidators: {
	            glyphs: validateGlyphsURL
	        }
	    }));
	
	    if (styleSpec.$version > 7 && style.constants) {
	        errors = errors.concat(validateConstants({
	            key: 'constants',
	            value: style.constants,
	            style: style,
	            styleSpec: styleSpec
	        }));
	    }
	
	    return sortErrors(errors);
	}
	
	validateStyleMin.source = wrapCleanErrors(__webpack_require__(123));
	validateStyleMin.layer = wrapCleanErrors(__webpack_require__(120));
	validateStyleMin.filter = wrapCleanErrors(__webpack_require__(119));
	validateStyleMin.paintProperty = wrapCleanErrors(__webpack_require__(121));
	validateStyleMin.layoutProperty = wrapCleanErrors(__webpack_require__(122));
	
	function sortErrors(errors) {
	    return [].concat(errors).sort(function (a, b) {
	        return a.line - b.line;
	    });
	}
	
	function wrapCleanErrors(inner) {
	    return function() {
	        return sortErrors(inner.apply(this, arguments));
	    };
	}
	
	module.exports = validateStyleMin;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var getType = __webpack_require__(108);
	
	module.exports = function validateConstants(options) {
	    var key = options.key;
	    var constants = options.value;
	    var styleSpec = options.styleSpec;
	
	    if (styleSpec.$version > 7) {
	        if (constants) {
	            return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
	        } else {
	            return [];
	        }
	    } else {
	        var type = getType(constants);
	        if (type !== 'object') {
	            return [new ValidationError(key, constants, 'object expected, %s found', type)];
	        }
	
	        var errors = [];
	        for (var constantName in constants) {
	            if (constantName[0] !== '@') {
	                errors.push(new ValidationError(key + '.' + constantName, constants[constantName], 'constants must start with "@"'));
	            }
	        }
	        return errors;
	    }
	
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var format = __webpack_require__(105).format;
	
	function ValidationError(key, value /*, message, ...*/) {
	    this.message = (
	        (key ? key + ': ' : '') +
	        format.apply(format, Array.prototype.slice.call(arguments, 2))
	    );
	
	    if (value !== null && value !== undefined && value.__line__) {
	        this.line = value.__line__;
	    }
	}
	
	module.exports = ValidationError;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(106);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(107);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3), __webpack_require__(4)))

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 107 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 108 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function getType(val) {
	    if (val instanceof Number) {
	        return 'number';
	    } else if (val instanceof String) {
	        return 'string';
	    } else if (val instanceof Boolean) {
	        return 'boolean';
	    } else if (Array.isArray(val)) {
	        return 'array';
	    } else if (val === null) {
	        return 'null';
	    } else {
	        return typeof val;
	    }
	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var getType = __webpack_require__(108);
	var extend = __webpack_require__(110);
	
	// Main recursive validation function. Tracks:
	//
	// - key: string representing location of validation in style tree. Used only
	//   for more informative error reporting.
	// - value: current value from style being evaluated. May be anything from a
	//   high level object that needs to be descended into deeper or a simple
	//   scalar value.
	// - valueSpec: current spec being evaluated. Tracks value.
	
	module.exports = function validate(options) {
	
	    var validateFunction = __webpack_require__(111);
	    var validateObject = __webpack_require__(112);
	    var VALIDATORS = {
	        '*': function() {
	            return [];
	        },
	        'array': __webpack_require__(113),
	        'boolean': __webpack_require__(114),
	        'number': __webpack_require__(115),
	        'color': __webpack_require__(116),
	        'constants': __webpack_require__(103),
	        'enum': __webpack_require__(117),
	        'filter': __webpack_require__(119),
	        'function': __webpack_require__(111),
	        'layer': __webpack_require__(120),
	        'object': __webpack_require__(112),
	        'source': __webpack_require__(123),
	        'string': __webpack_require__(124)
	    };
	
	    var value = options.value;
	    var valueSpec = options.valueSpec;
	    var key = options.key;
	    var styleSpec = options.styleSpec;
	    var style = options.style;
	
	    if (getType(value) === 'string' && value[0] === '@') {
	        if (styleSpec.$version > 7) {
	            return [new ValidationError(key, value, 'constants have been deprecated as of v8')];
	        }
	        if (!(value in style.constants)) {
	            return [new ValidationError(key, value, 'constant "%s" not found', value)];
	        }
	        options = extend({}, options, { value: style.constants[value] });
	    }
	
	    if (valueSpec.function && getType(value) === 'object') {
	        return validateFunction(options);
	
	    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
	        return VALIDATORS[valueSpec.type](options);
	
	    } else {
	        return validateObject(extend({}, options, {
	            valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec
	        }));
	    }
	};


/***/ },
/* 110 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (output) {
	    for (var i = 1; i < arguments.length; i++) {
	        var input = arguments[i];
	        for (var k in input) {
	            output[k] = input[k];
	        }
	    }
	    return output;
	};


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var getType = __webpack_require__(108);
	var validate = __webpack_require__(109);
	var validateObject = __webpack_require__(112);
	var validateArray = __webpack_require__(113);
	
	module.exports = function validateFunction(options) {
	    var originalValueSpec = options.valueSpec;
	
	    return validateObject({
	        key: options.key,
	        value: options.value,
	        valueSpec: options.styleSpec.function,
	        style: options.style,
	        styleSpec: options.styleSpec,
	        objectElementValidators: { stops: validateFunctionStops }
	    });
	
	    function validateFunctionStops(options) {
	        var errors = [];
	        var value = options.value;
	
	        errors = errors.concat(validateArray({
	            key: options.key,
	            value: value,
	            valueSpec: options.valueSpec,
	            style: options.style,
	            styleSpec: options.styleSpec,
	            arrayElementValidator: validateFunctionStop
	        }));
	
	        if (getType(value) === 'array' && value.length === 0) {
	            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
	        }
	
	        return errors;
	    }
	
	    function validateFunctionStop(options) {
	        var errors = [];
	        var value = options.value;
	        var key = options.key;
	
	        if (getType(value) !== 'array') {
	            return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
	        }
	
	        if (value.length !== 2) {
	            return [new ValidationError(key, value, 'array length %d expected, length %d found', 2, value.length)];
	        }
	
	        errors = errors.concat(validate({
	            key: key + '[0]',
	            value: value[0],
	            valueSpec: {type: 'number'},
	            style: options.style,
	            styleSpec: options.styleSpec
	        }));
	
	        errors = errors.concat(validate({
	            key: key + '[1]',
	            value: value[1],
	            valueSpec: originalValueSpec,
	            style: options.style,
	            styleSpec: options.styleSpec
	        }));
	
	        if (getType(value[0]) === 'number') {
	            if (originalValueSpec.function === 'piecewise-constant' && value[0] % 1 !== 0) {
	                errors.push(new ValidationError(key + '[0]', value[0], 'zoom level for piecewise-constant functions must be an integer'));
	            }
	
	            if (options.arrayIndex !== 0) {
	                if (value[0] < options.array[options.arrayIndex - 1][0]) {
	                    errors.push(new ValidationError(key + '[0]', value[0], 'array stops must appear in ascending order'));
	                }
	            }
	        }
	
	        return errors;
	    }
	
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var getType = __webpack_require__(108);
	var validate = __webpack_require__(109);
	
	module.exports = function validateObject(options) {
	    var key = options.key;
	    var object = options.value;
	    var valueSpec = options.valueSpec;
	    var objectElementValidators = options.objectElementValidators || {};
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    var errors = [];
	
	    var type = getType(object);
	    if (type !== 'object') {
	        return [new ValidationError(key, object, 'object expected, %s found', type)];
	    }
	
	    for (var objectKey in object) {
	        var valueSpecKey = objectKey.split('.')[0]; // treat 'paint.*' as 'paint'
	        var objectElementSpec = valueSpec && (valueSpec[valueSpecKey] || valueSpec['*']);
	        var objectElementValidator = objectElementValidators[valueSpecKey] || objectElementValidators['*'];
	
	        if (objectElementSpec || objectElementValidator) {
	            errors = errors.concat((objectElementValidator || validate)({
	                key: (key ? key + '.' : key) + objectKey,
	                value: object[objectKey],
	                valueSpec: objectElementSpec,
	                style: style,
	                styleSpec: styleSpec,
	                object: object,
	                objectKey: objectKey
	            }));
	
	        // tolerate root-level extra keys & arbitrary layer properties
	        // TODO remove this layer-specific logic
	        } else if (key !== '' && key.split('.').length !== 1) {
	            errors.push(new ValidationError(key, object[objectKey], 'unknown property "%s"', objectKey));
	        }
	    }
	
	    for (valueSpecKey in valueSpec) {
	        if (valueSpec[valueSpecKey].required && valueSpec[valueSpecKey]['default'] === undefined && object[valueSpecKey] === undefined) {
	            errors.push(new ValidationError(key, object, 'missing required property "%s"', valueSpecKey));
	        }
	    }
	
	    return errors;
	};


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getType = __webpack_require__(108);
	var validate = __webpack_require__(109);
	var ValidationError = __webpack_require__(104);
	
	module.exports = function validateArray(options) {
	    var array = options.value;
	    var arraySpec = options.valueSpec;
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    var key = options.key;
	    var validateArrayElement = options.arrayElementValidator || validate;
	
	    if (getType(array) !== 'array') {
	        return [new ValidationError(key, array, 'array expected, %s found', getType(array))];
	    }
	
	    if (arraySpec.length && array.length !== arraySpec.length) {
	        return [new ValidationError(key, array, 'array length %d expected, length %d found', arraySpec.length, array.length)];
	    }
	
	    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
	        return [new ValidationError(key, array, 'array length at least %d expected, length %d found', arraySpec['min-length'], array.length)];
	    }
	
	    var arrayElementSpec = {
	        "type": arraySpec.value
	    };
	
	    if (styleSpec.$version < 7) {
	        arrayElementSpec.function = arraySpec.function;
	    }
	
	    if (getType(arraySpec.value) === 'object') {
	        arrayElementSpec = arraySpec.value;
	    }
	
	    var errors = [];
	    for (var i = 0; i < array.length; i++) {
	        errors = errors.concat(validateArrayElement({
	            array: array,
	            arrayIndex: i,
	            value: array[i],
	            valueSpec: arrayElementSpec,
	            style: style,
	            styleSpec: styleSpec,
	            key: key + '[' + i + ']'
	        }));
	    }
	    return errors;
	};


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getType = __webpack_require__(108);
	var ValidationError = __webpack_require__(104);
	
	module.exports = function validateBoolean(options) {
	    var value = options.value;
	    var key = options.key;
	    var type = getType(value);
	
	    if (type !== 'boolean') {
	        return [new ValidationError(key, value, 'boolean expected, %s found', type)];
	    }
	
	    return [];
	};


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getType = __webpack_require__(108);
	var ValidationError = __webpack_require__(104);
	
	module.exports = function validateNumber(options) {
	    var key = options.key;
	    var value = options.value;
	    var valueSpec = options.valueSpec;
	    var type = getType(value);
	
	    if (type !== 'number') {
	        return [new ValidationError(key, value, 'number expected, %s found', type)];
	    }
	
	    if ('minimum' in valueSpec && value < valueSpec.minimum) {
	        return [new ValidationError(key, value, '%s is less than the minimum value %s', value, valueSpec.minimum)];
	    }
	
	    if ('maximum' in valueSpec && value > valueSpec.maximum) {
	        return [new ValidationError(key, value, '%s is greater than the maximum value %s', value, valueSpec.maximum)];
	    }
	
	    return [];
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var getType = __webpack_require__(108);
	var parseCSSColor = __webpack_require__(97).parseCSSColor;
	
	module.exports = function validateColor(options) {
	    var key = options.key;
	    var value = options.value;
	    var type = getType(value);
	
	    if (type !== 'string') {
	        return [new ValidationError(key, value, 'color expected, %s found', type)];
	    }
	
	    if (parseCSSColor(value) === null) {
	        return [new ValidationError(key, value, 'color expected, "%s" found', value)];
	    }
	
	    return [];
	};


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var unbundle = __webpack_require__(118);
	
	module.exports = function validateEnum(options) {
	    var key = options.key;
	    var value = options.value;
	    var valueSpec = options.valueSpec;
	    var errors = [];
	
	    if (valueSpec.values.indexOf(unbundle(value)) === -1) {
	        errors.push(new ValidationError(key, value, 'expected one of [%s], %s found', valueSpec.values.join(', '), value));
	    }
	    return errors;
	};


/***/ },
/* 118 */
/***/ function(module, exports) {

	'use strict';
	
	// Turn jsonlint-lines-primitives objects into primitive objects
	module.exports = function unbundle(value) {
	    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
	        return value.valueOf();
	    } else {
	        return value;
	    }
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var validateEnum = __webpack_require__(117);
	var getType = __webpack_require__(108);
	var unbundle = __webpack_require__(118);
	
	module.exports = function validateFilter(options) {
	    var value = options.value;
	    var key = options.key;
	    var styleSpec = options.styleSpec;
	    var type;
	
	    var errors = [];
	
	    if (getType(value) !== 'array') {
	        return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
	    }
	
	    if (value.length < 1) {
	        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
	    }
	
	    errors = errors.concat(validateEnum({
	        key: key + '[0]',
	        value: value[0],
	        valueSpec: styleSpec.filter_operator,
	        style: options.style,
	        styleSpec: options.styleSpec
	    }));
	
	    switch (unbundle(value[0])) {
	        case '<':
	        case '<=':
	        case '>':
	        case '>=':
	            if (value.length >= 2 && value[1] == '$type') {
	                errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "%s"', value[0]));
	            }
	        /* falls through */
	        case '==':
	        case '!=':
	            if (value.length != 3) {
	                errors.push(new ValidationError(key, value, 'filter array for operator "%s" must have 3 elements', value[0]));
	            }
	        /* falls through */
	        case 'in':
	        case '!in':
	            if (value.length >= 2) {
	                type = getType(value[1]);
	                if (type !== 'string') {
	                    errors.push(new ValidationError(key + '[1]', value[1], 'string expected, %s found', type));
	                } else if (value[1][0] === '@') {
	                    errors.push(new ValidationError(key + '[1]', value[1], 'filter key cannot be a constant'));
	                }
	            }
	            for (var i = 2; i < value.length; i++) {
	                type = getType(value[i]);
	                if (value[1] == '$type') {
	                    errors = errors.concat(validateEnum({
	                        key: key + '[' + i + ']',
	                        value: value[i],
	                        valueSpec: styleSpec.geometry_type,
	                        style: options.style,
	                        styleSpec: options.styleSpec
	                    }));
	                } else if (type === 'string' && value[i][0] === '@') {
	                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'filter value cannot be a constant'));
	                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
	                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, %s found', type));
	                }
	            }
	            break;
	
	        case 'any':
	        case 'all':
	        case 'none':
	            for (i = 1; i < value.length; i++) {
	                errors = errors.concat(validateFilter({
	                    key: key + '[' + i + ']',
	                    value: value[i],
	                    style: options.style,
	                    styleSpec: options.styleSpec
	                }));
	            }
	            break;
	    }
	
	    return errors;
	};


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var unbundle = __webpack_require__(118);
	var validateObject = __webpack_require__(112);
	var validateFilter = __webpack_require__(119);
	var validatePaintProperty = __webpack_require__(121);
	var validateLayoutProperty = __webpack_require__(122);
	var extend = __webpack_require__(110);
	
	module.exports = function validateLayer(options) {
	    var errors = [];
	
	    var layer = options.value;
	    var key = options.key;
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	
	    if (!layer.type && !layer.ref) {
	        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
	    }
	    var type = unbundle(layer.type);
	    var ref = unbundle(layer.ref);
	
	    if (layer.id) {
	        for (var i = 0; i < options.arrayIndex; i++) {
	            var otherLayer = style.layers[i];
	            if (unbundle(otherLayer.id) === unbundle(layer.id)) {
	                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "%s", previously used at line %d', layer.id, otherLayer.id.__line__));
	            }
	        }
	    }
	
	    if ('ref' in layer) {
	        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
	            if (p in layer) {
	                errors.push(new ValidationError(key, layer[p], '"%s" is prohibited for ref layers', p));
	            }
	        });
	
	        var parent;
	
	        style.layers.forEach(function(layer) {
	            if (layer.id == ref) parent = layer;
	        });
	
	        if (!parent) {
	            errors.push(new ValidationError(key, layer.ref, 'ref layer "%s" not found', ref));
	        } else if (parent.ref) {
	            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
	        } else {
	            type = unbundle(parent.type);
	        }
	    } else if (type !== 'background') {
	        if (!layer.source) {
	            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
	        } else {
	            var source = style.sources[layer.source];
	            if (!source) {
	                errors.push(new ValidationError(key, layer.source, 'source "%s" not found', layer.source));
	            } else if (source.type == 'vector' && type == 'raster') {
	                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a raster source', layer.id));
	            } else if (source.type == 'raster' && type != 'raster') {
	                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a vector source', layer.id));
	            } else if (source.type == 'vector' && !layer['source-layer']) {
	                errors.push(new ValidationError(key, layer, 'layer "%s" must specify a "source-layer"', layer.id));
	            }
	        }
	    }
	
	    errors = errors.concat(validateObject({
	        key: key,
	        value: layer,
	        valueSpec: styleSpec.layer,
	        style: options.style,
	        styleSpec: options.styleSpec,
	        objectElementValidators: {
	            filter: validateFilter,
	            layout: function(options) {
	                return validateObject({
	                    layer: layer,
	                    key: options.key,
	                    value: options.value,
	                    style: options.style,
	                    styleSpec: options.styleSpec,
	                    objectElementValidators: {
	                        '*': function(options) {
	                            return validateLayoutProperty(extend({layerType: type}, options));
	                        }
	                    }
	                });
	            },
	            paint: function(options) {
	                return validateObject({
	                    layer: layer,
	                    key: options.key,
	                    value: options.value,
	                    style: options.style,
	                    styleSpec: options.styleSpec,
	                    objectElementValidators: {
	                        '*': function(options) {
	                            return validatePaintProperty(extend({layerType: type}, options));
	                        }
	                    }
	                });
	            }
	        }
	    }));
	
	    return errors;
	};


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var validate = __webpack_require__(109);
	var ValidationError = __webpack_require__(104);
	
	module.exports = function validatePaintProperty(options) {
	    var key = options.key;
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    var value = options.value;
	    var propertyKey = options.objectKey;
	    var layerSpec = styleSpec['paint_' + options.layerType];
	
	    var transitionMatch = propertyKey.match(/^(.*)-transition$/);
	
	    if (transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
	        return validate({
	            key: key,
	            value: value,
	            valueSpec: styleSpec.transition,
	            style: style,
	            styleSpec: styleSpec
	        });
	
	    } else if (options.valueSpec || layerSpec[propertyKey]) {
	        return validate({
	            key: options.key,
	            value: value,
	            valueSpec: options.valueSpec || layerSpec[propertyKey],
	            style: style,
	            styleSpec: styleSpec
	        });
	
	    } else {
	        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
	    }
	
	};


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var validate = __webpack_require__(109);
	var ValidationError = __webpack_require__(104);
	
	module.exports = function validateLayoutProperty(options) {
	    var key = options.key;
	    var style = options.style;
	    var styleSpec = options.styleSpec;
	    var value = options.value;
	    var propertyKey = options.objectKey;
	    var layerSpec = styleSpec['layout_' + options.layerType];
	
	    if (options.valueSpec || layerSpec[propertyKey]) {
	        var errors = [];
	
	        if (options.layerType === 'symbol') {
	            if (propertyKey === 'icon-image' && style && !style.sprite) {
	                errors.push(new ValidationError(key, value, 'use of "icon-image" requires a style "sprite" property'));
	            } else if (propertyKey === 'text-field' && style && !style.glyphs) {
	                errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
	            }
	        }
	
	        return errors.concat(validate({
	            key: options.key,
	            value: value,
	            valueSpec: options.valueSpec || layerSpec[propertyKey],
	            style: style,
	            styleSpec: styleSpec
	        }));
	
	    } else {
	        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
	    }
	
	};


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var unbundle = __webpack_require__(118);
	var validateObject = __webpack_require__(112);
	var validateEnum = __webpack_require__(117);
	
	module.exports = function validateSource(options) {
	    var value = options.value;
	    var key = options.key;
	    var styleSpec = options.styleSpec;
	    var style = options.style;
	
	    if (!value.type) {
	        return [new ValidationError(key, value, '"type" is required')];
	    }
	
	    var type = unbundle(value.type);
	    switch (type) {
	        case 'vector':
	        case 'raster':
	            var errors = [];
	            errors = errors.concat(validateObject({
	                key: key,
	                value: value,
	                valueSpec: styleSpec.source_tile,
	                style: options.style,
	                styleSpec: styleSpec
	            }));
	            if ('url' in value) {
	                for (var prop in value) {
	                    if (['type', 'url', 'tileSize'].indexOf(prop) < 0) {
	                        errors.push(new ValidationError(key + '.' + prop, value[prop], 'a source with a "url" property may not include a "%s" property', prop));
	                    }
	                }
	            }
	            return errors;
	
	        case 'geojson':
	            return validateObject({
	                key: key,
	                value: value,
	                valueSpec: styleSpec.source_geojson,
	                style: style,
	                styleSpec: styleSpec
	            });
	
	        case 'video':
	            return validateObject({
	                key: key,
	                value: value,
	                valueSpec: styleSpec.source_video,
	                style: style,
	                styleSpec: styleSpec
	            });
	
	        case 'image':
	            return validateObject({
	                key: key,
	                value: value,
	                valueSpec: styleSpec.source_image,
	                style: style,
	                styleSpec: styleSpec
	            });
	
	        default:
	            return validateEnum({
	                key: key + '.type',
	                value: value.type,
	                valueSpec: {values: ['vector', 'raster', 'geojson', 'video', 'image']},
	                style: style,
	                styleSpec: styleSpec
	            });
	    }
	};


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var getType = __webpack_require__(108);
	var ValidationError = __webpack_require__(104);
	
	module.exports = function validateString(options) {
	    var value = options.value;
	    var key = options.key;
	    var type = getType(value);
	
	    if (type !== 'string') {
	        return [new ValidationError(key, value, 'string expected, %s found', type)];
	    }
	
	    return [];
	};


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(126);


/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = {
		"$version": 8,
		"$root": {
			"version": {
				"required": true,
				"type": "enum",
				"values": [
					8
				]
			},
			"name": {
				"type": "string"
			},
			"metadata": {
				"type": "*"
			},
			"center": {
				"type": "array",
				"value": "number"
			},
			"zoom": {
				"type": "number"
			},
			"bearing": {
				"type": "number",
				"default": 0,
				"period": 360,
				"units": "degrees"
			},
			"pitch": {
				"type": "number",
				"default": 0,
				"units": "degrees"
			},
			"sources": {
				"required": true,
				"type": "sources"
			},
			"sprite": {
				"type": "string"
			},
			"glyphs": {
				"type": "string"
			},
			"transition": {
				"type": "transition"
			},
			"layers": {
				"required": true,
				"type": "array",
				"value": "layer"
			}
		},
		"sources": {
			"*": {
				"type": "source"
			}
		},
		"source": [
			"source_tile",
			"source_geojson",
			"source_video",
			"source_image"
		],
		"source_tile": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"vector",
					"raster"
				]
			},
			"url": {
				"type": "string"
			},
			"tiles": {
				"type": "array",
				"value": "string"
			},
			"minzoom": {
				"type": "number",
				"default": 0
			},
			"maxzoom": {
				"type": "number",
				"default": 22
			},
			"tileSize": {
				"type": "number",
				"default": 512,
				"units": "pixels"
			},
			"*": {
				"type": "*"
			}
		},
		"source_geojson": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"geojson"
				]
			},
			"data": {
				"type": "*"
			},
			"maxzoom": {
				"type": "number",
				"default": 14
			},
			"buffer": {
				"type": "number",
				"default": 64
			},
			"tolerance": {
				"type": "number",
				"default": 3
			},
			"cluster": {
				"type": "boolean",
				"default": false
			},
			"clusterRadius": {
				"type": "number",
				"default": 400
			},
			"clusterMaxZoom": {
				"type": "number"
			}
		},
		"source_video": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"video"
				]
			},
			"urls": {
				"required": true,
				"type": "array",
				"value": "string"
			},
			"coordinates": {
				"required": true,
				"type": "array",
				"length": 4,
				"value": {
					"type": "array",
					"length": 2,
					"value": "number"
				}
			}
		},
		"source_image": {
			"type": {
				"required": true,
				"type": "enum",
				"values": [
					"image"
				]
			},
			"url": {
				"required": true,
				"type": "string"
			},
			"coordinates": {
				"required": true,
				"type": "array",
				"length": 4,
				"value": {
					"type": "array",
					"length": 2,
					"value": "number"
				}
			}
		},
		"layer": {
			"id": {
				"type": "string",
				"required": true
			},
			"type": {
				"type": "enum",
				"values": [
					"fill",
					"line",
					"symbol",
					"circle",
					"raster",
					"background"
				]
			},
			"metadata": {
				"type": "*"
			},
			"ref": {
				"type": "string"
			},
			"source": {
				"type": "string"
			},
			"source-layer": {
				"type": "string"
			},
			"minzoom": {
				"type": "number",
				"minimum": 0,
				"maximum": 22
			},
			"maxzoom": {
				"type": "number",
				"minimum": 0,
				"maximum": 22
			},
			"interactive": {
				"type": "boolean",
				"default": false
			},
			"filter": {
				"type": "filter"
			},
			"layout": {
				"type": "layout"
			},
			"paint": {
				"type": "paint"
			},
			"paint.*": {
				"type": "paint"
			}
		},
		"layout": [
			"layout_fill",
			"layout_line",
			"layout_circle",
			"layout_symbol",
			"layout_raster",
			"layout_background"
		],
		"layout_background": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible"
			}
		},
		"layout_fill": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible"
			}
		},
		"layout_circle": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible"
			}
		},
		"layout_line": {
			"line-cap": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"butt",
					"round",
					"square"
				],
				"default": "butt"
			},
			"line-join": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"bevel",
					"round",
					"miter"
				],
				"default": "miter"
			},
			"line-miter-limit": {
				"type": "number",
				"default": 2,
				"function": "interpolated",
				"requires": [
					{
						"line-join": "miter"
					}
				]
			},
			"line-round-limit": {
				"type": "number",
				"default": 1.05,
				"function": "interpolated",
				"requires": [
					{
						"line-join": "round"
					}
				]
			},
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible"
			}
		},
		"layout_symbol": {
			"symbol-placement": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"point",
					"line"
				],
				"default": "point"
			},
			"symbol-spacing": {
				"type": "number",
				"default": 250,
				"minimum": 1,
				"function": "interpolated",
				"units": "pixels",
				"requires": [
					{
						"symbol-placement": "line"
					}
				]
			},
			"symbol-avoid-edges": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false
			},
			"icon-allow-overlap": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"requires": [
					"icon-image"
				]
			},
			"icon-ignore-placement": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"requires": [
					"icon-image"
				]
			},
			"icon-optional": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"requires": [
					"icon-image",
					"text-field"
				]
			},
			"icon-rotation-alignment": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "viewport",
				"requires": [
					"icon-image"
				]
			},
			"icon-size": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"function": "interpolated",
				"requires": [
					"icon-image"
				]
			},
			"icon-image": {
				"type": "string",
				"function": "piecewise-constant",
				"tokens": true
			},
			"icon-rotate": {
				"type": "number",
				"default": 0,
				"period": 360,
				"function": "interpolated",
				"units": "degrees",
				"requires": [
					"icon-image"
				]
			},
			"icon-padding": {
				"type": "number",
				"default": 2,
				"minimum": 0,
				"function": "interpolated",
				"units": "pixels",
				"requires": [
					"icon-image"
				]
			},
			"icon-keep-upright": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"requires": [
					"icon-image",
					{
						"icon-rotation-alignment": "map"
					},
					{
						"symbol-placement": "line"
					}
				]
			},
			"icon-offset": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"requires": [
					"icon-image"
				]
			},
			"text-rotation-alignment": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "viewport",
				"requires": [
					"text-field"
				]
			},
			"text-field": {
				"type": "string",
				"function": "piecewise-constant",
				"default": "",
				"tokens": true
			},
			"text-font": {
				"type": "array",
				"value": "string",
				"function": "piecewise-constant",
				"default": [
					"Open Sans Regular",
					"Arial Unicode MS Regular"
				],
				"requires": [
					"text-field"
				]
			},
			"text-size": {
				"type": "number",
				"default": 16,
				"minimum": 0,
				"units": "pixels",
				"function": "interpolated",
				"requires": [
					"text-field"
				]
			},
			"text-max-width": {
				"type": "number",
				"default": 10,
				"minimum": 0,
				"units": "em",
				"function": "interpolated",
				"requires": [
					"text-field"
				]
			},
			"text-line-height": {
				"type": "number",
				"default": 1.2,
				"units": "em",
				"function": "interpolated",
				"requires": [
					"text-field"
				]
			},
			"text-letter-spacing": {
				"type": "number",
				"default": 0,
				"units": "em",
				"function": "interpolated",
				"requires": [
					"text-field"
				]
			},
			"text-justify": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"left",
					"center",
					"right"
				],
				"default": "center",
				"requires": [
					"text-field"
				]
			},
			"text-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"center",
					"left",
					"right",
					"top",
					"bottom",
					"top-left",
					"top-right",
					"bottom-left",
					"bottom-right"
				],
				"default": "center",
				"requires": [
					"text-field"
				]
			},
			"text-max-angle": {
				"type": "number",
				"default": 45,
				"units": "degrees",
				"function": "interpolated",
				"requires": [
					"text-field",
					{
						"symbol-placement": "line"
					}
				]
			},
			"text-rotate": {
				"type": "number",
				"default": 0,
				"period": 360,
				"units": "degrees",
				"function": "interpolated",
				"requires": [
					"text-field"
				]
			},
			"text-padding": {
				"type": "number",
				"default": 2,
				"minimum": 0,
				"units": "pixels",
				"function": "interpolated",
				"requires": [
					"text-field"
				]
			},
			"text-keep-upright": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": true,
				"requires": [
					"text-field",
					{
						"text-rotation-alignment": "map"
					},
					{
						"symbol-placement": "line"
					}
				]
			},
			"text-transform": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"none",
					"uppercase",
					"lowercase"
				],
				"default": "none",
				"requires": [
					"text-field"
				]
			},
			"text-offset": {
				"type": "array",
				"value": "number",
				"units": "ems",
				"function": "interpolated",
				"length": 2,
				"default": [
					0,
					0
				],
				"requires": [
					"text-field"
				]
			},
			"text-allow-overlap": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"requires": [
					"text-field"
				]
			},
			"text-ignore-placement": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"requires": [
					"text-field"
				]
			},
			"text-optional": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": false,
				"requires": [
					"text-field",
					"icon-image"
				]
			},
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible"
			}
		},
		"layout_raster": {
			"visibility": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"visible",
					"none"
				],
				"default": "visible"
			}
		},
		"filter": {
			"type": "array",
			"value": "*"
		},
		"filter_operator": {
			"type": "enum",
			"values": [
				"==",
				"!=",
				">",
				">=",
				"<",
				"<=",
				"in",
				"!in",
				"all",
				"any",
				"none"
			]
		},
		"geometry_type": {
			"type": "enum",
			"values": [
				"Point",
				"LineString",
				"Polygon"
			]
		},
		"color_operation": {
			"type": "enum",
			"values": [
				"lighten",
				"saturate",
				"spin",
				"fade",
				"mix"
			]
		},
		"function": {
			"stops": {
				"type": "array",
				"required": true,
				"value": "function_stop"
			},
			"base": {
				"type": "number",
				"default": 1,
				"minimum": 0
			},
			"property": {
				"type": "string",
				"default": "$zoom"
			},
			"type": {
				"type": "enum",
				"values": [
					"exponential",
					"interval",
					"categorical"
				],
				"default": "exponential"
			}
		},
		"function_stop": {
			"type": "array",
			"minimum": 0,
			"maximum": 22,
			"value": [
				"number",
				"color"
			],
			"length": 2
		},
		"paint": [
			"paint_fill",
			"paint_line",
			"paint_circle",
			"paint_symbol",
			"paint_raster",
			"paint_background"
		],
		"paint_fill": {
			"fill-antialias": {
				"type": "boolean",
				"function": "piecewise-constant",
				"default": true
			},
			"fill-opacity": {
				"type": "number",
				"function": "interpolated",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"transition": true
			},
			"fill-color": {
				"type": "color",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "fill-pattern"
					}
				]
			},
			"fill-outline-color": {
				"type": "color",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "fill-pattern"
					},
					{
						"fill-antialias": true
					}
				]
			},
			"fill-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"fill-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "map",
				"requires": [
					"fill-translate"
				]
			},
			"fill-pattern": {
				"type": "string",
				"function": "piecewise-constant",
				"transition": true
			}
		},
		"paint_line": {
			"line-opacity": {
				"type": "number",
				"function": "interpolated",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"transition": true
			},
			"line-color": {
				"type": "color",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "line-pattern"
					}
				]
			},
			"line-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"line-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "map",
				"requires": [
					"line-translate"
				]
			},
			"line-width": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"line-gap-width": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"line-offset": {
				"type": "number",
				"default": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"line-blur": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"line-dasharray": {
				"type": "array",
				"value": "number",
				"function": "piecewise-constant",
				"minimum": 0,
				"transition": true,
				"units": "line widths",
				"requires": [
					{
						"!": "line-pattern"
					}
				]
			},
			"line-pattern": {
				"type": "string",
				"function": "piecewise-constant",
				"transition": true
			}
		},
		"paint_circle": {
			"circle-radius": {
				"type": "number",
				"default": 5,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"circle-color": {
				"type": "color",
				"default": "#000000",
				"function": "interpolated",
				"transition": true
			},
			"circle-blur": {
				"type": "number",
				"default": 0,
				"function": "interpolated",
				"transition": true
			},
			"circle-opacity": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"circle-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels"
			},
			"circle-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "map",
				"requires": [
					"circle-translate"
				]
			}
		},
		"paint_symbol": {
			"icon-opacity": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true,
				"requires": [
					"icon-image"
				]
			},
			"icon-color": {
				"type": "color",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"requires": [
					"icon-image"
				]
			},
			"icon-halo-color": {
				"type": "color",
				"default": "rgba(0, 0, 0, 0)",
				"function": "interpolated",
				"transition": true,
				"requires": [
					"icon-image"
				]
			},
			"icon-halo-width": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"requires": [
					"icon-image"
				]
			},
			"icon-halo-blur": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"requires": [
					"icon-image"
				]
			},
			"icon-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"requires": [
					"icon-image"
				]
			},
			"icon-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "map",
				"requires": [
					"icon-image",
					"icon-translate"
				]
			},
			"text-opacity": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true,
				"requires": [
					"text-field"
				]
			},
			"text-color": {
				"type": "color",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"requires": [
					"text-field"
				]
			},
			"text-halo-color": {
				"type": "color",
				"default": "rgba(0, 0, 0, 0)",
				"function": "interpolated",
				"transition": true,
				"requires": [
					"text-field"
				]
			},
			"text-halo-width": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"requires": [
					"text-field"
				]
			},
			"text-halo-blur": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"requires": [
					"text-field"
				]
			},
			"text-translate": {
				"type": "array",
				"value": "number",
				"length": 2,
				"default": [
					0,
					0
				],
				"function": "interpolated",
				"transition": true,
				"units": "pixels",
				"requires": [
					"text-field"
				]
			},
			"text-translate-anchor": {
				"type": "enum",
				"function": "piecewise-constant",
				"values": [
					"map",
					"viewport"
				],
				"default": "map",
				"requires": [
					"text-field",
					"text-translate"
				]
			}
		},
		"paint_raster": {
			"raster-opacity": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"raster-hue-rotate": {
				"type": "number",
				"default": 0,
				"period": 360,
				"function": "interpolated",
				"transition": true,
				"units": "degrees"
			},
			"raster-brightness-min": {
				"type": "number",
				"function": "interpolated",
				"default": 0,
				"minimum": 0,
				"maximum": 1,
				"transition": true
			},
			"raster-brightness-max": {
				"type": "number",
				"function": "interpolated",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"transition": true
			},
			"raster-saturation": {
				"type": "number",
				"default": 0,
				"minimum": -1,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"raster-contrast": {
				"type": "number",
				"default": 0,
				"minimum": -1,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			},
			"raster-fade-duration": {
				"type": "number",
				"default": 300,
				"minimum": 0,
				"function": "interpolated",
				"transition": true,
				"units": "milliseconds"
			}
		},
		"paint_background": {
			"background-color": {
				"type": "color",
				"default": "#000000",
				"function": "interpolated",
				"transition": true,
				"requires": [
					{
						"!": "background-pattern"
					}
				]
			},
			"background-pattern": {
				"type": "string",
				"function": "piecewise-constant",
				"transition": true
			},
			"background-opacity": {
				"type": "number",
				"default": 1,
				"minimum": 0,
				"maximum": 1,
				"function": "interpolated",
				"transition": true
			}
		},
		"transition": {
			"duration": {
				"type": "number",
				"default": 300,
				"minimum": 0,
				"units": "milliseconds"
			},
			"delay": {
				"type": "number",
				"default": 0,
				"minimum": 0,
				"units": "milliseconds"
			}
		}
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ValidationError = __webpack_require__(104);
	var validateString = __webpack_require__(124);
	
	module.exports = function(options) {
	    var value = options.value;
	    var key = options.key;
	
	    var errors = validateString(options);
	    if (errors.length) return errors;
	
	    if (value.indexOf('{fontstack}') === -1) {
	        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
	    }
	
	    if (value.indexOf('{range}') === -1) {
	        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
	    }
	
	    return errors;
	};


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var StyleLayer = __webpack_require__(90);
	
	function BackgroundStyleLayer() {
	    StyleLayer.apply(this, arguments);
	}
	
	module.exports = BackgroundStyleLayer;
	
	BackgroundStyleLayer.prototype = util.inherit(StyleLayer, {});


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var StyleLayer = __webpack_require__(90);
	
	function CircleStyleLayer() {
	    StyleLayer.apply(this, arguments);
	}
	
	module.exports = CircleStyleLayer;
	
	CircleStyleLayer.prototype = util.inherit(StyleLayer, {});


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var StyleLayer = __webpack_require__(90);
	
	function FillStyleLayer() {
	    StyleLayer.apply(this, arguments);
	}
	
	module.exports = FillStyleLayer;
	
	FillStyleLayer.prototype = util.inherit(StyleLayer, {});


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var StyleLayer = __webpack_require__(90);
	
	function LineStyleLayer() {
	    StyleLayer.apply(this, arguments);
	}
	
	module.exports = LineStyleLayer;
	
	LineStyleLayer.prototype = util.inherit(StyleLayer, {
	
	    getPaintValue: function(name, globalProperties, featureProperties) {
	        var value = StyleLayer.prototype.getPaintValue.apply(this, arguments);
	
	        // If the line is dashed, scale the dash lengths by the line
	        // width at the previous round zoom level.
	        if (value && name === 'line-dasharray') {
	            var flooredZoom = Math.floor(globalProperties.zoom);
	            if (this._flooredZoom !== flooredZoom) {
	                this._flooredZoom = flooredZoom;
	                this._flooredLineWidth = this.getPaintValue('line-width', globalProperties, featureProperties);
	            }
	
	            value.fromScale *= this._flooredLineWidth;
	            value.toScale *= this._flooredLineWidth;
	        }
	
	        return value;
	    }
	});


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var StyleLayer = __webpack_require__(90);
	
	function RasterStyleLayer() {
	    StyleLayer.apply(this, arguments);
	}
	
	module.exports = RasterStyleLayer;
	
	RasterStyleLayer.prototype = util.inherit(StyleLayer, {});


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var StyleLayer = __webpack_require__(90);
	
	function SymbolStyleLayer() {
	    StyleLayer.apply(this, arguments);
	}
	
	module.exports = SymbolStyleLayer;
	
	SymbolStyleLayer.prototype = util.inherit(StyleLayer, {
	
	    isHidden: function() {
	        if (StyleLayer.prototype.isHidden.apply(this, arguments)) return true;
	
	        var isTextHidden = this.paint['text-opacity'] === 0 || !this.layout['text-field'];
	        var isIconHidden = this.paint['icon-opacity'] === 0 || !this.layout['icon-image'];
	        if (isTextHidden && isIconHidden) return true;
	
	        return false;
	    },
	
	    getLayoutValue: function(name, globalProperties, featureProperties) {
	        if (name === 'text-rotation-alignment' &&
	                this.getLayoutValue('symbol-placement', globalProperties, featureProperties) === 'line' &&
	                !this.getLayoutProperty('text-rotation-alignment')) {
	            return 'map';
	        } else if (name === 'icon-rotation-alignment' &&
	                this.getLayoutValue('symbol-placement', globalProperties, featureProperties) === 'line' &&
	                !this.getLayoutProperty('icon-rotation-alignment')) {
	            return 'map';
	        } else {
	            return StyleLayer.prototype.getLayoutValue.apply(this, arguments);
	        }
	    }
	
	});


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Evented = __webpack_require__(86);
	var ajax = __webpack_require__(135);
	var browser = __webpack_require__(85);
	var normalizeURL = __webpack_require__(136).normalizeSpriteURL;
	
	module.exports = ImageSprite;
	
	function ImageSprite(base) {
	    this.base = base;
	    this.retina = browser.devicePixelRatio > 1;
	
	    var format = this.retina ? '@2x' : '';
	
	    ajax.getJSON(normalizeURL(base, format, '.json'), function(err, data) {
	        if (err) {
	            this.fire('error', {error: err});
	            return;
	        }
	
	        this.data = data;
	        if (this.img) this.fire('load');
	    }.bind(this));
	
	    ajax.getImage(normalizeURL(base, format, '.png'), function(err, img) {
	        if (err) {
	            this.fire('error', {error: err});
	            return;
	        }
	
	        // premultiply the sprite
	        var data = img.getData();
	        var newdata = img.data = new Uint8Array(data.length);
	        for (var i = 0; i < data.length; i += 4) {
	            var alpha = data[i + 3] / 255;
	            newdata[i + 0] = data[i + 0] * alpha;
	            newdata[i + 1] = data[i + 1] * alpha;
	            newdata[i + 2] = data[i + 2] * alpha;
	            newdata[i + 3] = data[i + 3];
	        }
	
	        this.img = img;
	        if (this.data) this.fire('load');
	    }.bind(this));
	}
	
	ImageSprite.prototype = Object.create(Evented);
	
	ImageSprite.prototype.toJSON = function() {
	    return this.base;
	};
	
	ImageSprite.prototype.loaded = function() {
	    return !!(this.data && this.img);
	};
	
	ImageSprite.prototype.resize = function(/*gl*/) {
	    if (browser.devicePixelRatio > 1 !== this.retina) {
	        var newSprite = new ImageSprite(this.base);
	        newSprite.on('load', function() {
	            this.img = newSprite.img;
	            this.data = newSprite.data;
	            this.retina = newSprite.retina;
	        }.bind(this));
	    }
	};
	
	function SpritePosition() {}
	SpritePosition.prototype = { x: 0, y: 0, width: 0, height: 0, pixelRatio: 1, sdf: false };
	
	ImageSprite.prototype.getSpritePosition = function(name) {
	    if (!this.loaded()) return new SpritePosition();
	
	    var pos = this.data && this.data[name];
	    if (pos && this.img) return pos;
	
	    return new SpritePosition();
	};


/***/ },
/* 135 */
/***/ function(module, exports) {

	'use strict';
	
	exports.getJSON = function(url, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.setRequestHeader('Accept', 'application/json');
	    xhr.onerror = function(e) {
	        callback(e);
	    };
	    xhr.onload = function() {
	        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
	            var data;
	            try {
	                data = JSON.parse(xhr.response);
	            } catch (err) {
	                return callback(err);
	            }
	            callback(null, data);
	        } else {
	            callback(new Error(xhr.statusText));
	        }
	    };
	    xhr.send();
	    return xhr;
	};
	
	exports.getArrayBuffer = function(url, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.responseType = 'arraybuffer';
	    xhr.onerror = function(e) {
	        callback(e);
	    };
	    xhr.onload = function() {
	        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
	            callback(null, xhr.response);
	        } else {
	            callback(new Error(xhr.statusText));
	        }
	    };
	    xhr.send();
	    return xhr;
	};
	
	function sameOrigin(url) {
	    var a = document.createElement('a');
	    a.href = url;
	    return a.protocol === document.location.protocol && a.host === document.location.host;
	}
	
	exports.getImage = function(url, callback) {
	    return exports.getArrayBuffer(url, function(err, imgData) {
	        if (err) return callback(err);
	        var img = new Image();
	        img.onload = function() {
	            callback(null, img);
	            (window.URL || window.webkitURL).revokeObjectURL(img.src);
	        };
	        var blob = new Blob([new Uint8Array(imgData)], { type: 'image/png' });
	        img.src = (window.URL || window.webkitURL).createObjectURL(blob);
	        img.getData = function() {
	            var canvas = document.createElement('canvas');
	            var context = canvas.getContext('2d');
	            canvas.width = img.width;
	            canvas.height = img.height;
	            context.drawImage(img, 0, 0);
	            return context.getImageData(0, 0, img.width, img.height).data;
	        };
	        return img;
	    });
	};
	
	exports.getVideo = function(urls, callback) {
	    var video = document.createElement('video');
	    video.onloadstart = function() {
	        callback(null, video);
	    };
	    for (var i = 0; i < urls.length; i++) {
	        var s = document.createElement('source');
	        if (!sameOrigin(urls[i])) {
	            video.crossOrigin = 'Anonymous';
	        }
	        s.src = urls[i];
	        video.appendChild(s);
	    }
	    video.getData = function() { return video; };
	    return video;
	};


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var config = __webpack_require__(137);
	var browser = __webpack_require__(85);
	
	function normalizeURL(url, pathPrefix, accessToken) {
	    accessToken = accessToken || config.ACCESS_TOKEN;
	
	    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
	        throw new Error('An API access token is required to use Mapbox GL. ' +
	            'See https://www.mapbox.com/developers/api/#access-tokens');
	    }
	
	    url = url.replace(/^mapbox:\/\//, config.API_URL + pathPrefix);
	    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';
	
	    if (config.REQUIRE_ACCESS_TOKEN) {
	        if (accessToken[0] === 's') {
	            throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
	                'See https://www.mapbox.com/developers/api/#access-tokens');
	        }
	
	        url += accessToken;
	    }
	
	    return url;
	}
	
	module.exports.normalizeStyleURL = function(url, accessToken) {
	    if (!url.match(/^mapbox:\/\/styles\//))
	        return url;
	
	    var split = url.split('/');
	    var user = split[3];
	    var style = split[4];
	    var draft = split[5] ? '/draft' : '';
	    return normalizeURL('mapbox://' + user + '/' + style + draft, '/styles/v1/', accessToken);
	};
	
	module.exports.normalizeSourceURL = function(url, accessToken) {
	    if (!url.match(/^mapbox:\/\//))
	        return url;
	
	    // TileJSON requests need a secure flag appended to their URLs so
	    // that the server knows to send SSL-ified resource references.
	    return normalizeURL(url + '.json', '/v4/', accessToken) + '&secure';
	};
	
	module.exports.normalizeGlyphsURL = function(url, accessToken) {
	    if (!url.match(/^mapbox:\/\//))
	        return url;
	
	    var user = url.split('/')[3];
	    return normalizeURL('mapbox://' + user + '/{fontstack}/{range}.pbf', '/fonts/v1/', accessToken);
	};
	
	module.exports.normalizeSpriteURL = function(url, format, ext, accessToken) {
	    if (!url.match(/^mapbox:\/\/sprites\//))
	        return url + format + ext;
	
	    var split = url.split('/');
	    var user = split[3];
	    var style = split[4];
	    var draft = split[5] ? '/draft' : '';
	    return normalizeURL('mapbox://' + user + '/' + style + draft + '/sprite' + format + ext, '/styles/v1/', accessToken);
	};
	
	module.exports.normalizeTileURL = function(url, sourceUrl, tileSize) {
	    if (!sourceUrl || !sourceUrl.match(/^mapbox:\/\//))
	        return url;
	
	    // The v4 mapbox tile API supports 512x512 image tiles only when @2x
	    // is appended to the tile URL. If `tileSize: 512` is specified for
	    // a Mapbox raster source force the @2x suffix even if a non hidpi
	    // device.
	    url = url.replace(/([?&]access_token=)tk\.[^&]+/, '$1' + config.ACCESS_TOKEN);
	    var extension = browser.supportsWebp ? 'webp' : '$1';
	    return url.replace(/\.((?:png|jpg)\d*)(?=$|\?)/, browser.devicePixelRatio >= 2 || tileSize === 512 ? '@2x.' + extension : '.' + extension);
	};


/***/ },
/* 137 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    API_URL: 'https://api.mapbox.com',
	    REQUIRE_ACCESS_TOKEN: true
	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var normalizeURL = __webpack_require__(136).normalizeGlyphsURL;
	var getArrayBuffer = __webpack_require__(135).getArrayBuffer;
	var Glyphs = __webpack_require__(139);
	var GlyphAtlas = __webpack_require__(140);
	var Protobuf = __webpack_require__(142);
	
	module.exports = GlyphSource;
	
	/**
	 * A glyph source has a URL from which to load new glyphs and manages
	 * GlyphAtlases in which to store glyphs used by the requested fontstacks
	 * and ranges.
	 *
	 * @param {string} url glyph template url
	 * @private
	 */
	function GlyphSource(url) {
	    this.url = url && normalizeURL(url);
	    this.atlases = {};
	    this.stacks = {};
	    this.loading = {};
	}
	
	GlyphSource.prototype.getSimpleGlyphs = function(fontstack, glyphIDs, uid, callback) {
	    if (this.stacks[fontstack] === undefined) {
	        this.stacks[fontstack] = {};
	    }
	    if (this.atlases[fontstack] === undefined) {
	        this.atlases[fontstack] = new GlyphAtlas(128, 128);
	    }
	
	    var glyphs = {};
	    var stack = this.stacks[fontstack];
	    var atlas = this.atlases[fontstack];
	
	    // the number of pixels the sdf bitmaps are padded by
	    var buffer = 3;
	
	    var missing = {};
	    var remaining = 0;
	    var range;
	
	    for (var i = 0; i < glyphIDs.length; i++) {
	        var glyphID = glyphIDs[i];
	        range = Math.floor(glyphID / 256);
	
	        if (stack[range]) {
	            var glyph = stack[range].glyphs[glyphID];
	            var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
	            if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
	        } else {
	            if (missing[range] === undefined) {
	                missing[range] = [];
	                remaining++;
	            }
	            missing[range].push(glyphID);
	        }
	    }
	
	    if (!remaining) callback(undefined, glyphs, fontstack);
	
	    var onRangeLoaded = function(err, range, data) {
	        // TODO not be silent about errors
	        if (!err) {
	            var stack = this.stacks[fontstack][range] = data.stacks[0];
	            for (var i = 0; i < missing[range].length; i++) {
	                var glyphID = missing[range][i];
	                var glyph = stack.glyphs[glyphID];
	                var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
	                if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
	            }
	        }
	        remaining--;
	        if (!remaining) callback(undefined, glyphs, fontstack);
	    }.bind(this);
	
	    for (var r in missing) {
	        this.loadRange(fontstack, r, onRangeLoaded);
	    }
	};
	
	// A simplified representation of the glyph containing only the properties needed for shaping.
	function SimpleGlyph(glyph, rect, buffer) {
	    var padding = 1;
	    this.advance = glyph.advance;
	    this.left = glyph.left - buffer - padding;
	    this.top = glyph.top + buffer + padding;
	    this.rect = rect;
	}
	
	GlyphSource.prototype.loadRange = function(fontstack, range, callback) {
	    if (range * 256 > 65535) return callback('glyphs > 65535 not supported');
	
	    if (this.loading[fontstack] === undefined) {
	        this.loading[fontstack] = {};
	    }
	    var loading = this.loading[fontstack];
	
	    if (loading[range]) {
	        loading[range].push(callback);
	    } else {
	        loading[range] = [callback];
	
	        var rangeName = (range * 256) + '-' + (range * 256 + 255);
	        var url = glyphUrl(fontstack, rangeName, this.url);
	
	        getArrayBuffer(url, function(err, data) {
	            var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
	            for (var i = 0; i < loading[range].length; i++) {
	                loading[range][i](err, range, glyphs);
	            }
	            delete loading[range];
	        });
	    }
	};
	
	GlyphSource.prototype.getGlyphAtlas = function(fontstack) {
	    return this.atlases[fontstack];
	};
	
	/**
	 * Use CNAME sharding to load a specific glyph range over a randomized
	 * but consistent subdomain.
	 * @param {string} fontstack comma-joined fonts
	 * @param {string} range comma-joined range
	 * @param {url} url templated url
	 * @param {string} [subdomains=abc] subdomains as a string where each letter is one.
	 * @returns {string} a url to load that section of glyphs
	 * @private
	 */
	function glyphUrl(fontstack, range, url, subdomains) {
	    subdomains = subdomains || 'abc';
	
	    return url
	        .replace('{s}', subdomains[fontstack.length % subdomains.length])
	        .replace('{fontstack}', fontstack)
	        .replace('{range}', range);
	}


/***/ },
/* 139 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = Glyphs;
	
	function Glyphs(pbf, end) {
	    this.stacks = pbf.readFields(readFontstacks, [], end);
	}
	
	function readFontstacks(tag, stacks, pbf) {
	    if (tag === 1) {
	        var fontstack = pbf.readMessage(readFontstack, {glyphs: {}});
	        stacks.push(fontstack);
	    }
	}
	
	function readFontstack(tag, fontstack, pbf) {
	    if (tag === 1) fontstack.name = pbf.readString();
	    else if (tag === 2) fontstack.range = pbf.readString();
	    else if (tag === 3) {
	        var glyph = pbf.readMessage(readGlyph, {});
	        fontstack.glyphs[glyph.id] = glyph;
	    }
	}
	
	function readGlyph(tag, glyph, pbf) {
	    if (tag === 1) glyph.id = pbf.readVarint();
	    else if (tag === 2) glyph.bitmap = pbf.readBytes();
	    else if (tag === 3) glyph.width = pbf.readVarint();
	    else if (tag === 4) glyph.height = pbf.readVarint();
	    else if (tag === 5) glyph.left = pbf.readSVarint();
	    else if (tag === 6) glyph.top = pbf.readSVarint();
	    else if (tag === 7) glyph.advance = pbf.readVarint();
	}


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	var ShelfPack = __webpack_require__(141);
	
	module.exports = GlyphAtlas;
	function GlyphAtlas(width, height) {
	    this.width = width;
	    this.height = height;
	
	    this.bin = new ShelfPack(width, height);
	    this.index = {};
	    this.ids = {};
	    this.data = new Uint8Array(width * height);
	}
	
	GlyphAtlas.prototype.getGlyphs = function() {
	    var glyphs = {},
	        split,
	        name,
	        id;
	
	    for (var key in this.ids) {
	        split = key.split('#');
	        name = split[0];
	        id = split[1];
	
	        if (!glyphs[name]) glyphs[name] = [];
	        glyphs[name].push(id);
	    }
	
	    return glyphs;
	};
	
	GlyphAtlas.prototype.getRects = function() {
	    var rects = {},
	        split,
	        name,
	        id;
	
	    for (var key in this.ids) {
	        split = key.split('#');
	        name = split[0];
	        id = split[1];
	
	        if (!rects[name]) rects[name] = {};
	        rects[name][id] = this.index[key];
	    }
	
	    return rects;
	};
	
	
	GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
	    if (!glyph) {
	        // console.warn('missing glyph', code, String.fromCharCode(code));
	        return null;
	    }
	    var key = name + "#" + glyph.id;
	
	    // The glyph is already in this texture.
	    if (this.index[key]) {
	        if (this.ids[key].indexOf(id) < 0) {
	            this.ids[key].push(id);
	        }
	        return this.index[key];
	    }
	
	    // The glyph bitmap has zero width.
	    if (!glyph.bitmap) {
	        return null;
	    }
	
	    var bufferedWidth = glyph.width + buffer * 2;
	    var bufferedHeight = glyph.height + buffer * 2;
	
	    // Add a 1px border around every image.
	    var padding = 1;
	    var packWidth = bufferedWidth + 2 * padding;
	    var packHeight = bufferedHeight + 2 * padding;
	
	    // Increase to next number divisible by 4, but at least 1.
	    // This is so we can scale down the texture coordinates and pack them
	    // into 2 bytes rather than 4 bytes.
	    packWidth += (4 - packWidth % 4);
	    packHeight += (4 - packHeight % 4);
	
	    var rect = this.bin.packOne(packWidth, packHeight);
	    if (!rect) {
	        this.resize();
	        rect = this.bin.packOne(packWidth, packHeight);
	    }
	    if (!rect) {
	        console.warn('glyph bitmap overflow');
	        return null;
	    }
	
	    this.index[key] = rect;
	    this.ids[key] = [id];
	
	    var target = this.data;
	    var source = glyph.bitmap;
	    for (var y = 0; y < bufferedHeight; y++) {
	        var y1 = this.width * (rect.y + y + padding) + rect.x + padding;
	        var y2 = bufferedWidth * y;
	        for (var x = 0; x < bufferedWidth; x++) {
	            target[y1 + x] = source[y2 + x];
	        }
	    }
	
	    this.dirty = true;
	
	    return rect;
	};
	
	GlyphAtlas.prototype.resize = function() {
	    var origw = this.width,
	        origh = this.height;
	
	    // For now, don't grow the atlas beyond 1024x1024 because of how
	    // texture coords pack into unsigned byte in symbol bucket.
	    if (origw > 512 || origh > 512) return;
	
	    if (this.texture) {
	        if (this.gl) {
	            this.gl.deleteTexture(this.texture);
	        }
	        this.texture = null;
	    }
	
	    this.width *= 2;
	    this.height *= 2;
	    this.bin.resize(this.width, this.height);
	
	    var buf = new ArrayBuffer(this.width * this.height),
	        src, dst;
	    for (var i = 0; i < origh; i++) {
	        src = new Uint8Array(this.data.buffer, origh * i, origw);
	        dst = new Uint8Array(buf, origh * i * 2, origw);
	        dst.set(src);
	    }
	    this.data = new Uint8Array(buf);
	};
	
	GlyphAtlas.prototype.bind = function(gl) {
	    this.gl = gl;
	    if (!this.texture) {
	        this.texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);
	
	    } else {
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	    }
	};
	
	GlyphAtlas.prototype.updateTexture = function(gl) {
	    this.bind(gl);
	    if (this.dirty) {
	        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
	        this.dirty = false;
	    }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 141 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = ShelfPack;
	
	
	/**
	 * Create a new ShelfPack bin allocator.
	 *
	 * Uses the Shelf Best Height Fit algorithm from
	 * http://clb.demon.fi/files/RectangleBinPack.pdf
	 *
	 * @class  ShelfPack
	 * @param  {number}  [w=64]  Initial width of the sprite
	 * @param  {number}  [h=64]  Initial width of the sprite
	 * @param  {Object}  [options]
	 * @param  {boolean} [options.autoResize=false]  If `true`, the sprite will automatically grow
	 * @example
	 * var sprite = new ShelfPack(64, 64, { autoResize: false });
	 */
	function ShelfPack(w, h, options) {
	    options = options || {};
	    this.w = w || 64;
	    this.h = h || 64;
	    this.autoResize = !!options.autoResize;
	    this.shelves = [];
	    this.stats = {};
	    this.count = function(h) {
	        this.stats[h] = (this.stats[h] | 0) + 1;
	    };
	}
	
	/**
	 * Batch pack multiple bins into the sprite.
	 *
	 * @param   {Array}   bins Array of requested bins - each object should have `width`, `height` (or `w`, `h`) properties
	 * @param   {Object}  [options]
	 * @param   {boolean} [options.inPlace=false] If `true`, the supplied bin objects will be updated inplace with `x` and `y` properties
	 * @returns {Array}   Array of allocated bins - each bin is an object with `x`, `y`, `w`, `h` properties
	 * @example
	 * var bins = [
	 *     { id: 'a', width: 12, height: 12 },
	 *     { id: 'b', width: 12, height: 16 },
	 *     { id: 'c', width: 12, height: 24 }
	 * ];
	 * var results = sprite.pack(bins, { inPlace: false });
	 */
	ShelfPack.prototype.pack = function(bins, options) {
	    bins = [].concat(bins);
	    options = options || {};
	
	    var results = [],
	        w, h, allocation;
	
	    for (var i = 0; i < bins.length; i++) {
	        w = bins[i].w || bins[i].width;
	        h = bins[i].h || bins[i].height;
	        if (w && h) {
	            allocation = this.packOne(w, h);
	            if (!allocation) {
	                continue;
	            }
	            if (options.inPlace) {
	                bins[i].x = allocation.x;
	                bins[i].y = allocation.y;
	            }
	            results.push(allocation);
	        }
	    }
	
	    return results;
	};
	
	/**
	 * Pack a single bin into the sprite.
	 *
	 * @param   {number}  w   Width of the bin to allocate
	 * @param   {number}  h   Height of the bin to allocate
	 * @returns {Object}  Allocated bin object with `x`, `y`, `w`, `h` properties, or `null` if allocation failed
	 * @example
	 * var results = sprite.packOne(12, 16);
	 */
	ShelfPack.prototype.packOne = function(w, h) {
	    var y = 0,
	        best = { shelf: -1, waste: Infinity },
	        shelf, waste;
	
	    // find the best shelf
	    for (var i = 0; i < this.shelves.length; i++) {
	        shelf = this.shelves[i];
	        y += shelf.h;
	
	        // exactly the right height with width to spare, pack it..
	        if (h === shelf.h && w <= shelf.free) {
	            this.count(h);
	            return shelf.alloc(w, h);
	        }
	        // not enough height or width, skip it..
	        if (h > shelf.h || w > shelf.free) {
	            continue;
	        }
	        // maybe enough height or width, minimize waste..
	        if (h < shelf.h && w <= shelf.free) {
	            waste = shelf.h - h;
	            if (waste < best.waste) {
	                best.waste = waste;
	                best.shelf = i;
	            }
	        }
	    }
	
	    if (best.shelf !== -1) {
	        shelf = this.shelves[best.shelf];
	        this.count(h);
	        return shelf.alloc(w, h);
	    }
	
	    // add shelf..
	    if (h <= (this.h - y) && w <= this.w) {
	        shelf = new Shelf(y, this.w, h);
	        this.shelves.push(shelf);
	        this.count(h);
	        return shelf.alloc(w, h);
	    }
	
	    // no more space..
	    // If `autoResize` option is set, grow the sprite as follows:
	    //  * double whichever sprite dimension is smaller (`w1` or `h1`)
	    //  * if sprite dimensions are equal, grow width before height
	    //  * accomodate very large bin requests (big `w` or `h`)
	    if (this.autoResize) {
	        var h1, h2, w1, w2;
	
	        h1 = h2 = this.h;
	        w1 = w2 = this.w;
	
	        if (w1 <= h1 || w > w1) {   // grow width..
	            w2 = Math.max(w, w1) * 2;
	        }
	        if (h1 < w1 || h > h1) {    // grow height..
	            h2 = Math.max(h, h1) * 2;
	        }
	
	        this.resize(w2, h2);
	        return this.packOne(w, h);  // retry
	    }
	
	    return null;
	};
	
	/**
	 * Clear the sprite.
	 *
	 * @example
	 * sprite.clear();
	 */
	ShelfPack.prototype.clear = function() {
	    this.shelves = [];
	    this.stats = {};
	};
	
	/**
	 * Resize the sprite.
	 * The resize will fail if the requested dimensions are smaller than the current sprite dimensions.
	 *
	 * @param   {number}  w  Requested new sprite width
	 * @param   {number}  h  Requested new sprite height
	 * @returns {boolean} `true` if resize succeeded, `false` if failed
	 * @example
	 * sprite.resize(256, 256);
	 */
	ShelfPack.prototype.resize = function(w, h) {
	    if (w < this.w || h < this.h) {
	        return false;
	    }
	
	    this.w = w;
	    this.h = h;
	    for (var i = 0; i < this.shelves.length; i++) {
	        this.shelves[i].resize(w);
	    }
	    return true;
	};
	
	
	
	/**
	 * Create a new Shelf.
	 *
	 * @private
	 * @class  Shelf
	 * @param  {number}  y   Top coordinate of the new shelf
	 * @param  {number}  w   Width of the new shelf
	 * @param  {number}  h   Height of the new shelf
	 * @example
	 * var shelf = new Shelf(64, 512, 24);
	 */
	function Shelf(y, w, h) {
	    this.x = 0;
	    this.y = y;
	    this.w = this.free = w;
	    this.h = h;
	}
	
	/**
	 * Allocate a single bin into the shelf.
	 *
	 * @private
	 * @param   {number}  w   Width of the bin to allocate
	 * @param   {number}  h   Height of the bin to allocate
	 * @returns {Object}  Allocated bin object with `x`, `y`, `w`, `h` properties, or `null` if allocation failed
	 * @example
	 * shelf.alloc(12, 16);
	 */
	Shelf.prototype.alloc = function(w, h) {
	    if (w > this.free || h > this.h) {
	        return null;
	    }
	    var x = this.x;
	    this.x += w;
	    this.free -= w;
	    return { x: x, y: this.y, w: w, h: h, width: w, height: h };
	};
	
	/**
	 * Resize the shelf.
	 * The resize will fail if the requested width is smaller than the current shelf width.
	 *
	 * @private
	 * @param   {number}  w  Requested new width of the shelf
	 * @returns {boolean} true if resize succeeded, false if failed
	 * @example
	 * shelf.resize(512);
	 */
	Shelf.prototype.resize = function(w) {
	    if (w < this.w) {
	        return false;
	    }
	    this.free += (w - this.w);
	    this.w = w;
	    return true;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = Pbf;
	
	var Buffer = global.Buffer || __webpack_require__(143);
	
	function Pbf(buf) {
	    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
	    this.pos = 0;
	    this.length = this.buf.length;
	}
	
	Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
	Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
	Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
	Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32
	
	var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
	    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
	    POW_2_63 = Math.pow(2, 63);
	
	Pbf.prototype = {
	
	    destroy: function() {
	        this.buf = null;
	    },
	
	    // === READING =================================================================
	
	    readFields: function(readField, result, end) {
	        end = end || this.length;
	
	        while (this.pos < end) {
	            var val = this.readVarint(),
	                tag = val >> 3,
	                startPos = this.pos;
	
	            readField(tag, result, this);
	
	            if (this.pos === startPos) this.skip(val);
	        }
	        return result;
	    },
	
	    readMessage: function(readField, result) {
	        return this.readFields(readField, result, this.readVarint() + this.pos);
	    },
	
	    readFixed32: function() {
	        var val = this.buf.readUInt32LE(this.pos);
	        this.pos += 4;
	        return val;
	    },
	
	    readSFixed32: function() {
	        var val = this.buf.readInt32LE(this.pos);
	        this.pos += 4;
	        return val;
	    },
	
	    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
	
	    readFixed64: function() {
	        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
	        this.pos += 8;
	        return val;
	    },
	
	    readSFixed64: function() {
	        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
	        this.pos += 8;
	        return val;
	    },
	
	    readFloat: function() {
	        var val = this.buf.readFloatLE(this.pos);
	        this.pos += 4;
	        return val;
	    },
	
	    readDouble: function() {
	        var val = this.buf.readDoubleLE(this.pos);
	        this.pos += 8;
	        return val;
	    },
	
	    readVarint: function() {
	        var buf = this.buf,
	            val, b, b0, b1, b2, b3;
	
	        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
	        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
	        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
	        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;
	
	        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;
	
	        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
	        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
	        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
	        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
	        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
	        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;
	
	        throw new Error('Expected varint not more than 10 bytes');
	    },
	
	    readVarint64: function() {
	        var startPos = this.pos,
	            val = this.readVarint();
	
	        if (val < POW_2_63) return val;
	
	        var pos = this.pos - 2;
	        while (this.buf[pos] === 0xff) pos--;
	        if (pos < startPos) pos = startPos;
	
	        val = 0;
	        for (var i = 0; i < pos - startPos + 1; i++) {
	            var b = ~this.buf[startPos + i] & 0x7f;
	            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
	        }
	
	        return -val - 1;
	    },
	
	    readSVarint: function() {
	        var num = this.readVarint();
	        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
	    },
	
	    readBoolean: function() {
	        return Boolean(this.readVarint());
	    },
	
	    readString: function() {
	        var end = this.readVarint() + this.pos,
	            str = this.buf.toString('utf8', this.pos, end);
	        this.pos = end;
	        return str;
	    },
	
	    readBytes: function() {
	        var end = this.readVarint() + this.pos,
	            buffer = this.buf.slice(this.pos, end);
	        this.pos = end;
	        return buffer;
	    },
	
	    // verbose for performance reasons; doesn't affect gzipped size
	
	    readPackedVarint: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readVarint());
	        return arr;
	    },
	    readPackedSVarint: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readSVarint());
	        return arr;
	    },
	    readPackedBoolean: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readBoolean());
	        return arr;
	    },
	    readPackedFloat: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readFloat());
	        return arr;
	    },
	    readPackedDouble: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readDouble());
	        return arr;
	    },
	    readPackedFixed32: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readFixed32());
	        return arr;
	    },
	    readPackedSFixed32: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readSFixed32());
	        return arr;
	    },
	    readPackedFixed64: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readFixed64());
	        return arr;
	    },
	    readPackedSFixed64: function() {
	        var end = this.readVarint() + this.pos, arr = [];
	        while (this.pos < end) arr.push(this.readSFixed64());
	        return arr;
	    },
	
	    skip: function(val) {
	        var type = val & 0x7;
	        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
	        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
	        else if (type === Pbf.Fixed32) this.pos += 4;
	        else if (type === Pbf.Fixed64) this.pos += 8;
	        else throw new Error('Unimplemented type: ' + type);
	    },
	
	    // === WRITING =================================================================
	
	    writeTag: function(tag, type) {
	        this.writeVarint((tag << 3) | type);
	    },
	
	    realloc: function(min) {
	        var length = this.length || 16;
	
	        while (length < this.pos + min) length *= 2;
	
	        if (length !== this.length) {
	            var buf = new Buffer(length);
	            this.buf.copy(buf);
	            this.buf = buf;
	            this.length = length;
	        }
	    },
	
	    finish: function() {
	        this.length = this.pos;
	        this.pos = 0;
	        return this.buf.slice(0, this.length);
	    },
	
	    writeFixed32: function(val) {
	        this.realloc(4);
	        this.buf.writeUInt32LE(val, this.pos);
	        this.pos += 4;
	    },
	
	    writeSFixed32: function(val) {
	        this.realloc(4);
	        this.buf.writeInt32LE(val, this.pos);
	        this.pos += 4;
	    },
	
	    writeFixed64: function(val) {
	        this.realloc(8);
	        this.buf.writeInt32LE(val & -1, this.pos);
	        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
	        this.pos += 8;
	    },
	
	    writeSFixed64: function(val) {
	        this.realloc(8);
	        this.buf.writeInt32LE(val & -1, this.pos);
	        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
	        this.pos += 8;
	    },
	
	    writeVarint: function(val) {
	        val = +val;
	
	        if (val <= 0x7f) {
	            this.realloc(1);
	            this.buf[this.pos++] = val;
	
	        } else if (val <= 0x3fff) {
	            this.realloc(2);
	            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
	            this.buf[this.pos++] = ((val >>> 7) & 0x7f);
	
	        } else if (val <= 0x1fffff) {
	            this.realloc(3);
	            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
	            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
	            this.buf[this.pos++] = ((val >>> 14) & 0x7f);
	
	        } else if (val <= 0xfffffff) {
	            this.realloc(4);
	            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
	            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
	            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
	            this.buf[this.pos++] = ((val >>> 21) & 0x7f);
	
	        } else {
	            var pos = this.pos;
	            while (val >= 0x80) {
	                this.realloc(1);
	                this.buf[this.pos++] = (val & 0xff) | 0x80;
	                val /= 0x80;
	            }
	            this.realloc(1);
	            this.buf[this.pos++] = val | 0;
	            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
	        }
	    },
	
	    writeSVarint: function(val) {
	        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
	    },
	
	    writeBoolean: function(val) {
	        this.writeVarint(Boolean(val));
	    },
	
	    writeString: function(str) {
	        str = String(str);
	        var bytes = Buffer.byteLength(str);
	        this.writeVarint(bytes);
	        this.realloc(bytes);
	        this.buf.write(str, this.pos);
	        this.pos += bytes;
	    },
	
	    writeFloat: function(val) {
	        this.realloc(4);
	        this.buf.writeFloatLE(val, this.pos);
	        this.pos += 4;
	    },
	
	    writeDouble: function(val) {
	        this.realloc(8);
	        this.buf.writeDoubleLE(val, this.pos);
	        this.pos += 8;
	    },
	
	    writeBytes: function(buffer) {
	        var len = buffer.length;
	        this.writeVarint(len);
	        this.realloc(len);
	        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
	    },
	
	    writeRawMessage: function(fn, obj) {
	        this.pos++; // reserve 1 byte for short message length
	
	        // write the message directly to the buffer and see how much was written
	        var startPos = this.pos;
	        fn(obj, this);
	        var len = this.pos - startPos;
	
	        var varintLen =
	            len <= 0x7f ? 1 :
	            len <= 0x3fff ? 2 :
	            len <= 0x1fffff ? 3 :
	            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));
	
	        // if 1 byte isn't enough for encoding message length, shift the data to the right
	        if (varintLen > 1) {
	            this.realloc(varintLen - 1);
	            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
	        }
	
	        // finally, write the message length in the reserved place and restore the position
	        this.pos = startPos - 1;
	        this.writeVarint(len);
	        this.pos += len;
	    },
	
	    writeMessage: function(tag, fn, obj) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeRawMessage(fn, obj);
	    },
	
	    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
	    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
	    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
	    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
	    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
	    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
	    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
	    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
	    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },
	
	    writeBytesField: function(tag, buffer) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeBytes(buffer);
	    },
	    writeFixed32Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeFixed32(val);
	    },
	    writeSFixed32Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeSFixed32(val);
	    },
	    writeFixed64Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeFixed64(val);
	    },
	    writeSFixed64Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeSFixed64(val);
	    },
	    writeVarintField: function(tag, val) {
	        this.writeTag(tag, Pbf.Varint);
	        this.writeVarint(val);
	    },
	    writeSVarintField: function(tag, val) {
	        this.writeTag(tag, Pbf.Varint);
	        this.writeSVarint(val);
	    },
	    writeStringField: function(tag, str) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeString(str);
	    },
	    writeFloatField: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeFloat(val);
	    },
	    writeDoubleField: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeDouble(val);
	    },
	    writeBooleanField: function(tag, val) {
	        this.writeVarintField(tag, Boolean(val));
	    }
	};
	
	function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
	function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
	function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
	function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
	function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
	function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
	function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
	function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
	function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	// lightweight Buffer shim for pbf browser build
	// based on code from github.com/feross/buffer (MIT-licensed)
	
	module.exports = Buffer;
	
	var ieee754 = __webpack_require__(146);
	
	var BufferMethods;
	
	function Buffer(length) {
	    var arr;
	    if (length && length.length) {
	        arr = length;
	        length = arr.length;
	    }
	    var buf = new Uint8Array(length || 0);
	    if (arr) buf.set(arr);
	
	    buf.readUInt32LE = BufferMethods.readUInt32LE;
	    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
	    buf.readInt32LE = BufferMethods.readInt32LE;
	    buf.writeInt32LE = BufferMethods.writeInt32LE;
	    buf.readFloatLE = BufferMethods.readFloatLE;
	    buf.writeFloatLE = BufferMethods.writeFloatLE;
	    buf.readDoubleLE = BufferMethods.readDoubleLE;
	    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
	    buf.toString = BufferMethods.toString;
	    buf.write = BufferMethods.write;
	    buf.slice = BufferMethods.slice;
	    buf.copy = BufferMethods.copy;
	
	    buf._isBuffer = true;
	    return buf;
	}
	
	var lastStr, lastStrEncoded;
	
	BufferMethods = {
	    readUInt32LE: function(pos) {
	        return ((this[pos]) |
	            (this[pos + 1] << 8) |
	            (this[pos + 2] << 16)) +
	            (this[pos + 3] * 0x1000000);
	    },
	
	    writeUInt32LE: function(val, pos) {
	        this[pos] = val;
	        this[pos + 1] = (val >>> 8);
	        this[pos + 2] = (val >>> 16);
	        this[pos + 3] = (val >>> 24);
	    },
	
	    readInt32LE: function(pos) {
	        return ((this[pos]) |
	            (this[pos + 1] << 8) |
	            (this[pos + 2] << 16)) +
	            (this[pos + 3] << 24);
	    },
	
	    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
	    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },
	
	    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
	    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },
	
	    toString: function(encoding, start, end) {
	        var str = '',
	            tmp = '';
	
	        start = start || 0;
	        end = Math.min(this.length, end || this.length);
	
	        for (var i = start; i < end; i++) {
	            var ch = this[i];
	            if (ch <= 0x7F) {
	                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
	                tmp = '';
	            } else {
	                tmp += '%' + ch.toString(16);
	            }
	        }
	
	        str += decodeURIComponent(tmp);
	
	        return str;
	    },
	
	    write: function(str, pos) {
	        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
	        for (var i = 0; i < bytes.length; i++) {
	            this[pos + i] = bytes[i];
	        }
	    },
	
	    slice: function(start, end) {
	        return this.subarray(start, end);
	    },
	
	    copy: function(buf, pos) {
	        pos = pos || 0;
	        for (var i = 0; i < this.length; i++) {
	            buf[pos + i] = this[i];
	        }
	    }
	};
	
	BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;
	
	Buffer.byteLength = function(str) {
	    lastStr = str;
	    lastStrEncoded = encodeString(str);
	    return lastStrEncoded.length;
	};
	
	Buffer.isBuffer = function(buf) {
	    return !!(buf && buf._isBuffer);
	};
	
	function encodeString(str) {
	    var length = str.length,
	        bytes = [];
	
	    for (var i = 0, c, lead; i < length; i++) {
	        c = str.charCodeAt(i); // code point
	
	        if (c > 0xD7FF && c < 0xE000) {
	
	            if (lead) {
	                if (c < 0xDC00) {
	                    bytes.push(0xEF, 0xBF, 0xBD);
	                    lead = c;
	                    continue;
	
	                } else {
	                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
	                    lead = null;
	                }
	
	            } else {
	                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
	                else lead = c;
	
	                continue;
	            }
	
	        } else if (lead) {
	            bytes.push(0xEF, 0xBF, 0xBD);
	            lead = null;
	        }
	
	        if (c < 0x80) bytes.push(c);
	        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
	        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
	        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
	    }
	    return bytes;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144).Buffer))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global, console) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(145)
	var ieee754 = __webpack_require__(146)
	var isArray = __webpack_require__(147)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144).Buffer, (function() { return this; }()), __webpack_require__(4)))

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 146 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 147 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	var ShelfPack = __webpack_require__(141);
	var browser = __webpack_require__(85);
	
	module.exports = SpriteAtlas;
	function SpriteAtlas(width, height) {
	    this.width = width;
	    this.height = height;
	
	    this.bin = new ShelfPack(width, height);
	    this.images = {};
	    this.data = false;
	    this.texture = 0; // WebGL ID
	    this.filter = 0; // WebGL ID
	    this.pixelRatio = 1;
	    this.dirty = true;
	}
	
	function copyBitmap(src, srcStride, srcX, srcY, dst, dstStride, dstX, dstY, width, height, wrap) {
	    var srcI = srcY * srcStride + srcX;
	    var dstI = dstY * dstStride + dstX;
	    var x, y;
	
	    if (wrap) {
	        // add 1 pixel wrapped padding on each side of the image
	        dstI -= dstStride;
	        for (y = -1; y <= height; y++, srcI = ((y + height) % height + srcY) * srcStride + srcX, dstI += dstStride) {
	            for (x = -1; x <= width; x++) {
	                dst[dstI + x] = src[srcI + ((x + width) % width)];
	            }
	        }
	
	    } else {
	        for (y = 0; y < height; y++, srcI += srcStride, dstI += dstStride) {
	            for (x = 0; x < width; x++) {
	                dst[dstI + x] = src[srcI + x];
	            }
	        }
	    }
	}
	
	SpriteAtlas.prototype.allocateImage = function(pixelWidth, pixelHeight) {
	
	    pixelWidth = pixelWidth / this.pixelRatio;
	    pixelHeight = pixelHeight / this.pixelRatio;
	
	    // Increase to next number divisible by 4, but at least 1.
	    // This is so we can scale down the texture coordinates and pack them
	    // into 2 bytes rather than 4 bytes.
	    // Pad icons to prevent them from polluting neighbours during linear interpolation
	    var padding = 2;
	    var packWidth = pixelWidth + padding + (4 - (pixelWidth + padding) % 4);
	    var packHeight = pixelHeight + padding + (4 - (pixelHeight + padding) % 4);// + 4;
	
	    var rect = this.bin.packOne(packWidth, packHeight);
	    if (!rect) {
	        console.warn('SpriteAtlas out of space.');
	        return null;
	    }
	
	    return rect;
	};
	
	SpriteAtlas.prototype.getImage = function(name, wrap) {
	    if (this.images[name]) {
	        return this.images[name];
	    }
	
	    if (!this.sprite) {
	        return null;
	    }
	
	    var pos = this.sprite.getSpritePosition(name);
	    if (!pos.width || !pos.height) {
	        return null;
	    }
	
	    var rect = this.allocateImage(pos.width, pos.height);
	    if (!rect) {
	        return null;
	    }
	
	    var image = new AtlasImage(rect, pos.width / pos.pixelRatio, pos.height / pos.pixelRatio, pos.sdf, pos.pixelRatio / this.pixelRatio);
	    this.images[name] = image;
	
	    this.copy(rect, pos, wrap);
	
	    return image;
	};
	
	
	// Return position of a repeating fill pattern.
	SpriteAtlas.prototype.getPosition = function(name, repeating) {
	    var image = this.getImage(name, repeating);
	    var rect = image && image.rect;
	
	    if (!rect) {
	        return null;
	    }
	
	    var width = image.width * image.pixelRatio;
	    var height = image.height * image.pixelRatio;
	    var padding = 1;
	
	    return {
	        size: [image.width, image.height],
	        tl: [(rect.x + padding)         / this.width, (rect.y + padding)          / this.height],
	        br: [(rect.x + padding + width) / this.width, (rect.y + padding + height) / this.height]
	    };
	};
	
	
	SpriteAtlas.prototype.allocate = function() {
	    if (!this.data) {
	        var w = Math.floor(this.width * this.pixelRatio);
	        var h = Math.floor(this.height * this.pixelRatio);
	        this.data = new Uint32Array(w * h);
	        for (var i = 0; i < this.data.length; i++) {
	            this.data[i] = 0;
	        }
	    }
	};
	
	
	SpriteAtlas.prototype.copy = function(dst, src, wrap) {
	    if (!this.sprite.img.data) return;
	    var srcImg = new Uint32Array(this.sprite.img.data.buffer);
	
	    this.allocate();
	    var dstImg = this.data;
	
	    var padding = 1;
	
	    copyBitmap(
	        /* source buffer */  srcImg,
	        /* source stride */  this.sprite.img.width,
	        /* source x */       src.x,
	        /* source y */       src.y,
	        /* dest buffer */    dstImg,
	        /* dest stride */    this.width * this.pixelRatio,
	        /* dest x */         (dst.x + padding) * this.pixelRatio,
	        /* dest y */         (dst.y + padding) * this.pixelRatio,
	        /* icon dimension */ src.width,
	        /* icon dimension */ src.height,
	        /* wrap */ wrap
	    );
	
	    this.dirty = true;
	};
	
	SpriteAtlas.prototype.setSprite = function(sprite) {
	    if (sprite) {
	        this.pixelRatio = browser.devicePixelRatio > 1 ? 2 : 1;
	
	        if (this.canvas) {
	            this.canvas.width = this.width * this.pixelRatio;
	            this.canvas.height = this.height * this.pixelRatio;
	        }
	    }
	    this.sprite = sprite;
	};
	
	SpriteAtlas.prototype.addIcons = function(icons, callback) {
	    for (var i = 0; i < icons.length; i++) {
	        this.getImage(icons[i]);
	    }
	
	    callback(null, this.images);
	};
	
	SpriteAtlas.prototype.bind = function(gl, linear) {
	    var first = false;
	    if (!this.texture) {
	        this.texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        first = true;
	    } else {
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	    }
	
	    var filterVal = linear ? gl.LINEAR : gl.NEAREST;
	    if (filterVal !== this.filter) {
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterVal);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterVal);
	        this.filter = filterVal;
	    }
	
	    if (this.dirty) {
	        this.allocate();
	
	        if (first) {
	            gl.texImage2D(
	                gl.TEXTURE_2D, // enum target
	                0, // ind level
	                gl.RGBA, // ind internalformat
	                this.width * this.pixelRatio, // GLsizei width
	                this.height * this.pixelRatio, // GLsizei height
	                0, // ind border
	                gl.RGBA, // enum format
	                gl.UNSIGNED_BYTE, // enum type
	                new Uint8Array(this.data.buffer) // Object data
	            );
	        } else {
	            gl.texSubImage2D(
	                gl.TEXTURE_2D, // enum target
	                0, // int level
	                0, // int xoffset
	                0, // int yoffset
	                this.width * this.pixelRatio, // long width
	                this.height * this.pixelRatio, // long height
	                gl.RGBA, // enum format
	                gl.UNSIGNED_BYTE, // enum type
	                new Uint8Array(this.data.buffer) // Object pixels
	            );
	        }
	
	        this.dirty = false;
	    }
	};
	
	function AtlasImage(rect, width, height, sdf, pixelRatio) {
	    this.rect = rect;
	    this.width = width;
	    this.height = height;
	    this.sdf = sdf;
	    this.pixelRatio = pixelRatio;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	module.exports = LineAtlas;
	
	/**
	 * A LineAtlas lets us reuse rendered dashed lines
	 * by writing many of them to a texture and then fetching their positions
	 * using .getDash.
	 *
	 * @param {number} width
	 * @param {number} height
	 * @private
	 */
	function LineAtlas(width, height) {
	    this.width = width;
	    this.height = height;
	    this.nextRow = 0;
	
	    this.bytes = 4;
	    this.data = new Uint8Array(this.width * this.height * this.bytes);
	
	    this.positions = {};
	}
	
	LineAtlas.prototype.setSprite = function(sprite) {
	    this.sprite = sprite;
	};
	
	/**
	 * Get or create a dash line pattern.
	 *
	 * @param {Array<number>} dasharray
	 * @param {boolean} round whether to add circle caps in between dash segments
	 * @returns {Object} position of dash texture in { y, height, width }
	 * @private
	 */
	LineAtlas.prototype.getDash = function(dasharray, round) {
	    var key = dasharray.join(",") + round;
	
	    if (!this.positions[key]) {
	        this.positions[key] = this.addDash(dasharray, round);
	    }
	    return this.positions[key];
	};
	
	LineAtlas.prototype.addDash = function(dasharray, round) {
	
	    var n = round ? 7 : 0;
	    var height = 2 * n + 1;
	    var offset = 128;
	
	    if (this.nextRow + height > this.height) {
	        console.warn('LineAtlas out of space');
	        return null;
	    }
	
	    var length = 0;
	    for (var i = 0; i < dasharray.length; i++) {
	        length += dasharray[i];
	    }
	
	    var stretch = this.width / length;
	    var halfWidth = stretch / 2;
	
	    // If dasharray has an odd length, both the first and last parts
	    // are dashes and should be joined seamlessly.
	    var oddLength = dasharray.length % 2 === 1;
	
	    for (var y = -n; y <= n; y++) {
	        var row = this.nextRow + n + y;
	        var index = this.width * row;
	
	        var left = oddLength ? -dasharray[dasharray.length - 1] : 0;
	        var right = dasharray[0];
	        var partIndex = 1;
	
	        for (var x = 0; x < this.width; x++) {
	
	            while (right < x / stretch) {
	                left = right;
	                right = right + dasharray[partIndex];
	
	                if (oddLength && partIndex === dasharray.length - 1) {
	                    right += dasharray[0];
	                }
	
	                partIndex++;
	            }
	
	            var distLeft = Math.abs(x - left * stretch);
	            var distRight = Math.abs(x - right * stretch);
	            var dist = Math.min(distLeft, distRight);
	            var inside = (partIndex % 2) === 1;
	            var signedDistance;
	
	            if (round) {
	                // Add circle caps
	                var distMiddle = n ? y / n * (halfWidth + 1) : 0;
	                if (inside) {
	                    var distEdge = halfWidth - Math.abs(distMiddle);
	                    signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
	                } else {
	                    signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
	                }
	            } else {
	                signedDistance = (inside ? 1 : -1) * dist;
	            }
	
	            this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
	        }
	    }
	
	    var pos = {
	        y: (this.nextRow + n + 0.5) / this.height,
	        height: 2 * n / this.height,
	        width: length
	    };
	
	    this.nextRow += height;
	    this.dirty = true;
	
	    return pos;
	};
	
	LineAtlas.prototype.bind = function(gl) {
	    if (!this.texture) {
	        this.texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
	
	    } else {
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	
	        if (this.dirty) {
	            this.dirty = false;
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
	        }
	    }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Actor = __webpack_require__(151);
	var WebWorkify = __webpack_require__(152);
	
	module.exports = Dispatcher;
	
	function Dispatcher(length, parent) {
	    this.actors = [];
	    this.currentActor = 0;
	    for (var i = 0; i < length; i++) {
	        var worker = new WebWorkify(__webpack_require__(153));
	        var actor = new Actor(worker, parent);
	        actor.name = "Worker " + i;
	        this.actors.push(actor);
	    }
	}
	
	Dispatcher.prototype = {
	    broadcast: function(type, data) {
	        for (var i = 0; i < this.actors.length; i++) {
	            this.actors[i].send(type, data);
	        }
	    },
	
	    send: function(type, data, callback, targetID, buffers) {
	        if (typeof targetID !== 'number' || isNaN(targetID)) {
	            // Use round robin to send requests to web workers.
	            targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
	        }
	
	        this.actors[targetID].send(type, data, callback, buffers);
	        return targetID;
	    },
	
	    remove: function() {
	        for (var i = 0; i < this.actors.length; i++) {
	            this.actors[i].target.terminate();
	        }
	        this.actors = [];
	    }
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = Actor;
	
	/**
	 * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
	 * that maintains the relationship between asynchronous tasks and the objects
	 * that spin them off - in this case, tasks like parsing parts of styles,
	 * owned by the styles
	 *
	 * @param {WebWorker} target
	 * @param {WebWorker} parent
	 * @private
	 */
	function Actor(target, parent) {
	    this.target = target;
	    this.parent = parent;
	    this.callbacks = {};
	    this.callbackID = 0;
	    this.receive = this.receive.bind(this);
	    this.target.addEventListener('message', this.receive, false);
	}
	
	Actor.prototype.receive = function(message) {
	    var data = message.data,
	        callback;
	
	    if (data.type === '<response>') {
	        callback = this.callbacks[data.id];
	        delete this.callbacks[data.id];
	        callback(data.error || null, data.data);
	    } else if (typeof data.id !== 'undefined') {
	        var id = data.id;
	        this.parent[data.type](data.data, function(err, data, buffers) {
	            this.postMessage({
	                type: '<response>',
	                id: String(id),
	                error: err ? String(err) : null,
	                data: data
	            }, buffers);
	        }.bind(this));
	    } else {
	        this.parent[data.type](data.data);
	    }
	};
	
	Actor.prototype.send = function(type, data, callback, buffers) {
	    var id = null;
	    if (callback) this.callbacks[id = this.callbackID++] = callback;
	    this.postMessage({ type: type, id: String(id), data: data }, buffers);
	};
	
	/**
	 * Wrapped postMessage API that abstracts around IE's lack of
	 * `transferList` support.
	 *
	 * @param {Object} message
	 * @param {Object} transferList
	 * @private
	 */
	Actor.prototype.postMessage = function(message, transferList) {
	    this.target.postMessage(message, transferList);
	};


/***/ },
/* 152 */
/***/ function(module, exports) {

	var __webpack_require__ = arguments[2];
	var sources = __webpack_require__.m;
	
	var webpackBootstrapFunc = function(modules) {
	    var installedModules = {};
	    function __webpack_require__(moduleId) {
	      if(installedModules[moduleId])
	        return installedModules[moduleId].exports;
	      var module = installedModules[moduleId] = {
	        exports: {},
	        id: moduleId,
	        loaded: false
	      };
	      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	      module.loaded = true;
	      return module.exports;
	    }
	    __webpack_require__.m = modules;
	    __webpack_require__.c = installedModules;
	    __webpack_require__.oe = function(err) { throw err; };
	    __webpack_require__.p = "";
	    var f = __webpack_require__(__webpack_require__.s = entryModule);
	    return f.default || f; // try to call default if defined to also support babel esmodule exports
	}
	
	module.exports = function (fn) {
	    var key;
	    for (var i = 0, l = sources.length; i < l; i++) {
	        if (!sources[i]) {
	            continue;
	        }
	        var wrapperFuncString = sources[i].toString();
	        var fnString = fn.toString();
	        var exp = __webpack_require__(i);
	        // Using babel as a transpiler to use esmodule, the export will always
	        // be an object with the default export as a property of it. To ensure
	        // the existing api and babel esmodule exports are both supported we
	        // check for both
	        if (exp && (exp === fn || exp.default === fn)) {
	            key = i;
	            break;
	        } else if (wrapperFuncString.indexOf(fnString) > -1) {
	            sources[i] = wrapperFuncString.substring(0, wrapperFuncString.length - 1) + '\n' + fnString.match(/function\s?(.+?)\s?\(.*/)[1] + '();\n}';
	            key = i;
	            break;
	        }
	    }
	
	    // window = {}; => https://github.com/borisirota/webworkify-webpack/issues/1
	    var src = 'window = {};\n'
	        + 'var fn = (' + webpackBootstrapFunc.toString().replace('entryModule', key) + ')(['
	        + sources.map(function (func) {
	            return func.toString();
	        }).join(',')
	        + ']);\n'
	        + '(typeof fn === "function") && fn(self);'; // not a function when calling a function from the current scope
	
	    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
	
	    return new Worker(URL.createObjectURL(
	        new Blob([src], { type: 'text/javascript' })
	    ));
	};


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Actor = __webpack_require__(151);
	var WorkerTile = __webpack_require__(154);
	var StyleLayer = __webpack_require__(90);
	var util = __webpack_require__(82);
	var ajax = __webpack_require__(135);
	var vt = __webpack_require__(178);
	var Protobuf = __webpack_require__(142);
	var supercluster = __webpack_require__(186);
	
	var geojsonvt = __webpack_require__(191);
	var rewind = __webpack_require__(198);
	var GeoJSONWrapper = __webpack_require__(201);
	var vtpbf = __webpack_require__(202);
	
	module.exports = function(self) {
	    return new Worker(self);
	};
	
	function Worker(self) {
	    this.self = self;
	    this.actor = new Actor(self, this);
	    this.loading = {};
	
	    this.loaded = {};
	    this.geoJSONIndexes = {};
	}
	
	util.extend(Worker.prototype, {
	    'set layers': function(layers) {
	        this.layers = {};
	        var that = this;
	
	        // Filter layers and create an id -> layer map
	        var childLayerIndicies = [];
	        for (var i = 0; i < layers.length; i++) {
	            var layer = layers[i];
	            if (layer.type === 'fill' || layer.type === 'line' || layer.type === 'circle' || layer.type === 'symbol') {
	                if (layer.ref) {
	                    childLayerIndicies.push(i);
	                } else {
	                    setLayer(layer);
	                }
	            }
	        }
	
	        // Create an instance of StyleLayer per layer
	        for (var j = 0; j < childLayerIndicies.length; j++) {
	            setLayer(layers[childLayerIndicies[j]]);
	        }
	
	        function setLayer(serializedLayer) {
	            var styleLayer = StyleLayer.create(
	                serializedLayer,
	                serializedLayer.ref && that.layers[serializedLayer.ref]
	            );
	            styleLayer.updatePaintTransitions({}, {transition: false});
	            that.layers[styleLayer.id] = styleLayer;
	        }
	
	        this.layerFamilies = createLayerFamilies(this.layers);
	    },
	
	    'update layers': function(layers) {
	        var that = this;
	        var id;
	        var layer;
	
	        // Update ref parents
	        for (id in layers) {
	            layer = layers[id];
	            if (layer.ref) updateLayer(layer);
	        }
	
	        // Update ref children
	        for (id in layers) {
	            layer = layers[id];
	            if (!layer.ref) updateLayer(layer);
	        }
	
	        function updateLayer(layer) {
	            var refLayer = that.layers[layer.ref];
	            if (that.layers[layer.id]) {
	                that.layers[layer.id].set(layer, refLayer);
	            } else {
	                that.layers[layer.id] = StyleLayer.create(layer, refLayer);
	            }
	            that.layers[layer.id].updatePaintTransitions({}, {transition: false});
	        }
	
	        this.layerFamilies = createLayerFamilies(this.layers);
	    },
	
	    'load tile': function(params, callback) {
	        var source = params.source,
	            uid = params.uid;
	
	        if (!this.loading[source])
	            this.loading[source] = {};
	
	
	        var tile = this.loading[source][uid] = new WorkerTile(params);
	
	        tile.xhr = ajax.getArrayBuffer(params.url, done.bind(this));
	
	        function done(err, data) {
	            delete this.loading[source][uid];
	
	            if (err) return callback(err);
	
	            tile.data = new vt.VectorTile(new Protobuf(new Uint8Array(data)));
	            tile.parse(tile.data, this.layerFamilies, this.actor, data, callback);
	
	            this.loaded[source] = this.loaded[source] || {};
	            this.loaded[source][uid] = tile;
	        }
	    },
	
	    'reload tile': function(params, callback) {
	        var loaded = this.loaded[params.source],
	            uid = params.uid;
	        if (loaded && loaded[uid]) {
	            var tile = loaded[uid];
	            tile.parse(tile.data, this.layerFamilies, this.actor, params.rawTileData, callback);
	        }
	    },
	
	    'abort tile': function(params) {
	        var loading = this.loading[params.source],
	            uid = params.uid;
	        if (loading && loading[uid]) {
	            loading[uid].xhr.abort();
	            delete loading[uid];
	        }
	    },
	
	    'remove tile': function(params) {
	        var loaded = this.loaded[params.source],
	            uid = params.uid;
	        if (loaded && loaded[uid]) {
	            delete loaded[uid];
	        }
	    },
	
	    'redo placement': function(params, callback) {
	        var loaded = this.loaded[params.source],
	            loading = this.loading[params.source],
	            uid = params.uid;
	
	        if (loaded && loaded[uid]) {
	            var tile = loaded[uid];
	            var result = tile.redoPlacement(params.angle, params.pitch, params.showCollisionBoxes);
	
	            if (result.result) {
	                callback(null, result.result, result.transferables);
	            }
	
	        } else if (loading && loading[uid]) {
	            loading[uid].angle = params.angle;
	        }
	    },
	
	    'parse geojson': function(params, callback) {
	        var indexData = function(err, data) {
	            rewind(data, true);
	            if (err) return callback(err);
	            if (typeof data != 'object') {
	                return callback(new Error("Input data is not a valid GeoJSON object."));
	            }
	            try {
	                this.geoJSONIndexes[params.source] = params.cluster ?
	                    supercluster(params.superclusterOptions).load(data.features) :
	                    geojsonvt(data, params.geojsonVtOptions);
	            } catch (err) {
	                return callback(err);
	            }
	            callback(null);
	        }.bind(this);
	
	        // Not, because of same origin issues, urls must either include an
	        // explicit origin or absolute path.
	        // ie: /foo/bar.json or http://example.com/bar.json
	        // but not ../foo/bar.json
	        if (params.url) {
	            ajax.getJSON(params.url, indexData);
	        } else if (typeof params.data === 'string') {
	            indexData(null, JSON.parse(params.data));
	        } else {
	            return callback(new Error("Input data is not a valid GeoJSON object."));
	        }
	    },
	
	    'load geojson tile': function(params, callback) {
	        var source = params.source,
	            coord = params.coord;
	
	        if (!this.geoJSONIndexes[source]) return callback(null, null); // we couldn't load the file
	
	        // console.time('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);
	
	        var geoJSONTile = this.geoJSONIndexes[source].getTile(Math.min(coord.z, params.maxZoom), coord.x, coord.y);
	
	        // console.timeEnd('tile ' + coord.z + ' ' + coord.x + ' ' + coord.y);
	
	        // if (!geoJSONTile) console.log('not found', this.geoJSONIndexes[source], coord);
	
	        var tile = geoJSONTile ? new WorkerTile(params) : undefined;
	
	        this.loaded[source] = this.loaded[source] || {};
	        this.loaded[source][params.uid] = tile;
	
	        if (geoJSONTile) {
	            var geojsonWrapper = new GeoJSONWrapper(geoJSONTile.features);
	            geojsonWrapper.name = '_geojsonTileLayer';
	            var rawTileData = vtpbf({ layers: { '_geojsonTileLayer': geojsonWrapper }}).buffer;
	            tile.parse(geojsonWrapper, this.layerFamilies, this.actor, rawTileData, callback);
	        } else {
	            return callback(null, null); // nothing in the given tile
	        }
	    }
	});
	
	function createLayerFamilies(layers) {
	    var families = {};
	
	    for (var layerId in layers) {
	        var layer = layers[layerId];
	        var parentLayerId = layer.ref || layer.id;
	        var parentLayer = layers[parentLayerId];
	
	        if (parentLayer.layout && parentLayer.layout.visibility === 'none') continue;
	
	        families[parentLayerId] = families[parentLayerId] || [];
	        if (layerId === parentLayerId) {
	            families[parentLayerId].unshift(layer);
	        } else {
	            families[parentLayerId].push(layer);
	        }
	    }
	
	    return families;
	}


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var FeatureIndex = __webpack_require__(155);
	var CollisionTile = __webpack_require__(184);
	var Bucket = __webpack_require__(157);
	var CollisionBoxArray = __webpack_require__(185);
	var DictionaryCoder = __webpack_require__(177);
	
	module.exports = WorkerTile;
	
	function WorkerTile(params) {
	    this.coord = params.coord;
	    this.uid = params.uid;
	    this.zoom = params.zoom;
	    this.tileSize = params.tileSize;
	    this.source = params.source;
	    this.overscaling = params.overscaling;
	    this.angle = params.angle;
	    this.pitch = params.pitch;
	    this.showCollisionBoxes = params.showCollisionBoxes;
	}
	
	WorkerTile.prototype.parse = function(data, layerFamilies, actor, rawTileData, callback) {
	
	    this.status = 'parsing';
	    this.data = data;
	
	    this.collisionBoxArray = new CollisionBoxArray();
	    var collisionTile = new CollisionTile(this.angle, this.pitch, this.collisionBoxArray);
	    var featureIndex = new FeatureIndex(this.coord, this.overscaling, collisionTile, data.layers);
	    var sourceLayerCoder = new DictionaryCoder(data.layers ? Object.keys(data.layers).sort() : ['_geojsonTileLayer']);
	
	    var stats = { _total: 0 };
	
	    var tile = this;
	    var bucketsById = {};
	    var bucketsBySourceLayer = {};
	    var i;
	    var layer;
	    var sourceLayerId;
	    var bucket;
	
	    // Map non-ref layers to buckets.
	    var bucketIndex = 0;
	    for (var layerId in layerFamilies) {
	        layer = layerFamilies[layerId][0];
	
	        if (layer.source !== this.source) continue;
	        if (layer.ref) continue;
	        if (layer.minzoom && this.zoom < layer.minzoom) continue;
	        if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;
	        if (layer.layout && layer.layout.visibility === 'none') continue;
	        if (data.layers && !data.layers[layer.sourceLayer]) continue;
	
	        bucket = Bucket.create({
	            layer: layer,
	            index: bucketIndex++,
	            childLayers: layerFamilies[layerId],
	            zoom: this.zoom,
	            overscaling: this.overscaling,
	            showCollisionBoxes: this.showCollisionBoxes,
	            collisionBoxArray: this.collisionBoxArray,
	            sourceLayerIndex: sourceLayerCoder.encode(layer.sourceLayer || '_geojsonTileLayer')
	        });
	        bucket.createFilter();
	
	        bucketsById[layer.id] = bucket;
	
	        if (data.layers) { // vectortile
	            sourceLayerId = layer.sourceLayer;
	            bucketsBySourceLayer[sourceLayerId] = bucketsBySourceLayer[sourceLayerId] || {};
	            bucketsBySourceLayer[sourceLayerId][layer.id] = bucket;
	        }
	    }
	
	    // read each layer, and sort its features into buckets
	    if (data.layers) { // vectortile
	        for (sourceLayerId in bucketsBySourceLayer) {
	            layer = data.layers[sourceLayerId];
	            if (layer) {
	                sortLayerIntoBuckets(layer, bucketsBySourceLayer[sourceLayerId]);
	            }
	        }
	    } else { // geojson
	        sortLayerIntoBuckets(data, bucketsById);
	    }
	
	    function sortLayerIntoBuckets(layer, buckets) {
	        for (var i = 0; i < layer.length; i++) {
	            var feature = layer.feature(i);
	            feature.index = i;
	            for (var id in buckets) {
	                if (buckets[id].filter(feature))
	                    buckets[id].features.push(feature);
	            }
	        }
	    }
	
	    var buckets = [],
	        symbolBuckets = this.symbolBuckets = [],
	        otherBuckets = [];
	
	    featureIndex.bucketLayerIDs = {};
	
	    for (var id in bucketsById) {
	        bucket = bucketsById[id];
	        if (bucket.features.length === 0) continue;
	
	        featureIndex.bucketLayerIDs[bucket.index] = bucket.childLayers.map(getLayerId);
	
	        buckets.push(bucket);
	
	        if (bucket.type === 'symbol')
	            symbolBuckets.push(bucket);
	        else
	            otherBuckets.push(bucket);
	    }
	
	    var icons = {};
	    var stacks = {};
	    var deps = 0;
	
	
	    if (symbolBuckets.length > 0) {
	
	        // Get dependencies for symbol buckets
	        for (i = symbolBuckets.length - 1; i >= 0; i--) {
	            symbolBuckets[i].updateIcons(icons);
	            symbolBuckets[i].updateFont(stacks);
	        }
	
	        for (var fontName in stacks) {
	            stacks[fontName] = Object.keys(stacks[fontName]).map(Number);
	        }
	        icons = Object.keys(icons);
	
	        actor.send('get glyphs', {uid: this.uid, stacks: stacks}, function(err, newStacks) {
	            stacks = newStacks;
	            gotDependency(err);
	        });
	
	        if (icons.length) {
	            actor.send('get icons', {icons: icons}, function(err, newIcons) {
	                icons = newIcons;
	                gotDependency(err);
	            });
	        } else {
	            gotDependency();
	        }
	    }
	
	    // immediately parse non-symbol buckets (they have no dependencies)
	    for (i = otherBuckets.length - 1; i >= 0; i--) {
	        parseBucket(this, otherBuckets[i]);
	    }
	
	    if (symbolBuckets.length === 0)
	        return done();
	
	    function gotDependency(err) {
	        if (err) return callback(err);
	        deps++;
	        if (deps === 2) {
	            // all symbol bucket dependencies fetched; parse them in proper order
	            for (var i = symbolBuckets.length - 1; i >= 0; i--) {
	                parseBucket(tile, symbolBuckets[i]);
	            }
	            done();
	        }
	    }
	
	    function parseBucket(tile, bucket) {
	        var now = Date.now();
	        bucket.populateBuffers(collisionTile, stacks, icons);
	        var time = Date.now() - now;
	
	
	        if (bucket.type !== 'symbol') {
	            for (var i = 0; i < bucket.features.length; i++) {
	                var feature = bucket.features[i];
	                featureIndex.insert(feature, feature.index, bucket.sourceLayerIndex, bucket.index);
	            }
	        }
	
	        bucket.features = null;
	
	        stats._total += time;
	        stats[bucket.id] = (stats[bucket.id] || 0) + time;
	    }
	
	    function done() {
	        tile.status = 'done';
	
	        if (tile.redoPlacementAfterDone) {
	            tile.redoPlacement(tile.angle, tile.pitch, null);
	            tile.redoPlacementAfterDone = false;
	        }
	
	        var featureIndex_ = featureIndex.serialize();
	        var collisionTile_ = collisionTile.serialize();
	        var collisionBoxArray = tile.collisionBoxArray.serialize();
	        var transferables = [rawTileData].concat(featureIndex_.transferables).concat(collisionTile_.transferables);
	
	        var nonEmptyBuckets = buckets.filter(isBucketEmpty);
	
	        callback(null, {
	            buckets: nonEmptyBuckets.map(serializeBucket),
	            bucketStats: stats, // TODO put this in a separate message?
	            featureIndex: featureIndex_.data,
	            collisionTile: collisionTile_.data,
	            collisionBoxArray: collisionBoxArray,
	            rawTileData: rawTileData
	        }, getTransferables(nonEmptyBuckets).concat(transferables));
	    }
	};
	
	WorkerTile.prototype.redoPlacement = function(angle, pitch, showCollisionBoxes) {
	    if (this.status !== 'done') {
	        this.redoPlacementAfterDone = true;
	        this.angle = angle;
	        return {};
	    }
	
	    var collisionTile = new CollisionTile(angle, pitch, this.collisionBoxArray);
	
	    var buckets = this.symbolBuckets;
	
	    for (var i = buckets.length - 1; i >= 0; i--) {
	        buckets[i].placeFeatures(collisionTile, showCollisionBoxes);
	    }
	
	    var collisionTile_ = collisionTile.serialize();
	
	    var nonEmptyBuckets = buckets.filter(isBucketEmpty);
	
	    return {
	        result: {
	            buckets: nonEmptyBuckets.map(serializeBucket),
	            collisionTile: collisionTile_.data
	        },
	        transferables: getTransferables(nonEmptyBuckets).concat(collisionTile_.transferables)
	    };
	};
	
	function isBucketEmpty(bucket) {
	    for (var bufferName in bucket.arrays) {
	        if (bucket.arrays[bufferName].length > 0) return true;
	    }
	    return false;
	}
	
	function serializeBucket(bucket) {
	    return bucket.serialize();
	}
	
	function getTransferables(buckets) {
	    var transferables = [];
	    for (var i in buckets) {
	        var bucket = buckets[i];
	        for (var j in bucket.arrays) {
	            transferables.push(bucket.arrays[j].arrayBuffer);
	        }
	    }
	    return transferables;
	}
	
	function getLayerId(layer) {
	    return layer.id;
	}


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	var loadGeometry = __webpack_require__(156);
	var EXTENT = __webpack_require__(157).EXTENT;
	var featureFilter = __webpack_require__(158);
	var StructArrayType = __webpack_require__(161);
	var Grid = __webpack_require__(176);
	var DictionaryCoder = __webpack_require__(177);
	var vt = __webpack_require__(178);
	var Protobuf = __webpack_require__(142);
	var GeoJSONFeature = __webpack_require__(182);
	var arraysIntersect = __webpack_require__(82).arraysIntersect;
	
	var intersection = __webpack_require__(183);
	var multiPolygonIntersectsBufferedMultiPoint = intersection.multiPolygonIntersectsBufferedMultiPoint;
	var multiPolygonIntersectsMultiPolygon = intersection.multiPolygonIntersectsMultiPolygon;
	var multiPolygonIntersectsBufferedMultiLine = intersection.multiPolygonIntersectsBufferedMultiLine;
	
	
	var FeatureIndexArray = new StructArrayType({
	    members: [
	        // the index of the feature in the original vectortile
	        { type: 'Uint32', name: 'featureIndex' },
	        // the source layer the feature appears in
	        { type: 'Uint16', name: 'sourceLayerIndex' },
	        // the bucket the feature appears in
	        { type: 'Uint16', name: 'bucketIndex' }
	    ]});
	
	module.exports = FeatureIndex;
	
	function FeatureIndex(coord, overscaling, collisionTile) {
	    if (coord.grid) {
	        var serialized = coord;
	        var rawTileData = overscaling;
	        coord = serialized.coord;
	        overscaling = serialized.overscaling;
	        this.grid = new Grid(serialized.grid);
	        this.featureIndexArray = new FeatureIndexArray(serialized.featureIndexArray);
	        this.rawTileData = rawTileData;
	        this.bucketLayerIDs = serialized.bucketLayerIDs;
	    } else {
	        this.grid = new Grid(EXTENT, 16, 0);
	        this.featureIndexArray = new FeatureIndexArray();
	    }
	    this.coord = coord;
	    this.overscaling = overscaling;
	    this.x = coord.x;
	    this.y = coord.y;
	    this.z = coord.z - Math.log(overscaling) / Math.LN2;
	    this.setCollisionTile(collisionTile);
	}
	
	FeatureIndex.prototype.insert = function(feature, featureIndex, sourceLayerIndex, bucketIndex) {
	    var key = this.featureIndexArray.length;
	    this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);
	    var geometry = loadGeometry(feature);
	
	    for (var r = 0; r < geometry.length; r++) {
	        var ring = geometry[r];
	
	        // TODO: skip holes when we start using vector tile spec 2.0
	
	        var bbox = [Infinity, Infinity, -Infinity, -Infinity];
	        for (var i = 0; i < ring.length; i++) {
	            var p = ring[i];
	            bbox[0] = Math.min(bbox[0], p.x);
	            bbox[1] = Math.min(bbox[1], p.y);
	            bbox[2] = Math.max(bbox[2], p.x);
	            bbox[3] = Math.max(bbox[3], p.y);
	        }
	
	        this.grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);
	    }
	};
	
	FeatureIndex.prototype.setCollisionTile = function(collisionTile) {
	    this.collisionTile = collisionTile;
	};
	
	FeatureIndex.prototype.serialize = function() {
	    var data = {
	        coord: this.coord,
	        overscaling: this.overscaling,
	        grid: this.grid.toArrayBuffer(),
	        featureIndexArray: this.featureIndexArray.serialize(),
	        bucketLayerIDs: this.bucketLayerIDs
	    };
	    return {
	        data: data,
	        transferables: [data.grid, data.featureIndexArray.arrayBuffer]
	    };
	};
	
	function translateDistance(translate) {
	    return Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]);
	}
	
	// Finds features in this tile at a particular position.
	FeatureIndex.prototype.query = function(args, styleLayers) {
	    if (!this.vtLayers) {
	        this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
	        this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);
	    }
	
	    var result = {};
	
	    var params = args.params || {},
	        pixelsToTileUnits = EXTENT / args.tileSize / args.scale,
	        filter = featureFilter(params.filter);
	
	    // Features are indexed their original geometries. The rendered geometries may
	    // be buffered, translated or offset. Figure out how much the search radius needs to be
	    // expanded by to include these features.
	    var additionalRadius = 0;
	    for (var id in styleLayers) {
	        var styleLayer = styleLayers[id];
	        var paint = styleLayer.paint;
	
	        var styleLayerDistance = 0;
	        if (styleLayer.type === 'line') {
	            styleLayerDistance = getLineWidth(paint) / 2 + Math.abs(paint['line-offset']) + translateDistance(paint['line-translate']);
	        } else if (styleLayer.type === 'fill') {
	            styleLayerDistance = translateDistance(paint['fill-translate']);
	        } else if (styleLayer.type === 'circle') {
	            styleLayerDistance = paint['circle-radius'] + translateDistance(paint['circle-translate']);
	        }
	        additionalRadius = Math.max(additionalRadius, styleLayerDistance * pixelsToTileUnits);
	    }
	
	    var queryGeometry = args.queryGeometry.map(function(q) {
	        return q.map(function(p) {
	            return new Point(p.x, p.y);
	        });
	    });
	
	    var minX = Infinity;
	    var minY = Infinity;
	    var maxX = -Infinity;
	    var maxY = -Infinity;
	    for (var i = 0; i < queryGeometry.length; i++) {
	        var ring = queryGeometry[i];
	        for (var k = 0; k < ring.length; k++) {
	            var p = ring[k];
	            minX = Math.min(minX, p.x);
	            minY = Math.min(minY, p.y);
	            maxX = Math.max(maxX, p.x);
	            maxY = Math.max(maxY, p.y);
	        }
	    }
	
	    var matching = this.grid.query(minX - additionalRadius, minY - additionalRadius, maxX + additionalRadius, maxY + additionalRadius);
	    matching.sort(topDownFeatureComparator);
	    this.filterMatching(result, matching, this.featureIndexArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);
	
	    var matchingSymbols = this.collisionTile.queryRenderedSymbols(minX, minY, maxX, maxY, args.scale);
	    matchingSymbols.sort();
	    this.filterMatching(result, matchingSymbols, this.collisionTile.collisionBoxArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);
	
	    return result;
	};
	
	function topDownFeatureComparator(a, b) {
	    return b - a;
	}
	
	function getLineWidth(paint) {
	    if (paint['line-gap-width'] > 0) {
	        return paint['line-gap-width'] + 2 * paint['line-width'];
	    } else {
	        return paint['line-width'];
	    }
	}
	
	FeatureIndex.prototype.filterMatching = function(result, matching, array, queryGeometry, filter, filterLayerIDs, styleLayers, bearing, pixelsToTileUnits) {
	    var previousIndex;
	    for (var k = 0; k < matching.length; k++) {
	        var index = matching[k];
	
	        // don't check the same feature more than once
	        if (index === previousIndex) continue;
	        previousIndex = index;
	
	        var match = array.get(index);
	
	        var layerIDs = this.bucketLayerIDs[match.bucketIndex];
	        if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs)) continue;
	
	        var sourceLayerName = this.sourceLayerCoder.decode(match.sourceLayerIndex);
	        var sourceLayer = this.vtLayers[sourceLayerName];
	        var feature = sourceLayer.feature(match.featureIndex);
	
	        if (!filter(feature)) continue;
	
	        var geometry = null;
	
	        for (var l = 0; l < layerIDs.length; l++) {
	            var layerID = layerIDs[l];
	
	            if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {
	                continue;
	            }
	
	            var styleLayer = styleLayers[layerID];
	            if (!styleLayer) continue;
	
	            var translatedPolygon;
	            if (styleLayer.type !== 'symbol') {
	                // all symbols already match the style
	
	                if (!geometry) geometry = loadGeometry(feature);
	
	                var paint = styleLayer.paint;
	
	                if (styleLayer.type === 'line') {
	                    translatedPolygon = translate(queryGeometry,
	                            paint['line-translate'], paint['line-translate-anchor'],
	                            bearing, pixelsToTileUnits);
	                    var halfWidth = getLineWidth(paint) / 2 * pixelsToTileUnits;
	                    if (paint['line-offset']) {
	                        geometry = offsetLine(geometry, paint['line-offset'] * pixelsToTileUnits);
	                    }
	                    if (!multiPolygonIntersectsBufferedMultiLine(translatedPolygon, geometry, halfWidth)) continue;
	
	                } else if (styleLayer.type === 'fill') {
	                    translatedPolygon = translate(queryGeometry,
	                            paint['fill-translate'], paint['fill-translate-anchor'],
	                            bearing, pixelsToTileUnits);
	                    if (!multiPolygonIntersectsMultiPolygon(translatedPolygon, geometry)) continue;
	
	                } else if (styleLayer.type === 'circle') {
	                    translatedPolygon = translate(queryGeometry,
	                            paint['circle-translate'], paint['circle-translate-anchor'],
	                            bearing, pixelsToTileUnits);
	                    var circleRadius = paint['circle-radius'] * pixelsToTileUnits;
	                    if (!multiPolygonIntersectsBufferedMultiPoint(translatedPolygon, geometry, circleRadius)) continue;
	                }
	            }
	
	            var geojsonFeature = new GeoJSONFeature(feature, this.z, this.x, this.y);
	            geojsonFeature.layer = styleLayer.serialize({
	                includeRefProperties: true
	            });
	            var layerResult = result[layerID];
	            if (layerResult === undefined) {
	                layerResult = result[layerID] = [];
	            }
	            layerResult.push(geojsonFeature);
	        }
	    }
	};
	
	function translate(queryGeometry, translate, translateAnchor, bearing, pixelsToTileUnits) {
	    if (!translate[0] && !translate[1]) {
	        return queryGeometry;
	    }
	
	    translate = Point.convert(translate);
	
	    if (translateAnchor === "viewport") {
	        translate._rotate(-bearing);
	    }
	
	    var translated = [];
	    for (var i = 0; i < queryGeometry.length; i++) {
	        var ring = queryGeometry[i];
	        var translatedRing = [];
	        for (var k = 0; k < ring.length; k++) {
	            translatedRing.push(ring[k].sub(translate._mult(pixelsToTileUnits)));
	        }
	        translated.push(translatedRing);
	    }
	    return translated;
	}
	
	function offsetLine(rings, offset) {
	    var newRings = [];
	    var zero = new Point(0, 0);
	    for (var k = 0; k < rings.length; k++) {
	        var ring = rings[k];
	        var newRing = [];
	        for (var i = 0; i < ring.length; i++) {
	            var a = ring[i - 1];
	            var b = ring[i];
	            var c = ring[i + 1];
	            var aToB = i === 0 ? zero : b.sub(a)._unit()._perp();
	            var bToC = i === ring.length - 1 ? zero : c.sub(b)._unit()._perp();
	            var extrude = aToB._add(bToC)._unit();
	
	            var cosHalfAngle = extrude.x * bToC.x + extrude.y * bToC.y;
	            extrude._mult(1 / cosHalfAngle);
	
	            newRing.push(extrude._mult(offset)._add(b));
	        }
	        newRings.push(newRing);
	    }
	    return newRings;
	}


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	var EXTENT = __webpack_require__(157).EXTENT;
	var EXTENT_MIN = EXTENT * -2;
	var EXTENT_MAX = (EXTENT * 2) - 1;
	
	// only log a geometry warning once per context
	var warned = false;
	
	/**
	 * Loads a geometry from a VectorTileFeature and scales it to the common extent
	 * used internally.
	 * @private
	 */
	module.exports = function loadGeometry(feature) {
	    var scale = EXTENT / feature.extent;
	    var geometry = feature.loadGeometry();
	    for (var r = 0; r < geometry.length; r++) {
	        var ring = geometry[r];
	        for (var p = 0; p < ring.length; p++) {
	            var point = ring[p];
	            // round here because mapbox-gl-native uses integers to represent
	            // points and we need to do the same to avoid renering differences.
	            point.x = Math.round(point.x * scale);
	            point.y = Math.round(point.y * scale);
	            if (warned === false && (
	                point.x < EXTENT_MIN ||
	                point.x > EXTENT_MAX ||
	                point.y < EXTENT_MIN ||
	                point.y > EXTENT_MAX)) {
	                console.warn('Geometry exceeds allowed extent, reduce your vector tile buffer size');
	                warned = true;
	            }
	        }
	    }
	    return geometry;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var featureFilter = __webpack_require__(158);
	var Buffer = __webpack_require__(159);
	var util = __webpack_require__(82);
	var StructArrayType = __webpack_require__(161);
	
	module.exports = Bucket;
	
	/**
	 * Instantiate the appropriate subclass of `Bucket` for `options`.
	 * @private
	 * @param options See `Bucket` constructor options
	 * @returns {Bucket}
	 */
	Bucket.create = function(options) {
	    var Classes = {
	        fill: __webpack_require__(162),
	        line: __webpack_require__(163),
	        circle: __webpack_require__(164),
	        symbol: __webpack_require__(165)
	    };
	    return new Classes[options.layer.type](options);
	};
	
	
	/**
	 * The maximum extent of a feature that can be safely stored in the buffer.
	 * In practice, all features are converted to this extent before being added.
	 *
	 * Positions are stored as signed 16bit integers.
	 * One bit is lost for signedness to support featuers extending past the left edge of the tile.
	 * One bit is lost because the line vertex buffer packs 1 bit of other data into the int.
	 * One bit is lost to support features extending past the extent on the right edge of the tile.
	 * This leaves us with 2^13 = 8192
	 *
	 * @private
	 * @readonly
	 */
	Bucket.EXTENT = 8192;
	
	/**
	 * The `Bucket` class is the single point of knowledge about turning vector
	 * tiles into WebGL buffers.
	 *
	 * `Bucket` is an abstract class. A subclass exists for each Mapbox GL
	 * style spec layer type. Because `Bucket` is an abstract class,
	 * instances should be created via the `Bucket.create` method.
	 *
	 * @class Bucket
	 * @private
	 * @param options
	 * @param {number} options.zoom Zoom level of the buffers being built. May be
	 *     a fractional zoom level.
	 * @param options.layer A Mapbox GL style layer object
	 * @param {Object.<string, Buffer>} options.buffers The set of `Buffer`s being
	 *     built for this tile. This object facilitates sharing of `Buffer`s be
	       between `Bucket`s.
	 */
	function Bucket(options) {
	    this.zoom = options.zoom;
	    this.overscaling = options.overscaling;
	    this.layer = options.layer;
	    this.childLayers = options.childLayers;
	
	    this.type = this.layer.type;
	    this.features = [];
	    this.id = this.layer.id;
	    this.index = options.index;
	    this.sourceLayer = this.layer.sourceLayer;
	    this.sourceLayerIndex = options.sourceLayerIndex;
	    this.minZoom = this.layer.minzoom;
	    this.maxZoom = this.layer.maxzoom;
	
	    this.attributes = createAttributes(this);
	
	    if (options.elementGroups) {
	        this.elementGroups = options.elementGroups;
	        this.buffers = util.mapObject(options.arrays, function(array, bufferName) {
	            var arrayType = options.arrayTypes[bufferName];
	            var type = (arrayType.members.length && arrayType.members[0].name === 'vertices' ? Buffer.BufferType.ELEMENT : Buffer.BufferType.VERTEX);
	            return new Buffer(array, arrayType, type);
	        });
	    }
	}
	
	/**
	 * Build the buffers! Features are set directly to the `features` property.
	 * @private
	 */
	Bucket.prototype.populateBuffers = function() {
	    this.createArrays();
	    this.recalculateStyleLayers();
	
	    for (var i = 0; i < this.features.length; i++) {
	        this.addFeature(this.features[i]);
	    }
	
	    this.trimArrays();
	};
	
	/**
	 * Check if there is enough space available in the current element group for
	 * `vertexLength` vertices. If not, append a new elementGroup. Should be called
	 * by `populateBuffers` and its callees.
	 * @private
	 * @param {string} programName the name of the program associated with the buffer that will receive the vertices
	 * @param {number} vertexLength The number of vertices that will be inserted to the buffer.
	 */
	Bucket.prototype.makeRoomFor = function(programName, numVertices) {
	    var groups = this.elementGroups[programName];
	    var currentGroup = groups.length && groups[groups.length - 1];
	
	    if (!currentGroup || currentGroup.vertexLength + numVertices > 65535) {
	        var vertexArray = this.arrays[this.getBufferName(programName, 'vertex')];
	        var elementArray = this.arrays[this.getBufferName(programName, 'element')];
	        var secondElementArray = this.arrays[this.getBufferName(programName, 'secondElement')];
	
	        currentGroup = {
	            vertexStartIndex: vertexArray.length,
	            elementStartIndex: elementArray && elementArray.length,
	            secondElementStartIndex: secondElementArray && secondElementArray.length,
	            elementLength: 0,
	            vertexLength: 0,
	            secondElementLength: 0,
	            elementOffset: elementArray && elementArray.length * elementArray.bytesPerElement,
	            secondElementOffset: secondElementArray && secondElementArray.length * secondElementArray.bytesPerElement,
	            vertexOffset: vertexArray && vertexArray.length * vertexArray.bytesPerElement
	        };
	        groups.push(currentGroup);
	    }
	
	    return currentGroup;
	};
	
	/**
	 * Start using a new shared `buffers` object and recreate instances of `Buffer`
	 * as necessary.
	 * @private
	 */
	Bucket.prototype.createArrays = function() {
	    var elementGroups = this.elementGroups = {};
	    var arrays = this.arrays = {};
	    var arrayTypes = this.arrayTypes = {};
	
	    for (var programName in this.programInterfaces) {
	        var programInterface = this.programInterfaces[programName];
	
	        if (programInterface.vertexBuffer) {
	            var vertexBufferName = this.getBufferName(programName, 'vertex');
	
	            var VertexArrayType = new StructArrayType({
	                members: this.attributes[programName].layoutAttributes,
	                alignment: Buffer.VERTEX_ATTRIBUTE_ALIGNMENT
	            });
	
	            arrays[vertexBufferName] = new VertexArrayType();
	            arrayTypes[vertexBufferName] = VertexArrayType.serialize();
	
	            var layerPaintAttributes = this.attributes[programName].paintAttributes;
	            for (var layerName in layerPaintAttributes) {
	                var paintVertexBufferName = this.getBufferName(layerName, programName);
	
	                var PaintVertexArrayType = new StructArrayType({
	                    members: layerPaintAttributes[layerName].enabled,
	                    alignment: Buffer.VERTEX_ATTRIBUTE_ALIGNMENT
	                });
	
	                arrays[paintVertexBufferName] = new PaintVertexArrayType();
	                arrayTypes[paintVertexBufferName] = PaintVertexArrayType.serialize();
	            }
	        }
	
	        if (programInterface.elementBuffer) {
	            var elementBufferName = this.getBufferName(programName, 'element');
	            var ElementArrayType = createElementBufferType(programInterface.elementBufferComponents);
	            arrays[elementBufferName] = new ElementArrayType();
	            arrayTypes[elementBufferName] = ElementArrayType.serialize();
	        }
	
	        if (programInterface.secondElementBuffer) {
	            var secondElementBufferName = this.getBufferName(programName, 'secondElement');
	            var SecondElementArrayType = createElementBufferType(programInterface.secondElementBufferComponents);
	            arrays[secondElementBufferName] = new SecondElementArrayType();
	            arrayTypes[secondElementBufferName] = SecondElementArrayType.serialize();
	        }
	
	        elementGroups[programName] = [];
	    }
	};
	
	Bucket.prototype.destroy = function(gl) {
	    for (var k in this.buffers) {
	        this.buffers[k].destroy(gl);
	    }
	};
	
	Bucket.prototype.trimArrays = function() {
	    for (var bufferName in this.arrays) {
	        this.arrays[bufferName].trim();
	    }
	};
	
	/**
	 * Set the attribute pointers in a WebGL context
	 * @private
	 * @param gl The WebGL context
	 * @param program The active WebGL program
	 * @param {number} offset The offset of the attribute data in the currently bound GL buffer.
	 */
	Bucket.prototype.setAttribPointers = function(programName, gl, program, offset) {
	    var vertexBuffer = this.buffers[this.getBufferName(programName, 'vertex')];
	    vertexBuffer.setVertexAttribPointers(gl, program, offset / vertexBuffer.itemSize);
	};
	
	Bucket.prototype.setUniforms = function(gl, programName, program, layer, globalProperties) {
	    var disabledAttributes = this.attributes[programName].paintAttributes[layer.id].disabled;
	    for (var i = 0; i < disabledAttributes.length; i++) {
	        var attribute = disabledAttributes[i];
	        var attributeId = program[attribute.name];
	        gl['uniform' + attribute.components + 'fv'](attributeId, attribute.getValue(layer, globalProperties));
	    }
	};
	
	Bucket.prototype.bindLayoutBuffers = function(programInterfaceName, gl, options) {
	    var programInterface = this.programInterfaces[programInterfaceName];
	
	    if (programInterface.vertexBuffer) {
	        var vertexBuffer = this.buffers[this.getBufferName(programInterfaceName, 'vertex')];
	        vertexBuffer.bind(gl);
	    }
	
	    if (programInterface.elementBuffer && (!options || !options.secondElement)) {
	        var elementBuffer = this.buffers[this.getBufferName(programInterfaceName, 'element')];
	        elementBuffer.bind(gl);
	    }
	
	    if (programInterface.secondElementBuffer && (options && options.secondElement)) {
	        var secondElementBuffer = this.buffers[this.getBufferName(programInterfaceName, 'secondElement')];
	        secondElementBuffer.bind(gl);
	    }
	};
	
	Bucket.prototype.bindPaintBuffer = function(gl, interfaceName, layerID, program, vertexStartIndex) {
	    var buffer = this.buffers[this.getBufferName(layerID, interfaceName)];
	    buffer.bind(gl);
	    buffer.setVertexAttribPointers(gl, program, vertexStartIndex);
	};
	
	/**
	 * Get the name of a buffer.
	 * @param {string} programName The name of the program that will use the buffer
	 * @param {string} type One of "vertex", "element", or "secondElement"
	 * @returns {string}
	 */
	Bucket.prototype.getBufferName = function(programName, type) {
	    return programName + capitalize(type);
	};
	
	Bucket.prototype.serialize = function() {
	    return {
	        layerId: this.layer.id,
	        zoom: this.zoom,
	        elementGroups: this.elementGroups,
	        arrays: util.mapObject(this.arrays, function(array) {
	            return array.serialize();
	        }),
	        arrayTypes: this.arrayTypes,
	
	        childLayerIds: this.childLayers.map(function(layer) {
	            return layer.id;
	        })
	    };
	};
	
	Bucket.prototype.createFilter = function() {
	    if (!this.filter) {
	        this.filter = featureFilter(this.layer.filter);
	    }
	};
	
	var FAKE_ZOOM_HISTORY = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };
	Bucket.prototype.recalculateStyleLayers = function() {
	    for (var i = 0; i < this.childLayers.length; i++) {
	        this.childLayers[i].recalculate(this.zoom, FAKE_ZOOM_HISTORY);
	    }
	};
	
	Bucket.prototype.getProgramMacros = function(programInterface, layer) {
	    var macros = [];
	    var enabledAttributes = this.attributes[programInterface].paintAttributes[layer.id].enabled;
	    for (var i = 0; i < enabledAttributes.length; i++) {
	        macros.push('ATTRIBUTE_' + enabledAttributes[i].name.toUpperCase());
	    }
	    return macros;
	};
	
	Bucket.prototype.addPaintAttributes = function(interfaceName, globalProperties, featureProperties, startIndex, endIndex) {
	    for (var l = 0; l < this.childLayers.length; l++) {
	        var layer = this.childLayers[l];
	        var length = this.arrays[this.getBufferName(interfaceName, 'vertex')].length;
	        var vertexArray = this.arrays[this.getBufferName(layer.id, interfaceName)];
	        var enabled = this.attributes[interfaceName].paintAttributes[layer.id].enabled;
	        for (var m = 0; m < enabled.length; m++) {
	            var attribute = enabled[m];
	
	            if (attribute.paintProperty === undefined) continue;
	
	            var value = attribute.getValue(layer, globalProperties, featureProperties);
	            var multiplier = attribute.multiplier || 1;
	            var components = attribute.components || 1;
	
	            vertexArray.resize(length);
	            for (var i = startIndex; i < endIndex; i++) {
	                var vertex = vertexArray.get(i);
	                for (var c = 0; c < components; c++) {
	                    var memberName = components > 1 ? (attribute.name + c) : attribute.name;
	                    vertex[memberName] = value[c] * multiplier;
	                }
	            }
	        }
	    }
	};
	
	function createElementBufferType(components) {
	    return new StructArrayType({
	        members: [{
	            type: Buffer.ELEMENT_ATTRIBUTE_TYPE,
	            name: 'vertices',
	            components: components || 3
	        }]
	    });
	}
	
	function capitalize(string) {
	    return string.charAt(0).toUpperCase() + string.slice(1);
	}
	
	function createAttributes(bucket) {
	    var attributes = {};
	    for (var interfaceName in bucket.programInterfaces) {
	        var interfaceAttributes = attributes[interfaceName] = { layoutAttributes: [], paintAttributes: {} };
	        var layerPaintAttributes = interfaceAttributes.paintAttributes;
	
	        for (var c = 0; c < bucket.childLayers.length; c++) {
	            var childLayer = bucket.childLayers[c];
	            layerPaintAttributes[childLayer.id] = { enabled: [], disabled: [] };
	        }
	
	        var interface_ = bucket.programInterfaces[interfaceName];
	        for (var i = 0; i < interface_.attributes.length; i++) {
	            var attribute = interface_.attributes[i];
	
	            if (attribute.paintProperty === undefined) {
	                interfaceAttributes.layoutAttributes.push(attribute);
	            } else {
	                for (var j = 0; j < bucket.childLayers.length; j++) {
	                    var layer = bucket.childLayers[j];
	                    var paintAttributes = layerPaintAttributes[layer.id];
	
	                    if (layer.isPaintValueFeatureConstant(attribute.paintProperty)) {
	                        paintAttributes.disabled.push(attribute);
	                    } else {
	                        paintAttributes.enabled.push(attribute);
	                    }
	                }
	            }
	        }
	    }
	    return attributes;
	}


/***/ },
/* 158 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = createFilter;
	
	var types = ['Unknown', 'Point', 'LineString', 'Polygon'];
	
	/**
	 * Given a filter expressed as nested arrays, return a new function
	 * that evaluates whether a given feature (with a .properties or .tags property)
	 * passes its test.
	 *
	 * @param {Array} filter mapbox gl filter
	 * @returns {Function} filter-evaluating function
	 */
	function createFilter(filter) {
	    return new Function('f', 'return ' + compile(filter));
	}
	
	function compile(filter) {
	    if (!filter) return 'true';
	    var op = filter[0];
	    if (filter.length <= 1) return op === 'any' ? 'false' : 'true';
	    var str =
	        op === '==' ? compare(filter[1], filter[2], '===', false) :
	        op === '!=' ? compare(filter[1], filter[2], '!==', false) :
	        op === '<' ||
	        op === '>' ||
	        op === '<=' ||
	        op === '>=' ? compare(filter[1], filter[2], op, true) :
	        op === 'any' ? filter.slice(1).map(compile).join('||') :
	        op === 'all' ? filter.slice(1).map(compile).join('&&') :
	        op === 'none' ? '!(' + filter.slice(1).map(compile).join('||') + ')' :
	        op === 'in' ? compileIn(filter[1], filter.slice(2)) :
	        op === '!in' ? '!(' + compileIn(filter[1], filter.slice(2)) + ')' :
	        'true';
	    return '(' + str + ')';
	}
	
	function valueExpr(key) {
	    return key === '$type' ? 'f.type' : '(f.properties || {})[' + JSON.stringify(key) + ']';
	}
	function compare(key, val, op, checkType) {
	    var left = valueExpr(key);
	    var right = key === '$type' ? types.indexOf(val) : JSON.stringify(val);
	    return (checkType ? 'typeof ' + left + '=== typeof ' + right + '&&' : '') + left + op + right;
	}
	function compileIn(key, values) {
	    if (key === '$type') values = values.map(function(value) { return types.indexOf(value); });
	    var left = JSON.stringify(values.sort(compareFn));
	    var right = valueExpr(key);
	
	    if (values.length <= 200) return left + '.indexOf(' + right + ') !== -1';
	
	    return 'function(v, a, i, j) {' +
	        'while (i <= j) { var m = (i + j) >> 1;' +
	        '    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;' +
	        '}' +
	    'return false; }(' + right + ', ' + left + ',0,' + (values.length - 1) + ')';
	}
	
	function compareFn(a, b) {
	    return a < b ? -1 : a > b ? 1 : 0;
	}


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	var assert = __webpack_require__(160);
	
	module.exports = Buffer;
	
	/**
	 * The `Buffer` class turns a `StructArray` into a WebGL buffer. Each member of the StructArray's
	 * Struct type is converted to a WebGL atribute.
	 *
	 * @class Buffer
	 * @private
	 * @param {object} array A serialized StructArray.
	 * @param {object} arrayType A serialized StructArrayType.
	 * @param {BufferType} type
	 */
	function Buffer(array, arrayType, type) {
	    this.arrayBuffer = array.arrayBuffer;
	    this.length = array.length;
	    this.attributes = arrayType.members;
	    this.itemSize = arrayType.bytesPerElement;
	    this.type = type;
	    this.arrayType = arrayType;
	}
	
	/**
	 * Bind this buffer to a WebGL context.
	 * @private
	 * @param gl The WebGL context
	 */
	Buffer.prototype.bind = function(gl) {
	    var type = gl[this.type];
	
	    if (!this.buffer) {
	        this.buffer = gl.createBuffer();
	        gl.bindBuffer(type, this.buffer);
	        gl.bufferData(type, this.arrayBuffer, gl.STATIC_DRAW);
	
	        // dump array buffer once it's bound to gl
	        this.arrayBuffer = null;
	    } else {
	        gl.bindBuffer(type, this.buffer);
	    }
	};
	
	/**
	 * @enum {string} AttributeType
	 * @private
	 * @readonly
	 */
	var AttributeType = {
	    Int8:   'BYTE',
	    Uint8:  'UNSIGNED_BYTE',
	    Int16:  'SHORT',
	    Uint16: 'UNSIGNED_SHORT'
	};
	
	/**
	 * Set the attribute pointers in a WebGL context
	 * @private
	 * @param gl The WebGL context
	 * @param program The active WebGL program
	 * @param {number} offset The index offset of the attribute data in the currently bound GL buffer.
	 */
	Buffer.prototype.setVertexAttribPointers = function(gl, program, offset) {
	    for (var j = 0; j < this.attributes.length; j++) {
	        var member = this.attributes[j];
	        var attribIndex = program[member.name];
	        assert(attribIndex !== undefined, 'array member "' + member.name + '" name does not match shader attribute name');
	
	        gl.vertexAttribPointer(
	            attribIndex,
	            member.components,
	            gl[AttributeType[member.type]],
	            false,
	            this.arrayType.bytesPerElement,
	            offset * this.arrayType.bytesPerElement + member.offset
	        );
	    }
	};
	
	/**
	 * Destroy the GL buffer bound to the given WebGL context
	 * @private
	 * @param gl The WebGL context
	 */
	Buffer.prototype.destroy = function(gl) {
	    if (this.buffer) {
	        gl.deleteBuffer(this.buffer);
	    }
	};
	
	/**
	 * @enum {string} BufferType
	 * @private
	 * @readonly
	 */
	Buffer.BufferType = {
	    VERTEX: 'ARRAY_BUFFER',
	    ELEMENT: 'ELEMENT_ARRAY_BUFFER'
	};
	
	/**
	 * An `BufferType.ELEMENT` buffer holds indicies of a corresponding `BufferType.VERTEX` buffer.
	 * These indicies are stored in the `BufferType.ELEMENT` buffer as `UNSIGNED_SHORT`s.
	 *
	 * @private
	 * @readonly
	 */
	Buffer.ELEMENT_ATTRIBUTE_TYPE = 'Uint16';
	
	/**
	 * WebGL performs best if vertex attribute offsets are aligned to 4 byte boundaries.
	 * @private
	 * @readonly
	 */
	Buffer.VERTEX_ATTRIBUTE_ALIGNMENT = 4;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144).Buffer))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(105);
	
	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;
	
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}
	
	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	
	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;
	
	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }
	
	    return true;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }
	
	  return false;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }
	
	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};
	
	assert.ifError = function(err) { if (err) {throw err;}};
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// Note: all "sizes" are measured in bytes
	
	var assert = __webpack_require__(160);
	
	module.exports = StructArrayType;
	
	var viewTypes = {
	    'Int8': Int8Array,
	    'Uint8': Uint8Array,
	    'Uint8Clamped': Uint8ClampedArray,
	    'Int16': Int16Array,
	    'Uint16': Uint16Array,
	    'Int32': Int32Array,
	    'Uint32': Uint32Array,
	    'Float32': Float32Array,
	    'Float64': Float64Array
	};
	
	/**
	 * @typedef StructMember
	 * @private
	 * @property {string} name
	 * @property {string} type
	 * @property {number} components
	 */
	
	var structArrayTypeCache = {};
	
	/**
	 * `StructArrayType` is used to create new `StructArray` types.
	 *
	 * `StructArray` provides an abstraction over `ArrayBuffer` and `TypedArray` making it behave like
	 * an array of typed structs. A StructArray is comprised of elements. Each element has a set of
	 * members that are defined when the `StructArrayType` is created.
	 *
	 * StructArrays useful for creating large arrays that:
	 * - can be transferred from workers as a Transferable object
	 * - can be copied cheaply
	 * - use less memory for lower-precision members
	 * - can be used as buffers in WebGL.
	 *
	 * @class StructArrayType
	 * @param {Array.<StructMember>}
	 * @param options
	 * @param {number} options.alignment Use `4` to align members to 4 byte boundaries. Default is 1.
	 *
	 * @example
	 *
	 * var PointArrayType = new StructArrayType({
	 *  members: [
	 *      { type: 'Int16', name: 'x' },
	 *      { type: 'Int16', name: 'y' }
	 *  ]});
	 *
	 *  var pointArray = new PointArrayType();
	 *  pointArray.emplaceBack(10, 15);
	 *  pointArray.emplaceBack(20, 35);
	 *
	 *  point = pointArray.get(0);
	 *  assert(point.x === 10);
	 *  assert(point.y === 15);
	 *
	 * @private
	 */
	function StructArrayType(options) {
	
	    var key = JSON.stringify(options);
	    if (structArrayTypeCache[key]) {
	        return structArrayTypeCache[key];
	    }
	
	    if (options.alignment === undefined) options.alignment = 1;
	
	    function StructType() {
	        Struct.apply(this, arguments);
	    }
	
	    StructType.prototype = Object.create(Struct.prototype);
	
	    var offset = 0;
	    var maxSize = 0;
	    var usedTypes = ['Uint8'];
	
	    StructType.prototype.members = options.members.map(function(member) {
	        member = {
	            name: member.name,
	            type: member.type,
	            components: member.components || 1
	        };
	
	        assert(member.name.length);
	        assert(member.type in viewTypes);
	
	        if (usedTypes.indexOf(member.type) < 0) usedTypes.push(member.type);
	
	        var typeSize = sizeOf(member.type);
	        maxSize = Math.max(maxSize, typeSize);
	        member.offset = offset = align(offset, Math.max(options.alignment, typeSize));
	
	        for (var c = 0; c < member.components; c++) {
	            Object.defineProperty(StructType.prototype, member.name + (member.components === 1 ? '' : c), {
	                get: createGetter(member, c),
	                set: createSetter(member, c)
	            });
	        }
	
	        offset += typeSize * member.components;
	
	        return member;
	    });
	
	    StructType.prototype.alignment = options.alignment;
	    StructType.prototype.size = align(offset, Math.max(maxSize, options.alignment));
	
	    function StructArrayType() {
	        StructArray.apply(this, arguments);
	        this.members = StructType.prototype.members;
	    }
	
	    StructArrayType.serialize = serializeStructArrayType;
	
	    StructArrayType.prototype = Object.create(StructArray.prototype);
	    StructArrayType.prototype.StructType = StructType;
	    StructArrayType.prototype.bytesPerElement = StructType.prototype.size;
	    StructArrayType.prototype.emplaceBack = createEmplaceBack(StructType.prototype.members, StructType.prototype.size);
	    StructArrayType.prototype._usedTypes = usedTypes;
	
	
	    structArrayTypeCache[key] = StructArrayType;
	
	    return StructArrayType;
	}
	
	/**
	 * Serialize the StructArray type. This serializes the *type* not an instance of the type.
	 * @private
	 */
	function serializeStructArrayType() {
	    return {
	        members: this.prototype.StructType.prototype.members,
	        alignment: this.prototype.StructType.prototype.alignment,
	        bytesPerElement: this.prototype.bytesPerElement
	    };
	}
	
	
	function align(offset, size) {
	    return Math.ceil(offset / size) * size;
	}
	
	function sizeOf(type) {
	    return viewTypes[type].BYTES_PER_ELEMENT;
	}
	
	function getArrayViewName(type) {
	    return type.toLowerCase();
	}
	
	
	/*
	 * > I saw major perf gains by shortening the source of these generated methods (i.e. renaming
	 * > elementIndex to i) (likely due to v8 inlining heuristics).
	 * - lucaswoj
	 */
	function createEmplaceBack(members, bytesPerElement) {
	    var usedTypeSizes = [];
	    var argNames = [];
	    var body = '' +
	    'var i = this.length;\n' +
	    'this.resize(this.length + 1);\n';
	
	    for (var m = 0; m < members.length; m++) {
	        var member = members[m];
	        var size = sizeOf(member.type);
	
	        if (usedTypeSizes.indexOf(size) < 0) {
	            usedTypeSizes.push(size);
	            body += 'var o' + size.toFixed(0) + ' = i * ' + (bytesPerElement / size).toFixed(0) + ';\n';
	        }
	
	        for (var c = 0; c < member.components; c++) {
	            var argName = 'v' + argNames.length;
	            var index = 'o' + size.toFixed(0) + ' + ' + (member.offset / size + c).toFixed(0);
	            body += 'this.' + getArrayViewName(member.type) + '[' + index + '] = ' + argName + ';\n';
	            argNames.push(argName);
	        }
	    }
	
	    body += 'return i;';
	
	    return new Function(argNames, body);
	}
	
	function createMemberComponentString(member, component) {
	    var elementOffset = 'this._pos' + sizeOf(member.type).toFixed(0);
	    var componentOffset = (member.offset / sizeOf(member.type) + component).toFixed(0);
	    var index = elementOffset + ' + ' + componentOffset;
	    return 'this._structArray.' + getArrayViewName(member.type) + '[' + index + ']';
	
	}
	
	function createGetter(member, c) {
	    return new Function([], 'return ' + createMemberComponentString(member, c) + ';');
	}
	
	function createSetter(member, c) {
	    return new Function(['x'], createMemberComponentString(member, c) + ' = x;');
	}
	
	/**
	 * @class Struct
	 * @param {StructArray} structArray The StructArray the struct is stored in
	 * @param {number} index The index of the struct in the StructArray.
	 * @private
	 */
	function Struct(structArray, index) {
	    this._structArray = structArray;
	    this._pos1 = index * this.size;
	    this._pos2 = this._pos1 / 2;
	    this._pos4 = this._pos1 / 4;
	    this._pos8 = this._pos1 / 8;
	}
	
	/**
	 * @class StructArray
	 * The StructArray class is inherited by the custom StructArrayType classes created with
	 * `new StructArrayType(members, options)`.
	 * @private
	 */
	function StructArray(serialized) {
	    if (serialized !== undefined) {
	    // Create from an serialized StructArray
	        this.arrayBuffer = serialized.arrayBuffer;
	        this.length = serialized.length;
	        this.capacity = this.arrayBuffer.byteLength / this.bytesPerElement;
	        this._refreshViews();
	
	    // Create a new StructArray
	    } else {
	        this.capacity = -1;
	        this.resize(0);
	    }
	}
	
	/**
	 * @property {number}
	 * @private
	 * @readonly
	 */
	StructArray.prototype.DEFAULT_CAPACITY = 128;
	
	/**
	 * @property {number}
	 * @private
	 * @readonly
	 */
	StructArray.prototype.RESIZE_MULTIPLIER = 5;
	
	/**
	 * Serialize this StructArray instance
	 * @private
	 */
	StructArray.prototype.serialize = function() {
	    this.trim();
	    return {
	        length: this.length,
	        arrayBuffer: this.arrayBuffer
	    };
	};
	
	/**
	 * Return the Struct at the given location in the array.
	 * @private
	 * @param {number} index The index of the element.
	 */
	StructArray.prototype.get = function(index) {
	    return new this.StructType(this, index);
	};
	
	/**
	 * Resize the array to discard unused capacity.
	 * @private
	 */
	StructArray.prototype.trim = function() {
	    if (this.length !== this.capacity) {
	        this.capacity = this.length;
	        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);
	        this._refreshViews();
	    }
	};
	
	/**
	 * Resize the array.
	 * If `n` is greater than the current length then additional elements with undefined values are added.
	 * If `n` is less than the current length then the array will be reduced to the first `n` elements.
	 * @param {number} n The new size of the array.
	 */
	StructArray.prototype.resize = function(n) {
	    this.length = n;
	    if (n > this.capacity) {
	        this.capacity = Math.max(n, Math.floor(this.capacity * this.RESIZE_MULTIPLIER), this.DEFAULT_CAPACITY);
	        this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
	
	        var oldUint8Array = this.uint8;
	        this._refreshViews();
	        if (oldUint8Array) this.uint8.set(oldUint8Array);
	    }
	};
	
	/**
	 * Create TypedArray views for the current ArrayBuffer.
	 * @private
	 */
	StructArray.prototype._refreshViews = function() {
	    for (var t = 0; t < this._usedTypes.length; t++) {
	        var type = this._usedTypes[t];
	        this[getArrayViewName(type)] = new viewTypes[type](this.arrayBuffer);
	    }
	};


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Bucket = __webpack_require__(157);
	var util = __webpack_require__(82);
	var loadGeometry = __webpack_require__(156);
	
	module.exports = FillBucket;
	
	function FillBucket() {
	    Bucket.apply(this, arguments);
	}
	
	FillBucket.prototype = util.inherit(Bucket, {});
	
	FillBucket.prototype.addFillVertex = function(x, y) {
	    return this.arrays.fillVertex.emplaceBack(x, y);
	};
	
	FillBucket.prototype.programInterfaces = {
	    fill: {
	        vertexBuffer: true,
	        elementBuffer: true,
	        secondElementBuffer: true,
	        secondElementBufferComponents: 2,
	
	        attributes: [{
	            name: 'a_pos',
	            components: 2,
	            type: 'Int16'
	        }]
	    }
	};
	
	FillBucket.prototype.addFeature = function(feature) {
	    var lines = loadGeometry(feature);
	    for (var i = 0; i < lines.length; i++) {
	        this.addFill(lines[i]);
	    }
	};
	
	FillBucket.prototype.addFill = function(vertices) {
	    if (vertices.length < 3) {
	        //console.warn('a fill must have at least three vertices');
	        return;
	    }
	
	    // Calculate the total number of vertices we're going to produce so that we
	    // can resize the buffer beforehand, or detect whether the current line
	    // won't fit into the buffer anymore.
	    // In order to be able to use the vertex buffer for drawing the antialiased
	    // outlines, we separate all polygon vertices with a degenerate (out-of-
	    // viewplane) vertex.
	
	    var len = vertices.length;
	
	    // Expand this geometry buffer to hold all the required vertices.
	    var group = this.makeRoomFor('fill', len + 1);
	
	    // We're generating triangle fans, so we always start with the first coordinate in this polygon.
	    var firstIndex, prevIndex;
	    for (var i = 0; i < vertices.length; i++) {
	        var currentVertex = vertices[i];
	
	        var currentIndex = this.addFillVertex(currentVertex.x, currentVertex.y) - group.vertexStartIndex;
	        group.vertexLength++;
	        if (i === 0) firstIndex = currentIndex;
	
	        // Only add triangles that have distinct vertices.
	        if (i >= 2 && (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
	            this.arrays.fillElement.emplaceBack(firstIndex, prevIndex, currentIndex);
	            group.elementLength++;
	        }
	
	        if (i >= 1) {
	            this.arrays.fillSecondElement.emplaceBack(prevIndex, currentIndex);
	            group.secondElementLength++;
	        }
	
	        prevIndex = currentIndex;
	    }
	};


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Bucket = __webpack_require__(157);
	var util = __webpack_require__(82);
	var loadGeometry = __webpack_require__(156);
	var EXTENT = Bucket.EXTENT;
	
	// NOTE ON EXTRUDE SCALE:
	// scale the extrusion vector so that the normal length is this value.
	// contains the "texture" normals (-1..1). this is distinct from the extrude
	// normals for line joins, because the x-value remains 0 for the texture
	// normal array, while the extrude normal actually moves the vertex to create
	// the acute/bevelled line join.
	var EXTRUDE_SCALE = 63;
	
	/*
	 * Sharp corners cause dashed lines to tilt because the distance along the line
	 * is the same at both the inner and outer corners. To improve the appearance of
	 * dashed lines we add extra points near sharp corners so that a smaller part
	 * of the line is tilted.
	 *
	 * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an
	 * extra vertex. The default is 75 degrees.
	 *
	 * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.
	 */
	var COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));
	var SHARP_CORNER_OFFSET = 15;
	
	// The number of bits that is used to store the line distance in the buffer.
	var LINE_DISTANCE_BUFFER_BITS = 14;
	
	// We don't have enough bits for the line distance as we'd like to have, so
	// use this value to scale the line distance (in tile units) down to a smaller
	// value. This lets us store longer distances while sacrificing precision.
	var LINE_DISTANCE_SCALE = 1 / 2;
	
	// The maximum line distance, in tile units, that fits in the buffer.
	var MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS) / LINE_DISTANCE_SCALE;
	
	
	module.exports = LineBucket;
	
	/**
	 * @private
	 */
	function LineBucket() {
	    Bucket.apply(this, arguments);
	}
	
	LineBucket.prototype = util.inherit(Bucket, {});
	
	LineBucket.prototype.addLineVertex = function(point, extrude, tx, ty, dir, linesofar) {
	    return this.arrays.lineVertex.emplaceBack(
	            // a_pos
	            (point.x << 1) | tx,
	            (point.y << 1) | ty,
	            // a_data
	            // add 128 to store an byte in an unsigned byte
	            Math.round(EXTRUDE_SCALE * extrude.x) + 128,
	            Math.round(EXTRUDE_SCALE * extrude.y) + 128,
	            // Encode the -1/0/1 direction value into the first two bits of .z of a_data.
	            // Combine it with the lower 6 bits of `linesofar` (shifted by 2 bites to make
	            // room for the direction value). The upper 8 bits of `linesofar` are placed in
	            // the `w` component. `linesofar` is scaled down by `LINE_DISTANCE_SCALE` so that
	            // we can store longer distances while sacrificing precision.
	            ((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * LINE_DISTANCE_SCALE) & 0x3F) << 2),
	            (linesofar * LINE_DISTANCE_SCALE) >> 6);
	};
	
	LineBucket.prototype.programInterfaces = {
	    line: {
	        vertexBuffer: true,
	        elementBuffer: true,
	
	        attributes: [{
	            name: 'a_pos',
	            components: 2,
	            type: 'Int16'
	        }, {
	            name: 'a_data',
	            components: 4,
	            type: 'Uint8'
	        }]
	    }
	};
	
	LineBucket.prototype.addFeature = function(feature) {
	    var lines = loadGeometry(feature);
	    for (var i = 0; i < lines.length; i++) {
	        this.addLine(
	            lines[i],
	            this.layer.layout['line-join'],
	            this.layer.layout['line-cap'],
	            this.layer.layout['line-miter-limit'],
	            this.layer.layout['line-round-limit']
	        );
	    }
	};
	
	LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {
	
	    var len = vertices.length;
	    // If the line has duplicate vertices at the end, adjust length to remove them.
	    while (len > 2 && vertices[len - 1].equals(vertices[len - 2])) {
	        len--;
	    }
	
	    if (vertices.length < 2) {
	        //console.warn('a line must have at least two vertices');
	        return;
	    }
	
	    if (join === 'bevel') miterLimit = 1.05;
	
	    var sharpCornerOffset = SHARP_CORNER_OFFSET * (EXTENT / (512 * this.overscaling));
	
	    var firstVertex = vertices[0],
	        lastVertex = vertices[len - 1],
	        closed = firstVertex.equals(lastVertex);
	
	    // we could be more precise, but it would only save a negligible amount of space
	    this.makeRoomFor('line', len * 10);
	
	    if (len === 2 && closed) {
	        // console.warn('a line may not have coincident points');
	        return;
	    }
	
	    this.distance = 0;
	
	    var beginCap = cap,
	        endCap = closed ? 'butt' : cap,
	        startOfLine = true,
	        currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;
	
	    // the last three vertices added
	    this.e1 = this.e2 = this.e3 = -1;
	
	    if (closed) {
	        currentVertex = vertices[len - 2];
	        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
	    }
	
	    for (var i = 0; i < len; i++) {
	
	        nextVertex = closed && i === len - 1 ?
	            vertices[1] : // if the line is closed, we treat the last vertex like the first
	            vertices[i + 1]; // just the next vertex
	
	        // if two consecutive vertices exist, skip the current one
	        if (nextVertex && vertices[i].equals(nextVertex)) continue;
	
	        if (nextNormal) prevNormal = nextNormal;
	        if (currentVertex) prevVertex = currentVertex;
	
	        currentVertex = vertices[i];
	
	        // Calculate the normal towards the next vertex in this line. In case
	        // there is no next vertex, pretend that the line is continuing straight,
	        // meaning that we are just using the previous normal.
	        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;
	
	        // If we still don't have a previous normal, this is the beginning of a
	        // non-closed line, so we're doing a straight "join".
	        prevNormal = prevNormal || nextNormal;
	
	        // Determine the normal of the join extrusion. It is the angle bisector
	        // of the segments between the previous line and the next line.
	        var joinNormal = prevNormal.add(nextNormal)._unit();
	
	        /*  joinNormal     prevNormal
	         *                   
	         *                .________. prevVertex
	         *                |
	         * nextNormal    |  currentVertex
	         *                |
	         *     nextVertex !
	         *
	         */
	
	        // Calculate the length of the miter (the ratio of the miter to the width).
	        // Find the cosine of the angle between the next and join normals
	        // using dot product. The inverse of that is the miter length.
	        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
	        var miterLength = 1 / cosHalfAngle;
	
	        var isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;
	
	        if (isSharpCorner && i > 0) {
	            var prevSegmentLength = currentVertex.dist(prevVertex);
	            if (prevSegmentLength > 2 * sharpCornerOffset) {
	                var newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());
	                this.distance += newPrevVertex.dist(prevVertex);
	                this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false);
	                prevVertex = newPrevVertex;
	            }
	        }
	
	        // The join if a middle vertex, otherwise the cap.
	        var middleVertex = prevVertex && nextVertex;
	        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;
	
	        if (middleVertex && currentJoin === 'round') {
	            if (miterLength < roundLimit) {
	                currentJoin = 'miter';
	            } else if (miterLength <= 2) {
	                currentJoin = 'fakeround';
	            }
	        }
	
	        if (currentJoin === 'miter' && miterLength > miterLimit) {
	            currentJoin = 'bevel';
	        }
	
	        if (currentJoin === 'bevel') {
	            // The maximum extrude length is 128 / 63 = 2 times the width of the line
	            // so if miterLength >= 2 we need to draw a different type of bevel where.
	            if (miterLength > 2) currentJoin = 'flipbevel';
	
	            // If the miterLength is really small and the line bevel wouldn't be visible,
	            // just draw a miter join to save a triangle.
	            if (miterLength < miterLimit) currentJoin = 'miter';
	        }
	
	        // Calculate how far along the line the currentVertex is
	        if (prevVertex) this.distance += currentVertex.dist(prevVertex);
	
	        if (currentJoin === 'miter') {
	
	            joinNormal._mult(miterLength);
	            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);
	
	        } else if (currentJoin === 'flipbevel') {
	            // miter is too big, flip the direction to make a beveled join
	
	            if (miterLength > 100) {
	                // Almost parallel lines
	                joinNormal = nextNormal.clone();
	
	            } else {
	                var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
	                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
	                joinNormal._perp()._mult(bevelLength * direction);
	            }
	            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);
	            this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false);
	
	        } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {
	            var lineTurnsLeft = (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;
	            var offset = -Math.sqrt(miterLength * miterLength - 1);
	            if (lineTurnsLeft) {
	                offsetB = 0;
	                offsetA = offset;
	            } else {
	                offsetA = 0;
	                offsetB = offset;
	            }
	
	            // Close previous segment with a bevel
	            if (!startOfLine) {
	                this.addCurrentVertex(currentVertex, this.distance, prevNormal, offsetA, offsetB, false);
	            }
	
	            if (currentJoin === 'fakeround') {
	                // The join angle is sharp enough that a round join would be visible.
	                // Bevel joins fill the gap between segments with a single pie slice triangle.
	                // Create a round join by adding multiple pie slices. The join isn't actually round, but
	                // it looks like it is at the sizes we render lines at.
	
	                // Add more triangles for sharper angles.
	                // This math is just a good enough approximation. It isn't "correct".
	                var n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);
	                var approxFractionalJoinNormal;
	
	                for (var m = 0; m < n; m++) {
	                    approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();
	                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
	                }
	
	                this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft);
	
	                for (var k = n - 1; k >= 0; k--) {
	                    approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();
	                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
	                }
	            }
	
	            // Start next segment
	            if (nextVertex) {
	                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -offsetA, -offsetB, false);
	            }
	
	        } else if (currentJoin === 'butt') {
	            if (!startOfLine) {
	                // Close previous segment with a butt
	                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);
	            }
	
	            // Start next segment with a butt
	            if (nextVertex) {
	                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
	            }
	
	        } else if (currentJoin === 'square') {
	
	            if (!startOfLine) {
	                // Close previous segment with a square cap
	                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false);
	
	                // The segment is done. Unset vertices to disconnect segments.
	                this.e1 = this.e2 = -1;
	            }
	
	            // Start next segment
	            if (nextVertex) {
	                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false);
	            }
	
	        } else if (currentJoin === 'round') {
	
	            if (!startOfLine) {
	                // Close previous segment with butt
	                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);
	
	                // Add round cap or linejoin at end of segment
	                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true);
	
	                // The segment is done. Unset vertices to disconnect segments.
	                this.e1 = this.e2 = -1;
	            }
	
	
	            // Start next segment with a butt
	            if (nextVertex) {
	                // Add round cap before first segment
	                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true);
	
	                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
	            }
	        }
	
	        if (isSharpCorner && i < len - 1) {
	            var nextSegmentLength = currentVertex.dist(nextVertex);
	            if (nextSegmentLength > 2 * sharpCornerOffset) {
	                var newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());
	                this.distance += newCurrentVertex.dist(currentVertex);
	                this.addCurrentVertex(newCurrentVertex, this.distance, nextNormal.mult(1), 0, 0, false);
	                currentVertex = newCurrentVertex;
	            }
	        }
	
	        startOfLine = false;
	    }
	
	};
	
	/**
	 * Add two vertices to the buffers.
	 *
	 * @param {Object} currentVertex the line vertex to add buffer vertices for
	 * @param {number} distance the distance from the beginning of the line to the vertex
	 * @param {number} endLeft extrude to shift the left vertex along the line
	 * @param {number} endRight extrude to shift the left vertex along the line
	 * @param {boolean} round whether this is a round cap
	 * @private
	 */
	LineBucket.prototype.addCurrentVertex = function(currentVertex, distance, normal, endLeft, endRight, round) {
	    var tx = round ? 1 : 0;
	    var extrude;
	    var group = this.elementGroups.line[this.elementGroups.line.length - 1];
	    group.vertexLength += 2;
	
	    extrude = normal.clone();
	    if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
	    this.e3 = this.addLineVertex(currentVertex, extrude, tx, 0, endLeft, distance) - group.vertexStartIndex;
	    if (this.e1 >= 0 && this.e2 >= 0) {
	        this.arrays.lineElement.emplaceBack(this.e1, this.e2, this.e3);
	        group.elementLength++;
	    }
	    this.e1 = this.e2;
	    this.e2 = this.e3;
	
	    extrude = normal.mult(-1);
	    if (endRight) extrude._sub(normal.perp()._mult(endRight));
	    this.e3 = this.addLineVertex(currentVertex, extrude, tx, 1, -endRight, distance) - group.vertexStartIndex;
	    if (this.e1 >= 0 && this.e2 >= 0) {
	        this.arrays.lineElement.emplaceBack(this.e1, this.e2, this.e3);
	        group.elementLength++;
	    }
	    this.e1 = this.e2;
	    this.e2 = this.e3;
	
	    // There is a maximum "distance along the line" that we can store in the buffers.
	    // When we get close to the distance, reset it to zero and add the vertex again with
	    // a distance of zero. The max distance is determined by the number of bits we allocate
	    // to `linesofar`.
	    if (distance > MAX_LINE_DISTANCE / 2) {
	        this.distance = 0;
	        this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round);
	    }
	};
	
	/**
	 * Add a single new vertex and a triangle using two previous vertices.
	 * This adds a pie slice triangle near a join to simulate round joins
	 *
	 * @param {Object} currentVertex the line vertex to add buffer vertices for
	 * @param {number} distance the distance from the beggining of the line to the vertex
	 * @param {Object} extrude the offset of the new vertex from the currentVertex
	 * @param {boolean} whether the line is turning left or right at this angle
	 * @private
	 */
	LineBucket.prototype.addPieSliceVertex = function(currentVertex, distance, extrude, lineTurnsLeft) {
	    var ty = lineTurnsLeft ? 1 : 0;
	    extrude = extrude.mult(lineTurnsLeft ? -1 : 1);
	    var group = this.elementGroups.line[this.elementGroups.line.length - 1];
	
	    this.e3 = this.addLineVertex(currentVertex, extrude, 0, ty, 0, distance) - group.vertexStartIndex;
	    group.vertexLength++;
	
	    if (this.e1 >= 0 && this.e2 >= 0) {
	        this.arrays.lineElement.emplaceBack(this.e1, this.e2, this.e3);
	        group.elementLength++;
	    }
	
	    if (lineTurnsLeft) {
	        this.e2 = this.e3;
	    } else {
	        this.e1 = this.e3;
	    }
	};


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Bucket = __webpack_require__(157);
	var util = __webpack_require__(82);
	var loadGeometry = __webpack_require__(156);
	var EXTENT = Bucket.EXTENT;
	
	module.exports = CircleBucket;
	
	/**
	 * Circles are represented by two triangles.
	 *
	 * Each corner has a pos that is the center of the circle and an extrusion
	 * vector that is where it points.
	 * @private
	 */
	function CircleBucket() {
	    Bucket.apply(this, arguments);
	}
	
	CircleBucket.prototype = util.inherit(Bucket, {});
	
	CircleBucket.prototype.addCircleVertex = function(x, y, extrudeX, extrudeY) {
	    return this.arrays.circleVertex.emplaceBack(
	            (x * 2) + ((extrudeX + 1) / 2),
	            (y * 2) + ((extrudeY + 1) / 2));
	};
	
	CircleBucket.prototype.programInterfaces = {
	    circle: {
	        vertexBuffer: true,
	        elementBuffer: true,
	
	        attributes: [{
	            name: 'a_pos',
	            components: 2,
	            type: 'Int16'
	        }, {
	            name: 'a_color',
	            components: 4,
	            type: 'Uint8',
	            getValue: function(layer, globalProperties, featureProperties) {
	                return util.premultiply(layer.getPaintValue("circle-color", globalProperties, featureProperties));
	            },
	            multiplier: 255,
	            paintProperty: 'circle-color'
	        }, {
	            name: 'a_radius',
	            components: 1,
	            type: 'Uint16',
	            isLayerConstant: false,
	            getValue: function(layer, globalProperties, featureProperties) {
	                return [layer.getPaintValue("circle-radius", globalProperties, featureProperties)];
	            },
	            multiplier: 10,
	            paintProperty: 'circle-radius'
	        }]
	    }
	};
	
	CircleBucket.prototype.addFeature = function(feature) {
	    var globalProperties = {zoom: this.zoom};
	    var geometries = loadGeometry(feature);
	
	    var startIndex = this.arrays.circleVertex.length;
	
	    for (var j = 0; j < geometries.length; j++) {
	        for (var k = 0; k < geometries[j].length; k++) {
	
	            var x = geometries[j][k].x;
	            var y = geometries[j][k].y;
	
	            // Do not include points that are outside the tile boundaries.
	            if (x < 0 || x >= EXTENT || y < 0 || y >= EXTENT) continue;
	
	            // this geometry will be of the Point type, and we'll derive
	            // two triangles from it.
	            //
	            // 
	            //  3     2 
	            //          
	            //  0     1 
	            // 
	
	            var group = this.makeRoomFor('circle', 4);
	
	            var index = this.addCircleVertex(x, y, -1, -1) - group.vertexStartIndex;
	            this.addCircleVertex(x, y, 1, -1);
	            this.addCircleVertex(x, y, 1, 1);
	            this.addCircleVertex(x, y, -1, 1);
	            group.vertexLength += 4;
	
	            this.arrays.circleElement.emplaceBack(index, index + 1, index + 2);
	            this.arrays.circleElement.emplaceBack(index, index + 3, index + 2);
	            group.elementLength += 2;
	        }
	    }
	
	    this.addPaintAttributes('circle', globalProperties, feature.properties, startIndex, this.arrays.circleVertex.length);
	};


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	var Point = __webpack_require__(88);
	
	var Bucket = __webpack_require__(157);
	var Anchor = __webpack_require__(166);
	var getAnchors = __webpack_require__(167);
	var resolveTokens = __webpack_require__(169);
	var Quads = __webpack_require__(170);
	var Shaping = __webpack_require__(171);
	var resolveText = __webpack_require__(172);
	var mergeLines = __webpack_require__(173);
	var clipLine = __webpack_require__(174);
	var util = __webpack_require__(82);
	var loadGeometry = __webpack_require__(156);
	var CollisionFeature = __webpack_require__(175);
	
	var shapeText = Shaping.shapeText;
	var shapeIcon = Shaping.shapeIcon;
	var getGlyphQuads = Quads.getGlyphQuads;
	var getIconQuads = Quads.getIconQuads;
	
	var EXTENT = Bucket.EXTENT;
	
	module.exports = SymbolBucket;
	
	function SymbolBucket(options) {
	    Bucket.apply(this, arguments);
	    this.showCollisionBoxes = options.showCollisionBoxes;
	    this.overscaling = options.overscaling;
	    this.collisionBoxArray = options.collisionBoxArray;
	}
	
	SymbolBucket.prototype = util.inherit(Bucket, {});
	
	var programAttributes = [{
	    name: 'a_pos',
	    components: 2,
	    type: 'Int16'
	}, {
	    name: 'a_offset',
	    components: 2,
	    type: 'Int16'
	}, {
	    name: 'a_data1',
	    components: 4,
	    type: 'Uint8'
	}, {
	    name: 'a_data2',
	    components: 2,
	    type: 'Uint8'
	}];
	
	function addVertex(array, x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom) {
	    return array.emplaceBack(
	            // pos
	            x,
	            y,
	            // offset
	            Math.round(ox * 64), // use 1/64 pixels for placement
	            Math.round(oy * 64),
	            // data1
	            tx / 4,                   // tex
	            ty / 4,                   // tex
	            (labelminzoom || 0) * 10, // labelminzoom
	            0,
	            // data2
	            (minzoom || 0) * 10,               // minzoom
	            Math.min(maxzoom || 25, 25) * 10); // minzoom
	}
	
	SymbolBucket.prototype.addCollisionBoxVertex = function(point, extrude, maxZoom, placementZoom) {
	    return this.arrays.collisionBoxVertex.emplaceBack(
	            // pos
	            point.x,
	            point.y,
	            // extrude
	            Math.round(extrude.x),
	            Math.round(extrude.y),
	            // data
	            maxZoom * 10,
	            placementZoom * 10);
	};
	
	SymbolBucket.prototype.programInterfaces = {
	
	    glyph: {
	        vertexBuffer: true,
	        elementBuffer: true,
	        attributes: programAttributes
	    },
	
	    icon: {
	        vertexBuffer: true,
	        elementBuffer: true,
	        attributes: programAttributes
	    },
	
	    collisionBox: {
	        vertexBuffer: true,
	
	        attributes: [{
	            name: 'a_pos',
	            components: 2,
	            type: 'Int16'
	        }, {
	            name: 'a_extrude',
	            components: 2,
	            type: 'Int16'
	        }, {
	            name: 'a_data',
	            components: 2,
	            type: 'Uint8'
	        }]
	    }
	};
	
	SymbolBucket.prototype.populateBuffers = function(collisionTile, stacks, icons) {
	
	    // To reduce the number of labels that jump around when zooming we need
	    // to use a text-size value that is the same for all zoom levels.
	    // This calculates text-size at a high zoom level so that all tiles can
	    // use the same value when calculating anchor positions.
	    var zoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };
	    this.adjustedTextMaxSize = this.layer.getLayoutValue('text-size', {zoom: 18, zoomHistory: zoomHistory});
	    this.adjustedTextSize = this.layer.getLayoutValue('text-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});
	    this.adjustedIconMaxSize = this.layer.getLayoutValue('icon-size', {zoom: 18, zoomHistory: zoomHistory});
	    this.adjustedIconSize = this.layer.getLayoutValue('icon-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});
	
	    var tileSize = 512 * this.overscaling;
	    this.tilePixelRatio = EXTENT / tileSize;
	    this.compareText = {};
	    this.symbolInstances = [];
	    this.iconsNeedLinear = false;
	
	    var layout = this.layer.layout;
	    var features = this.features;
	    var textFeatures = this.textFeatures;
	
	    var horizontalAlign = 0.5,
	        verticalAlign = 0.5;
	
	    switch (layout['text-anchor']) {
	    case 'right':
	    case 'top-right':
	    case 'bottom-right':
	        horizontalAlign = 1;
	        break;
	    case 'left':
	    case 'top-left':
	    case 'bottom-left':
	        horizontalAlign = 0;
	        break;
	    }
	
	    switch (layout['text-anchor']) {
	    case 'bottom':
	    case 'bottom-right':
	    case 'bottom-left':
	        verticalAlign = 1;
	        break;
	    case 'top':
	    case 'top-right':
	    case 'top-left':
	        verticalAlign = 0;
	        break;
	    }
	
	    var justify = layout['text-justify'] === 'right' ? 1 :
	        layout['text-justify'] === 'left' ? 0 :
	        0.5;
	
	    var oneEm = 24;
	    var lineHeight = layout['text-line-height'] * oneEm;
	    var maxWidth = layout['symbol-placement'] !== 'line' ? layout['text-max-width'] * oneEm : 0;
	    var spacing = layout['text-letter-spacing'] * oneEm;
	    var textOffset = [layout['text-offset'][0] * oneEm, layout['text-offset'][1] * oneEm];
	    var fontstack = layout['text-font'].join(',');
	
	    var geometries = [];
	    for (var g = 0; g < features.length; g++) {
	        geometries.push(loadGeometry(features[g]));
	    }
	
	    if (layout['symbol-placement'] === 'line') {
	        // Merge adjacent lines with the same text to improve labelling.
	        // It's better to place labels on one long line than on many short segments.
	        var merged = mergeLines(features, textFeatures, geometries);
	
	        geometries = merged.geometries;
	        features = merged.features;
	        textFeatures = merged.textFeatures;
	    }
	
	    var shapedText, shapedIcon;
	
	    for (var k = 0; k < features.length; k++) {
	        if (!geometries[k]) continue;
	
	        if (textFeatures[k]) {
	            shapedText = shapeText(textFeatures[k], stacks[fontstack], maxWidth,
	                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
	        } else {
	            shapedText = null;
	        }
	
	        if (layout['icon-image']) {
	            var iconName = resolveTokens(features[k].properties, layout['icon-image']);
	            var image = icons[iconName];
	            shapedIcon = shapeIcon(image, layout);
	
	            if (image) {
	                if (this.sdfIcons === undefined) {
	                    this.sdfIcons = image.sdf;
	                } else if (this.sdfIcons !== image.sdf) {
	                    console.warn('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');
	                }
	                if (image.pixelRatio !== 1) {
	                    this.iconsNeedLinear = true;
	                }
	            }
	        } else {
	            shapedIcon = null;
	        }
	
	        if (shapedText || shapedIcon) {
	            this.addFeature(geometries[k], shapedText, shapedIcon, features[k].index);
	        }
	    }
	
	    this.placeFeatures(collisionTile, this.showCollisionBoxes);
	
	    this.trimArrays();
	};
	
	SymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon, featureIndex) {
	    var layout = this.layer.layout;
	
	    var glyphSize = 24;
	
	    var fontScale = this.adjustedTextSize / glyphSize,
	        textMaxSize = this.adjustedTextMaxSize !== undefined ? this.adjustedTextMaxSize : this.adjustedTextSize,
	        textBoxScale = this.tilePixelRatio * fontScale,
	        textMaxBoxScale = this.tilePixelRatio * textMaxSize / glyphSize,
	        iconBoxScale = this.tilePixelRatio * this.adjustedIconSize,
	        symbolMinDistance = this.tilePixelRatio * layout['symbol-spacing'],
	        avoidEdges = layout['symbol-avoid-edges'],
	        textPadding = layout['text-padding'] * this.tilePixelRatio,
	        iconPadding = layout['icon-padding'] * this.tilePixelRatio,
	        textMaxAngle = layout['text-max-angle'] / 180 * Math.PI,
	        textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
	        iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
	        mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
	            layout['text-ignore-placement'] || layout['icon-ignore-placement'],
	        isLine = layout['symbol-placement'] === 'line',
	        textRepeatDistance = symbolMinDistance / 2;
	
	    if (isLine) {
	        lines = clipLine(lines, 0, 0, EXTENT, EXTENT);
	    }
	
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	
	        // Calculate the anchor points around which you want to place labels
	        var anchors;
	        if (isLine) {
	            anchors = getAnchors(
	                line,
	                symbolMinDistance,
	                textMaxAngle,
	                shapedText,
	                shapedIcon,
	                glyphSize,
	                textMaxBoxScale,
	                this.overscaling,
	                EXTENT
	            );
	        } else {
	            anchors = [ new Anchor(line[0].x, line[0].y, 0) ];
	        }
	
	        // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.
	        for (var j = 0, len = anchors.length; j < len; j++) {
	            var anchor = anchors[j];
	
	            if (shapedText && isLine) {
	                if (this.anchorIsTooClose(shapedText.text, textRepeatDistance, anchor)) {
	                    continue;
	                }
	            }
	
	            var inside = !(anchor.x < 0 || anchor.x > EXTENT || anchor.y < 0 || anchor.y > EXTENT);
	
	            if (avoidEdges && !inside) continue;
	
	            // Normally symbol layers are drawn across tile boundaries. Only symbols
	            // with their anchors within the tile boundaries are added to the buffers
	            // to prevent symbols from being drawn twice.
	            //
	            // Symbols in layers with overlap are sorted in the y direction so that
	            // symbols lower on the canvas are drawn on top of symbols near the top.
	            // To preserve this order across tile boundaries these symbols can't
	            // be drawn across tile boundaries. Instead they need to be included in
	            // the buffers for both tiles and clipped to tile boundaries at draw time.
	            var addToBuffers = inside || mayOverlap;
	
	            this.symbolInstances.push(new SymbolInstance(anchor, line, shapedText, shapedIcon, layout,
	                        addToBuffers, this.symbolInstances.length, this.collisionBoxArray, featureIndex, this.sourceLayerIndex, this.index,
	                        textBoxScale, textPadding, textAlongLine,
	                        iconBoxScale, iconPadding, iconAlongLine));
	        }
	    }
	};
	
	SymbolBucket.prototype.anchorIsTooClose = function(text, repeatDistance, anchor) {
	    var compareText = this.compareText;
	    if (!(text in compareText)) {
	        compareText[text] = [];
	    } else {
	        var otherAnchors = compareText[text];
	        for (var k = otherAnchors.length - 1; k >= 0; k--) {
	            if (anchor.dist(otherAnchors[k]) < repeatDistance) {
	                // If it's within repeatDistance of one anchor, stop looking
	                return true;
	            }
	        }
	    }
	    // If anchor is not within repeatDistance of any other anchor, add to array
	    compareText[text].push(anchor);
	    return false;
	};
	
	SymbolBucket.prototype.placeFeatures = function(collisionTile, showCollisionBoxes) {
	    this.recalculateStyleLayers();
	
	    // Calculate which labels can be shown and when they can be shown and
	    // create the bufers used for rendering.
	
	    this.createArrays();
	
	    var elementGroups = this.elementGroups = {
	        glyph: [],
	        icon: [],
	        sdfIcons: this.sdfIcons,
	        iconsNeedLinear: this.iconsNeedLinear
	    };
	
	    var layout = this.layer.layout;
	    var maxScale = collisionTile.maxScale;
	
	    elementGroups.glyph.adjustedSize = this.adjustedTextSize;
	    elementGroups.icon.adjustedSize = this.adjustedIconSize;
	
	    // Transfer the name of the fonstack back to the main thread along with the buffers.
	    // The draw function needs to know which fonstack's glyph atlas to bind when rendering.
	    elementGroups.glyph.fontstack = layout['text-font'].join(',');
	
	    var textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';
	    var iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';
	
	    var mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
	        layout['text-ignore-placement'] || layout['icon-ignore-placement'];
	
	    // Sort symbols by their y position on the canvas so that they lower symbols
	    // are drawn on top of higher symbols.
	    // Don't sort symbols that won't overlap because it isn't necessary and
	    // because it causes more labels to pop in and out when rotating.
	    if (mayOverlap) {
	        var angle = collisionTile.angle;
	        var sin = Math.sin(angle),
	            cos = Math.cos(angle);
	
	        this.symbolInstances.sort(function(a, b) {
	            var aRotated = (sin * a.x + cos * a.y) | 0;
	            var bRotated = (sin * b.x + cos * b.y) | 0;
	            return (aRotated - bRotated) || (b.index - a.index);
	        });
	    }
	
	    for (var p = 0; p < this.symbolInstances.length; p++) {
	        var symbolInstance = this.symbolInstances[p];
	        var hasText = symbolInstance.hasText;
	        var hasIcon = symbolInstance.hasIcon;
	
	        var iconWithoutText = layout['text-optional'] || !hasText,
	            textWithoutIcon = layout['icon-optional'] || !hasIcon;
	
	
	        // Calculate the scales at which the text and icon can be placed without collision.
	
	        var glyphScale = hasText ?
	            collisionTile.placeCollisionFeature(symbolInstance.textCollisionFeature,
	                    layout['text-allow-overlap'], layout['symbol-avoid-edges']) :
	            collisionTile.minScale;
	
	        var iconScale = hasIcon ?
	            collisionTile.placeCollisionFeature(symbolInstance.iconCollisionFeature,
	                    layout['icon-allow-overlap'], layout['symbol-avoid-edges']) :
	            collisionTile.minScale;
	
	
	        // Combine the scales for icons and text.
	
	        if (!iconWithoutText && !textWithoutIcon) {
	            iconScale = glyphScale = Math.max(iconScale, glyphScale);
	        } else if (!textWithoutIcon && glyphScale) {
	            glyphScale = Math.max(iconScale, glyphScale);
	        } else if (!iconWithoutText && iconScale) {
	            iconScale = Math.max(iconScale, glyphScale);
	        }
	
	
	        // Insert final placement into collision tree and add glyphs/icons to buffers
	
	        if (hasText) {
	            collisionTile.insertCollisionFeature(symbolInstance.textCollisionFeature, glyphScale, layout['text-ignore-placement']);
	            if (glyphScale <= maxScale) {
	                this.addSymbols('glyph', symbolInstance.glyphQuads, glyphScale, layout['text-keep-upright'], textAlongLine, collisionTile.angle);
	            }
	        }
	
	        if (hasIcon) {
	            collisionTile.insertCollisionFeature(symbolInstance.iconCollisionFeature, iconScale, layout['icon-ignore-placement']);
	            if (iconScale <= maxScale) {
	                this.addSymbols('icon', symbolInstance.iconQuads, iconScale, layout['icon-keep-upright'], iconAlongLine, collisionTile.angle);
	            }
	        }
	
	    }
	
	    if (showCollisionBoxes) this.addToDebugBuffers(collisionTile);
	};
	
	SymbolBucket.prototype.addSymbols = function(programName, quads, scale, keepUpright, alongLine, placementAngle) {
	
	    var group = this.makeRoomFor(programName, 4 * quads.length);
	
	    // TODO manual curry
	    var elementArray = this.arrays[this.getBufferName(programName, 'element')];
	    var vertexArray = this.arrays[this.getBufferName(programName, 'vertex')];
	
	    var zoom = this.zoom;
	    var placementZoom = Math.max(Math.log(scale) / Math.LN2 + zoom, 0);
	
	    for (var k = 0; k < quads.length; k++) {
	
	        var symbol = quads[k],
	            angle = symbol.angle;
	
	        // drop upside down versions of glyphs
	        var a = (angle + placementAngle + Math.PI) % (Math.PI * 2);
	        if (keepUpright && alongLine && (a <= Math.PI / 2 || a > Math.PI * 3 / 2)) continue;
	
	        var tl = symbol.tl,
	            tr = symbol.tr,
	            bl = symbol.bl,
	            br = symbol.br,
	            tex = symbol.tex,
	            anchorPoint = symbol.anchorPoint,
	
	            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
	            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);
	
	        if (maxZoom <= minZoom) continue;
	
	        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
	        if (minZoom === placementZoom) minZoom = 0;
	
	        var index = addVertex(vertexArray, anchorPoint.x, anchorPoint.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom) - group.vertexStartIndex;
	        addVertex(vertexArray, anchorPoint.x, anchorPoint.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom);
	        addVertex(vertexArray, anchorPoint.x, anchorPoint.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom);
	        addVertex(vertexArray, anchorPoint.x, anchorPoint.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom);
	        group.vertexLength += 4;
	
	        elementArray.emplaceBack(index, index + 1, index + 2);
	        elementArray.emplaceBack(index + 1, index + 2, index + 3);
	        group.elementLength += 2;
	    }
	
	};
	
	SymbolBucket.prototype.updateIcons = function(icons) {
	    this.recalculateStyleLayers();
	    var iconValue = this.layer.layout['icon-image'];
	    if (!iconValue) return;
	
	    for (var i = 0; i < this.features.length; i++) {
	        var iconName = resolveTokens(this.features[i].properties, iconValue);
	        if (iconName)
	            icons[iconName] = true;
	    }
	};
	
	SymbolBucket.prototype.updateFont = function(stacks) {
	    this.recalculateStyleLayers();
	    var fontName = this.layer.layout['text-font'],
	        stack = stacks[fontName] = stacks[fontName] || {};
	
	    this.textFeatures = resolveText(this.features, this.layer.layout, stack);
	};
	
	SymbolBucket.prototype.addToDebugBuffers = function(collisionTile) {
	    this.elementGroups.collisionBox = [];
	    var group = this.makeRoomFor('collisionBox', 0);
	    var angle = -collisionTile.angle;
	    var yStretch = collisionTile.yStretch;
	
	    for (var j = 0; j < this.symbolInstances.length; j++) {
	        for (var i = 0; i < 2; i++) {
	            var feature = this.symbolInstances[j][i === 0 ? 'textCollisionFeature' : 'iconCollisionFeature'];
	            if (!feature) continue;
	
	            for (var b = feature.boxStartIndex; b < feature.boxEndIndex; b++) {
	                var box = this.collisionBoxArray.get(b);
	                var anchorPoint = box.anchorPoint;
	
	                var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);
	                var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);
	                var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);
	                var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);
	
	                var maxZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.maxScale) / Math.LN2));
	                var placementZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.placementScale) / Math.LN2));
	
	                this.addCollisionBoxVertex(anchorPoint, tl, maxZoom, placementZoom);
	                this.addCollisionBoxVertex(anchorPoint, tr, maxZoom, placementZoom);
	                this.addCollisionBoxVertex(anchorPoint, tr, maxZoom, placementZoom);
	                this.addCollisionBoxVertex(anchorPoint, br, maxZoom, placementZoom);
	                this.addCollisionBoxVertex(anchorPoint, br, maxZoom, placementZoom);
	                this.addCollisionBoxVertex(anchorPoint, bl, maxZoom, placementZoom);
	                this.addCollisionBoxVertex(anchorPoint, bl, maxZoom, placementZoom);
	                this.addCollisionBoxVertex(anchorPoint, tl, maxZoom, placementZoom);
	                group.vertexLength += 8;
	            }
	        }
	    }
	};
	
	function SymbolInstance(anchor, line, shapedText, shapedIcon, layout, addToBuffers, index, collisionBoxArray, featureIndex, sourceLayerIndex, bucketIndex,
	                        textBoxScale, textPadding, textAlongLine,
	                        iconBoxScale, iconPadding, iconAlongLine) {
	
	    this.x = anchor.x;
	    this.y = anchor.y;
	    this.index = index;
	    this.hasText = !!shapedText;
	    this.hasIcon = !!shapedIcon;
	
	    if (this.hasText) {
	        this.glyphQuads = addToBuffers ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layout, textAlongLine) : [];
	        this.textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex,
	                shapedText, textBoxScale, textPadding, textAlongLine, false);
	    }
	
	    if (this.hasIcon) {
	        this.iconQuads = addToBuffers ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layout, iconAlongLine) : [];
	        this.iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex,
	                shapedIcon, iconBoxScale, iconPadding, iconAlongLine, true);
	    }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	
	module.exports = Anchor;
	
	function Anchor(x, y, angle, segment) {
	    this.x = x;
	    this.y = y;
	    this.angle = angle;
	
	    if (segment !== undefined) {
	        this.segment = segment;
	    }
	}
	
	Anchor.prototype = Object.create(Point.prototype);
	
	Anchor.prototype.clone = function() {
	    return new Anchor(this.x, this.y, this.angle, this.segment);
	};


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var interpolate = __webpack_require__(92);
	var Anchor = __webpack_require__(166);
	var checkMaxAngle = __webpack_require__(168);
	
	module.exports = getAnchors;
	
	function getAnchors(line, spacing, maxAngle, shapedText, shapedIcon, glyphSize, boxScale, overscaling, tileExtent) {
	
	    // Resample a line to get anchor points for labels and check that each
	    // potential label passes text-max-angle check and has enough froom to fit
	    // on the line.
	
	    var angleWindowSize = shapedText ?
	        3 / 5 * glyphSize * boxScale :
	        0;
	
	    var labelLength = Math.max(
	        shapedText ? shapedText.right - shapedText.left : 0,
	        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);
	
	    // Is the line continued from outside the tile boundary?
	    var isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;
	
	    // Is the label long, relative to the spacing?
	    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.
	    if (spacing - labelLength * boxScale  < spacing / 4) {
	        spacing = labelLength * boxScale + spacing / 4;
	    }
	
	    // Offset the first anchor by:
	    // Either half the label length plus a fixed extra offset if the line is not continued
	    // Or half the spacing if the line is continued.
	
	    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.
	    var fixedExtraOffset = glyphSize * 2;
	
	    var offset = !isLineContinued ?
	        ((labelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :
	        (spacing / 2 * overscaling) % spacing;
	
	    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, isLineContinued, false, tileExtent);
	}
	
	
	function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {
	
	    var halfLabelLength = labelLength / 2;
	    var lineLength = 0;
	    for (var k = 0; k < line.length - 1; k++) {
	        lineLength += line[k].dist(line[k + 1]);
	    }
	
	    var distance = 0,
	        markedDistance = offset - spacing;
	
	    var anchors = [];
	
	    for (var i = 0; i < line.length - 1; i++) {
	
	        var a = line[i],
	            b = line[i + 1];
	
	        var segmentDist = a.dist(b),
	            angle = b.angleTo(a);
	
	        while (markedDistance + spacing < distance + segmentDist) {
	            markedDistance += spacing;
	
	            var t = (markedDistance - distance) / segmentDist,
	                x = interpolate(a.x, b.x, t),
	                y = interpolate(a.y, b.y, t);
	
	            // Check that the point is within the tile boundaries and that
	            // the label would fit before the beginning and end of the line
	            // if placed at this point.
	            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&
	                    markedDistance - halfLabelLength >= 0 &&
	                    markedDistance + halfLabelLength <= lineLength) {
	                var anchor = new Anchor(x, y, angle, i)._round();
	
	                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
	                    anchors.push(anchor);
	                }
	            }
	        }
	
	        distance += segmentDist;
	    }
	
	    if (!placeAtMiddle && !anchors.length && !isLineContinued) {
	        // The first attempt at finding anchors at which labels can be placed failed.
	        // Try again, but this time just try placing one anchor at the middle of the line.
	        // This has the most effect for short lines in overscaled tiles, since the
	        // initial offset used in overscaled tiles is calculated to align labels with positions in
	        // parent tiles instead of placing the label as close to the beginning as possible.
	        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);
	    }
	
	    return anchors;
	}


/***/ },
/* 168 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = checkMaxAngle;
	
	/**
	 * Labels placed around really sharp angles aren't readable. Check if any
	 * part of the potential label has a combined angle that is too big.
	 *
	 * @param {Array<Point>} line
	 * @param {Anchor} anchor The point on the line around which the label is anchored.
	 * @param {number} labelLength The length of the label in geometry units.
	 * @param {number} windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.
	 * @param {number} maxAngle The maximum combined angle that any window along the label is allowed to have.
	 *
	 * @returns {boolean} whether the label should be placed
	 * @private
	 */
	function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {
	
	    // horizontal labels always pass
	    if (anchor.segment === undefined) return true;
	
	    var p = anchor;
	    var index = anchor.segment + 1;
	    var anchorDistance = 0;
	
	    // move backwards along the line to the first segment the label appears on
	    while (anchorDistance > -labelLength / 2) {
	        index--;
	
	        // there isn't enough room for the label after the beginning of the line
	        if (index < 0) return false;
	
	        anchorDistance -= line[index].dist(p);
	        p = line[index];
	    }
	
	    anchorDistance += line[index].dist(line[index + 1]);
	    index++;
	
	    // store recent corners and their total angle difference
	    var recentCorners = [];
	    var recentAngleDelta = 0;
	
	    // move forwards by the length of the label and check angles along the way
	    while (anchorDistance < labelLength / 2) {
	        var prev = line[index - 1];
	        var current = line[index];
	        var next = line[index + 1];
	
	        // there isn't enough room for the label before the end of the line
	        if (!next) return false;
	
	        var angleDelta = prev.angleTo(current) - current.angleTo(next);
	        // restrict angle to -pi..pi range
	        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);
	
	        recentCorners.push({
	            distance: anchorDistance,
	            angleDelta: angleDelta
	        });
	        recentAngleDelta += angleDelta;
	
	        // remove corners that are far enough away from the list of recent anchors
	        while (anchorDistance - recentCorners[0].distance > windowSize) {
	            recentAngleDelta -= recentCorners.shift().angleDelta;
	        }
	
	        // the sum of angles within the window area exceeds the maximum allowed value. check fails.
	        if (recentAngleDelta > maxAngle) return false;
	
	        index++;
	        anchorDistance += current.dist(next);
	    }
	
	    // no part of the line had an angle greater than the maximum allowed. check passes.
	    return true;
	}


/***/ },
/* 169 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = resolveTokens;
	
	/**
	 * Replace tokens in a string template with values in an object
	 *
	 * @param {Object} properties a key/value relationship between tokens and replacements
	 * @param {string} text the template string
	 * @returns {string} the template with tokens replaced
	 * @private
	 */
	function resolveTokens(properties, text) {
	    return text.replace(/{([^{}()\[\]<>$=:;.,^]+)}/g, function(match, key) {
	        return key in properties ? properties[key] : '';
	    });
	}


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	
	module.exports = {
	    getIconQuads: getIconQuads,
	    getGlyphQuads: getGlyphQuads
	};
	
	var minScale = 0.5; // underscale by 1 zoom level
	
	/**
	 * A textured quad for rendering a single icon or glyph.
	 *
	 * The zoom range the glyph can be shown is defined by minScale and maxScale.
	 *
	 * @param {Point} anchorPoint the point the symbol is anchored around
	 * @param {Point} tl The offset of the top left corner from the anchor.
	 * @param {Point} tr The offset of the top right corner from the anchor.
	 * @param {Point} bl The offset of the bottom left corner from the anchor.
	 * @param {Point} br The offset of the bottom right corner from the anchor.
	 * @param {Object} tex The texture coordinates.
	 * @param {number} angle The angle of the label at it's center, not the angle of this quad.
	 * @param {number} minScale The minimum scale, relative to the tile's intended scale, that the glyph can be shown at.
	 * @param {number} maxScale The maximum scale, relative to the tile's intended scale, that the glyph can be shown at.
	 *
	 * @class SymbolQuad
	 * @private
	 */
	function SymbolQuad(anchorPoint, tl, tr, bl, br, tex, angle, minScale, maxScale) {
	    this.anchorPoint = anchorPoint;
	    this.tl = tl;
	    this.tr = tr;
	    this.bl = bl;
	    this.br = br;
	    this.tex = tex;
	    this.angle = angle;
	    this.minScale = minScale;
	    this.maxScale = maxScale;
	}
	
	/**
	 * Create the quads used for rendering an icon.
	 *
	 * @param {Anchor} anchor
	 * @param {PositionedIcon} shapedIcon
	 * @param {number} boxScale A magic number for converting glyph metric units to geometry units.
	 * @param {Array<Array<Point>>} line
	 * @param {LayoutProperties} layout
	 * @param {boolean} alongLine Whether the icon should be placed along the line.
	 * @returns {Array<SymbolQuad>}
	 * @private
	 */
	function getIconQuads(anchor, shapedIcon, boxScale, line, layout, alongLine) {
	
	    var rect = shapedIcon.image.rect;
	
	    var border = 1;
	    var left = shapedIcon.left - border;
	    var right = left + rect.w / shapedIcon.image.pixelRatio;
	    var top = shapedIcon.top - border;
	    var bottom = top + rect.h / shapedIcon.image.pixelRatio;
	    var tl = new Point(left, top);
	    var tr = new Point(right, top);
	    var br = new Point(right, bottom);
	    var bl = new Point(left, bottom);
	
	    var angle = layout['icon-rotate'] * Math.PI / 180;
	    if (alongLine) {
	        var prev = line[anchor.segment];
	        if (anchor.y === prev.y && anchor.x === prev.x && anchor.segment + 1 < line.length) {
	            var next = line[anchor.segment + 1];
	            angle += Math.atan2(anchor.y - next.y, anchor.x - next.x) + Math.PI;
	        } else {
	            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);
	        }
	    }
	
	    if (angle) {
	        var sin = Math.sin(angle),
	            cos = Math.cos(angle),
	            matrix = [cos, -sin, sin, cos];
	
	        tl = tl.matMult(matrix);
	        tr = tr.matMult(matrix);
	        bl = bl.matMult(matrix);
	        br = br.matMult(matrix);
	    }
	
	    return [new SymbolQuad(new Point(anchor.x, anchor.y), tl, tr, bl, br, shapedIcon.image.rect, 0, minScale, Infinity)];
	}
	
	/**
	 * Create the quads used for rendering a text label.
	 *
	 * @param {Anchor} anchor
	 * @param {Shaping} shaping
	 * @param {number} boxScale A magic number for converting from glyph metric units to geometry units.
	 * @param {Array<Array<Point>>} line
	 * @param {LayoutProperties} layout
	 * @param {boolean} alongLine Whether the label should be placed along the line.
	 * @returns {Array<SymbolQuad>}
	 * @private
	 */
	function getGlyphQuads(anchor, shaping, boxScale, line, layout, alongLine) {
	
	    var textRotate = layout['text-rotate'] * Math.PI / 180;
	    var keepUpright = layout['text-keep-upright'];
	
	    var positionedGlyphs = shaping.positionedGlyphs;
	    var quads = [];
	
	    for (var k = 0; k < positionedGlyphs.length; k++) {
	        var positionedGlyph = positionedGlyphs[k];
	        var glyph = positionedGlyph.glyph;
	        var rect = glyph.rect;
	
	        if (!rect) continue;
	
	        var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;
	
	        var glyphInstances;
	        var labelMinScale = minScale;
	        if (alongLine) {
	            glyphInstances = [];
	            labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, true);
	            if (keepUpright) {
	                labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, false));
	            }
	
	        } else {
	            glyphInstances = [{
	                anchorPoint: new Point(anchor.x, anchor.y),
	                offset: 0,
	                angle: 0,
	                maxScale: Infinity,
	                minScale: minScale
	            }];
	        }
	
	        var x1 = positionedGlyph.x + glyph.left,
	            y1 = positionedGlyph.y - glyph.top,
	            x2 = x1 + rect.w,
	            y2 = y1 + rect.h,
	
	            otl = new Point(x1, y1),
	            otr = new Point(x2, y1),
	            obl = new Point(x1, y2),
	            obr = new Point(x2, y2);
	
	        for (var i = 0; i < glyphInstances.length; i++) {
	
	            var instance = glyphInstances[i],
	                tl = otl,
	                tr = otr,
	                bl = obl,
	                br = obr,
	                angle = instance.angle + textRotate;
	
	            if (angle) {
	                var sin = Math.sin(angle),
	                    cos = Math.cos(angle),
	                    matrix = [cos, -sin, sin, cos];
	
	                tl = tl.matMult(matrix);
	                tr = tr.matMult(matrix);
	                bl = bl.matMult(matrix);
	                br = br.matMult(matrix);
	            }
	
	            // Prevent label from extending past the end of the line
	            var glyphMinScale = Math.max(instance.minScale, labelMinScale);
	
	            var glyphAngle = (anchor.angle + textRotate + instance.offset + 2 * Math.PI) % (2 * Math.PI);
	            quads.push(new SymbolQuad(instance.anchorPoint, tl, tr, bl, br, rect, glyphAngle, glyphMinScale, instance.maxScale));
	
	        }
	    }
	
	    return quads;
	}
	
	/**
	 * We can only render glyph quads that slide along a straight line. To draw
	 * curved lines we need an instance of a glyph for each segment it appears on.
	 * This creates all the instances of a glyph that are necessary to render a label.
	 *
	 * We need a
	 * @param {Array<Object>} glyphInstances An empty array that glyphInstances are added to.
	 * @param {Anchor} anchor
	 * @param {number} offset The glyph's offset from the center of the label.
	 * @param {Array<Point>} line
	 * @param {number} segment The index of the segment of the line on which the anchor exists.
	 * @param {boolean} forward If true get the glyphs that come later on the line, otherwise get the glyphs that come earlier.
	 *
	 * @returns {Array<Object>} glyphInstances
	 * @private
	 */
	function getSegmentGlyphs(glyphs, anchor, offset, line, segment, forward) {
	    var upsideDown = !forward;
	
	    if (offset < 0) forward = !forward;
	
	    if (forward) segment++;
	
	    var newAnchorPoint = new Point(anchor.x, anchor.y);
	    var end = line[segment];
	    var prevScale = Infinity;
	
	    offset = Math.abs(offset);
	
	    var placementScale = minScale;
	
	    while (true) {
	        var distance = newAnchorPoint.dist(end);
	        var scale = offset / distance;
	
	        // Get the angle of the line segment
	        var angle = Math.atan2(end.y - newAnchorPoint.y, end.x - newAnchorPoint.x);
	        if (!forward) angle += Math.PI;
	        if (upsideDown) angle += Math.PI;
	
	        glyphs.push({
	            anchorPoint: newAnchorPoint,
	            offset: upsideDown ? Math.PI : 0,
	            minScale: scale,
	            maxScale: prevScale,
	            angle: (angle + 2 * Math.PI) % (2 * Math.PI)
	        });
	
	        if (scale <= placementScale) break;
	
	        newAnchorPoint = end;
	
	        // skip duplicate nodes
	        while (newAnchorPoint.equals(end)) {
	            segment += forward ? 1 : -1;
	            end = line[segment];
	            if (!end) {
	                return scale;
	            }
	        }
	
	        var unit = end.sub(newAnchorPoint)._unit();
	        newAnchorPoint = newAnchorPoint.sub(unit._mult(distance));
	
	        prevScale = scale;
	    }
	
	    return placementScale;
	}


/***/ },
/* 171 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    shapeText: shapeText,
	    shapeIcon: shapeIcon
	};
	
	
	// The position of a glyph relative to the text's anchor point.
	function PositionedGlyph(codePoint, x, y, glyph) {
	    this.codePoint = codePoint;
	    this.x = x;
	    this.y = y;
	    this.glyph = glyph;
	}
	
	// A collection of positioned glyphs and some metadata
	function Shaping(positionedGlyphs, text, top, bottom, left, right) {
	    this.positionedGlyphs = positionedGlyphs;
	    this.text = text;
	    this.top = top;
	    this.bottom = bottom;
	    this.left = left;
	    this.right = right;
	}
	
	function shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {
	
	    var positionedGlyphs = [];
	    var shaping = new Shaping(positionedGlyphs, text, translate[1], translate[1], translate[0], translate[0]);
	
	    // the y offset *should* be part of the font metadata
	    var yOffset = -17;
	
	    var x = 0;
	    var y = yOffset;
	
	    for (var i = 0; i < text.length; i++) {
	        var codePoint = text.charCodeAt(i);
	        var glyph = glyphs[codePoint];
	
	        if (!glyph) continue;
	
	        positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));
	        x += glyph.advance + spacing;
	    }
	
	    if (!positionedGlyphs.length) return false;
	
	    linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate);
	
	    return shaping;
	}
	
	var invisible = {
	    0x20:   true, // space
	    0x200b: true  // zero-width space
	};
	
	var breakable = {
	    0x20:   true, // space
	    0x26:   true, // ampersand
	    0x2b:   true, // plus sign
	    0x2d:   true, // hyphen-minus
	    0x2f:   true, // solidus
	    0xad:   true, // soft hyphen
	    0xb7:   true, // middle dot
	    0x200b: true, // zero-width space
	    0x2010: true, // hyphen
	    0x2013: true  // en dash
	};
	
	function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate) {
	    var lastSafeBreak = null;
	
	    var lengthBeforeCurrentLine = 0;
	    var lineStartIndex = 0;
	    var line = 0;
	
	    var maxLineLength = 0;
	
	    var positionedGlyphs = shaping.positionedGlyphs;
	
	    if (maxWidth) {
	        for (var i = 0; i < positionedGlyphs.length; i++) {
	            var positionedGlyph = positionedGlyphs[i];
	
	            positionedGlyph.x -= lengthBeforeCurrentLine;
	            positionedGlyph.y += lineHeight * line;
	
	            if (positionedGlyph.x > maxWidth && lastSafeBreak !== null) {
	
	                var lineLength = positionedGlyphs[lastSafeBreak + 1].x;
	                maxLineLength = Math.max(lineLength, maxLineLength);
	
	                for (var k = lastSafeBreak + 1; k <= i; k++) {
	                    positionedGlyphs[k].y += lineHeight;
	                    positionedGlyphs[k].x -= lineLength;
	                }
	
	                if (justify) {
	                    // Collapse invisible characters.
	                    var lineEnd = lastSafeBreak;
	                    if (invisible[positionedGlyphs[lastSafeBreak].codePoint]) {
	                        lineEnd--;
	                    }
	
	                    justifyLine(positionedGlyphs, glyphs, lineStartIndex, lineEnd, justify);
	                }
	
	                lineStartIndex = lastSafeBreak + 1;
	                lastSafeBreak = null;
	                lengthBeforeCurrentLine += lineLength;
	                line++;
	            }
	
	            if (breakable[positionedGlyph.codePoint]) {
	                lastSafeBreak = i;
	            }
	        }
	    }
	
	    var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];
	    var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;
	    maxLineLength = Math.max(maxLineLength, lastLineLength);
	
	    var height = (line + 1) * lineHeight;
	
	    justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);
	    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate);
	
	    // Calculate the bounding box
	    shaping.top += -verticalAlign * height;
	    shaping.bottom = shaping.top + height;
	    shaping.left += -horizontalAlign * maxLineLength;
	    shaping.right = shaping.left + maxLineLength;
	}
	
	function justifyLine(positionedGlyphs, glyphs, start, end, justify) {
	    var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;
	    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;
	
	    for (var j = start; j <= end; j++) {
	        positionedGlyphs[j].x -= lineIndent;
	    }
	
	}
	
	function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate) {
	    var shiftX = (justify - horizontalAlign) * maxLineLength + translate[0];
	    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight + translate[1];
	
	    for (var j = 0; j < positionedGlyphs.length; j++) {
	        positionedGlyphs[j].x += shiftX;
	        positionedGlyphs[j].y += shiftY;
	    }
	}
	
	
	function shapeIcon(image, layout) {
	    if (!image || !image.rect) return null;
	
	    var dx = layout['icon-offset'][0];
	    var dy = layout['icon-offset'][1];
	    var x1 = dx - image.width / 2;
	    var x2 = x1 + image.width;
	    var y1 = dy - image.height / 2;
	    var y2 = y1 + image.height;
	
	    return new PositionedIcon(image, y1, y2, x1, x2);
	}
	
	function PositionedIcon(image, top, bottom, left, right) {
	    this.image = image;
	    this.top = top;
	    this.bottom = bottom;
	    this.left = left;
	    this.right = right;
	}


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var resolveTokens = __webpack_require__(169);
	
	module.exports = resolveText;
	
	/**
	 * For an array of features determine what glyphs need to be loaded
	 * and apply any text preprocessing. The remaining users of text should
	 * use the `textFeatures` key returned by this function rather than accessing
	 * feature text directly.
	 * @private
	 */
	function resolveText(features, layoutProperties, codepoints) {
	    var textFeatures = [];
	
	    for (var i = 0, fl = features.length; i < fl; i++) {
	        var text = resolveTokens(features[i].properties, layoutProperties['text-field']);
	        if (!text) {
	            textFeatures[i] = null;
	            continue;
	        }
	        text = text.toString();
	
	        var transform = layoutProperties['text-transform'];
	        if (transform === 'uppercase') {
	            text = text.toLocaleUpperCase();
	        } else if (transform === 'lowercase') {
	            text = text.toLocaleLowerCase();
	        }
	
	        for (var j = 0; j < text.length; j++) {
	            codepoints[text.charCodeAt(j)] = true;
	        }
	
	        // Track indexes of features with text.
	        textFeatures[i] = text;
	    }
	
	    return textFeatures;
	}


/***/ },
/* 173 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (features, textFeatures, geometries) {
	
	    var leftIndex = {},
	        rightIndex = {},
	        mergedFeatures = [],
	        mergedGeom = [],
	        mergedTexts = [],
	        mergedIndex = 0,
	        k;
	
	    function add(k) {
	        mergedFeatures.push(features[k]);
	        mergedGeom.push(geometries[k]);
	        mergedTexts.push(textFeatures[k]);
	        mergedIndex++;
	    }
	
	    function mergeFromRight(leftKey, rightKey, geom) {
	        var i = rightIndex[leftKey];
	        delete rightIndex[leftKey];
	        rightIndex[rightKey] = i;
	
	        mergedGeom[i][0].pop();
	        mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);
	        return i;
	    }
	
	    function mergeFromLeft(leftKey, rightKey, geom) {
	        var i = leftIndex[rightKey];
	        delete leftIndex[rightKey];
	        leftIndex[leftKey] = i;
	
	        mergedGeom[i][0].shift();
	        mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);
	        return i;
	    }
	
	    function getKey(text, geom, onRight) {
	        var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
	        return text + ':' + point.x + ':' + point.y;
	    }
	
	    for (k = 0; k < features.length; k++) {
	        var geom = geometries[k],
	            text = textFeatures[k];
	
	        if (!text) {
	            add(k);
	            continue;
	        }
	
	        var leftKey = getKey(text, geom),
	            rightKey = getKey(text, geom, true);
	
	        if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {
	            // found lines with the same text adjacent to both ends of the current line, merge all three
	            var j = mergeFromLeft(leftKey, rightKey, geom);
	            var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);
	
	            delete leftIndex[leftKey];
	            delete rightIndex[rightKey];
	
	            rightIndex[getKey(text, mergedGeom[i], true)] = i;
	            mergedGeom[j] = null;
	
	        } else if (leftKey in rightIndex) {
	            // found mergeable line adjacent to the start of the current line, merge
	            mergeFromRight(leftKey, rightKey, geom);
	
	        } else if (rightKey in leftIndex) {
	            // found mergeable line adjacent to the end of the current line, merge
	            mergeFromLeft(leftKey, rightKey, geom);
	
	        } else {
	            // no adjacent lines, add as a new item
	            add(k);
	            leftIndex[leftKey] = mergedIndex - 1;
	            rightIndex[rightKey] = mergedIndex - 1;
	        }
	    }
	
	    return {
	        features: mergedFeatures,
	        textFeatures: mergedTexts,
	        geometries: mergedGeom
	    };
	};


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	
	module.exports = clipLine;
	
	/**
	 * Returns the part of a multiline that intersects with the provided rectangular box.
	 *
	 * @param {Array<Array<Point>>} lines
	 * @param {number} x1 the left edge of the box
	 * @param {number} y1 the top edge of the box
	 * @param {number} x2 the right edge of the box
	 * @param {number} y2 the bottom edge of the box
	 * @returns {Array<Array<Point>>} lines
	 * @private
	 */
	function clipLine(lines, x1, y1, x2, y2) {
	    var clippedLines = [];
	
	    for (var l = 0; l < lines.length; l++) {
	        var line = lines[l];
	        var clippedLine;
	
	        for (var i = 0; i < line.length - 1; i++) {
	            var p0 = line[i];
	            var p1 = line[i + 1];
	
	
	            if (p0.x < x1 && p1.x < x1) {
	                continue;
	            } else if (p0.x < x1) {
	                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
	            } else if (p1.x < x1) {
	                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
	            }
	
	            if (p0.y < y1 && p1.y < y1) {
	                continue;
	            } else if (p0.y < y1) {
	                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
	            } else if (p1.y < y1) {
	                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
	            }
	
	            if (p0.x >= x2 && p1.x >= x2) {
	                continue;
	            } else if (p0.x >= x2) {
	                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
	            } else if (p1.x >= x2) {
	                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
	            }
	
	            if (p0.y >= y2 && p1.y >= y2) {
	                continue;
	            } else if (p0.y >= y2) {
	                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
	            } else if (p1.y >= y2) {
	                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
	            }
	
	            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
	                clippedLine = [p0];
	                clippedLines.push(clippedLine);
	            }
	
	            clippedLine.push(p1);
	        }
	    }
	
	    return clippedLines;
	}


/***/ },
/* 175 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = CollisionFeature;
	
	/**
	 * A CollisionFeature represents the area of the tile covered by a single label.
	 * It is used with CollisionTile to check if the label overlaps with any
	 * previous labels. A CollisionFeature is mostly just a set of CollisionBox
	 * objects.
	 *
	 * @class CollisionFeature
	 * @param {Array<Point>} line The geometry the label is placed on.
	 * @param {Anchor} anchor The point along the line around which the label is anchored.
	 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
	 * @param {Array<string>} layerIDs The IDs of the layers that this CollisionFeature is a part of.
	 * @param {Object} shaped The text or icon shaping results.
	 * @param {number} boxScale A magic number used to convert from glyph metrics units to geometry units.
	 * @param {number} padding The amount of padding to add around the label edges.
	 * @param {boolean} alignLine Whether the label is aligned with the line or the viewport.
	 *
	 * @private
	 */
	function CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaped, boxScale, padding, alignLine, straight) {
	
	    var y1 = shaped.top * boxScale - padding;
	    var y2 = shaped.bottom * boxScale + padding;
	    var x1 = shaped.left * boxScale - padding;
	    var x2 = shaped.right * boxScale + padding;
	
	    this.boxStartIndex = collisionBoxArray.length;
	
	    if (alignLine) {
	
	        var height = y2 - y1;
	        var length = x2 - x1;
	
	        if (height > 0) {
	            // set minimum box height to avoid very many small labels
	            height = Math.max(10 * boxScale, height);
	
	            if (straight) {
	                // used for icon labels that are aligned with the line, but don't curve along it
	                var vector = line[anchor.segment + 1].sub(line[anchor.segment])._unit()._mult(length);
	                var straightLine = [anchor.sub(vector), anchor.add(vector)];
	                this._addLineCollisionBoxes(collisionBoxArray, straightLine, anchor, 0, length, height, featureIndex, sourceLayerIndex, bucketIndex);
	            } else {
	                // used for text labels that curve along a line
	                this._addLineCollisionBoxes(collisionBoxArray, line, anchor, anchor.segment, length, height, featureIndex, sourceLayerIndex, bucketIndex);
	            }
	        }
	
	    } else {
	        collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, Infinity, featureIndex, sourceLayerIndex, bucketIndex,
	                0, 0, 0, 0, 0);
	    }
	
	    this.boxEndIndex = collisionBoxArray.length;
	}
	
	/**
	 * Create a set of CollisionBox objects for a line.
	 *
	 * @param {Array<Point>} line
	 * @param {Anchor} anchor
	 * @param {number} labelLength The length of the label in geometry units.
	 * @param {Anchor} anchor The point along the line around which the label is anchored.
	 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
	 * @param {number} boxSize The size of the collision boxes that will be created.
	 *
	 * @private
	 */
	CollisionFeature.prototype._addLineCollisionBoxes = function(collisionBoxArray, line, anchor, segment, labelLength, boxSize, featureIndex, sourceLayerIndex, bucketIndex) {
	    var step = boxSize / 2;
	    var nBoxes = Math.floor(labelLength / step);
	
	    // offset the center of the first box by half a box so that the edge of the
	    // box is at the edge of the label.
	    var firstBoxOffset = -boxSize / 2;
	
	    var bboxes = this.boxes;
	
	    var p = anchor;
	    var index = segment + 1;
	    var anchorDistance = firstBoxOffset;
	
	    // move backwards along the line to the first segment the label appears on
	    do {
	        index--;
	
	        // there isn't enough room for the label after the beginning of the line
	        // checkMaxAngle should have already caught this
	        if (index < 0) return bboxes;
	
	        anchorDistance -= line[index].dist(p);
	        p = line[index];
	    } while (anchorDistance > -labelLength / 2);
	
	    var segmentLength = line[index].dist(line[index + 1]);
	
	    for (var i = 0; i < nBoxes; i++) {
	        // the distance the box will be from the anchor
	        var boxDistanceToAnchor = -labelLength / 2 + i * step;
	
	        // the box is not on the current segment. Move to the next segment.
	        while (anchorDistance + segmentLength < boxDistanceToAnchor) {
	            anchorDistance += segmentLength;
	            index++;
	
	            // There isn't enough room before the end of the line.
	            if (index + 1 >= line.length) return bboxes;
	
	            segmentLength = line[index].dist(line[index + 1]);
	        }
	
	        // the distance the box will be from the beginning of the segment
	        var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;
	
	        var p0 = line[index];
	        var p1 = line[index + 1];
	        var boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();
	
	        var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);
	        var maxScale = labelLength / 2 / distanceToInnerEdge;
	
	        collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,
	                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale,
	                featureIndex, sourceLayerIndex, bucketIndex,
	                0, 0, 0, 0, 0);
	    }
	
	    return bboxes;
	};


/***/ },
/* 176 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = GridIndex;
	
	var NUM_PARAMS = 3;
	
	function GridIndex(extent, n, padding) {
	    var cells = this.cells = [];
	
	    if (extent instanceof ArrayBuffer) {
	        this.arrayBuffer = extent;
	        var array = new Int32Array(this.arrayBuffer);
	        extent = array[0];
	        n = array[1];
	        padding = array[2];
	
	        this.d = n + 2 * padding;
	        for (var k = 0; k < this.d * this.d; k++) {
	            var start = array[NUM_PARAMS + k];
	            var end = array[NUM_PARAMS + k + 1];
	            cells.push(start === end ?
	                    null :
	                    array.subarray(start, end));
	        }
	        var keysOffset = array[NUM_PARAMS + cells.length];
	        var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
	        this.keys = array.subarray(keysOffset, bboxesOffset);
	        this.bboxes = array.subarray(bboxesOffset);
	
	        this.insert = this._insertReadonly;
	
	    } else {
	        this.d = n + 2 * padding;
	        for (var i = 0; i < this.d * this.d; i++) {
	            cells.push([]);
	        }
	        this.keys = [];
	        this.bboxes = [];
	    }
	
	    this.n = n;
	    this.extent = extent;
	    this.padding = padding;
	    this.scale = n / extent;
	    this.uid = 0;
	
	    var p = (padding / n) * extent;
	    this.min = -p;
	    this.max = extent + p;
	}
	
	
	GridIndex.prototype.insert = function(key, x1, y1, x2, y2) {
	    this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);
	    this.keys.push(key);
	    this.bboxes.push(x1);
	    this.bboxes.push(y1);
	    this.bboxes.push(x2);
	    this.bboxes.push(y2);
	};
	
	GridIndex.prototype._insertReadonly = function() {
	    throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
	};
	
	GridIndex.prototype._insertCell = function(x1, y1, x2, y2, cellIndex, uid) {
	    this.cells[cellIndex].push(uid);
	};
	
	GridIndex.prototype.query = function(x1, y1, x2, y2) {
	    var min = this.min;
	    var max = this.max;
	    if (x1 <= min && y1 <= min && max <= x2 && max <= y2) {
	        return this.keys.slice();
	
	    } else {
	        var result = [];
	        var seenUids = {};
	        this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids);
	        return result;
	    }
	};
	
	GridIndex.prototype._queryCell = function(x1, y1, x2, y2, cellIndex, result, seenUids) {
	    var cell = this.cells[cellIndex];
	    if (cell !== null) {
	        var keys = this.keys;
	        var bboxes = this.bboxes;
	        for (var u = 0; u < cell.length; u++) {
	            var uid = cell[u];
	            if (seenUids[uid] === undefined) {
	                var offset = uid * 4;
	                if ((x1 <= bboxes[offset + 2]) &&
	                    (y1 <= bboxes[offset + 3]) &&
	                    (x2 >= bboxes[offset + 0]) &&
	                    (y2 >= bboxes[offset + 1])) {
	                    seenUids[uid] = true;
	                    result.push(keys[uid]);
	                } else {
	                    seenUids[uid] = false;
	                }
	            }
	        }
	    }
	};
	
	GridIndex.prototype._forEachCell = function(x1, y1, x2, y2, fn, arg1, arg2) {
	    var cx1 = this._convertToCellCoord(x1);
	    var cy1 = this._convertToCellCoord(y1);
	    var cx2 = this._convertToCellCoord(x2);
	    var cy2 = this._convertToCellCoord(y2);
	    for (var x = cx1; x <= cx2; x++) {
	        for (var y = cy1; y <= cy2; y++) {
	            var cellIndex = this.d * y + x;
	            if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2)) return;
	        }
	    }
	};
	
	GridIndex.prototype._convertToCellCoord = function(x) {
	    return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
	};
	
	GridIndex.prototype.toArrayBuffer = function() {
	    if (this.arrayBuffer) return this.arrayBuffer;
	
	    var cells = this.cells;
	
	    var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
	    var totalCellLength = 0;
	    for (var i = 0; i < this.cells.length; i++) {
	        totalCellLength += this.cells[i].length;
	    }
	
	    var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
	    array[0] = this.extent;
	    array[1] = this.n;
	    array[2] = this.padding;
	
	    var offset = metadataLength;
	    for (var k = 0; k < cells.length; k++) {
	        var cell = cells[k];
	        array[NUM_PARAMS + k] = offset;
	        array.set(cell, offset);
	        offset += cell.length;
	    }
	
	    array[NUM_PARAMS + cells.length] = offset;
	    array.set(this.keys, offset);
	    offset += this.keys.length;
	
	    array[NUM_PARAMS + cells.length + 1] = offset;
	    array.set(this.bboxes, offset);
	    offset += this.bboxes.length;
	
	    return array.buffer;
	};


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assert = __webpack_require__(160);
	
	module.exports = DictionaryCoder;
	
	function DictionaryCoder(strings) {
	    this._stringToNumber = {};
	    this._numberToString = [];
	    for (var i = 0; i < strings.length; i++) {
	        var string = strings[i];
	        this._stringToNumber[string] = i;
	        this._numberToString[i] = string;
	    }
	}
	
	DictionaryCoder.prototype.encode = function(string) {
	    assert(string in this._stringToNumber);
	    return this._stringToNumber[string];
	};
	
	DictionaryCoder.prototype.decode = function(n) {
	    assert(n < this._numberToString.length);
	    return this._numberToString[n];
	};


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	module.exports.VectorTile = __webpack_require__(179);
	module.exports.VectorTileFeature = __webpack_require__(181);
	module.exports.VectorTileLayer = __webpack_require__(180);


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var VectorTileLayer = __webpack_require__(180);
	
	module.exports = VectorTile;
	
	function VectorTile(pbf, end) {
	    this.layers = pbf.readFields(readTile, {}, end);
	}
	
	function readTile(tag, layers, pbf) {
	    if (tag === 3) {
	        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
	        if (layer.length) layers[layer.name] = layer;
	    }
	}
	


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var VectorTileFeature = __webpack_require__(181);
	
	module.exports = VectorTileLayer;
	
	function VectorTileLayer(pbf, end) {
	    // Public
	    this.version = 1;
	    this.name = null;
	    this.extent = 4096;
	    this.length = 0;
	
	    // Private
	    this._pbf = pbf;
	    this._keys = [];
	    this._values = [];
	    this._features = [];
	
	    pbf.readFields(readLayer, this, end);
	
	    this.length = this._features.length;
	}
	
	function readLayer(tag, layer, pbf) {
	    if (tag === 15) layer.version = pbf.readVarint();
	    else if (tag === 1) layer.name = pbf.readString();
	    else if (tag === 5) layer.extent = pbf.readVarint();
	    else if (tag === 2) layer._features.push(pbf.pos);
	    else if (tag === 3) layer._keys.push(pbf.readString());
	    else if (tag === 4) layer._values.push(readValueMessage(pbf));
	}
	
	function readValueMessage(pbf) {
	    var value = null,
	        end = pbf.readVarint() + pbf.pos;
	
	    while (pbf.pos < end) {
	        var tag = pbf.readVarint() >> 3;
	
	        value = tag === 1 ? pbf.readString() :
	            tag === 2 ? pbf.readFloat() :
	            tag === 3 ? pbf.readDouble() :
	            tag === 4 ? pbf.readVarint64() :
	            tag === 5 ? pbf.readVarint() :
	            tag === 6 ? pbf.readSVarint() :
	            tag === 7 ? pbf.readBoolean() : null;
	    }
	
	    return value;
	}
	
	// return feature `i` from this layer as a `VectorTileFeature`
	VectorTileLayer.prototype.feature = function(i) {
	    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');
	
	    this._pbf.pos = this._features[i];
	
	    var end = this._pbf.readVarint() + this._pbf.pos;
	    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
	};


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	
	module.exports = VectorTileFeature;
	
	function VectorTileFeature(pbf, end, extent, keys, values) {
	    // Public
	    this.properties = {};
	    this.extent = extent;
	    this.type = 0;
	
	    // Private
	    this._pbf = pbf;
	    this._geometry = -1;
	    this._keys = keys;
	    this._values = values;
	
	    pbf.readFields(readFeature, this, end);
	}
	
	function readFeature(tag, feature, pbf) {
	    if (tag == 1) feature._id = pbf.readVarint();
	    else if (tag == 2) readTag(pbf, feature);
	    else if (tag == 3) feature.type = pbf.readVarint();
	    else if (tag == 4) feature._geometry = pbf.pos;
	}
	
	function readTag(pbf, feature) {
	    var end = pbf.readVarint() + pbf.pos;
	
	    while (pbf.pos < end) {
	        var key = feature._keys[pbf.readVarint()],
	            value = feature._values[pbf.readVarint()];
	        feature.properties[key] = value;
	    }
	}
	
	VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];
	
	VectorTileFeature.prototype.loadGeometry = function() {
	    var pbf = this._pbf;
	    pbf.pos = this._geometry;
	
	    var end = pbf.readVarint() + pbf.pos,
	        cmd = 1,
	        length = 0,
	        x = 0,
	        y = 0,
	        lines = [],
	        line;
	
	    while (pbf.pos < end) {
	        if (!length) {
	            var cmdLen = pbf.readVarint();
	            cmd = cmdLen & 0x7;
	            length = cmdLen >> 3;
	        }
	
	        length--;
	
	        if (cmd === 1 || cmd === 2) {
	            x += pbf.readSVarint();
	            y += pbf.readSVarint();
	
	            if (cmd === 1) { // moveTo
	                if (line) lines.push(line);
	                line = [];
	            }
	
	            line.push(new Point(x, y));
	
	        } else if (cmd === 7) {
	
	            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
	            if (line) {
	                line.push(line[0].clone()); // closePolygon
	            }
	
	        } else {
	            throw new Error('unknown command ' + cmd);
	        }
	    }
	
	    if (line) lines.push(line);
	
	    return lines;
	};
	
	VectorTileFeature.prototype.bbox = function() {
	    var pbf = this._pbf;
	    pbf.pos = this._geometry;
	
	    var end = pbf.readVarint() + pbf.pos,
	        cmd = 1,
	        length = 0,
	        x = 0,
	        y = 0,
	        x1 = Infinity,
	        x2 = -Infinity,
	        y1 = Infinity,
	        y2 = -Infinity;
	
	    while (pbf.pos < end) {
	        if (!length) {
	            var cmdLen = pbf.readVarint();
	            cmd = cmdLen & 0x7;
	            length = cmdLen >> 3;
	        }
	
	        length--;
	
	        if (cmd === 1 || cmd === 2) {
	            x += pbf.readSVarint();
	            y += pbf.readSVarint();
	            if (x < x1) x1 = x;
	            if (x > x2) x2 = x;
	            if (y < y1) y1 = y;
	            if (y > y2) y2 = y;
	
	        } else if (cmd !== 7) {
	            throw new Error('unknown command ' + cmd);
	        }
	    }
	
	    return [x1, y1, x2, y2];
	};
	
	VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
	    var size = this.extent * Math.pow(2, z),
	        x0 = this.extent * x,
	        y0 = this.extent * y,
	        coords = this.loadGeometry(),
	        type = VectorTileFeature.types[this.type];
	
	    for (var i = 0; i < coords.length; i++) {
	        var line = coords[i];
	        for (var j = 0; j < line.length; j++) {
	            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
	            line[j] = [
	                (p.x + x0) * 360 / size - 180,
	                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
	            ];
	        }
	    }
	
	    if (type === 'Point' && coords.length === 1) {
	        coords = coords[0][0];
	    } else if (type === 'Point') {
	        coords = coords[0];
	        type = 'MultiPoint';
	    } else if (type === 'LineString' && coords.length === 1) {
	        coords = coords[0];
	    } else if (type === 'LineString') {
	        type = 'MultiLineString';
	    }
	
	    var result = {
	        type: "Feature",
	        geometry: {
	            type: type,
	            coordinates: coords
	        },
	        properties: this.properties
	    };
	
	    if ('_id' in this) {
	        result.id = this._id;
	    }
	
	    return result;
	};


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var VectorTileFeature = __webpack_require__(178).VectorTileFeature;
	
	module.exports = Feature;
	
	function Feature(vectorTileFeature, z, x, y) {
	    this._vectorTileFeature = vectorTileFeature;
	    vectorTileFeature._z = z;
	    vectorTileFeature._x = x;
	    vectorTileFeature._y = y;
	
	    this.properties = vectorTileFeature.properties;
	
	    if (vectorTileFeature._id) {
	        this.id = vectorTileFeature._id;
	    }
	}
	
	Feature.prototype = {
	    type: "Feature",
	
	    get geometry() {
	        if (this._geometry === undefined) {
	            var feature = this._vectorTileFeature;
	            var coords = projectCoords(
	                feature.loadGeometry(),
	                feature.extent,
	                feature._z, feature._x, feature._y);
	
	            var type = VectorTileFeature.types[feature.type];
	
	            if (type === 'Point' && coords.length === 1) {
	                coords = coords[0][0];
	            } else if (type === 'Point') {
	                coords = coords[0];
	                type = 'MultiPoint';
	            } else if (type === 'LineString' && coords.length === 1) {
	                coords = coords[0];
	            } else if (type === 'LineString') {
	                type = 'MultiLineString';
	            }
	
	            this._geometry = {
	                type: type,
	                coordinates: coords
	            };
	
	            this._vectorTileFeature = null;
	        }
	        return this._geometry;
	    },
	
	    set geometry(g) {
	        this._geometry = g;
	    },
	
	    toJSON: function() {
	        var json = {};
	        for (var i in this) {
	            if (i === '_geometry' || i === '_vectorTileFeature') continue;
	            json[i] = this[i];
	        }
	        return json;
	    }
	};
	
	function projectCoords(coords, extent, z, x, y) {
	    var size = extent * Math.pow(2, z),
	        x0 = extent * x,
	        y0 = extent * y;
	    for (var i = 0; i < coords.length; i++) {
	        var line = coords[i];
	        for (var j = 0; j < line.length; j++) {
	            var p = line[j];
	            var y2 = 180 - (p.y + y0) * 360 / size;
	            line[j] = [
	                (p.x + x0) * 360 / size - 180,
	                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
	            ];
	        }
	    }
	    return coords;
	}


/***/ },
/* 183 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	    multiPolygonIntersectsBufferedMultiPoint: multiPolygonIntersectsBufferedMultiPoint,
	    multiPolygonIntersectsMultiPolygon: multiPolygonIntersectsMultiPolygon,
	    multiPolygonIntersectsBufferedMultiLine: multiPolygonIntersectsBufferedMultiLine
	};
	
	function multiPolygonIntersectsBufferedMultiPoint(multiPolygon, rings, radius) {
	    for (var j = 0; j < multiPolygon.length; j++) {
	        var polygon = multiPolygon[j];
	        for (var i = 0; i < rings.length; i++) {
	            var ring = rings[i];
	            for (var k = 0; k < ring.length; k++) {
	                var point = ring[k];
	                if (polygonContainsPoint(polygon, point)) return true;
	                if (pointIntersectsBufferedLine(point, polygon, radius)) return true;
	            }
	        }
	    }
	    return false;
	}
	
	function multiPolygonIntersectsMultiPolygon(multiPolygonA, multiPolygonB) {
	
	    if (multiPolygonA.length === 1 && multiPolygonA[0].length === 1) {
	        return multiPolygonContainsPoint(multiPolygonB, multiPolygonA[0][0]);
	    }
	
	    for (var m = 0; m < multiPolygonB.length; m++) {
	        var ring = multiPolygonB[m];
	        for (var n = 0; n < ring.length; n++) {
	            if (multiPolygonContainsPoint(multiPolygonA, ring[n])) return true;
	        }
	    }
	
	    for (var j = 0; j < multiPolygonA.length; j++) {
	        var polygon = multiPolygonA[j];
	        for (var i = 0; i < polygon.length; i++) {
	            if (multiPolygonContainsPoint(multiPolygonB, polygon[i])) return true;
	        }
	
	        for (var k = 0; k < multiPolygonB.length; k++) {
	            if (lineIntersectsLine(polygon, multiPolygonB[k])) return true;
	        }
	    }
	
	    return false;
	}
	
	function multiPolygonIntersectsBufferedMultiLine(multiPolygon, multiLine, radius) {
	    for (var i = 0; i < multiLine.length; i++) {
	        var line = multiLine[i];
	
	        for (var j = 0; j < multiPolygon.length; j++) {
	            var polygon = multiPolygon[j];
	
	            if (polygon.length >= 3) {
	                for (var k = 0; k < line.length; k++) {
	                    if (polygonContainsPoint(polygon, line[k])) return true;
	                }
	            }
	
	            if (lineIntersectsBufferedLine(polygon, line, radius)) return true;
	        }
	    }
	    return false;
	}
	
	function lineIntersectsBufferedLine(lineA, lineB, radius) {
	
	    if (lineA.length > 1) {
	        if (lineIntersectsLine(lineA, lineB)) return true;
	
	        // Check whether any point in either line is within radius of the other line
	        for (var j = 0; j < lineB.length; j++) {
	            if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) return true;
	        }
	    }
	
	    for (var k = 0; k < lineA.length; k++) {
	        if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) return true;
	    }
	
	    return false;
	}
	
	function lineIntersectsLine(lineA, lineB) {
	    for (var i = 0; i < lineA.length - 1; i++) {
	        var a0 = lineA[i];
	        var a1 = lineA[i + 1];
	        for (var j = 0; j < lineB.length - 1; j++) {
	            var b0 = lineB[j];
	            var b1 = lineB[j + 1];
	            if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) return true;
	        }
	    }
	    return false;
	}
	
	
	// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/
	function isCounterClockwise(a, b, c) {
	    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
	}
	
	function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
	    return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) &&
	        isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);
	}
	
	function pointIntersectsBufferedLine(p, line, radius) {
	    var radiusSquared = radius * radius;
	
	    if (line.length === 1) return p.distSqr(line[0]) < radiusSquared;
	
	    for (var i = 1; i < line.length; i++) {
	        // Find line segments that have a distance <= radius^2 to p
	        // In that case, we treat the line as "containing point p".
	        var v = line[i - 1], w = line[i];
	        if (distToSegmentSquared(p, v, w) < radiusSquared) return true;
	    }
	    return false;
	}
	
	// Code from http://stackoverflow.com/a/1501725/331379.
	function distToSegmentSquared(p, v, w) {
	    var l2 = v.distSqr(w);
	    if (l2 === 0) return p.distSqr(v);
	    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	    if (t < 0) return p.distSqr(v);
	    if (t > 1) return p.distSqr(w);
	    return p.distSqr(w.sub(v)._mult(t)._add(v));
	}
	
	// point in polygon ray casting algorithm
	function multiPolygonContainsPoint(rings, p) {
	    var c = false,
	        ring, p1, p2;
	
	    for (var k = 0; k < rings.length; k++) {
	        ring = rings[k];
	        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
	            p1 = ring[i];
	            p2 = ring[j];
	            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
	                c = !c;
	            }
	        }
	    }
	    return c;
	}
	
	function polygonContainsPoint(ring, p) {
	    var c = false;
	    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
	        var p1 = ring[i];
	        var p2 = ring[j];
	        if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
	            c = !c;
	        }
	    }
	    return c;
	}


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	var EXTENT = __webpack_require__(157).EXTENT;
	var Grid = __webpack_require__(176);
	
	module.exports = CollisionTile;
	
	/**
	 * A collision tile used to prevent symbols from overlapping. It keep tracks of
	 * where previous symbols have been placed and is used to check if a new
	 * symbol overlaps with any previously added symbols.
	 *
	 * @class CollisionTile
	 * @param {number} angle
	 * @param {number} pitch
	 * @private
	 */
	function CollisionTile(angle, pitch, collisionBoxArray) {
	    if (typeof angle === 'object') {
	        var serialized = angle;
	        collisionBoxArray = pitch;
	        angle = serialized.angle;
	        pitch = serialized.pitch;
	        this.grid = new Grid(serialized.grid);
	        this.ignoredGrid = new Grid(serialized.ignoredGrid);
	    } else {
	        this.grid = new Grid(EXTENT, 12, 6);
	        this.ignoredGrid = new Grid(EXTENT, 12, 0);
	    }
	
	    this.angle = angle;
	    this.pitch = pitch;
	
	    var sin = Math.sin(angle),
	        cos = Math.cos(angle);
	    this.rotationMatrix = [cos, -sin, sin, cos];
	    this.reverseRotationMatrix = [cos, sin, -sin, cos];
	
	    // Stretch boxes in y direction to account for the map tilt.
	    this.yStretch = 1 / Math.cos(pitch / 180 * Math.PI);
	
	    // The amount the map is squished depends on the y position.
	    // Sort of account for this by making all boxes a bit bigger.
	    this.yStretch = Math.pow(this.yStretch, 1.3);
	
	    this.collisionBoxArray = collisionBoxArray;
	    if (collisionBoxArray.length === 0) {
	        // the first collisionBoxArray is passed to a CollisionTile
	
	        // tempCollisionBox
	        collisionBoxArray.emplaceBack();
	
	        var maxInt16 = 32767;
	        //left
	        collisionBoxArray.emplaceBack(0, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
	                0, 0, 0, 0, 0, 0, 0, 0,
	                0);
	        // right
	        collisionBoxArray.emplaceBack(EXTENT, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
	                0, 0, 0, 0, 0, 0, 0, 0,
	                0);
	        // top
	        collisionBoxArray.emplaceBack(0, 0, -maxInt16, 0, maxInt16, 0, maxInt16,
	                0, 0, 0, 0, 0, 0, 0, 0,
	                0);
	        // bottom
	        collisionBoxArray.emplaceBack(0, EXTENT, -maxInt16, 0, maxInt16, 0, maxInt16,
	                0, 0, 0, 0, 0, 0, 0, 0,
	                0);
	    }
	
	    this.tempCollisionBox = collisionBoxArray.get(0);
	    this.edges = [
	        collisionBoxArray.get(1),
	        collisionBoxArray.get(2),
	        collisionBoxArray.get(3),
	        collisionBoxArray.get(4)
	    ];
	}
	
	CollisionTile.prototype.serialize = function() {
	    var data = {
	        angle: this.angle,
	        pitch: this.pitch,
	        grid: this.grid.toArrayBuffer(),
	        ignoredGrid: this.ignoredGrid.toArrayBuffer()
	    };
	    return {
	        data: data,
	        transferables: [data.grid, data.ignoredGrid]
	    };
	};
	
	CollisionTile.prototype.minScale = 0.25;
	CollisionTile.prototype.maxScale = 2;
	
	
	/**
	 * Find the scale at which the collisionFeature can be shown without
	 * overlapping with other features.
	 *
	 * @param {CollisionFeature} collisionFeature
	 * @returns {number} placementScale
	 * @private
	 */
	CollisionTile.prototype.placeCollisionFeature = function(collisionFeature, allowOverlap, avoidEdges) {
	
	    var collisionBoxArray = this.collisionBoxArray;
	    var minPlacementScale = this.minScale;
	    var rotationMatrix = this.rotationMatrix;
	    var yStretch = this.yStretch;
	
	    for (var b = collisionFeature.boxStartIndex; b < collisionFeature.boxEndIndex; b++) {
	
	        var box = collisionBoxArray.get(b);
	
	        var anchorPoint = box.anchorPoint._matMult(rotationMatrix);
	        var x = anchorPoint.x;
	        var y = anchorPoint.y;
	
	        var x1 = x + box.x1;
	        var y1 = y + box.y1 * yStretch;
	        var x2 = x + box.x2;
	        var y2 = y + box.y2 * yStretch;
	
	        box.bbox0 = x1;
	        box.bbox1 = y1;
	        box.bbox2 = x2;
	        box.bbox3 = y2;
	
	        if (!allowOverlap) {
	            var blockingBoxes = this.grid.query(x1, y1, x2, y2);
	
	            for (var i = 0; i < blockingBoxes.length; i++) {
	                var blocking = collisionBoxArray.get(blockingBoxes[i]);
	                var blockingAnchorPoint = blocking.anchorPoint._matMult(rotationMatrix);
	
	                minPlacementScale = this.getPlacementScale(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking);
	                if (minPlacementScale >= this.maxScale) {
	                    return minPlacementScale;
	                }
	            }
	        }
	
	        if (avoidEdges) {
	            var rotatedCollisionBox;
	
	            if (this.angle) {
	                var reverseRotationMatrix = this.reverseRotationMatrix;
	                var tl = new Point(box.x1, box.y1).matMult(reverseRotationMatrix);
	                var tr = new Point(box.x2, box.y1).matMult(reverseRotationMatrix);
	                var bl = new Point(box.x1, box.y2).matMult(reverseRotationMatrix);
	                var br = new Point(box.x2, box.y2).matMult(reverseRotationMatrix);
	
	                rotatedCollisionBox = this.tempCollisionBox;
	                rotatedCollisionBox.anchorPointX = box.anchorPoint.x;
	                rotatedCollisionBox.anchorPointY = box.anchorPoint.y;
	                rotatedCollisionBox.x1 = Math.min(tl.x, tr.x, bl.x, br.x);
	                rotatedCollisionBox.y1 = Math.min(tl.y, tr.x, bl.x, br.x);
	                rotatedCollisionBox.x2 = Math.max(tl.x, tr.x, bl.x, br.x);
	                rotatedCollisionBox.y2 = Math.max(tl.y, tr.x, bl.x, br.x);
	                rotatedCollisionBox.maxScale = box.maxScale;
	            } else {
	                rotatedCollisionBox = box;
	            }
	
	            for (var k = 0; k < this.edges.length; k++) {
	                var edgeBox = this.edges[k];
	                minPlacementScale = this.getPlacementScale(minPlacementScale, box.anchorPoint, rotatedCollisionBox, edgeBox.anchorPoint, edgeBox);
	                if (minPlacementScale >= this.maxScale) {
	                    return minPlacementScale;
	                }
	            }
	        }
	    }
	
	    return minPlacementScale;
	};
	
	CollisionTile.prototype.queryRenderedSymbols = function(minX, minY, maxX, maxY, scale) {
	    var sourceLayerFeatures = {};
	    var result = [];
	
	    var collisionBoxArray = this.collisionBoxArray;
	    var rotationMatrix = this.rotationMatrix;
	    var anchorPoint = new Point(minX, minY)._matMult(rotationMatrix);
	
	    var queryBox = this.tempCollisionBox;
	    queryBox.anchorX = anchorPoint.x;
	    queryBox.anchorY = anchorPoint.y;
	    queryBox.x1 = 0;
	    queryBox.y1 = 0;
	    queryBox.x2 = maxX - minX;
	    queryBox.y2 = maxY - minY;
	    queryBox.maxScale = scale;
	
	    // maxScale is stored using a Float32. Convert `scale` to the stored Float32 value.
	    scale = queryBox.maxScale;
	
	    var searchBox = [
	        anchorPoint.x + queryBox.x1 / scale,
	        anchorPoint.y + queryBox.y1 / scale * this.yStretch,
	        anchorPoint.x + queryBox.x2 / scale,
	        anchorPoint.y + queryBox.y2 / scale * this.yStretch
	    ];
	
	    var blockingBoxKeys = this.grid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
	    var blockingBoxKeys2 = this.ignoredGrid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
	    for (var k = 0; k < blockingBoxKeys2.length; k++) {
	        blockingBoxKeys.push(blockingBoxKeys2[k]);
	    }
	
	    for (var i = 0; i < blockingBoxKeys.length; i++) {
	        var blocking = collisionBoxArray.get(blockingBoxKeys[i]);
	
	        var sourceLayer = blocking.sourceLayerIndex;
	        var featureIndex = blocking.featureIndex;
	        if (sourceLayerFeatures[sourceLayer] === undefined) {
	            sourceLayerFeatures[sourceLayer] = {};
	        }
	
	        if (!sourceLayerFeatures[sourceLayer][featureIndex]) {
	            var blockingAnchorPoint = blocking.anchorPoint.matMult(rotationMatrix);
	            var minPlacementScale = this.getPlacementScale(this.minScale, anchorPoint, queryBox, blockingAnchorPoint, blocking);
	            if (minPlacementScale >= scale) {
	                sourceLayerFeatures[sourceLayer][featureIndex] = true;
	                result.push(blockingBoxKeys[i]);
	            }
	        }
	    }
	
	    return result;
	};
	
	CollisionTile.prototype.getPlacementScale = function(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking) {
	
	    // Find the lowest scale at which the two boxes can fit side by side without overlapping.
	    // Original algorithm:
	    var anchorDiffX = anchorPoint.x - blockingAnchorPoint.x;
	    var anchorDiffY = anchorPoint.y - blockingAnchorPoint.y;
	    var s1 = (blocking.x1 - box.x2) / anchorDiffX; // scale at which new box is to the left of old box
	    var s2 = (blocking.x2 - box.x1) / anchorDiffX; // scale at which new box is to the right of old box
	    var s3 = (blocking.y1 - box.y2) * this.yStretch / anchorDiffY; // scale at which new box is to the top of old box
	    var s4 = (blocking.y2 - box.y1) * this.yStretch / anchorDiffY; // scale at which new box is to the bottom of old box
	
	    if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
	    if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;
	
	    var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));
	    var blockingMaxScale = blocking.maxScale;
	    var boxMaxScale = box.maxScale;
	
	    if (collisionFreeScale > blockingMaxScale) {
	        // After a box's maxScale the label has shrunk enough that the box is no longer needed to cover it,
	        // so unblock the new box at the scale that the old box disappears.
	        collisionFreeScale = blockingMaxScale;
	    }
	
	    if (collisionFreeScale > boxMaxScale) {
	        // If the box can only be shown after it is visible, then the box can never be shown.
	        // But the label can be shown after this box is not visible.
	        collisionFreeScale = boxMaxScale;
	    }
	
	    if (collisionFreeScale > minPlacementScale &&
	            collisionFreeScale >= blocking.placementScale) {
	        // If this collision occurs at a lower scale than previously found collisions
	        // and the collision occurs while the other label is visible
	
	        // this this is the lowest scale at which the label won't collide with anything
	        minPlacementScale = collisionFreeScale;
	    }
	
	    return minPlacementScale;
	};
	
	
	/**
	 * Remember this collisionFeature and what scale it was placed at to block
	 * later features from overlapping with it.
	 *
	 * @param {CollisionFeature} collisionFeature
	 * @param {number} minPlacementScale
	 * @private
	 */
	CollisionTile.prototype.insertCollisionFeature = function(collisionFeature, minPlacementScale, ignorePlacement) {
	
	    var grid = ignorePlacement ? this.ignoredGrid : this.grid;
	    var collisionBoxArray = this.collisionBoxArray;
	
	    for (var k = collisionFeature.boxStartIndex; k < collisionFeature.boxEndIndex; k++) {
	        var box = collisionBoxArray.get(k);
	        box.placementScale = minPlacementScale;
	        if (minPlacementScale < this.maxScale) {
	            grid.insert(k, box.bbox0, box.bbox1, box.bbox2, box.bbox3);
	        }
	    }
	};


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var StructArrayType = __webpack_require__(161);
	var util = __webpack_require__(82);
	var Point = __webpack_require__(88);
	
	/**
	 * A collision box represents an area of the map that that is covered by a
	 * label. CollisionFeature uses one or more of these collision boxes to
	 * represent all the area covered by a single label. They are used to
	 * prevent collisions between labels.
	 *
	 * A collision box actually represents a 3d volume. The first two dimensions,
	 * x and y, are specified with `anchor` along with `x1`, `y1`, `x2`, `y2`.
	 * The third dimension, zoom, is limited by `maxScale` which determines
	 * how far in the z dimensions the box extends.
	 *
	 * As you zoom in on a map, all points on the map get further and further apart
	 * but labels stay roughly the same size. Labels cover less real world area on
	 * the map at higher zoom levels than they do at lower zoom levels. This is why
	 * areas are are represented with an anchor point and offsets from that point
	 * instead of just using four absolute points.
	 *
	 * Line labels are represented by a set of these boxes spaced out along a line.
	 * When you zoom in, line labels cover less real world distance along the line
	 * than they used to. Collision boxes near the edges that used to cover label
	 * no longer do. If a box doesn't cover the label anymore it should be ignored
	 * when doing collision checks. `maxScale` is how much you can scale the map
	 * before the label isn't within the box anymore.
	 * For example
	 * lower zoom:
	 * https://cloud.githubusercontent.com/assets/1421652/8060094/4d975f76-0e91-11e5-84b1-4edeb30a5875.png
	 * slightly higher zoom:
	 * https://cloud.githubusercontent.com/assets/1421652/8060061/26ae1c38-0e91-11e5-8c5a-9f380bf29f0a.png
	 * In the zoomed in image the two grey boxes on either side don't cover the
	 * label anymore. Their maxScale is smaller than the current scale.
	 *
	 *
	 * @class CollisionBoxArray
	 * @private
	 */
	
	var CollisionBoxArray = module.exports = new StructArrayType({
	    members: [
	        // the box is centered around the anchor point
	        { type: 'Int16', name: 'anchorPointX' },
	        { type: 'Int16', name: 'anchorPointY' },
	
	        // distances to the edges from the anchor
	        { type: 'Int16', name: 'x1' },
	        { type: 'Int16', name: 'y1' },
	        { type: 'Int16', name: 'x2' },
	        { type: 'Int16', name: 'y2' },
	
	        // the box is only valid for scales < maxScale.
	        // The box does not block other boxes at scales >= maxScale;
	        { type: 'Float32', name: 'maxScale' },
	
	        // the index of the feature in the original vectortile
	        { type: 'Uint32', name: 'featureIndex' },
	        // the source layer the feature appears in
	        { type: 'Uint16', name: 'sourceLayerIndex' },
	        // the bucket the feature appears in
	        { type: 'Uint16', name: 'bucketIndex' },
	
	        // rotated and scaled bbox used for indexing
	        { type: 'Int16', name: 'bbox0' },
	        { type: 'Int16', name: 'bbox1' },
	        { type: 'Int16', name: 'bbox2' },
	        { type: 'Int16', name: 'bbox3' },
	
	        { type: 'Float32', name: 'placementScale' }
	    ]});
	
	util.extendAll(CollisionBoxArray.prototype.StructType.prototype, {
	    get anchorPoint() {
	        return new Point(this.anchorPointX, this.anchorPointY);
	    }
	});


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	var kdbush = __webpack_require__(187);
	
	module.exports = supercluster;
	
	function supercluster(options) {
	    return new SuperCluster(options);
	}
	
	function SuperCluster(options) {
	    this.options = extend(Object.create(this.options), options);
	    this.trees = new Array(this.options.maxZoom + 1);
	}
	
	SuperCluster.prototype = {
	    options: {
	        minZoom: 0,   // min zoom to generate clusters on
	        maxZoom: 16,  // max zoom level to cluster the points on
	        radius: 40,   // cluster radius in pixels
	        extent: 512,  // tile extent (radius is calculated relative to it)
	        nodeSize: 64, // size of the KD-tree leaf node, affects performance
	        log: false    // whether to log timing info
	    },
	
	    load: function (points) {
	        var log = this.options.log;
	
	        if (log) console.time('total time');
	
	        var timerId = 'prepare ' + points.length + ' points';
	        if (log) console.time(timerId);
	
	        this.points = points;
	
	        // generate a cluster object for each point
	        var clusters = points.map(createPointCluster);
	        if (log) console.timeEnd(timerId);
	
	        // cluster points on max zoom, then cluster the results on previous zoom, etc.;
	        // results in a cluster hierarchy across zoom levels
	        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {
	            var now = +Date.now();
	
	            // index input points into a KD-tree
	            this.trees[z + 1] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);
	
	            clusters = this._cluster(clusters, z); // create a new set of clusters for the zoom
	
	            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
	        }
	
	        // index top-level clusters
	        this.trees[this.options.minZoom] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);
	
	        if (log) console.timeEnd('total time');
	
	        return this;
	    },
	
	    getClusters: function (bbox, zoom) {
	        var tree = this.trees[this._limitZoom(zoom)];
	        var ids = tree.range(lngX(bbox[0]), latY(bbox[3]), lngX(bbox[2]), latY(bbox[1]));
	        var clusters = [];
	        for (var i = 0; i < ids.length; i++) {
	            var c = tree.points[ids[i]];
	            clusters.push(c.id !== -1 ? this.points[c.id] : getClusterJSON(c));
	        }
	        return clusters;
	    },
	
	    getTile: function (z, x, y) {
	        var z2 = Math.pow(2, z);
	        var extent = this.options.extent;
	        var p = this.options.radius / extent;
	        var tree = this.trees[this._limitZoom(z)];
	        var ids = tree.range(
	            (x - p) / z2,
	            (y - p) / z2,
	            (x + 1 + p) / z2,
	            (y + 1 + p) / z2);
	
	        if (!ids.length) return null;
	
	        var tile = {
	            features: []
	        };
	        for (var i = 0; i < ids.length; i++) {
	            var c = tree.points[ids[i]];
	            var feature = {
	                type: 1,
	                geometry: [[
	                    Math.round(extent * (c.x * z2 - x)),
	                    Math.round(extent * (c.y * z2 - y))
	                ]],
	                tags: c.id !== -1 ? this.points[c.id].properties : getClusterProperties(c)
	            };
	            tile.features.push(feature);
	        }
	        return tile;
	    },
	
	    _limitZoom: function (z) {
	        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));
	    },
	
	    _cluster: function (points, zoom) {
	        var clusters = [];
	        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));
	
	        // loop through each point
	        for (var i = 0; i < points.length; i++) {
	            var p = points[i];
	            // if we've already visited the point at this zoom level, skip it
	            if (p.zoom <= zoom) continue;
	            p.zoom = zoom;
	
	            // find all nearby points
	            var tree = this.trees[zoom + 1];
	            var neighborIds = tree.within(p.x, p.y, r);
	
	            var foundNeighbors = false;
	            var numPoints = p.numPoints;
	            var wx = p.x * numPoints;
	            var wy = p.y * numPoints;
	
	            for (var j = 0; j < neighborIds.length; j++) {
	                var b = tree.points[neighborIds[j]];
	                // filter out neighbors that are too far or already processed
	                if (zoom < b.zoom) {
	                    foundNeighbors = true;
	                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)
	                    wx += b.x * b.numPoints; // accumulate coordinates for calculating weighted center
	                    wy += b.y * b.numPoints;
	                    numPoints += b.numPoints;
	                }
	            }
	
	            clusters.push(foundNeighbors ? createCluster(wx / numPoints, wy / numPoints, numPoints, -1) : p);
	        }
	
	        return clusters;
	    }
	};
	
	function createCluster(x, y, numPoints, id) {
	    return {
	        x: x, // weighted cluster center
	        y: y,
	        zoom: Infinity, // the last zoom the cluster was processed at
	        id: id, // index of the source feature in the original input array
	        numPoints: numPoints
	    };
	}
	
	function createPointCluster(p, i) {
	    var coords = p.geometry.coordinates;
	    return createCluster(lngX(coords[0]), latY(coords[1]), 1, i);
	}
	
	function getClusterJSON(cluster) {
	    return {
	        type: 'Feature',
	        properties: getClusterProperties(cluster),
	        geometry: {
	            type: 'Point',
	            coordinates: [xLng(cluster.x), yLat(cluster.y)]
	        }
	    };
	}
	
	function getClusterProperties(cluster) {
	    var count = cluster.numPoints;
	    var abbrev = count >= 10000 ? Math.round(count / 1000) + 'k' :
	                 count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;
	    return {
	        cluster: true,
	        point_count: count,
	        point_count_abbreviated: abbrev
	    };
	}
	
	// longitude/latitude to spherical mercator in [0..1] range
	function lngX(lng) {
	    return lng / 360 + 0.5;
	}
	function latY(lat) {
	    var sin = Math.sin(lat * Math.PI / 180),
	        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
	    return y < 0 ? 0 :
	           y > 1 ? 1 : y;
	}
	
	// spherical mercator to longitude/latitude
	function xLng(x) {
	    return (x - 0.5) * 360;
	}
	function yLat(y) {
	    var y2 = (180 - y * 360) * Math.PI / 180;
	    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
	}
	
	function extend(dest, src) {
	    for (var id in src) dest[id] = src[id];
	    return dest;
	}
	
	function getX(p) {
	    return p.x;
	}
	function getY(p) {
	    return p.y;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var sort = __webpack_require__(188);
	var range = __webpack_require__(189);
	var within = __webpack_require__(190);
	
	module.exports = kdbush;
	
	function kdbush(points, getX, getY, nodeSize, ArrayType) {
	    return new KDBush(points, getX, getY, nodeSize, ArrayType);
	}
	
	function KDBush(points, getX, getY, nodeSize, ArrayType) {
	    getX = getX || defaultGetX;
	    getY = getY || defaultGetY;
	    ArrayType = ArrayType || Array;
	
	    this.nodeSize = nodeSize || 64;
	    this.points = points;
	
	    this.ids = new ArrayType(points.length);
	    this.coords = new ArrayType(points.length * 2);
	
	    for (var i = 0; i < points.length; i++) {
	        this.ids[i] = i;
	        this.coords[2 * i] = getX(points[i]);
	        this.coords[2 * i + 1] = getY(points[i]);
	    }
	
	    sort(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);
	}
	
	KDBush.prototype = {
	    range: function (minX, minY, maxX, maxY) {
	        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
	    },
	
	    within: function (x, y, r) {
	        return within(this.ids, this.coords, x, y, r, this.nodeSize);
	    }
	};
	
	function defaultGetX(p) { return p[0]; }
	function defaultGetY(p) { return p[1]; }


/***/ },
/* 188 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = sortKD;
	
	function sortKD(ids, coords, nodeSize, left, right, depth) {
	    if (right - left <= nodeSize) return;
	
	    var m = Math.floor((left + right) / 2);
	
	    select(ids, coords, m, left, right, depth % 2);
	
	    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
	    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
	}
	
	function select(ids, coords, k, left, right, inc) {
	
	    while (right > left) {
	        if (right - left > 600) {
	            var n = right - left + 1;
	            var m = k - left + 1;
	            var z = Math.log(n);
	            var s = 0.5 * Math.exp(2 * z / 3);
	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	            select(ids, coords, k, newLeft, newRight, inc);
	        }
	
	        var t = coords[2 * k + inc];
	        var i = left;
	        var j = right;
	
	        swapItem(ids, coords, left, k);
	        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);
	
	        while (i < j) {
	            swapItem(ids, coords, i, j);
	            i++;
	            j--;
	            while (coords[2 * i + inc] < t) i++;
	            while (coords[2 * j + inc] > t) j--;
	        }
	
	        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);
	        else {
	            j++;
	            swapItem(ids, coords, j, right);
	        }
	
	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}
	
	function swapItem(ids, coords, i, j) {
	    swap(ids, i, j);
	    swap(coords, 2 * i, 2 * j);
	    swap(coords, 2 * i + 1, 2 * j + 1);
	}
	
	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}


/***/ },
/* 189 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = range;
	
	function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
	    var stack = [0, ids.length - 1, 0];
	    var result = [];
	    var x, y;
	
	    while (stack.length) {
	        var axis = stack.pop();
	        var right = stack.pop();
	        var left = stack.pop();
	
	        if (right - left <= nodeSize) {
	            for (var i = left; i <= right; i++) {
	                x = coords[2 * i];
	                y = coords[2 * i + 1];
	                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
	            }
	            continue;
	        }
	
	        var m = Math.floor((left + right) / 2);
	
	        x = coords[2 * m];
	        y = coords[2 * m + 1];
	
	        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);
	
	        var nextAxis = (axis + 1) % 2;
	
	        if (axis === 0 ? minX <= x : minY <= y) {
	            stack.push(left);
	            stack.push(m - 1);
	            stack.push(nextAxis);
	        }
	        if (axis === 0 ? maxX >= x : maxY >= y) {
	            stack.push(m + 1);
	            stack.push(right);
	            stack.push(nextAxis);
	        }
	    }
	
	    return result;
	}


/***/ },
/* 190 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = within;
	
	function within(ids, coords, qx, qy, r, nodeSize) {
	    var stack = [0, ids.length - 1, 0];
	    var result = [];
	    var r2 = r * r;
	
	    while (stack.length) {
	        var axis = stack.pop();
	        var right = stack.pop();
	        var left = stack.pop();
	
	        if (right - left <= nodeSize) {
	            for (var i = left; i <= right; i++) {
	                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
	            }
	            continue;
	        }
	
	        var m = Math.floor((left + right) / 2);
	
	        var x = coords[2 * m];
	        var y = coords[2 * m + 1];
	
	        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);
	
	        var nextAxis = (axis + 1) % 2;
	
	        if (axis === 0 ? qx - r <= x : qy - r <= y) {
	            stack.push(left);
	            stack.push(m - 1);
	            stack.push(nextAxis);
	        }
	        if (axis === 0 ? qx + r >= x : qy + r >= y) {
	            stack.push(m + 1);
	            stack.push(right);
	            stack.push(nextAxis);
	        }
	    }
	
	    return result;
	}
	
	function sqDist(ax, ay, bx, by) {
	    var dx = ax - bx;
	    var dy = ay - by;
	    return dx * dx + dy * dy;
	}


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';
	
	module.exports = geojsonvt;
	
	var convert = __webpack_require__(192),     // GeoJSON conversion and preprocessing
	    transform = __webpack_require__(194), // coordinate transformation
	    clip = __webpack_require__(195),           // stripe clipping algorithm
	    wrap = __webpack_require__(196),           // date line processing
	    createTile = __webpack_require__(197);     // final simplified tile generation
	
	
	function geojsonvt(data, options) {
	    return new GeoJSONVT(data, options);
	}
	
	function GeoJSONVT(data, options) {
	    options = this.options = extend(Object.create(this.options), options);
	
	    var debug = options.debug;
	
	    if (debug) console.time('preprocess data');
	
	    var z2 = 1 << options.maxZoom, // 2^z
	        features = convert(data, options.tolerance / (z2 * options.extent));
	
	    this.tiles = {};
	    this.tileCoords = [];
	
	    if (debug) {
	        console.timeEnd('preprocess data');
	        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
	        console.time('generate tiles');
	        this.stats = {};
	        this.total = 0;
	    }
	
	    features = wrap(features, options.buffer / options.extent, intersectX);
	
	    // start slicing from the top tile down
	    if (features.length) this.splitTile(features, 0, 0, 0);
	
	    if (debug) {
	        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
	        console.timeEnd('generate tiles');
	        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
	    }
	}
	
	GeoJSONVT.prototype.options = {
	    maxZoom: 14,            // max zoom to preserve detail on
	    indexMaxZoom: 5,        // max zoom in the tile index
	    indexMaxPoints: 100000, // max number of points per tile in the tile index
	    solidChildren: false,   // whether to tile solid square tiles further
	    tolerance: 3,           // simplification tolerance (higher means simpler)
	    extent: 4096,           // tile extent
	    buffer: 64,             // tile buffer on each side
	    debug: 0                // logging level (0, 1 or 2)
	};
	
	GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {
	
	    var stack = [features, z, x, y],
	        options = this.options,
	        debug = options.debug,
	        solid = null;
	
	    // avoid recursion by using a processing queue
	    while (stack.length) {
	        y = stack.pop();
	        x = stack.pop();
	        z = stack.pop();
	        features = stack.pop();
	
	        var z2 = 1 << z,
	            id = toID(z, x, y),
	            tile = this.tiles[id],
	            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);
	
	        if (!tile) {
	            if (debug > 1) console.time('creation');
	
	            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
	            this.tileCoords.push({z: z, x: x, y: y});
	
	            if (debug) {
	                if (debug > 1) {
	                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
	                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
	                    console.timeEnd('creation');
	                }
	                var key = 'z' + z;
	                this.stats[key] = (this.stats[key] || 0) + 1;
	                this.total++;
	            }
	        }
	
	        // save reference to original geometry in tile so that we can drill down later if we stop now
	        tile.source = features;
	
	        // if it's the first-pass tiling
	        if (!cz) {
	            // stop tiling if we reached max zoom, or if the tile is too simple
	            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;
	
	        // if a drilldown to a specific tile
	        } else {
	            // stop tiling if we reached base zoom or our target tile zoom
	            if (z === options.maxZoom || z === cz) continue;
	
	            // stop tiling if it's not an ancestor of the target tile
	            var m = 1 << (cz - z);
	            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;
	        }
	
	        // stop tiling if the tile is solid clipped square
	        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
	            if (cz) solid = z; // and remember the zoom if we're drilling down
	            continue;
	        }
	
	        // if we slice further down, no need to keep source geometry
	        tile.source = null;
	
	        if (debug > 1) console.time('clipping');
	
	        // values we'll use for clipping
	        var k1 = 0.5 * options.buffer / options.extent,
	            k2 = 0.5 - k1,
	            k3 = 0.5 + k1,
	            k4 = 1 + k1,
	            tl, bl, tr, br, left, right;
	
	        tl = bl = tr = br = null;
	
	        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
	        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);
	
	        if (left) {
	            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
	            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
	        }
	
	        if (right) {
	            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
	            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
	        }
	
	        if (debug > 1) console.timeEnd('clipping');
	
	        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
	        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
	        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
	        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
	    }
	
	    return solid;
	};
	
	GeoJSONVT.prototype.getTile = function (z, x, y) {
	    var options = this.options,
	        extent = options.extent,
	        debug = options.debug;
	
	    var z2 = 1 << z;
	    x = ((x % z2) + z2) % z2; // wrap tile x coordinate
	
	    var id = toID(z, x, y);
	    if (this.tiles[id]) return transform.tile(this.tiles[id], extent);
	
	    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);
	
	    var z0 = z,
	        x0 = x,
	        y0 = y,
	        parent;
	
	    while (!parent && z0 > 0) {
	        z0--;
	        x0 = Math.floor(x0 / 2);
	        y0 = Math.floor(y0 / 2);
	        parent = this.tiles[toID(z0, x0, y0)];
	    }
	
	    if (!parent || !parent.source) return null;
	
	    // if we found a parent tile containing the original geometry, we can drill down from it
	    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);
	
	    // it parent tile is a solid clipped square, return it instead since it's identical
	    if (isClippedSquare(parent, extent, options.buffer)) return transform.tile(parent, extent);
	
	    if (debug > 1) console.time('drilling down');
	    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
	    if (debug > 1) console.timeEnd('drilling down');
	
	    // one of the parent tiles was a solid clipped square
	    if (solid !== null) {
	        var m = 1 << (z - solid);
	        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
	    }
	
	    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
	};
	
	function toID(z, x, y) {
	    return (((1 << z) * y + x) * 32) + z;
	}
	
	function intersectX(a, b, x) {
	    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
	}
	function intersectY(a, b, y) {
	    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
	}
	
	function extend(dest, src) {
	    for (var i in src) dest[i] = src[i];
	    return dest;
	}
	
	// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
	function isClippedSquare(tile, extent, buffer) {
	
	    var features = tile.source;
	    if (features.length !== 1) return false;
	
	    var feature = features[0];
	    if (feature.type !== 3 || feature.geometry.length > 1) return false;
	
	    var len = feature.geometry[0].length;
	    if (len !== 5) return false;
	
	    for (var i = 0; i < len; i++) {
	        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
	        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
	            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
	    }
	
	    return true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = convert;
	
	var simplify = __webpack_require__(193);
	
	// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data
	
	function convert(data, tolerance) {
	    var features = [];
	
	    if (data.type === 'FeatureCollection') {
	        for (var i = 0; i < data.features.length; i++) {
	            convertFeature(features, data.features[i], tolerance);
	        }
	    } else if (data.type === 'Feature') {
	        convertFeature(features, data, tolerance);
	
	    } else {
	        // single geometry or a geometry collection
	        convertFeature(features, {geometry: data}, tolerance);
	    }
	    return features;
	}
	
	function convertFeature(features, feature, tolerance) {
	    var geom = feature.geometry,
	        type = geom.type,
	        coords = geom.coordinates,
	        tags = feature.properties,
	        i, j, rings;
	
	    if (type === 'Point') {
	        features.push(create(tags, 1, [projectPoint(coords)]));
	
	    } else if (type === 'MultiPoint') {
	        features.push(create(tags, 1, project(coords)));
	
	    } else if (type === 'LineString') {
	        features.push(create(tags, 2, [project(coords, tolerance)]));
	
	    } else if (type === 'MultiLineString' || type === 'Polygon') {
	        rings = [];
	        for (i = 0; i < coords.length; i++) {
	            rings.push(project(coords[i], tolerance));
	        }
	        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));
	
	    } else if (type === 'MultiPolygon') {
	        rings = [];
	        for (i = 0; i < coords.length; i++) {
	            for (j = 0; j < coords[i].length; j++) {
	                rings.push(project(coords[i][j], tolerance));
	            }
	        }
	        features.push(create(tags, 3, rings));
	
	    } else if (type === 'GeometryCollection') {
	        for (i = 0; i < geom.geometries.length; i++) {
	            convertFeature(features, {
	                geometry: geom.geometries[i],
	                properties: tags
	            }, tolerance);
	        }
	
	    } else {
	        throw new Error('Input data is not a valid GeoJSON object.');
	    }
	}
	
	function create(tags, type, geometry) {
	    var feature = {
	        geometry: geometry,
	        type: type,
	        tags: tags || null,
	        min: [2, 1], // initial bbox values;
	        max: [-1, 0]  // note that coords are usually in [0..1] range
	    };
	    calcBBox(feature);
	    return feature;
	}
	
	function project(lonlats, tolerance) {
	    var projected = [];
	    for (var i = 0; i < lonlats.length; i++) {
	        projected.push(projectPoint(lonlats[i]));
	    }
	    if (tolerance) {
	        simplify(projected, tolerance);
	        calcSize(projected);
	    }
	    return projected;
	}
	
	function projectPoint(p) {
	    var sin = Math.sin(p[1] * Math.PI / 180),
	        x = (p[0] / 360 + 0.5),
	        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
	
	    y = y < -1 ? -1 :
	        y > 1 ? 1 : y;
	
	    return [x, y, 0];
	}
	
	// calculate area and length of the poly
	function calcSize(points) {
	    var area = 0,
	        dist = 0;
	
	    for (var i = 0, a, b; i < points.length - 1; i++) {
	        a = b || points[i];
	        b = points[i + 1];
	
	        area += a[0] * b[1] - b[0] * a[1];
	
	        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
	        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
	    }
	    points.area = Math.abs(area / 2);
	    points.dist = dist;
	}
	
	// calculate the feature bounding box for faster clipping later
	function calcBBox(feature) {
	    var geometry = feature.geometry,
	        min = feature.min,
	        max = feature.max;
	
	    if (feature.type === 1) calcRingBBox(min, max, geometry);
	    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);
	
	    return feature;
	}
	
	function calcRingBBox(min, max, points) {
	    for (var i = 0, p; i < points.length; i++) {
	        p = points[i];
	        min[0] = Math.min(p[0], min[0]);
	        max[0] = Math.max(p[0], max[0]);
	        min[1] = Math.min(p[1], min[1]);
	        max[1] = Math.max(p[1], max[1]);
	    }
	}


/***/ },
/* 193 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = simplify;
	
	// calculate simplification data using optimized Douglas-Peucker algorithm
	
	function simplify(points, tolerance) {
	
	    var sqTolerance = tolerance * tolerance,
	        len = points.length,
	        first = 0,
	        last = len - 1,
	        stack = [],
	        i, maxSqDist, sqDist, index;
	
	    // always retain the endpoints (1 is the max value)
	    points[first][2] = 1;
	    points[last][2] = 1;
	
	    // avoid recursion by using a stack
	    while (last) {
	
	        maxSqDist = 0;
	
	        for (i = first + 1; i < last; i++) {
	            sqDist = getSqSegDist(points[i], points[first], points[last]);
	
	            if (sqDist > maxSqDist) {
	                index = i;
	                maxSqDist = sqDist;
	            }
	        }
	
	        if (maxSqDist > sqTolerance) {
	            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
	            stack.push(first);
	            stack.push(index);
	            first = index;
	
	        } else {
	            last = stack.pop();
	            first = stack.pop();
	        }
	    }
	}
	
	// square distance from a point to a segment
	function getSqSegDist(p, a, b) {
	
	    var x = a[0], y = a[1],
	        bx = b[0], by = b[1],
	        px = p[0], py = p[1],
	        dx = bx - x,
	        dy = by - y;
	
	    if (dx !== 0 || dy !== 0) {
	
	        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
	
	        if (t > 1) {
	            x = bx;
	            y = by;
	
	        } else if (t > 0) {
	            x += dx * t;
	            y += dy * t;
	        }
	    }
	
	    dx = px - x;
	    dy = py - y;
	
	    return dx * dx + dy * dy;
	}


/***/ },
/* 194 */
/***/ function(module, exports) {

	'use strict';
	
	exports.tile = transformTile;
	exports.point = transformPoint;
	
	// Transforms the coordinates of each feature in the given tile from
	// mercator-projected space into (extent x extent) tile space.
	function transformTile(tile, extent) {
	    if (tile.transformed) return tile;
	
	    var z2 = tile.z2,
	        tx = tile.x,
	        ty = tile.y,
	        i, j, k;
	
	    for (i = 0; i < tile.features.length; i++) {
	        var feature = tile.features[i],
	            geom = feature.geometry,
	            type = feature.type;
	
	        if (type === 1) {
	            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);
	
	        } else {
	            for (j = 0; j < geom.length; j++) {
	                var ring = geom[j];
	                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
	            }
	        }
	    }
	
	    tile.transformed = true;
	
	    return tile;
	}
	
	function transformPoint(p, extent, z2, tx, ty) {
	    var x = Math.round(extent * (p[0] * z2 - tx)),
	        y = Math.round(extent * (p[1] * z2 - ty));
	    return [x, y];
	}


/***/ },
/* 195 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = clip;
	
	/* clip features between two axis-parallel lines:
	 *     |        |
	 *  ___|___     |     /
	 * /   |   \____|____/
	 *     |        |
	 */
	
	function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {
	
	    k1 /= scale;
	    k2 /= scale;
	
	    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
	    else if (minAll > k2 || maxAll < k1) return null; // trivial reject
	
	    var clipped = [];
	
	    for (var i = 0; i < features.length; i++) {
	
	        var feature = features[i],
	            geometry = feature.geometry,
	            type = feature.type,
	            min, max;
	
	        min = feature.min[axis];
	        max = feature.max[axis];
	
	        if (min >= k1 && max <= k2) { // trivial accept
	            clipped.push(feature);
	            continue;
	        } else if (min > k2 || max < k1) continue; // trivial reject
	
	        var slices = type === 1 ?
	                clipPoints(geometry, k1, k2, axis) :
	                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);
	
	        if (slices.length) {
	            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
	            // so there's no need to recalculate bboxes
	            clipped.push({
	                geometry: slices,
	                type: type,
	                tags: features[i].tags || null,
	                min: feature.min,
	                max: feature.max
	            });
	        }
	    }
	
	    return clipped.length ? clipped : null;
	}
	
	function clipPoints(geometry, k1, k2, axis) {
	    var slice = [];
	
	    for (var i = 0; i < geometry.length; i++) {
	        var a = geometry[i],
	            ak = a[axis];
	
	        if (ak >= k1 && ak <= k2) slice.push(a);
	    }
	    return slice;
	}
	
	function clipGeometry(geometry, k1, k2, axis, intersect, closed) {
	
	    var slices = [];
	
	    for (var i = 0; i < geometry.length; i++) {
	
	        var ak = 0,
	            bk = 0,
	            b = null,
	            points = geometry[i],
	            area = points.area,
	            dist = points.dist,
	            len = points.length,
	            a, j, last;
	
	        var slice = [];
	
	        for (j = 0; j < len - 1; j++) {
	            a = b || points[j];
	            b = points[j + 1];
	            ak = bk || a[axis];
	            bk = b[axis];
	
	            if (ak < k1) {
	
	                if ((bk > k2)) { // ---|-----|-->
	                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
	                    if (!closed) slice = newSlice(slices, slice, area, dist);
	
	                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |
	
	            } else if (ak > k2) {
	
	                if ((bk < k1)) { // <--|-----|---
	                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
	                    if (!closed) slice = newSlice(slices, slice, area, dist);
	
	                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---
	
	            } else {
	
	                slice.push(a);
	
	                if (bk < k1) { // <--|---  |
	                    slice.push(intersect(a, b, k1));
	                    if (!closed) slice = newSlice(slices, slice, area, dist);
	
	                } else if (bk > k2) { // |  ---|-->
	                    slice.push(intersect(a, b, k2));
	                    if (!closed) slice = newSlice(slices, slice, area, dist);
	                }
	                // | --> |
	            }
	        }
	
	        // add the last point
	        a = points[len - 1];
	        ak = a[axis];
	        if (ak >= k1 && ak <= k2) slice.push(a);
	
	        // close the polygon if its endpoints are not the same after clipping
	
	        last = slice[slice.length - 1];
	        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);
	
	        // add the final slice
	        newSlice(slices, slice, area, dist);
	    }
	
	    return slices;
	}
	
	function newSlice(slices, slice, area, dist) {
	    if (slice.length) {
	        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
	        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
	        slice.area = area;
	        slice.dist = dist;
	
	        slices.push(slice);
	    }
	    return [];
	}


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var clip = __webpack_require__(195);
	
	module.exports = wrap;
	
	function wrap(features, buffer, intersectX) {
	    var merged = features,
	        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
	        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy
	
	    if (left || right) {
	        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy
	
	        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
	        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
	    }
	
	    return merged;
	}
	
	function shiftFeatureCoords(features, offset) {
	    var newFeatures = [];
	
	    for (var i = 0; i < features.length; i++) {
	        var feature = features[i],
	            type = feature.type;
	
	        var newGeometry;
	
	        if (type === 1) {
	            newGeometry = shiftCoords(feature.geometry, offset);
	        } else {
	            newGeometry = [];
	            for (var j = 0; j < feature.geometry.length; j++) {
	                newGeometry.push(shiftCoords(feature.geometry[j], offset));
	            }
	        }
	
	        newFeatures.push({
	            geometry: newGeometry,
	            type: type,
	            tags: feature.tags,
	            min: [feature.min[0] + offset, feature.min[1]],
	            max: [feature.max[0] + offset, feature.max[1]]
	        });
	    }
	
	    return newFeatures;
	}
	
	function shiftCoords(points, offset) {
	    var newPoints = [];
	    newPoints.area = points.area;
	    newPoints.dist = points.dist;
	
	    for (var i = 0; i < points.length; i++) {
	        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
	    }
	    return newPoints;
	}


/***/ },
/* 197 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = createTile;
	
	function createTile(features, z2, tx, ty, tolerance, noSimplify) {
	    var tile = {
	        features: [],
	        numPoints: 0,
	        numSimplified: 0,
	        numFeatures: 0,
	        source: null,
	        x: tx,
	        y: ty,
	        z2: z2,
	        transformed: false,
	        min: [2, 1],
	        max: [-1, 0]
	    };
	    for (var i = 0; i < features.length; i++) {
	        tile.numFeatures++;
	        addFeature(tile, features[i], tolerance, noSimplify);
	
	        var min = features[i].min,
	            max = features[i].max;
	
	        if (min[0] < tile.min[0]) tile.min[0] = min[0];
	        if (min[1] < tile.min[1]) tile.min[1] = min[1];
	        if (max[0] > tile.max[0]) tile.max[0] = max[0];
	        if (max[1] > tile.max[1]) tile.max[1] = max[1];
	    }
	    return tile;
	}
	
	function addFeature(tile, feature, tolerance, noSimplify) {
	
	    var geom = feature.geometry,
	        type = feature.type,
	        simplified = [],
	        sqTolerance = tolerance * tolerance,
	        i, j, ring, p;
	
	    if (type === 1) {
	        for (i = 0; i < geom.length; i++) {
	            simplified.push(geom[i]);
	            tile.numPoints++;
	            tile.numSimplified++;
	        }
	
	    } else {
	
	        // simplify and transform projected coordinates for tile geometry
	        for (i = 0; i < geom.length; i++) {
	            ring = geom[i];
	
	            // filter out tiny polylines & polygons
	            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
	                                (type === 3 && ring.area < sqTolerance))) {
	                tile.numPoints += ring.length;
	                continue;
	            }
	
	            var simplifiedRing = [];
	
	            for (j = 0; j < ring.length; j++) {
	                p = ring[j];
	                // keep points with importance > tolerance
	                if (noSimplify || p[2] > sqTolerance) {
	                    simplifiedRing.push(p);
	                    tile.numSimplified++;
	                }
	                tile.numPoints++;
	            }
	
	            simplified.push(simplifiedRing);
	        }
	    }
	
	    if (simplified.length) {
	        tile.features.push({
	            geometry: simplified,
	            type: type,
	            tags: feature.tags || null
	        });
	    }
	}


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var geojsonArea = __webpack_require__(199);
	
	module.exports = rewind;
	
	function rewind(gj, outer) {
	    switch ((gj && gj.type) || null) {
	        case 'FeatureCollection':
	            gj.features = gj.features.map(curryOuter(rewind, outer));
	            return gj;
	        case 'Feature':
	            gj.geometry = rewind(gj.geometry, outer);
	            return gj;
	        case 'Polygon':
	        case 'MultiPolygon':
	            return correct(gj, outer);
	        default:
	            return gj;
	    }
	}
	
	function curryOuter(a, b) {
	    return function(_) { return a(_, b); };
	}
	
	function correct(_, outer) {
	    if (_.type === 'Polygon') {
	        _.coordinates = correctRings(_.coordinates, outer);
	    } else if (_.type === 'MultiPolygon') {
	        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
	    }
	    return _;
	}
	
	function correctRings(_, outer) {
	    outer = !!outer;
	    _[0] = wind(_[0], !outer);
	    for (var i = 1; i < _.length; i++) {
	        _[i] = wind(_[i], outer);
	    }
	    return _;
	}
	
	function wind(_, dir) {
	    return cw(_) === dir ? _ : _.reverse();
	}
	
	function cw(_) {
	    return geojsonArea.ring(_) >= 0;
	}


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var wgs84 = __webpack_require__(200);
	
	module.exports.geometry = geometry;
	module.exports.ring = ringArea;
	
	function geometry(_) {
	    if (_.type === 'Polygon') return polygonArea(_.coordinates);
	    else if (_.type === 'MultiPolygon') {
	        var area = 0;
	        for (var i = 0; i < _.coordinates.length; i++) {
	            area += polygonArea(_.coordinates[i]);
	        }
	        return area;
	    } else {
	        return null;
	    }
	}
	
	function polygonArea(coords) {
	    var area = 0;
	    if (coords && coords.length > 0) {
	        area += Math.abs(ringArea(coords[0]));
	        for (var i = 1; i < coords.length; i++) {
	            area -= Math.abs(ringArea(coords[i]));
	        }
	    }
	    return area;
	}
	
	/**
	 * Calculate the approximate area of the polygon were it projected onto
	 *     the earth.  Note that this area will be positive if ring is oriented
	 *     clockwise, otherwise it will be negative.
	 *
	 * Reference:
	 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
	 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
	 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
	 *
	 * Returns:
	 * {float} The approximate signed geodesic area of the polygon in square
	 *     meters.
	 */
	
	function ringArea(coords) {
	    var area = 0;
	
	    if (coords.length > 2) {
	        var p1, p2;
	        for (var i = 0; i < coords.length - 1; i++) {
	            p1 = coords[i];
	            p2 = coords[i + 1];
	            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
	        }
	
	        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
	    }
	
	    return area;
	}
	
	function rad(_) {
	    return _ * Math.PI / 180;
	}


/***/ },
/* 200 */
/***/ function(module, exports) {

	module.exports.RADIUS = 6378137;
	module.exports.FLATTENING = 1/298.257223563;
	module.exports.POLAR_RADIUS = 6356752.3142;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Point = __webpack_require__(88);
	var VectorTileFeature = __webpack_require__(178).VectorTileFeature;
	var EXTENT = __webpack_require__(157).EXTENT;
	
	module.exports = GeoJSONWrapper;
	
	// conform to vectortile api
	function GeoJSONWrapper(features) {
	    this.features = features;
	    this.length = features.length;
	    this.extent = EXTENT;
	}
	
	GeoJSONWrapper.prototype.feature = function(i) {
	    return new FeatureWrapper(this.features[i]);
	};
	
	function FeatureWrapper(feature) {
	    this.type = feature.type;
	    this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry;
	    this.properties = feature.tags;
	    this.extent = EXTENT;
	}
	
	FeatureWrapper.prototype.loadGeometry = function() {
	    var rings = this.rawGeometry;
	    this.geometry = [];
	
	    for (var i = 0; i < rings.length; i++) {
	        var ring = rings[i],
	            newRing = [];
	        for (var j = 0; j < ring.length; j++) {
	            newRing.push(new Point(ring[j][0], ring[j][1]));
	        }
	        this.geometry.push(newRing);
	    }
	    return this.geometry;
	};
	
	FeatureWrapper.prototype.bbox = function() {
	    if (!this.geometry) this.loadGeometry();
	
	    var rings = this.geometry,
	        x1 = Infinity,
	        x2 = -Infinity,
	        y1 = Infinity,
	        y2 = -Infinity;
	
	    for (var i = 0; i < rings.length; i++) {
	        var ring = rings[i];
	
	        for (var j = 0; j < ring.length; j++) {
	            var coord = ring[j];
	
	            x1 = Math.min(x1, coord.x);
	            x2 = Math.max(x2, coord.x);
	            y1 = Math.min(y1, coord.y);
	            y2 = Math.max(y2, coord.y);
	        }
	    }
	
	    return [x1, y1, x2, y2];
	};
	
	FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var Pbf = __webpack_require__(142)
	var vtpb = __webpack_require__(203)
	var GeoJSONWrapper = __webpack_require__(204)
	
	module.exports = fromVectorTileJs
	module.exports.fromVectorTileJs = fromVectorTileJs
	module.exports.fromGeojsonVt = fromGeojsonVt
	module.exports.GeoJSONWrapper = GeoJSONWrapper
	
	/**
	 * Serialize a vector-tile-js-created tile to pbf
	 *
	 * @param {Object} tile
	 * @return {Buffer} uncompressed, pbf-serialized tile data
	 */
	function fromVectorTileJs (tile) {
	  var layers = []
	  for (var l in tile.layers) {
	    layers.push(prepareLayer(tile.layers[l]))
	  }
	
	  var out = new Pbf()
	  vtpb.tile.write({ layers: layers }, out)
	  return out.finish()
	}
	
	/**
	 * Serialized a geojson-vt-created tile to pbf.
	 *
	 * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects
	 * @return {Buffer} uncompressed, pbf-serialized tile data
	 */
	function fromGeojsonVt (layers) {
	  var l = {}
	  for (var k in layers) {
	    l[k] = new GeoJSONWrapper(layers[k].features)
	    l[k].name = k
	  }
	  return fromVectorTileJs({layers: l})
	}
	
	/**
	 * Prepare the given layer to be serialized by the auto-generated pbf
	 * serializer by encoding the feature geometry and properties.
	 */
	function prepareLayer (layer) {
	  var preparedLayer = {
	    name: layer.name || '',
	    version: layer.version || 1,
	    extent: layer.extent || 4096,
	    keys: [],
	    values: [],
	    features: []
	  }
	
	  var keycache = {}
	  var valuecache = {}
	
	  for (var i = 0; i < layer.length; i++) {
	    var feature = layer.feature(i)
	    feature.geometry = encodeGeometry(feature.loadGeometry())
	
	    var tags = []
	    for (var key in feature.properties) {
	      var keyIndex = keycache[key]
	      if (typeof keyIndex === 'undefined') {
	        preparedLayer.keys.push(key)
	        keyIndex = preparedLayer.keys.length - 1
	        keycache[key] = keyIndex
	      }
	      var value = wrapValue(feature.properties[key])
	      var valueIndex = valuecache[value.key]
	      if (typeof valueIndex === 'undefined') {
	        preparedLayer.values.push(value)
	        valueIndex = preparedLayer.values.length - 1
	        valuecache[value.key] = valueIndex
	      }
	      tags.push(keyIndex)
	      tags.push(valueIndex)
	    }
	
	    feature.tags = tags
	    preparedLayer.features.push(feature)
	  }
	
	  return preparedLayer
	}
	
	function command (cmd, length) {
	  return (length << 3) + (cmd & 0x7)
	}
	
	function zigzag (num) {
	  return (num << 1) ^ (num >> 31)
	}
	
	/**
	 * Encode a polygon's geometry into an array ready to be serialized
	 * to mapbox vector tile specified geometry data.
	 *
	 * @param {Array} Rings, each being an array of [x, y] tile-space coordinates
	 * @return {Array} encoded geometry
	 */
	function encodeGeometry (geometry) {
	  var encoded = []
	  var x = 0
	  var y = 0
	  var rings = geometry.length
	  for (var r = 0; r < rings; r++) {
	    var ring = geometry[r]
	    encoded.push(command(1, 1)) // moveto
	    for (var i = 0; i < ring.length; i++) {
	      if (i === 1) {
	        encoded.push(command(2, ring.length - 1)) // lineto
	      }
	      var dx = ring[i].x - x
	      var dy = ring[i].y - y
	      encoded.push(zigzag(dx), zigzag(dy))
	      x += dx
	      y += dy
	    }
	  }
	
	  return encoded
	}
	
	/**
	 * Wrap a property value according to its type. The returned object
	 * is of the form { xxxx_value: primitiveValue }, which is what the generated
	 * protobuf serializer expects.
	 */
	function wrapValue (value) {
	  var result
	  var type = typeof value
	  if (type === 'string') {
	    result = { string_value: value }
	  } else if (type === 'boolean') {
	    result = { bool_value: value }
	  } else if (type === 'number') {
	    if (value !== (value | 0)) {
	      result = { float_value: value }
	    } else if (value < 0) {
	      result = { sint_value: value }
	    } else {
	      result = { uint_value: value }
	    }
	  } else {
	    result = { string_value: '' + value }
	  }
	
	  result.key = type + ':' + value
	  return result
	}


/***/ },
/* 203 */
/***/ function(module, exports) {

	'use strict';
	
	// tile ========================================
	
	var tile = exports.tile = {read: readTile, write: writeTile};
	
	tile.GeomType = {
	    "Unknown": 0,
	    "Point": 1,
	    "LineString": 2,
	    "Polygon": 3
	};
	
	function readTile(pbf, end) {
	    return pbf.readFields(readTileField, {"layers": []}, end);
	}
	
	function readTileField(tag, tile, pbf) {
	    if (tag === 3) tile.layers.push(readLayer(pbf, pbf.readVarint() + pbf.pos));
	}
	
	function writeTile(tile, pbf) {
	    var i;
	    if (tile.layers !== undefined) for (i = 0; i < tile.layers.length; i++) pbf.writeMessage(3, writeLayer, tile.layers[i]);
	}
	
	// value ========================================
	
	tile.value = {read: readValue, write: writeValue};
	
	function readValue(pbf, end) {
	    return pbf.readFields(readValueField, {}, end);
	}
	
	function readValueField(tag, value, pbf) {
	    if (tag === 1) value.string_value = pbf.readString();
	    else if (tag === 2) value.float_value = pbf.readFloat();
	    else if (tag === 3) value.double_value = pbf.readDouble();
	    else if (tag === 4) value.int_value = pbf.readVarint();
	    else if (tag === 5) value.uint_value = pbf.readVarint();
	    else if (tag === 6) value.sint_value = pbf.readSVarint();
	    else if (tag === 7) value.bool_value = pbf.readBoolean();
	}
	
	function writeValue(value, pbf) {
	    if (value.string_value !== undefined) pbf.writeStringField(1, value.string_value);
	    if (value.float_value !== undefined) pbf.writeFloatField(2, value.float_value);
	    if (value.double_value !== undefined) pbf.writeDoubleField(3, value.double_value);
	    if (value.int_value !== undefined) pbf.writeVarintField(4, value.int_value);
	    if (value.uint_value !== undefined) pbf.writeVarintField(5, value.uint_value);
	    if (value.sint_value !== undefined) pbf.writeSVarintField(6, value.sint_value);
	    if (value.bool_value !== undefined) pbf.writeBooleanField(7, value.bool_value);
	}
	
	// feature ========================================
	
	tile.feature = {read: readFeature, write: writeFeature};
	
	function readFeature(pbf, end) {
	    var feature = pbf.readFields(readFeatureField, {}, end);
	    if (feature.type === undefined) feature.type = "Unknown";
	    return feature;
	}
	
	function readFeatureField(tag, feature, pbf) {
	    if (tag === 1) feature.id = pbf.readVarint();
	    else if (tag === 2) feature.tags = pbf.readPackedVarint();
	    else if (tag === 3) feature.type = pbf.readVarint();
	    else if (tag === 4) feature.geometry = pbf.readPackedVarint();
	}
	
	function writeFeature(feature, pbf) {
	    if (feature.id !== undefined) pbf.writeVarintField(1, feature.id);
	    if (feature.tags !== undefined) pbf.writePackedVarint(2, feature.tags);
	    if (feature.type !== undefined) pbf.writeVarintField(3, feature.type);
	    if (feature.geometry !== undefined) pbf.writePackedVarint(4, feature.geometry);
	}
	
	// layer ========================================
	
	tile.layer = {read: readLayer, write: writeLayer};
	
	function readLayer(pbf, end) {
	    return pbf.readFields(readLayerField, {"features": [], "keys": [], "values": []}, end);
	}
	
	function readLayerField(tag, layer, pbf) {
	    if (tag === 15) layer.version = pbf.readVarint();
	    else if (tag === 1) layer.name = pbf.readString();
	    else if (tag === 2) layer.features.push(readFeature(pbf, pbf.readVarint() + pbf.pos));
	    else if (tag === 3) layer.keys.push(pbf.readString());
	    else if (tag === 4) layer.values.push(readValue(pbf, pbf.readVarint() + pbf.pos));
	    else if (tag === 5) layer.extent = pbf.readVarint();
	}
	
	function writeLayer(layer, pbf) {
	    if (layer.version !== undefined) pbf.writeVarintField(15, layer.version);
	    if (layer.name !== undefined) pbf.writeStringField(1, layer.name);
	    var i;
	    if (layer.features !== undefined) for (i = 0; i < layer.features.length; i++) pbf.writeMessage(2, writeFeature, layer.features[i]);
	    if (layer.keys !== undefined) for (i = 0; i < layer.keys.length; i++) pbf.writeStringField(3, layer.keys[i]);
	    if (layer.values !== undefined) for (i = 0; i < layer.values.length; i++) pbf.writeMessage(4, writeValue, layer.values[i]);
	    if (layer.extent !== undefined) pbf.writeVarintField(5, layer.extent);
	}


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Point = __webpack_require__(88)
	var VectorTileFeature = __webpack_require__(178).VectorTileFeature
	
	module.exports = GeoJSONWrapper
	
	// conform to vectortile api
	function GeoJSONWrapper (features) {
	  this.features = features
	  this.length = features.length
	}
	
	GeoJSONWrapper.prototype.feature = function (i) {
	  return new FeatureWrapper(this.features[i])
	}
	
	function FeatureWrapper (feature) {
	  this.type = feature.type
	  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry
	  this.properties = feature.tags
	  this.extent = 4096
	}
	
	FeatureWrapper.prototype.loadGeometry = function () {
	  var rings = this.rawGeometry
	  this.geometry = []
	
	  for (var i = 0; i < rings.length; i++) {
	    var ring = rings[i]
	    var newRing = []
	    for (var j = 0; j < ring.length; j++) {
	      newRing.push(new Point(ring[j][0], ring[j][1]))
	    }
	    this.geometry.push(newRing)
	  }
	  return this.geometry
	}
	
	FeatureWrapper.prototype.bbox = function () {
	  if (!this.geometry) this.loadGeometry()
	
	  var rings = this.geometry
	  var x1 = Infinity
	  var x2 = -Infinity
	  var y1 = Infinity
	  var y2 = -Infinity
	
	  for (var i = 0; i < rings.length; i++) {
	    var ring = rings[i]
	
	    for (var j = 0; j < ring.length; j++) {
	      var coord = ring[j]
	
	      x1 = Math.min(x1, coord.x)
	      x2 = Math.max(x2, coord.x)
	      y1 = Math.min(y1, coord.y)
	      y2 = Math.max(y2, coord.y)
	    }
	  }
	
	  return [x1, y1, x2, y2]
	}
	
	FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON


/***/ },
/* 205 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = AnimationLoop;
	
	function AnimationLoop() {
	    this.n = 0;
	    this.times = [];
	}
	
	// Are all animations done?
	AnimationLoop.prototype.stopped = function() {
	    this.times = this.times.filter(function(t) {
	        return t.time >= (new Date()).getTime();
	    });
	    return !this.times.length;
	};
	
	// Add a new animation that will run t milliseconds
	// Returns an id that can be used to cancel it layer
	AnimationLoop.prototype.set = function(t) {
	    this.times.push({ id: this.n, time: t + (new Date()).getTime() });
	    return this.n++;
	};
	
	// Cancel an animation
	AnimationLoop.prototype.cancel = function(n) {
	    this.times = this.times.filter(function(t) {
	        return t.id !== n;
	    });
	};


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var ajax = __webpack_require__(135);
	var browser = __webpack_require__(85);
	var TilePyramid = __webpack_require__(207);
	var normalizeURL = __webpack_require__(136).normalizeSourceURL;
	var TileCoord = __webpack_require__(209);
	
	exports._loadTileJSON = function(options) {
	    var loaded = function(err, tileJSON) {
	        if (err) {
	            this.fire('error', {error: err});
	            return;
	        }
	
	        util.extend(this, util.pick(tileJSON,
	            ['tiles', 'minzoom', 'maxzoom', 'attribution']));
	
	        if (tileJSON.vector_layers) {
	            this.vectorLayers = tileJSON.vector_layers;
	            this.vectorLayerIds = this.vectorLayers.map(function(layer) { return layer.id; });
	        }
	
	        this._pyramid = new TilePyramid({
	            tileSize: this.tileSize,
	            minzoom: this.minzoom,
	            maxzoom: this.maxzoom,
	            roundZoom: this.roundZoom,
	            reparseOverscaled: this.reparseOverscaled,
	            load: this._loadTile.bind(this),
	            abort: this._abortTile.bind(this),
	            unload: this._unloadTile.bind(this),
	            add: this._addTile.bind(this),
	            remove: this._removeTile.bind(this),
	            redoPlacement: this._redoTilePlacement ? this._redoTilePlacement.bind(this) : undefined
	        });
	
	        this.fire('load');
	    }.bind(this);
	
	    if (options.url) {
	        ajax.getJSON(normalizeURL(options.url), loaded);
	    } else {
	        browser.frame(loaded.bind(this, null, options));
	    }
	};
	
	exports.redoPlacement = function() {
	    if (!this._pyramid) {
	        return;
	    }
	
	    var ids = this._pyramid.orderedIDs();
	    for (var i = 0; i < ids.length; i++) {
	        var tile = this._pyramid.getTile(ids[i]);
	        this._redoTilePlacement(tile);
	    }
	};
	
	exports._getTile = function(coord) {
	    return this._pyramid.getTile(coord.id);
	};
	
	exports._getVisibleCoordinates = function() {
	    if (!this._pyramid) return [];
	    else return this._pyramid.renderedIDs().map(TileCoord.fromID);
	};
	
	function sortTilesIn(a, b) {
	    var coordA = a.tile.coord;
	    var coordB = b.tile.coord;
	    return (coordA.z - coordB.z) || (coordA.y - coordB.y) || (coordA.x - coordB.x);
	}
	
	function mergeRenderedFeatureLayers(tiles) {
	    var result = tiles[0] || {};
	    for (var i = 1; i < tiles.length; i++) {
	        var tile = tiles[i];
	        for (var layerID in tile) {
	            var tileFeatures = tile[layerID];
	            var resultFeatures = result[layerID];
	            if (resultFeatures === undefined) {
	                resultFeatures = result[layerID] = tileFeatures;
	            } else {
	                for (var f = 0; f < tileFeatures.length; f++) {
	                    resultFeatures.push(tileFeatures[f]);
	                }
	            }
	        }
	    }
	    return result;
	}
	
	exports._queryRenderedVectorFeatures = function(queryGeometry, params, zoom, bearing) {
	    if (!this._pyramid)
	        return {};
	
	    var tilesIn = this._pyramid.tilesIn(queryGeometry);
	
	    tilesIn.sort(sortTilesIn);
	
	    var styleLayers = this.map.style._layers;
	
	    var renderedFeatureLayers = [];
	    for (var r = 0; r < tilesIn.length; r++) {
	        var tileIn = tilesIn[r];
	        if (!tileIn.tile.featureIndex) continue;
	
	        renderedFeatureLayers.push(tileIn.tile.featureIndex.query({
	            queryGeometry: tileIn.queryGeometry,
	            scale: tileIn.scale,
	            tileSize: tileIn.tile.tileSize,
	            bearing: bearing,
	            params: params
	        }, styleLayers));
	    }
	    return mergeRenderedFeatureLayers(renderedFeatureLayers);
	};
	
	exports._querySourceFeatures = function(params) {
	    if (!this._pyramid) {
	        return [];
	    }
	
	    var pyramid = this._pyramid;
	    var tiles = pyramid.renderedIDs().map(function(id) {
	        return pyramid.getTile(id);
	    });
	
	    var result = [];
	
	    var dataTiles = {};
	    for (var i = 0; i < tiles.length; i++) {
	        var tile = tiles[i];
	        var dataID = new TileCoord(Math.min(tile.sourceMaxZoom, tile.coord.z), tile.coord.x, tile.coord.y, 0).id;
	        if (!dataTiles[dataID]) {
	            dataTiles[dataID] = true;
	            tile.querySourceFeatures(result, params);
	        }
	    }
	
	    return result;
	};
	
	/*
	 * Create a tiled data source instance given an options object
	 *
	 * @param {Object} options
	 * @param {string} options.type Either `raster` or `vector`.
	 * @param {string} options.url A tile source URL. This should either be `mapbox://{mapid}` or a full `http[s]` url that points to a TileJSON endpoint.
	 * @param {Array} options.tiles An array of tile sources. If `url` is not specified, `tiles` can be used instead to specify tile sources, as in the TileJSON spec. Other TileJSON keys such as `minzoom` and `maxzoom` can be specified in a source object if `tiles` is used.
	 * @param {string} options.id An optional `id` to assign to the source
	 * @param {number} [options.tileSize=512] Optional tile size (width and height in pixels, assuming tiles are square). This option is only configurable for raster sources
	 * @example
	 * var sourceObj = new mapboxgl.Source.create({
	 *    type: 'vector',
	 *    url: 'mapbox://mapbox.mapbox-streets-v5'
	 * });
	 * map.addSource('some id', sourceObj); // add
	 * map.removeSource('some id');  // remove
	 */
	exports.create = function(source) {
	    // This is not at file scope in order to avoid a circular require.
	    var sources = {
	        vector: __webpack_require__(211),
	        raster: __webpack_require__(212),
	        geojson: __webpack_require__(213),
	        video: __webpack_require__(215),
	        image: __webpack_require__(217)
	    };
	
	    return exports.is(source) ? source : new sources[source.type](source);
	};
	
	exports.is = function(source) {
	    // This is not at file scope in order to avoid a circular require.
	    var sources = {
	        vector: __webpack_require__(211),
	        raster: __webpack_require__(212),
	        geojson: __webpack_require__(213),
	        video: __webpack_require__(215),
	        image: __webpack_require__(217)
	    };
	
	    for (var type in sources) {
	        if (source instanceof sources[type]) {
	            return true;
	        }
	    }
	
	    return false;
	};


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Tile = __webpack_require__(208);
	var TileCoord = __webpack_require__(209);
	var Point = __webpack_require__(88);
	var Cache = __webpack_require__(210);
	var Coordinate = __webpack_require__(84);
	var util = __webpack_require__(82);
	var EXTENT = __webpack_require__(157).EXTENT;
	
	module.exports = TilePyramid;
	
	/**
	 * A tile pyramid is a specialized cache and datastructure
	 * that contains tiles. It's used by sources to manage their
	 * data.
	 *
	 * @param {Object} options
	 * @param {number} options.tileSize
	 * @param {number} options.minzoom
	 * @param {number} options.maxzoom
	 * @private
	 */
	function TilePyramid(options) {
	    this.tileSize = options.tileSize;
	    this.minzoom = options.minzoom;
	    this.maxzoom = options.maxzoom;
	    this.roundZoom = options.roundZoom;
	    this.reparseOverscaled = options.reparseOverscaled;
	
	    this._load = options.load;
	    this._abort = options.abort;
	    this._unload = options.unload;
	    this._add = options.add;
	    this._remove = options.remove;
	    this._redoPlacement = options.redoPlacement;
	
	    this._tiles = {};
	    this._cache = new Cache(0, function(tile) { return this._unload(tile); }.bind(this));
	
	    this._filterRendered = this._filterRendered.bind(this);
	}
	
	
	TilePyramid.maxOverzooming = 10;
	TilePyramid.maxUnderzooming = 3;
	
	TilePyramid.prototype = {
	    /**
	     * Confirm that every tracked tile is loaded.
	     * @returns {boolean} whether all tiles are loaded.
	     * @private
	     */
	    loaded: function() {
	        for (var t in this._tiles) {
	            if (!this._tiles[t].loaded && !this._tiles[t].errored)
	                return false;
	        }
	        return true;
	    },
	
	    /**
	     * Return all tile ids ordered with z-order, and cast to numbers
	     * @returns {Array<number>} ids
	     * @private
	     */
	    orderedIDs: function() {
	        return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);
	    },
	
	    renderedIDs: function() {
	        return this.orderedIDs().filter(this._filterRendered);
	    },
	
	    _filterRendered: function(id) {
	        return this._tiles[id].loaded && !this._coveredTiles[id];
	    },
	
	    reload: function() {
	        this._cache.reset();
	        for (var i in this._tiles) {
	            this._load(this._tiles[i]);
	        }
	    },
	
	    /**
	     * Get a specific tile by id
	     * @param {string|number} id tile id
	     * @returns {Object} tile
	     * @private
	     */
	    getTile: function(id) {
	        return this._tiles[id];
	    },
	
	    /**
	     * get the zoom level adjusted for the difference in map and source tilesizes
	     * @param {Object} transform
	     * @returns {number} zoom level
	     * @private
	     */
	    getZoom: function(transform) {
	        return transform.zoom + Math.log(transform.tileSize / this.tileSize) / Math.LN2;
	    },
	
	    /**
	     * Return a zoom level that will cover all tiles in a given transform
	     * @param {Object} transform
	     * @returns {number} zoom level
	     * @private
	     */
	    coveringZoomLevel: function(transform) {
	        return (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
	    },
	
	    /**
	     * Given a transform, return all coordinates that could cover that
	     * transform for a covering zoom level.
	     * @param {Object} transform
	     * @returns {Array<Tile>} tiles
	     * @private
	     */
	    coveringTiles: function(transform) {
	        var z = this.coveringZoomLevel(transform);
	        var actualZ = z;
	
	        if (z < this.minzoom) return [];
	        if (z > this.maxzoom) z = this.maxzoom;
	
	        var tr = transform,
	            tileCenter = tr.locationCoordinate(tr.center)._zoomTo(z),
	            centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);
	
	        return TileCoord.cover(z, [
	            tr.pointCoordinate(new Point(0, 0))._zoomTo(z),
	            tr.pointCoordinate(new Point(tr.width, 0))._zoomTo(z),
	            tr.pointCoordinate(new Point(tr.width, tr.height))._zoomTo(z),
	            tr.pointCoordinate(new Point(0, tr.height))._zoomTo(z)
	        ], this.reparseOverscaled ? actualZ : z).sort(function(a, b) {
	            return centerPoint.dist(a) - centerPoint.dist(b);
	        });
	    },
	
	    /**
	     * Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
	     * adds found tiles to retain object; returns true if any child is found.
	     *
	     * @param {Coordinate} coord
	     * @param {number} maxCoveringZoom
	     * @param {boolean} retain
	     * @returns {boolean} whether the operation was complete
	     * @private
	     */
	    findLoadedChildren: function(coord, maxCoveringZoom, retain) {
	        var found = false;
	
	        for (var id in this._tiles) {
	            var tile = this._tiles[id];
	
	            // only consider loaded tiles on higher zoom levels (up to maxCoveringZoom)
	            if (retain[id] || !tile.loaded || tile.coord.z <= coord.z || tile.coord.z > maxCoveringZoom) continue;
	
	            // disregard tiles that are not descendants of the given tile coordinate
	            var z2 = Math.pow(2, Math.min(tile.coord.z, this.maxzoom) - Math.min(coord.z, this.maxzoom));
	            if (Math.floor(tile.coord.x / z2) !== coord.x ||
	                Math.floor(tile.coord.y / z2) !== coord.y)
	                continue;
	
	            // found loaded child
	            retain[id] = true;
	            found = true;
	
	            // loop through parents; retain the topmost loaded one if found
	            while (tile && tile.coord.z - 1 > coord.z) {
	                var parentId = tile.coord.parent(this.maxzoom).id;
	                tile = this._tiles[parentId];
	
	                if (tile && tile.loaded) {
	                    delete retain[id];
	                    retain[parentId] = true;
	                }
	            }
	        }
	        return found;
	    },
	
	    /**
	     * Find a loaded parent of the given tile (up to minCoveringZoom);
	     * adds the found tile to retain object and returns the tile if found
	     *
	     * @param {Coordinate} coord
	     * @param {number} minCoveringZoom
	     * @param {boolean} retain
	     * @returns {Tile} tile object
	     * @private
	     */
	    findLoadedParent: function(coord, minCoveringZoom, retain) {
	        for (var z = coord.z - 1; z >= minCoveringZoom; z--) {
	            coord = coord.parent(this.maxzoom);
	            var tile = this._tiles[coord.id];
	            if (tile && tile.loaded) {
	                retain[coord.id] = true;
	                return tile;
	            }
	            if (this._cache.has(coord.id)) {
	                this.addTile(coord);
	                retain[coord.id] = true;
	                return this._tiles[coord.id];
	            }
	        }
	    },
	
	    /**
	     * Resizes the tile cache based on the current viewport's size.
	     *
	     * Larger viewports use more tiles and need larger caches. Larger viewports
	     * are more likely to be found on devices with more memory and on pages where
	     * the map is more important.
	     *
	     * @private
	     */
	    updateCacheSize: function(transform) {
	        var widthInTiles = Math.ceil(transform.width / transform.tileSize) + 1;
	        var heightInTiles = Math.ceil(transform.height / transform.tileSize) + 1;
	        var approxTilesInView = widthInTiles * heightInTiles;
	        var commonZoomRange = 5;
	        this._cache.setMaxSize(Math.floor(approxTilesInView * commonZoomRange));
	    },
	
	    /**
	     * Removes tiles that are outside the viewport and adds new tiles that
	     * are inside the viewport.
	     * @private
	     */
	    update: function(used, transform, fadeDuration) {
	        var i;
	        var coord;
	        var tile;
	
	        this.updateCacheSize(transform);
	
	        // Determine the overzooming/underzooming amounts.
	        var zoom = (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
	        var minCoveringZoom = Math.max(zoom - TilePyramid.maxOverzooming, this.minzoom);
	        var maxCoveringZoom = Math.max(zoom + TilePyramid.maxUnderzooming,  this.minzoom);
	
	        // Retain is a list of tiles that we shouldn't delete, even if they are not
	        // the most ideal tile for the current viewport. This may include tiles like
	        // parent or child tiles that are *already* loaded.
	        var retain = {};
	        var now = new Date().getTime();
	
	        // Covered is a list of retained tiles who's areas are full covered by other,
	        // better, retained tiles. They are not drawn separately.
	        this._coveredTiles = {};
	
	        var required = used ? this.coveringTiles(transform) : [];
	        for (i = 0; i < required.length; i++) {
	            coord = required[i];
	            tile = this.addTile(coord);
	
	            retain[coord.id] = true;
	
	            if (tile.loaded)
	                continue;
	
	            // The tile we require is not yet loaded.
	            // Retain child or parent tiles that cover the same area.
	            if (!this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
	                this.findLoadedParent(coord, minCoveringZoom, retain);
	            }
	        }
	
	        var parentsForFading = {};
	
	        var ids = Object.keys(retain);
	        for (var k = 0; k < ids.length; k++) {
	            var id = ids[k];
	            coord = TileCoord.fromID(id);
	            tile = this._tiles[id];
	            if (tile && tile.timeAdded > now - (fadeDuration || 0)) {
	                // This tile is still fading in. Find tiles to cross-fade with it.
	                if (this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
	                    retain[id] = true;
	                }
	                this.findLoadedParent(coord, minCoveringZoom, parentsForFading);
	            }
	        }
	
	        var fadedParent;
	        for (fadedParent in parentsForFading) {
	            if (!retain[fadedParent]) {
	                // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.
	                this._coveredTiles[fadedParent] = true;
	            }
	        }
	        for (fadedParent in parentsForFading) {
	            retain[fadedParent] = true;
	        }
	
	        // Remove the tiles we don't need anymore.
	        var remove = util.keysDifference(this._tiles, retain);
	        for (i = 0; i < remove.length; i++) {
	            this.removeTile(+remove[i]);
	        }
	
	        this.transform = transform;
	    },
	
	    /**
	     * Add a tile, given its coordinate, to the pyramid.
	     * @param {Coordinate} coord
	     * @returns {Coordinate} the coordinate.
	     * @private
	     */
	    addTile: function(coord) {
	        var tile = this._tiles[coord.id];
	        if (tile)
	            return tile;
	
	        var wrapped = coord.wrapped();
	        tile = this._tiles[wrapped.id];
	
	        if (!tile) {
	            tile = this._cache.get(wrapped.id);
	            if (tile && this._redoPlacement) {
	                this._redoPlacement(tile);
	            }
	        }
	
	        if (!tile) {
	            var zoom = coord.z;
	            var overscaling = zoom > this.maxzoom ? Math.pow(2, zoom - this.maxzoom) : 1;
	            tile = new Tile(wrapped, this.tileSize * overscaling, this.maxzoom);
	            this._load(tile);
	        }
	
	        tile.uses++;
	        this._tiles[coord.id] = tile;
	        this._add(tile, coord);
	
	        return tile;
	    },
	
	    /**
	     * Remove a tile, given its id, from the pyramid
	     * @param {string|number} id tile id
	     * @returns {undefined} nothing
	     * @private
	     */
	    removeTile: function(id) {
	        var tile = this._tiles[id];
	        if (!tile)
	            return;
	
	        tile.uses--;
	        delete this._tiles[id];
	        this._remove(tile);
	
	        if (tile.uses > 0)
	            return;
	
	        if (tile.loaded) {
	            this._cache.add(tile.coord.wrapped().id, tile);
	        } else {
	            this._abort(tile);
	            this._unload(tile);
	        }
	    },
	
	    /**
	     * Remove all tiles from this pyramid
	     * @private
	     */
	    clearTiles: function() {
	        for (var id in this._tiles)
	            this.removeTile(id);
	        this._cache.reset();
	    },
	
	    /**
	     * Search through our current tiles and attempt to find the tiles that
	     * cover the given bounds.
	     * @param {Array<Coordinate>} queryGeometry coordinates of the corners of bounding rectangle
	     * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
	     * @private
	     */
	    tilesIn: function(queryGeometry) {
	        var tileResults = {};
	        var ids = this.orderedIDs();
	
	        var minX = Infinity;
	        var minY = Infinity;
	        var maxX = -Infinity;
	        var maxY = -Infinity;
	        var z = queryGeometry[0].zoom;
	
	        for (var k = 0; k < queryGeometry.length; k++) {
	            var p = queryGeometry[k];
	            minX = Math.min(minX, p.column);
	            minY = Math.min(minY, p.row);
	            maxX = Math.max(maxX, p.column);
	            maxY = Math.max(maxY, p.row);
	        }
	
	        for (var i = 0; i < ids.length; i++) {
	            var tile = this._tiles[ids[i]];
	            var coord = TileCoord.fromID(ids[i]);
	
	            var tileSpaceBounds = [
	                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(minX, minY, z)),
	                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(maxX, maxY, z))
	            ];
	
	            if (tileSpaceBounds[0].x < EXTENT && tileSpaceBounds[0].y < EXTENT &&
	                tileSpaceBounds[1].x >= 0 && tileSpaceBounds[1].y >= 0) {
	
	                var tileSpaceQueryGeometry = [];
	                for (var j = 0; j < queryGeometry.length; j++) {
	                    tileSpaceQueryGeometry.push(coordinateToTilePoint(coord, tile.sourceMaxZoom, queryGeometry[j]));
	                }
	
	                var tileResult = tileResults[tile.coord.id];
	                if (tileResult === undefined) {
	                    tileResult = tileResults[tile.coord.id] = {
	                        tile: tile,
	                        queryGeometry: [],
	                        scale: Math.pow(2, this.transform.zoom - tile.coord.z)
	                    };
	                }
	
	                // Wrapped tiles share one tileResult object but can have multiple queryGeometry parts
	                tileResult.queryGeometry.push(tileSpaceQueryGeometry);
	            }
	        }
	
	        var results = [];
	        for (var t in tileResults) {
	            results.push(tileResults[t]);
	        }
	        return results;
	    }
	};
	
	/**
	 * Convert a coordinate to a point in a tile's coordinate space.
	 * @param {Coordinate} tileCoord
	 * @param {Coordinate} coord
	 * @returns {Object} position
	 * @private
	 */
	function coordinateToTilePoint(tileCoord, sourceMaxZoom, coord) {
	    var zoomedCoord = coord.zoomTo(Math.min(tileCoord.z, sourceMaxZoom));
	    return {
	        x: (zoomedCoord.column - (tileCoord.x + tileCoord.w * Math.pow(2, tileCoord.z))) * EXTENT,
	        y: (zoomedCoord.row - tileCoord.y) * EXTENT
	    };
	
	}
	
	function compareKeyZoom(a, b) {
	    return (a % 32) - (b % 32);
	}


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var Bucket = __webpack_require__(157);
	var FeatureIndex = __webpack_require__(155);
	var vt = __webpack_require__(178);
	var Protobuf = __webpack_require__(142);
	var GeoJSONFeature = __webpack_require__(182);
	var featureFilter = __webpack_require__(158);
	var CollisionTile = __webpack_require__(184);
	var CollisionBoxArray = __webpack_require__(185);
	
	module.exports = Tile;
	
	/**
	 * A tile object is the combination of a Coordinate, which defines
	 * its place, as well as a unique ID and data tracking for its content
	 *
	 * @param {Coordinate} coord
	 * @param {number} size
	 * @private
	 */
	function Tile(coord, size, sourceMaxZoom) {
	    this.coord = coord;
	    this.uid = util.uniqueId();
	    this.loaded = false; // TODO rename loaded
	    this.isUnloaded = false;
	    this.uses = 0;
	    this.tileSize = size;
	    this.sourceMaxZoom = sourceMaxZoom;
	    this.buckets = {};
	}
	
	Tile.prototype = {
	
	    /**
	     * Given a data object with a 'buffers' property, load it into
	     * this tile's elementGroups and buffers properties and set loaded
	     * to true. If the data is null, like in the case of an empty
	     * GeoJSON tile, no-op but still set loaded to true.
	     * @param {Object} data
	     * @returns {undefined}
	     * @private
	     */
	    loadVectorData: function(data, style) {
	        this.loaded = true;
	
	        // empty GeoJSON tile
	        if (!data) return;
	
	        this.collisionBoxArray = new CollisionBoxArray(data.collisionBoxArray);
	        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
	        this.featureIndex = new FeatureIndex(data.featureIndex, data.rawTileData, this.collisionTile);
	        this.rawTileData = data.rawTileData;
	        this.buckets = unserializeBuckets(data.buckets, style);
	    },
	
	    /**
	     * given a data object and a GL painter, destroy and re-create
	     * all of its buffers.
	     * @param {Object} data
	     * @param {Object} painter
	     * @returns {undefined}
	     * @private
	     */
	    reloadSymbolData: function(data, painter, style) {
	        if (this.isUnloaded) return;
	
	        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
	        this.featureIndex.setCollisionTile(this.collisionTile);
	
	        // Destroy and delete existing symbol buckets
	        for (var id in this.buckets) {
	            var bucket = this.buckets[id];
	            if (bucket.type === 'symbol') {
	                bucket.destroy(painter.gl);
	                delete this.buckets[id];
	            }
	        }
	
	        // Add new symbol buckets
	        util.extend(this.buckets, unserializeBuckets(data.buckets, style));
	    },
	
	    /**
	     * Make sure that this tile doesn't own any data within a given
	     * painter, so that it doesn't consume any memory or maintain
	     * any references to the painter.
	     * @param {Object} painter gl painter object
	     * @returns {undefined}
	     * @private
	     */
	    unloadVectorData: function(painter) {
	        for (var id in this.buckets) {
	            var bucket = this.buckets[id];
	            bucket.destroy(painter.gl);
	        }
	
	        this.collisionBoxArray = null;
	        this.collisionTile = null;
	        this.featureIndex = null;
	        this.rawTileData = null;
	        this.buckets = null;
	        this.loaded = false;
	        this.isUnloaded = true;
	    },
	
	    redoPlacement: function(source) {
	        if (!this.loaded || this.redoingPlacement) {
	            this.redoWhenDone = true;
	            return;
	        }
	
	        this.redoingPlacement = true;
	
	        source.dispatcher.send('redo placement', {
	            uid: this.uid,
	            source: source.id,
	            angle: source.map.transform.angle,
	            pitch: source.map.transform.pitch,
	            showCollisionBoxes: source.map.showCollisionBoxes
	        }, done.bind(this), this.workerID);
	
	        function done(_, data) {
	            this.reloadSymbolData(data, source.map.painter, source.map.style);
	            source.fire('tile.load', {tile: this});
	
	            this.redoingPlacement = false;
	            if (this.redoWhenDone) {
	                this.redoPlacement(source);
	                this.redoWhenDone = false;
	            }
	        }
	    },
	
	    getBucket: function(layer) {
	        return this.buckets && this.buckets[layer.ref || layer.id];
	    },
	
	    querySourceFeatures: function(result, params) {
	        if (!this.rawTileData) return;
	
	        if (!this.vtLayers) {
	            this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
	        }
	
	        var layer = this.vtLayers._geojsonTileLayer || this.vtLayers[params.sourceLayer];
	
	        if (!layer) return;
	
	        var filter = featureFilter(params.filter);
	        var coord = { z: this.coord.z, x: this.coord.x, y: this.coord.y };
	
	        for (var i = 0; i < layer.length; i++) {
	            var feature = layer.feature(i);
	            if (filter(feature)) {
	                var geojsonFeature = new GeoJSONFeature(feature, this.coord.z, this.coord.x, this.coord.y);
	                geojsonFeature.tile = coord;
	                result.push(geojsonFeature);
	            }
	        }
	    }
	};
	
	function unserializeBuckets(input, style) {
	    var output = {};
	    for (var i = 0; i < input.length; i++) {
	        var bucket = Bucket.create(util.extend({
	            childLayers: input[i].childLayerIds.map(style.getLayer.bind(style)),
	            layer: style.getLayer(input[i].layerId)
	        }, input[i]));
	        output[bucket.id] = bucket;
	    }
	    return output;
	}


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assert = __webpack_require__(160);
	var Coordinate = __webpack_require__(84);
	
	module.exports = TileCoord;
	
	function TileCoord(z, x, y, w) {
	    assert(!isNaN(z) && z >= 0 && z % 1 === 0);
	    assert(!isNaN(x) && x >= 0 && x % 1 === 0);
	    assert(!isNaN(y) && y >= 0 && y % 1 === 0);
	
	    if (isNaN(w)) w = 0;
	
	    this.z = +z;
	    this.x = +x;
	    this.y = +y;
	    this.w = +w;
	
	    // calculate id
	    w *= 2;
	    if (w < 0) w = w * -1 - 1;
	    var dim = 1 << this.z;
	    this.id = ((dim * dim * w + dim * this.y + this.x) * 32) + this.z;
	
	    // for caching pos matrix calculation when rendering
	    this.posMatrix = null;
	}
	
	TileCoord.prototype.toString = function() {
	    return this.z + "/" + this.x + "/" + this.y;
	};
	
	TileCoord.prototype.toCoordinate = function() {
	    var zoom = this.z;
	    var tileScale = Math.pow(2, zoom);
	    var row = this.y;
	    var column = this.x + tileScale * this.w;
	    return new Coordinate(column, row, zoom);
	};
	
	// Parse a packed integer id into a TileCoord object
	TileCoord.fromID = function(id) {
	    var z = id % 32, dim = 1 << z;
	    var xy = ((id - z) / 32);
	    var x = xy % dim, y = ((xy - x) / dim) % dim;
	    var w = Math.floor(xy / (dim * dim));
	    if (w % 2 !== 0) w = w * -1 - 1;
	    w /= 2;
	    return new TileCoord(z, x, y, w);
	};
	
	// given a list of urls, choose a url template and return a tile URL
	TileCoord.prototype.url = function(urls, sourceMaxZoom) {
	    return urls[(this.x + this.y) % urls.length]
	        .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
	        .replace('{z}', Math.min(this.z, sourceMaxZoom || this.z))
	        .replace('{x}', this.x)
	        .replace('{y}', this.y);
	};
	
	// Return the coordinate of the parent tile
	TileCoord.prototype.parent = function(sourceMaxZoom) {
	    if (this.z === 0) return null;
	
	    // the id represents an overscaled tile, return the same coordinates with a lower z
	    if (this.z > sourceMaxZoom) {
	        return new TileCoord(this.z - 1, this.x, this.y, this.w);
	    }
	
	    return new TileCoord(this.z - 1, Math.floor(this.x / 2), Math.floor(this.y / 2), this.w);
	};
	
	TileCoord.prototype.wrapped = function() {
	    return new TileCoord(this.z, this.x, this.y, 0);
	};
	
	// Return the coordinates of the tile's children
	TileCoord.prototype.children = function(sourceMaxZoom) {
	
	    if (this.z >= sourceMaxZoom) {
	        // return a single tile coord representing a an overscaled tile
	        return [new TileCoord(this.z + 1, this.x, this.y, this.w)];
	    }
	
	    var z = this.z + 1;
	    var x = this.x * 2;
	    var y = this.y * 2;
	    return [
	        new TileCoord(z, x, y, this.w),
	        new TileCoord(z, x + 1, y, this.w),
	        new TileCoord(z, x, y + 1, this.w),
	        new TileCoord(z, x + 1, y + 1, this.w)
	    ];
	};
	
	// Taken from polymaps src/Layer.js
	// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383
	
	function edge(a, b) {
	    if (a.row > b.row) { var t = a; a = b; b = t; }
	    return {
	        x0: a.column,
	        y0: a.row,
	        x1: b.column,
	        y1: b.row,
	        dx: b.column - a.column,
	        dy: b.row - a.row
	    };
	}
	
	function scanSpans(e0, e1, ymin, ymax, scanLine) {
	    var y0 = Math.max(ymin, Math.floor(e1.y0));
	    var y1 = Math.min(ymax, Math.ceil(e1.y1));
	
	    // sort edges by x-coordinate
	    if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
	            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
	            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
	        var t = e0; e0 = e1; e1 = t;
	    }
	
	    // scan lines!
	    var m0 = e0.dx / e0.dy;
	    var m1 = e1.dx / e1.dy;
	    var d0 = e0.dx > 0; // use y + 1 to compute x0
	    var d1 = e1.dx < 0; // use y + 1 to compute x1
	    for (var y = y0; y < y1; y++) {
	        var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
	        var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
	        scanLine(Math.floor(x1), Math.ceil(x0), y);
	    }
	}
	
	function scanTriangle(a, b, c, ymin, ymax, scanLine) {
	    var ab = edge(a, b),
	        bc = edge(b, c),
	        ca = edge(c, a);
	
	    var t;
	
	    // sort edges by y-length
	    if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
	    if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
	    if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }
	
	    // scan span! scan span!
	    if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
	    if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
	}
	
	TileCoord.cover = function(z, bounds, actualZ) {
	    var tiles = 1 << z;
	    var t = {};
	
	    function scanLine(x0, x1, y) {
	        var x, wx, coord;
	        if (y >= 0 && y <= tiles) {
	            for (x = x0; x < x1; x++) {
	                wx = (x % tiles + tiles) % tiles;
	                coord = new TileCoord(actualZ, wx, y, Math.floor(x / tiles));
	                t[coord.id] = coord;
	            }
	        }
	    }
	
	    // Divide the screen up in two triangles and scan each of them:
	    // +---/
	    // | / |
	    // /---+
	    scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);
	    scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);
	
	    return Object.keys(t).map(function(id) {
	        return t[id];
	    });
	};


/***/ },
/* 210 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = LRUCache;
	
	/**
	 * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
	 * with hash lookup made possible by keeping a list of keys in parallel to
	 * an array of dictionary of values
	 *
	 * @param {number} max number of permitted values
	 * @param {Function} onRemove callback called with items when they expire
	 * @private
	 */
	function LRUCache(max, onRemove) {
	    this.max = max;
	    this.onRemove = onRemove;
	    this.reset();
	}
	
	/**
	 * Clear the cache
	 *
	 * @returns {LRUCache} this cache
	 * @private
	 */
	LRUCache.prototype.reset = function() {
	    for (var key in this.data) {
	        this.onRemove(this.data[key]);
	    }
	
	    this.data = {};
	    this.order = [];
	
	    return this;
	};
	
	/**
	 * Add a key, value combination to the cache, trimming its size if this pushes
	 * it over max length.
	 *
	 * @param {string} key lookup key for the item
	 * @param {*} data any value
	 *
	 * @returns {LRUCache} this cache
	 * @private
	 */
	LRUCache.prototype.add = function(key, data) {
	
	    if (this.has(key)) {
	        this.order.splice(this.order.indexOf(key), 1);
	        this.data[key] = data;
	        this.order.push(key);
	
	    } else {
	        this.data[key] = data;
	        this.order.push(key);
	
	        if (this.order.length > this.max) {
	            var removedData = this.get(this.order[0]);
	            if (removedData) this.onRemove(removedData);
	        }
	    }
	
	    return this;
	};
	
	/**
	 * Determine whether the value attached to `key` is present
	 *
	 * @param {string} key the key to be looked-up
	 * @returns {boolean} whether the cache has this value
	 * @private
	 */
	LRUCache.prototype.has = function(key) {
	    return key in this.data;
	};
	
	/**
	 * List all keys in the cache
	 *
	 * @returns {Array<string>} an array of keys in this cache.
	 * @private
	 */
	LRUCache.prototype.keys = function() {
	    return this.order;
	};
	
	/**
	 * Get the value attached to a specific key. If the key is not found,
	 * returns `null`
	 *
	 * @param {string} key the key to look up
	 * @returns {*} the data, or null if it isn't found
	 * @private
	 */
	LRUCache.prototype.get = function(key) {
	    if (!this.has(key)) { return null; }
	
	    var data = this.data[key];
	
	    delete this.data[key];
	    this.order.splice(this.order.indexOf(key), 1);
	
	    return data;
	};
	
	/**
	 * Change the max size of the cache.
	 *
	 * @param {number} max the max size of the cache
	 * @returns {LRUCache} this cache
	 * @private
	 */
	LRUCache.prototype.setMaxSize = function(max) {
	    this.max = max;
	
	    while (this.order.length > this.max) {
	        var removedData = this.get(this.order[0]);
	        if (removedData) this.onRemove(removedData);
	    }
	
	    return this;
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var Evented = __webpack_require__(86);
	var Source = __webpack_require__(206);
	var normalizeURL = __webpack_require__(136).normalizeTileURL;
	
	module.exports = VectorTileSource;
	
	function VectorTileSource(options) {
	    util.extend(this, util.pick(options, ['url', 'tileSize']));
	    this._options = util.extend({ type: 'vector' }, options);
	
	    if (this.tileSize !== 512) {
	        throw new Error('vector tile sources must have a tileSize of 512');
	    }
	
	    Source._loadTileJSON.call(this, options);
	}
	
	VectorTileSource.prototype = util.inherit(Evented, {
	    minzoom: 0,
	    maxzoom: 22,
	    tileSize: 512,
	    reparseOverscaled: true,
	    _loaded: false,
	    isTileClipped: true,
	
	    onAdd: function(map) {
	        this.map = map;
	    },
	
	    loaded: function() {
	        return this._pyramid && this._pyramid.loaded();
	    },
	
	    update: function(transform) {
	        if (this._pyramid) {
	            this._pyramid.update(this.used, transform);
	        }
	    },
	
	    reload: function() {
	        if (this._pyramid) {
	            this._pyramid.reload();
	        }
	    },
	
	    serialize: function() {
	        return util.extend({}, this._options);
	    },
	
	    getVisibleCoordinates: Source._getVisibleCoordinates,
	    getTile: Source._getTile,
	
	    queryRenderedFeatures: Source._queryRenderedVectorFeatures,
	    querySourceFeatures: Source._querySourceFeatures,
	
	    _loadTile: function(tile) {
	        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
	        var params = {
	            url: normalizeURL(tile.coord.url(this.tiles, this.maxzoom), this.url),
	            uid: tile.uid,
	            coord: tile.coord,
	            zoom: tile.coord.z,
	            tileSize: this.tileSize * overscaling,
	            source: this.id,
	            overscaling: overscaling,
	            angle: this.map.transform.angle,
	            pitch: this.map.transform.pitch,
	            showCollisionBoxes: this.map.showCollisionBoxes
	        };
	
	        if (tile.workerID) {
	            params.rawTileData = tile.rawTileData;
	            this.dispatcher.send('reload tile', params, this._tileLoaded.bind(this, tile), tile.workerID);
	        } else {
	            tile.workerID = this.dispatcher.send('load tile', params, this._tileLoaded.bind(this, tile));
	        }
	    },
	
	    _tileLoaded: function(tile, err, data) {
	        if (tile.aborted)
	            return;
	
	        if (err) {
	            tile.errored = true;
	            this.fire('tile.error', {tile: tile, error: err});
	            return;
	        }
	
	        tile.loadVectorData(data, this.map.style);
	
	        if (tile.redoWhenDone) {
	            tile.redoWhenDone = false;
	            tile.redoPlacement(this);
	        }
	
	        this.fire('tile.load', {tile: tile});
	        this.fire('tile.stats', data.bucketStats);
	    },
	
	    _abortTile: function(tile) {
	        tile.aborted = true;
	        this.dispatcher.send('abort tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
	    },
	
	    _addTile: function(tile) {
	        this.fire('tile.add', {tile: tile});
	    },
	
	    _removeTile: function(tile) {
	        this.fire('tile.remove', {tile: tile});
	    },
	
	    _unloadTile: function(tile) {
	        tile.unloadVectorData(this.map.painter);
	        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
	    },
	
	    redoPlacement: Source.redoPlacement,
	
	    _redoTilePlacement: function(tile) {
	        tile.redoPlacement(this);
	    }
	});


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var ajax = __webpack_require__(135);
	var Evented = __webpack_require__(86);
	var Source = __webpack_require__(206);
	var normalizeURL = __webpack_require__(136).normalizeTileURL;
	
	module.exports = RasterTileSource;
	
	function RasterTileSource(options) {
	    util.extend(this, util.pick(options, ['url', 'tileSize']));
	
	    Source._loadTileJSON.call(this, options);
	}
	
	RasterTileSource.prototype = util.inherit(Evented, {
	    minzoom: 0,
	    maxzoom: 22,
	    roundZoom: true,
	    tileSize: 512,
	    _loaded: false,
	
	    onAdd: function(map) {
	        this.map = map;
	    },
	
	    loaded: function() {
	        return this._pyramid && this._pyramid.loaded();
	    },
	
	    update: function(transform) {
	        if (this._pyramid) {
	            this._pyramid.update(this.used, transform, this.map.style.rasterFadeDuration);
	        }
	    },
	
	    reload: function() {
	        // noop
	    },
	
	    serialize: function() {
	        return {
	            type: 'raster',
	            url: this.url,
	            tileSize: this.tileSize
	        };
	    },
	
	    getVisibleCoordinates: Source._getVisibleCoordinates,
	    getTile: Source._getTile,
	
	    _loadTile: function(tile) {
	        var url = normalizeURL(tile.coord.url(this.tiles), this.url, this.tileSize);
	
	        tile.request = ajax.getImage(url, done.bind(this));
	
	        function done(err, img) {
	            delete tile.request;
	
	            if (tile.aborted)
	                return;
	
	            if (err) {
	                tile.errored = true;
	                this.fire('tile.error', {tile: tile, error: err});
	                return;
	            }
	
	            var gl = this.map.painter.gl;
	            tile.texture = this.map.painter.getTexture(img.width);
	            if (tile.texture) {
	                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
	                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
	            } else {
	                tile.texture = gl.createTexture();
	                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
	                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
	                tile.texture.size = img.width;
	            }
	            gl.generateMipmap(gl.TEXTURE_2D);
	
	            tile.timeAdded = new Date().getTime();
	            this.map.animationLoop.set(this.style.rasterFadeDuration);
	
	            tile.source = this;
	            tile.loaded = true;
	
	            this.fire('tile.load', {tile: tile});
	        }
	    },
	
	    _abortTile: function(tile) {
	        tile.aborted = true;
	
	        if (tile.request) {
	            tile.request.abort();
	            delete tile.request;
	        }
	    },
	
	    _addTile: function(tile) {
	        this.fire('tile.add', {tile: tile});
	    },
	
	    _removeTile: function(tile) {
	        this.fire('tile.remove', {tile: tile});
	    },
	
	    _unloadTile: function(tile) {
	        if (tile.texture) this.map.painter.saveTexture(tile.texture);
	    }
	});


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var Evented = __webpack_require__(86);
	var TilePyramid = __webpack_require__(207);
	var Source = __webpack_require__(206);
	var urlResolve = __webpack_require__(214);
	var EXTENT = __webpack_require__(157).EXTENT;
	
	module.exports = GeoJSONSource;
	
	/**
	 * Create a GeoJSON data source instance given an options object
	 * @class GeoJSONSource
	 * @param {Object} [options]
	 * @param {Object|string} options.data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
	 * @param {number} [options.maxzoom=18] Maximum zoom to preserve detail at.
	 * @param {number} [options.buffer] Tile buffer on each side in pixels.
	 * @param {number} [options.tolerance] Simplification tolerance (higher means simpler) in pixels.
	 * @param {number} [options.cluster] If the data is a collection of point features, setting this to true clusters the points by radius into groups.
	 * @param {number} [options.clusterRadius=50] Radius of each cluster when clustering points, in pixels.
	 * @param {number} [options.clusterMaxZoom] Max zoom to cluster points on. Defaults to one zoom less than `maxzoom` (so that last zoom features are not clustered).
	
	 * @example
	 * var sourceObj = new mapboxgl.GeoJSONSource({
	 *    data: {
	 *        "type": "FeatureCollection",
	 *        "features": [{
	 *            "type": "Feature",
	 *            "geometry": {
	 *                "type": "Point",
	 *                "coordinates": [
	 *                    -76.53063297271729,
	 *                    39.18174077994108
	 *                ]
	 *            }
	 *        }]
	 *    }
	 * });
	 * map.addSource('some id', sourceObj); // add
	 * map.removeSource('some id');  // remove
	 */
	function GeoJSONSource(options) {
	    options = options || {};
	
	    this._data = options.data;
	
	    if (options.maxzoom !== undefined) this.maxzoom = options.maxzoom;
	
	    var scale = EXTENT / this.tileSize;
	
	    this.geojsonVtOptions = {
	        buffer: (options.buffer !== undefined ? options.buffer : 128) * scale,
	        tolerance: (options.tolerance !== undefined ? options.tolerance : 0.375) * scale,
	        extent: EXTENT,
	        maxZoom: this.maxzoom
	    };
	
	    this.cluster = options.cluster || false;
	    this.superclusterOptions = {
	        maxZoom: Math.min(options.clusterMaxZoom, this.maxzoom - 1) || (this.maxzoom - 1),
	        extent: EXTENT,
	        radius: (options.clusterRadius || 50) * scale,
	        log: false
	    };
	
	    this._pyramid = new TilePyramid({
	        tileSize: this.tileSize,
	        minzoom: this.minzoom,
	        maxzoom: this.maxzoom,
	        reparseOverscaled: true,
	        load: this._loadTile.bind(this),
	        abort: this._abortTile.bind(this),
	        unload: this._unloadTile.bind(this),
	        add: this._addTile.bind(this),
	        remove: this._removeTile.bind(this),
	        redoPlacement: this._redoTilePlacement.bind(this)
	    });
	}
	
	GeoJSONSource.prototype = util.inherit(Evented, /** @lends GeoJSONSource.prototype */{
	    minzoom: 0,
	    maxzoom: 18,
	    tileSize: 512,
	    _dirty: true,
	    isTileClipped: true,
	
	    /**
	     * Update source geojson data and rerender map
	     *
	     * @param {Object|string} data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
	     * @returns {GeoJSONSource} this
	     */
	    setData: function(data) {
	        this._data = data;
	        this._dirty = true;
	
	        this.fire('change');
	
	        if (this.map)
	            this.update(this.map.transform);
	
	        return this;
	    },
	
	    onAdd: function(map) {
	        this.map = map;
	    },
	
	    loaded: function() {
	        return this._loaded && this._pyramid.loaded();
	    },
	
	    update: function(transform) {
	        if (this._dirty) {
	            this._updateData();
	        }
	
	        if (this._loaded) {
	            this._pyramid.update(this.used, transform);
	        }
	    },
	
	    reload: function() {
	        if (this._loaded) {
	            this._pyramid.reload();
	        }
	    },
	
	    serialize: function() {
	        return {
	            type: 'geojson',
	            data: this._data
	        };
	    },
	
	    getVisibleCoordinates: Source._getVisibleCoordinates,
	    getTile: Source._getTile,
	
	    queryRenderedFeatures: Source._queryRenderedVectorFeatures,
	    querySourceFeatures: Source._querySourceFeatures,
	
	    _updateData: function() {
	        this._dirty = false;
	        var options = {
	            tileSize: this.tileSize,
	            source: this.id,
	            geojsonVtOptions: this.geojsonVtOptions,
	            cluster: this.cluster,
	            superclusterOptions: this.superclusterOptions
	        };
	
	        var data = this._data;
	        if (typeof data === 'string') {
	            options.url = typeof window != 'undefined' ? urlResolve(window.location.href, data) : data;
	        } else {
	            options.data = JSON.stringify(data);
	        }
	        this.workerID = this.dispatcher.send('parse geojson', options, function(err) {
	            this._loaded = true;
	            if (err) {
	                this.fire('error', {error: err});
	            } else {
	                this._pyramid.reload();
	                this.fire('change');
	            }
	
	        }.bind(this));
	    },
	
	    _loadTile: function(tile) {
	        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
	        var params = {
	            uid: tile.uid,
	            coord: tile.coord,
	            zoom: tile.coord.z,
	            maxZoom: this.maxzoom,
	            tileSize: this.tileSize,
	            source: this.id,
	            overscaling: overscaling,
	            angle: this.map.transform.angle,
	            pitch: this.map.transform.pitch,
	            showCollisionBoxes: this.map.showCollisionBoxes
	        };
	
	        tile.workerID = this.dispatcher.send('load geojson tile', params, function(err, data) {
	
	            tile.unloadVectorData(this.map.painter);
	
	            if (tile.aborted)
	                return;
	
	            if (err) {
	                this.fire('tile.error', {tile: tile});
	                return;
	            }
	
	            tile.loadVectorData(data, this.map.style);
	
	            if (tile.redoWhenDone) {
	                tile.redoWhenDone = false;
	                tile.redoPlacement(this);
	            }
	
	            this.fire('tile.load', {tile: tile});
	
	        }.bind(this), this.workerID);
	    },
	
	    _abortTile: function(tile) {
	        tile.aborted = true;
	    },
	
	    _addTile: function(tile) {
	        this.fire('tile.add', {tile: tile});
	    },
	
	    _removeTile: function(tile) {
	        this.fire('tile.remove', {tile: tile});
	    },
	
	    _unloadTile: function(tile) {
	        tile.unloadVectorData(this.map.painter);
	        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
	    },
	
	    redoPlacement: Source.redoPlacement,
	
	    _redoTilePlacement: function(tile) {
	        tile.redoPlacement(this);
	    }
	});


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright 2014 Simon Lydell
	// X11 (MIT) Licensed. (See LICENSE.)
	
	void (function(root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  } else if (typeof exports === "object") {
	    module.exports = factory()
	  } else {
	    root.resolveUrl = factory()
	  }
	}(this, function() {
	
	  function resolveUrl(/* ...urls */) {
	    var numUrls = arguments.length
	
	    if (numUrls === 0) {
	      throw new Error("resolveUrl requires at least one argument; got none.")
	    }
	
	    var base = document.createElement("base")
	    base.href = arguments[0]
	
	    if (numUrls === 1) {
	      return base.href
	    }
	
	    var head = document.getElementsByTagName("head")[0]
	    head.insertBefore(base, head.firstChild)
	
	    var a = document.createElement("a")
	    var resolved
	
	    for (var index = 1; index < numUrls; index++) {
	      a.href = arguments[index]
	      resolved = a.href
	      base.href = resolved
	    }
	
	    head.removeChild(base)
	
	    return resolved
	  }
	
	  return resolveUrl
	
	}));


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var Tile = __webpack_require__(208);
	var TileCoord = __webpack_require__(209);
	var LngLat = __webpack_require__(216);
	var Point = __webpack_require__(88);
	var Evented = __webpack_require__(86);
	var ajax = __webpack_require__(135);
	var EXTENT = __webpack_require__(157).EXTENT;
	
	module.exports = VideoSource;
	
	/**
	 * Create a Video data source instance given an options object
	 * @class VideoSource
	 * @param {Object} [options]
	 * @param {Array<string>} options.urls An array of URLs to video files
	 * @param {Array} options.coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the video. Does not have to be a rectangle.
	 * @example
	 * var sourceObj = new mapboxgl.VideoSource({
	 *    url: [
	 *        'https://www.mapbox.com/videos/baltimore-smoke.mp4',
	 *        'https://www.mapbox.com/videos/baltimore-smoke.webm'
	 *    ],
	 *    coordinates: [
	 *        [-76.54335737228394, 39.18579907229748],
	 *        [-76.52803659439087, 39.1838364847587],
	 *        [-76.5295386314392, 39.17683392507606],
	 *        [-76.54520273208618, 39.17876344106642]
	 *    ]
	 * });
	 * map.addSource('some id', sourceObj); // add
	 * map.removeSource('some id');  // remove
	 */
	function VideoSource(options) {
	    this.urls = options.urls;
	    this.coordinates = options.coordinates;
	
	    ajax.getVideo(options.urls, function(err, video) {
	        // @TODO handle errors via event.
	        if (err) return;
	
	        this.video = video;
	        this.video.loop = true;
	
	        var loopID;
	
	        // start repainting when video starts playing
	        this.video.addEventListener('playing', function() {
	            loopID = this.map.style.animationLoop.set(Infinity);
	            this.map._rerender();
	        }.bind(this));
	
	        // stop repainting when video stops
	        this.video.addEventListener('pause', function() {
	            this.map.style.animationLoop.cancel(loopID);
	        }.bind(this));
	
	        this._loaded = true;
	
	        if (this.map) {
	            this.video.play();
	            this.setCoordinates(options.coordinates);
	        }
	    }.bind(this));
	}
	
	VideoSource.prototype = util.inherit(Evented, /** @lends VideoSource.prototype */{
	    roundZoom: true,
	
	    /**
	     * Return the HTML video element.
	     *
	     * @returns {Object}
	     */
	    getVideo: function() {
	        return this.video;
	    },
	
	    onAdd: function(map) {
	        this.map = map;
	        if (this.video) {
	            this.video.play();
	            this.setCoordinates(this.coordinates);
	        }
	    },
	
	    /**
	     * Update video coordinates and rerender map
	     *
	     * @param {Array} coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the video. Does not have to be a rectangle.
	     * @returns {VideoSource} this
	     */
	    setCoordinates: function(coordinates) {
	        this.coordinates = coordinates;
	
	        // Calculate which mercator tile is suitable for rendering the video in
	        // and create a buffer with the corner coordinates. These coordinates
	        // may be outside the tile, because raster tiles aren't clipped when rendering.
	
	        var map = this.map;
	        var cornerZ0Coords = coordinates.map(function(coord) {
	            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
	        });
	
	        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
	        centerCoord.column = Math.round(centerCoord.column);
	        centerCoord.row = Math.round(centerCoord.row);
	
	
	        var tileCoords = cornerZ0Coords.map(function(coord) {
	            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
	            return new Point(
	                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
	                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
	        });
	
	        var gl = map.painter.gl;
	        var maxInt16 = 32767;
	        var array = new Int16Array([
	            tileCoords[0].x, tileCoords[0].y, 0, 0,
	            tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
	            tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
	            tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
	        ]);
	
	        this.tile = new Tile(new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row));
	        this.tile.buckets = {};
	
	        this.tile.boundsBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
	
	        this.fire('change');
	
	        return this;
	    },
	
	    loaded: function() {
	        return this.video && this.video.readyState >= 2;
	    },
	
	    update: function() {
	        // noop
	    },
	
	    reload: function() {
	        // noop
	    },
	
	    prepare: function() {
	        if (!this._loaded) return;
	        if (this.video.readyState < 2) return; // not enough data for current position
	
	        var gl = this.map.painter.gl;
	        if (!this.tile.texture) {
	            this.tile.texture = gl.createTexture();
	            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
	        } else {
	            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
	        }
	
	        this._currentTime = this.video.currentTime;
	    },
	
	    getVisibleCoordinates: function() {
	        if (this.tile) return [this.tile.coord];
	        else return [];
	    },
	
	    getTile: function() {
	        return this.tile;
	    },
	
	    serialize: function() {
	        return {
	            type: 'video',
	            urls: this.urls,
	            coordinates: this.coordinates
	        };
	    }
	});


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = LngLat;
	
	var wrap = __webpack_require__(82).wrap;
	
	/**
	 * Create a longitude, latitude object from a given longitude and latitude pair in degrees.
	 * Mapbox GL uses Longitude, Latitude coordinate order to match GeoJSON.
	 *
	 * Note that any Mapbox GL method that accepts a `LngLat` object can also accept an
	 * `Array` and will perform an implicit conversion.  The following lines are equivalent:
	 ```
	 map.setCenter([-73.9749, 40.7736]);
	 map.setCenter( new mapboxgl.LngLat(-73.9749, 40.7736) );
	 ```
	 *
	 * @class LngLat
	 * @classdesc A representation of a longitude, latitude point, in degrees.
	 * @param {number} lng longitude
	 * @param {number} lat latitude
	 * @example
	 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
	 */
	function LngLat(lng, lat) {
	    if (isNaN(lng) || isNaN(lat)) {
	        throw new Error('Invalid LngLat object: (' + lng + ', ' + lat + ')');
	    }
	    this.lng = +lng;
	    this.lat = +lat;
	    if (this.lat > 90 || this.lat < -90) {
	        throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
	    }
	}
	
	/**
	 * Return a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
	 *
	 * @returns {LngLat} wrapped LngLat object
	 * @example
	 * var ll = new mapboxgl.LngLat(286.0251, 40.7736);
	 * var wrapped = ll.wrap();
	 * wrapped.lng; // = -73.9749
	 */
	LngLat.prototype.wrap = function () {
	    return new LngLat(wrap(this.lng, -180, 180), this.lat);
	};
	
	/**
	 * Return a `LngLat` as an array
	 *
	 * @returns {array} [lng, lat]
	 * @example
	 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
	 * ll.toArray(); // = [-73.9749, 40.7736]
	 */
	LngLat.prototype.toArray = function () {
	    return [this.lng, this.lat];
	};
	
	/**
	 * Return a `LngLat` as a string
	 *
	 * @returns {string} "LngLat(lng, lat)"
	 * @example
	 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
	 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
	 */
	LngLat.prototype.toString = function () {
	    return 'LngLat(' + this.lng + ', ' + this.lat + ')';
	};
	
	/**
	 * Convert an array to a `LngLat` object, or return an existing `LngLat` object
	 * unchanged.
	 *
	 * @param {Array<number>|LngLat} input `input` to convert
	 * @returns {LngLat} LngLat object or original input
	 * @example
	 * var arr = [-73.9749, 40.7736];
	 * var ll = mapboxgl.LngLat.convert(arr);
	 * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
	 */
	LngLat.convert = function (input) {
	    if (input instanceof LngLat) {
	        return input;
	    }
	    if (Array.isArray(input)) {
	        return new LngLat(input[0], input[1]);
	    }
	    return input;
	};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var Tile = __webpack_require__(208);
	var TileCoord = __webpack_require__(209);
	var LngLat = __webpack_require__(216);
	var Point = __webpack_require__(88);
	var Evented = __webpack_require__(86);
	var ajax = __webpack_require__(135);
	var EXTENT = __webpack_require__(157).EXTENT;
	
	module.exports = ImageSource;
	
	/**
	 * Create an Image source instance given an options object
	 * @class ImageSource
	 * @param {Object} [options]
	 * @param {string} options.url A string URL of an image file
	 * @param {Array} options.coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the image. Does not have to be a rectangle.
	 * @example
	 * var sourceObj = new mapboxgl.ImageSource({
	 *    url: 'https://www.mapbox.com/images/foo.png',
	 *    coordinates: [
	 *        [-76.54335737228394, 39.18579907229748],
	 *        [-76.52803659439087, 39.1838364847587],
	 *        [-76.5295386314392, 39.17683392507606],
	 *        [-76.54520273208618, 39.17876344106642]
	 *    ]
	 * });
	 * map.addSource('some id', sourceObj); // add
	 * map.removeSource('some id');  // remove
	 */
	function ImageSource(options) {
	    this.urls = options.urls;
	    this.coordinates = options.coordinates;
	
	    ajax.getImage(options.url, function(err, image) {
	        // @TODO handle errors via event.
	        if (err) return;
	
	        this.image = image;
	
	        this.image.addEventListener('load', function() {
	            this.map._rerender();
	        }.bind(this));
	
	        this._loaded = true;
	
	        if (this.map) {
	            this.setCoordinates(options.coordinates);
	        }
	    }.bind(this));
	}
	
	ImageSource.prototype = util.inherit(Evented, /** @lends ImageSource.prototype */ {
	    onAdd: function(map) {
	        this.map = map;
	        if (this.image) {
	            this.setCoordinates(this.coordinates);
	        }
	    },
	
	    /**
	     * Update image coordinates and rerender map
	     *
	     * @param {Array} coordinates Four geographical [lng, lat] coordinates in clockwise order defining the corners (starting with top left) of the image. Does not have to be a rectangle.
	     * @returns {ImageSource} this
	     */
	    setCoordinates: function(coordinates) {
	        this.coordinates = coordinates;
	
	        // Calculate which mercator tile is suitable for rendering the image in
	        // and create a buffer with the corner coordinates. These coordinates
	        // may be outside the tile, because raster tiles aren't clipped when rendering.
	
	        var map = this.map;
	        var cornerZ0Coords = coordinates.map(function(coord) {
	            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
	        });
	
	        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
	        centerCoord.column = Math.round(centerCoord.column);
	        centerCoord.row = Math.round(centerCoord.row);
	
	        var tileCoords = cornerZ0Coords.map(function(coord) {
	            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
	            return new Point(
	                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
	                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
	        });
	
	        var gl = map.painter.gl;
	        var maxInt16 = 32767;
	        var array = new Int16Array([
	            tileCoords[0].x, tileCoords[0].y, 0, 0,
	            tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
	            tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
	            tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
	        ]);
	
	        this.tile = new Tile(new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row));
	        this.tile.buckets = {};
	
	        this.tile.boundsBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
	
	        this.fire('change');
	
	        return this;
	    },
	
	    loaded: function() {
	        return this.image && this.image.complete;
	    },
	
	    update: function() {
	        // noop
	    },
	
	    reload: function() {
	        // noop
	    },
	
	    prepare: function() {
	        if (!this._loaded || !this.loaded()) return;
	
	        var painter = this.map.painter;
	        var gl = painter.gl;
	
	        if (!this.tile.texture) {
	            this.tile.texture = gl.createTexture();
	            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
	        } else {
	            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
	        }
	    },
	
	    getVisibleCoordinates: function() {
	        if (this.tile) return [this.tile.coord];
	        else return [];
	    },
	
	    getTile: function() {
	        return this.tile;
	    },
	
	    serialize: function() {
	        return {
	            type: 'image',
	            urls: this.urls,
	            coordinates: this.coordinates
	        };
	    }
	});


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var browser = __webpack_require__(85);
	var mat4 = __webpack_require__(219).mat4;
	var FrameHistory = __webpack_require__(229);
	var TilePyramid = __webpack_require__(207);
	var EXTENT = __webpack_require__(157).EXTENT;
	var pixelsToTileUnits = __webpack_require__(230);
	var util = __webpack_require__(82);
	
	module.exports = Painter;
	
	var glPolyfill = {
	    vertexAttrib2fv: function(attribute, values) {
	        this.vertexAttrib2f(attribute, values[0], values[1]);
	    },
	
	    vertexAttrib3fv: function(attribute, values) {
	        this.vertexAttrib3f(attribute, values[0], values[1], values[2]);
	    },
	
	    vertexAttrib4fv: function(attribute, values) {
	        this.vertexAttrib4f(attribute, values[0], values[1], values[2], values[3]);
	    }
	};
	
	/**
	 * Initialize a new painter object.
	 *
	 * @param {Canvas} gl an experimental-webgl drawing context
	 * @private
	 */
	function Painter(gl, transform) {
	    this.gl = util.extend(gl, glPolyfill);
	    this.transform = transform;
	
	    this.reusableTextures = {};
	    this.preFbos = {};
	
	    this.frameHistory = new FrameHistory();
	
	    this.setup();
	
	    // Within each layer there are multiple distinct z-planes that can be drawn to.
	    // This is implemented using the WebGL depth buffer.
	    this.numSublayers = TilePyramid.maxUnderzooming + TilePyramid.maxOverzooming + 1;
	    this.depthEpsilon = 1 / Math.pow(2, 16);
	
	    this.lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
	}
	
	util.extend(Painter.prototype, __webpack_require__(231));
	
	/*
	 * Update the GL viewport, projection matrix, and transforms to compensate
	 * for a new width and height value.
	 */
	Painter.prototype.resize = function(width, height) {
	    var gl = this.gl;
	
	    this.width = width * browser.devicePixelRatio;
	    this.height = height * browser.devicePixelRatio;
	    gl.viewport(0, 0, this.width, this.height);
	
	};
	
	
	Painter.prototype.setup = function() {
	    var gl = this.gl;
	
	    gl.verbose = true;
	
	    // We are blending the new pixels *behind* the existing pixels. That way we can
	    // draw front-to-back and use then stencil buffer to cull opaque pixels early.
	    gl.enable(gl.BLEND);
	    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	
	    gl.enable(gl.STENCIL_TEST);
	
	    gl.enable(gl.DEPTH_TEST);
	    gl.depthFunc(gl.LEQUAL);
	
	    this._depthMask = false;
	    gl.depthMask(false);
	
	    this.identityMatrix = mat4.create();
	
	    // The backgroundBuffer is used when drawing to the full *canvas*
	    this.backgroundBuffer = gl.createBuffer();
	    this.backgroundBuffer.itemSize = 2;
	    this.backgroundBuffer.itemCount = 4;
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
	
	    // The tileExtentBuffer is used when drawing to a full *tile*
	    this.tileExtentBuffer = gl.createBuffer();
	    this.tileExtentBuffer.itemSize = 4;
	    this.tileExtentBuffer.itemCount = 4;
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
	    gl.bufferData(
	        gl.ARRAY_BUFFER,
	        new Int16Array([
	            // tile coord x, tile coord y, texture coord x, texture coord y
	            0, 0, 0, 0,
	            EXTENT, 0, 32767, 0,
	            0, EXTENT, 0, 32767,
	            EXTENT, EXTENT,  32767, 32767
	        ]),
	        gl.STATIC_DRAW);
	
	    // The debugBuffer is used to draw tile outlines for debugging
	    this.debugBuffer = gl.createBuffer();
	    this.debugBuffer.itemSize = 2;
	    this.debugBuffer.itemCount = 5;
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
	    gl.bufferData(
	        gl.ARRAY_BUFFER,
	        new Int16Array([
	            0, 0, EXTENT, 0, EXTENT, EXTENT, 0, EXTENT, 0, 0]),
	        gl.STATIC_DRAW);
	
	    // The debugTextBuffer is used to draw tile IDs for debugging
	    this.debugTextBuffer = gl.createBuffer();
	    this.debugTextBuffer.itemSize = 2;
	};
	
	/*
	 * Reset the color buffers of the drawing canvas.
	 */
	Painter.prototype.clearColor = function() {
	    var gl = this.gl;
	    gl.clearColor(0, 0, 0, 0);
	    gl.clear(gl.COLOR_BUFFER_BIT);
	};
	
	/*
	 * Reset the drawing canvas by clearing the stencil buffer so that we can draw
	 * new tiles at the same location, while retaining previously drawn pixels.
	 */
	Painter.prototype.clearStencil = function() {
	    var gl = this.gl;
	    gl.clearStencil(0x0);
	    gl.stencilMask(0xFF);
	    gl.clear(gl.STENCIL_BUFFER_BIT);
	};
	
	Painter.prototype.clearDepth = function() {
	    var gl = this.gl;
	    gl.clearDepth(1);
	    this.depthMask(true);
	    gl.clear(gl.DEPTH_BUFFER_BIT);
	};
	
	Painter.prototype._renderTileClippingMasks = function(coords) {
	    var gl = this.gl;
	    gl.colorMask(false, false, false, false);
	    this.depthMask(false);
	    gl.disable(gl.DEPTH_TEST);
	    gl.enable(gl.STENCIL_TEST);
	
	    // Only write clipping IDs to the last 5 bits. The first three are used for drawing fills.
	    gl.stencilMask(0xF8);
	    // Tests will always pass, and ref value will be written to stencil buffer.
	    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
	
	    var idNext = 1;
	    this._tileClippingMaskIDs = {};
	    for (var i = 0; i < coords.length; i++) {
	        var coord = coords[i];
	        var id = this._tileClippingMaskIDs[coord.id] = (idNext++) << 3;
	
	        gl.stencilFunc(gl.ALWAYS, id, 0xF8);
	
	        var program = this.useProgram('fill');
	        this.setPosMatrix(coord.posMatrix);
	
	        // Draw the clipping mask
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
	        gl.vertexAttribPointer(program.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
	        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);
	    }
	
	    gl.stencilMask(0x00);
	    gl.colorMask(true, true, true, true);
	    this.depthMask(true);
	    gl.enable(gl.DEPTH_TEST);
	};
	
	Painter.prototype.enableTileClippingMask = function(coord) {
	    var gl = this.gl;
	    gl.stencilFunc(gl.EQUAL, this._tileClippingMaskIDs[coord.id], 0xF8);
	};
	
	// Overridden by headless tests.
	Painter.prototype.prepareBuffers = function() {};
	Painter.prototype.bindDefaultFramebuffer = function() {
	    var gl = this.gl;
	    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	};
	
	var draw = {
	    symbol: __webpack_require__(233),
	    circle: __webpack_require__(235),
	    line: __webpack_require__(236),
	    fill: __webpack_require__(237),
	    raster: __webpack_require__(238),
	    background: __webpack_require__(239),
	    debug: __webpack_require__(240)
	};
	
	Painter.prototype.render = function(style, options) {
	    this.style = style;
	    this.options = options;
	
	    this.lineAtlas = style.lineAtlas;
	
	    this.spriteAtlas = style.spriteAtlas;
	    this.spriteAtlas.setSprite(style.sprite);
	
	    this.glyphSource = style.glyphSource;
	
	    this.frameHistory.record(this.transform.zoom);
	
	    this.prepareBuffers();
	    this.clearColor();
	    this.clearDepth();
	
	    this.depthRange = (style._order.length + 2) * this.numSublayers * this.depthEpsilon;
	
	    this.renderPass({isOpaquePass: true});
	    this.renderPass({isOpaquePass: false});
	};
	
	Painter.prototype.renderPass = function(options) {
	    var groups = this.style._groups;
	    var isOpaquePass = options.isOpaquePass;
	    this.currentLayer = isOpaquePass ? this.style._order.length : -1;
	
	    for (var i = 0; i < groups.length; i++) {
	        var group = groups[isOpaquePass ? groups.length - 1 - i : i];
	        var source = this.style.sources[group.source];
	
	        var j;
	        var coords = [];
	        if (source) {
	            coords = source.getVisibleCoordinates();
	            for (j = 0; j < coords.length; j++) {
	                coords[j].posMatrix = this.transform.calculatePosMatrix(coords[j], source.maxzoom);
	            }
	            this.clearStencil();
	            if (source.prepare) source.prepare();
	            if (source.isTileClipped) {
	                this._renderTileClippingMasks(coords);
	            }
	        }
	
	        if (isOpaquePass) {
	            this.gl.disable(this.gl.BLEND);
	            this.isOpaquePass = true;
	        } else {
	            this.gl.enable(this.gl.BLEND);
	            this.isOpaquePass = false;
	            coords.reverse();
	        }
	
	        for (j = 0; j < group.length; j++) {
	            var layer = group[isOpaquePass ? group.length - 1 - j : j];
	            this.currentLayer += isOpaquePass ? -1 : 1;
	            this.renderLayer(this, source, layer, coords);
	        }
	
	        if (source) {
	            draw.debug(this, source, coords);
	        }
	    }
	};
	
	Painter.prototype.depthMask = function(mask) {
	    if (mask !== this._depthMask) {
	        this._depthMask = mask;
	        this.gl.depthMask(mask);
	    }
	};
	
	Painter.prototype.renderLayer = function(painter, source, layer, coords) {
	    if (layer.isHidden(this.transform.zoom)) return;
	    if (layer.type !== 'background' && !coords.length) return;
	    draw[layer.type](painter, source, layer, coords);
	};
	
	// Draws non-opaque areas. This is for debugging purposes.
	Painter.prototype.drawStencilBuffer = function() {
	    var gl = this.gl;
	    var program = this.useProgram('fill');
	    this.setPosMatrix(this.identityMatrix);
	
	    gl.stencilMask(0x00);
	    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
	
	    // Drw the filling quad where the stencil buffer isn't set.
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
	    gl.vertexAttribPointer(program.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
	
	    gl.uniform4fv(program.u_color, [0, 0, 0, 0.5]);
	    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);
	};
	
	Painter.prototype.setDepthSublayer = function(n) {
	    var farDepth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
	    var nearDepth = farDepth - 1 + this.depthRange;
	    this.gl.depthRange(nearDepth, farDepth);
	};
	
	Painter.prototype.translatePosMatrix = function(matrix, tile, translate, anchor) {
	    if (!translate[0] && !translate[1]) return matrix;
	
	    if (anchor === 'viewport') {
	        var sinA = Math.sin(-this.transform.angle);
	        var cosA = Math.cos(-this.transform.angle);
	        translate = [
	            translate[0] * cosA - translate[1] * sinA,
	            translate[0] * sinA + translate[1] * cosA
	        ];
	    }
	
	    var translation = [
	        pixelsToTileUnits(tile, translate[0], this.transform.zoom),
	        pixelsToTileUnits(tile, translate[1], this.transform.zoom),
	        0
	    ];
	
	    var translatedMatrix = new Float32Array(16);
	    mat4.translate(translatedMatrix, matrix, translation);
	    return translatedMatrix;
	};
	
	Painter.prototype.saveTexture = function(texture) {
	    var textures = this.reusableTextures[texture.size];
	    if (!textures) {
	        this.reusableTextures[texture.size] = [texture];
	    } else {
	        textures.push(texture);
	    }
	};
	
	
	Painter.prototype.getTexture = function(size) {
	    var textures = this.reusableTextures[size];
	    return textures && textures.length > 0 ? textures.pop() : null;
	};
	
	// Update the matrices if necessary. Note: This relies on object identity!
	// This means changing the matrix values without the actual matrix object
	// will FAIL to update the matrix properly.
	Painter.prototype.setPosMatrix = function(posMatrix) {
	    var program = this.currentProgram;
	    if (program.posMatrix !== posMatrix) {
	        this.gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);
	        program.posMatrix = posMatrix;
	    }
	};
	
	// Update the matrices if necessary. Note: This relies on object identity!
	// This means changing the matrix values without the actual matrix object
	// will FAIL to update the matrix properly.
	Painter.prototype.setExMatrix = function(exMatrix) {
	    var program = this.currentProgram;
	    if (exMatrix && program.exMatrix !== exMatrix && program.u_exmatrix) {
	        this.gl.uniformMatrix4fv(program.u_exmatrix, false, exMatrix);
	        program.exMatrix = exMatrix;
	    }
	};
	
	Painter.prototype.lineWidth = function(width) {
	    this.gl.lineWidth(util.clamp(width, this.lineWidthRange[0], this.lineWidthRange[1]));
	};


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview gl-matrix - High performance matrix and vector operations
	 * @author Brandon Jones
	 * @author Colin MacKenzie IV
	 * @version 2.3.2
	 */
	
	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	// END HEADER
	
	exports.glMatrix = __webpack_require__(220);
	exports.mat2 = __webpack_require__(221);
	exports.mat2d = __webpack_require__(222);
	exports.mat3 = __webpack_require__(223);
	exports.mat4 = __webpack_require__(224);
	exports.quat = __webpack_require__(225);
	exports.vec2 = __webpack_require__(228);
	exports.vec3 = __webpack_require__(226);
	exports.vec4 = __webpack_require__(227);

/***/ },
/* 220 */
/***/ function(module, exports) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	/**
	 * @class Common utilities
	 * @name glMatrix
	 */
	var glMatrix = {};
	
	// Configuration Constants
	glMatrix.EPSILON = 0.000001;
	glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	glMatrix.RANDOM = Math.random;
	glMatrix.ENABLE_SIMD = false;
	
	// Capability detection
	glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
	glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;
	
	/**
	 * Sets the type of array used when creating new vectors and matrices
	 *
	 * @param {Type} type Array type, such as Float32Array or Array
	 */
	glMatrix.setMatrixArrayType = function(type) {
	    glMatrix.ARRAY_TYPE = type;
	}
	
	var degree = Math.PI / 180;
	
	/**
	* Convert Degree To Radian
	*
	* @param {Number} Angle in Degrees
	*/
	glMatrix.toRadian = function(a){
	     return a * degree;
	}
	
	/**
	 * Tests whether or not the arguments have approximately the same value, within an absolute
	 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
	 * than or equal to 1.0, and a relative tolerance is used for larger values)
	 * 
	 * @param {Number} a The first number to test.
	 * @param {Number} b The second number to test.
	 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
	 */
	glMatrix.equals = function(a, b) {
		return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
	}
	
	module.exports = glMatrix;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	
	/**
	 * @class 2x2 Matrix
	 * @name mat2
	 */
	var mat2 = {};
	
	/**
	 * Creates a new identity mat2
	 *
	 * @returns {mat2} a new 2x2 matrix
	 */
	mat2.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};
	
	/**
	 * Creates a new mat2 initialized with values from an existing matrix
	 *
	 * @param {mat2} a matrix to clone
	 * @returns {mat2} a new 2x2 matrix
	 */
	mat2.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};
	
	/**
	 * Copy the values from one mat2 to another
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};
	
	/**
	 * Set a mat2 to the identity matrix
	 *
	 * @param {mat2} out the receiving matrix
	 * @returns {mat2} out
	 */
	mat2.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};
	
	/**
	 * Create a new mat2 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m10 Component in column 1, row 0 position (index 2)
	 * @param {Number} m11 Component in column 1, row 1 position (index 3)
	 * @returns {mat2} out A new 2x2 matrix
	 */
	mat2.fromValues = function(m00, m01, m10, m11) {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = m00;
	    out[1] = m01;
	    out[2] = m10;
	    out[3] = m11;
	    return out;
	};
	
	/**
	 * Set the components of a mat2 to the given values
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m10 Component in column 1, row 0 position (index 2)
	 * @param {Number} m11 Component in column 1, row 1 position (index 3)
	 * @returns {mat2} out
	 */
	mat2.set = function(out, m00, m01, m10, m11) {
	    out[0] = m00;
	    out[1] = m01;
	    out[2] = m10;
	    out[3] = m11;
	    return out;
	};
	
	
	/**
	 * Transpose the values of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a1 = a[1];
	        out[1] = a[2];
	        out[2] = a1;
	    } else {
	        out[0] = a[0];
	        out[1] = a[2];
	        out[2] = a[1];
	        out[3] = a[3];
	    }
	    
	    return out;
	};
	
	/**
	 * Inverts a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.invert = function(out, a) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	
	        // Calculate the determinant
	        det = a0 * a3 - a2 * a1;
	
	    if (!det) {
	        return null;
	    }
	    det = 1.0 / det;
	    
	    out[0] =  a3 * det;
	    out[1] = -a1 * det;
	    out[2] = -a2 * det;
	    out[3] =  a0 * det;
	
	    return out;
	};
	
	/**
	 * Calculates the adjugate of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	mat2.adjoint = function(out, a) {
	    // Caching this value is nessecary if out == a
	    var a0 = a[0];
	    out[0] =  a[3];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] =  a0;
	
	    return out;
	};
	
	/**
	 * Calculates the determinant of a mat2
	 *
	 * @param {mat2} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat2.determinant = function (a) {
	    return a[0] * a[3] - a[2] * a[1];
	};
	
	/**
	 * Multiplies two mat2's
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	mat2.multiply = function (out, a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    out[0] = a0 * b0 + a2 * b1;
	    out[1] = a1 * b0 + a3 * b1;
	    out[2] = a0 * b2 + a2 * b3;
	    out[3] = a1 * b2 + a3 * b3;
	    return out;
	};
	
	/**
	 * Alias for {@link mat2.multiply}
	 * @function
	 */
	mat2.mul = mat2.multiply;
	
	/**
	 * Rotates a mat2 by the given angle
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2} out
	 */
	mat2.rotate = function (out, a, rad) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = a0 *  c + a2 * s;
	    out[1] = a1 *  c + a3 * s;
	    out[2] = a0 * -s + a2 * c;
	    out[3] = a1 * -s + a3 * c;
	    return out;
	};
	
	/**
	 * Scales the mat2 by the dimensions in the given vec2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2} out
	 **/
	mat2.scale = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0 * v0;
	    out[1] = a1 * v0;
	    out[2] = a2 * v1;
	    out[3] = a3 * v1;
	    return out;
	};
	
	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2.identity(dest);
	 *     mat2.rotate(dest, dest, rad);
	 *
	 * @param {mat2} out mat2 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2} out
	 */
	mat2.fromRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = c;
	    out[1] = s;
	    out[2] = -s;
	    out[3] = c;
	    return out;
	}
	
	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2.identity(dest);
	 *     mat2.scale(dest, dest, vec);
	 *
	 * @param {mat2} out mat2 receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat2} out
	 */
	mat2.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = v[1];
	    return out;
	}
	
	/**
	 * Returns a string representation of a mat2
	 *
	 * @param {mat2} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat2.str = function (a) {
	    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};
	
	/**
	 * Returns Frobenius norm of a mat2
	 *
	 * @param {mat2} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat2.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
	};
	
	/**
	 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
	 * @param {mat2} L the lower triangular matrix 
	 * @param {mat2} D the diagonal matrix 
	 * @param {mat2} U the upper triangular matrix 
	 * @param {mat2} a the input matrix to factorize
	 */
	
	mat2.LDU = function (L, D, U, a) { 
	    L[2] = a[2]/a[0]; 
	    U[0] = a[0]; 
	    U[1] = a[1]; 
	    U[3] = a[3] - L[2] * U[1]; 
	    return [L, D, U];       
	}; 
	
	/**
	 * Adds two mat2's
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	mat2.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    return out;
	};
	
	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	mat2.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    return out;
	};
	
	/**
	 * Alias for {@link mat2.subtract}
	 * @function
	 */
	mat2.sub = mat2.subtract;
	
	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat2} a The first matrix.
	 * @param {mat2} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat2.exactEquals = function (a, b) {
	    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
	};
	
	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat2} a The first matrix.
	 * @param {mat2} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat2.equals = function (a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
	            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
	            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
	            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
	};
	
	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat2} out
	 */
	mat2.multiplyScalar = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    return out;
	};
	
	/**
	 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat2} out the receiving vector
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat2} out
	 */
	mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    return out;
	};
	
	module.exports = mat2;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	
	/**
	 * @class 2x3 Matrix
	 * @name mat2d
	 * 
	 * @description 
	 * A mat2d contains six elements defined as:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty]
	 * </pre>
	 * This is a short form for the 3x3 matrix:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty,
	 *  0, 0, 1]
	 * </pre>
	 * The last row is ignored so the array is shorter and operations are faster.
	 */
	var mat2d = {};
	
	/**
	 * Creates a new identity mat2d
	 *
	 * @returns {mat2d} a new 2x3 matrix
	 */
	mat2d.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(6);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	};
	
	/**
	 * Creates a new mat2d initialized with values from an existing matrix
	 *
	 * @param {mat2d} a matrix to clone
	 * @returns {mat2d} a new 2x3 matrix
	 */
	mat2d.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(6);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    return out;
	};
	
	/**
	 * Copy the values from one mat2d to another
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	mat2d.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    return out;
	};
	
	/**
	 * Set a mat2d to the identity matrix
	 *
	 * @param {mat2d} out the receiving matrix
	 * @returns {mat2d} out
	 */
	mat2d.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	};
	
	/**
	 * Create a new mat2d with the given values
	 *
	 * @param {Number} a Component A (index 0)
	 * @param {Number} b Component B (index 1)
	 * @param {Number} c Component C (index 2)
	 * @param {Number} d Component D (index 3)
	 * @param {Number} tx Component TX (index 4)
	 * @param {Number} ty Component TY (index 5)
	 * @returns {mat2d} A new mat2d
	 */
	mat2d.fromValues = function(a, b, c, d, tx, ty) {
	    var out = new glMatrix.ARRAY_TYPE(6);
	    out[0] = a;
	    out[1] = b;
	    out[2] = c;
	    out[3] = d;
	    out[4] = tx;
	    out[5] = ty;
	    return out;
	};
	
	/**
	 * Set the components of a mat2d to the given values
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {Number} a Component A (index 0)
	 * @param {Number} b Component B (index 1)
	 * @param {Number} c Component C (index 2)
	 * @param {Number} d Component D (index 3)
	 * @param {Number} tx Component TX (index 4)
	 * @param {Number} ty Component TY (index 5)
	 * @returns {mat2d} out
	 */
	mat2d.set = function(out, a, b, c, d, tx, ty) {
	    out[0] = a;
	    out[1] = b;
	    out[2] = c;
	    out[3] = d;
	    out[4] = tx;
	    out[5] = ty;
	    return out;
	};
	
	/**
	 * Inverts a mat2d
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	mat2d.invert = function(out, a) {
	    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
	        atx = a[4], aty = a[5];
	
	    var det = aa * ad - ab * ac;
	    if(!det){
	        return null;
	    }
	    det = 1.0 / det;
	
	    out[0] = ad * det;
	    out[1] = -ab * det;
	    out[2] = -ac * det;
	    out[3] = aa * det;
	    out[4] = (ac * aty - ad * atx) * det;
	    out[5] = (ab * atx - aa * aty) * det;
	    return out;
	};
	
	/**
	 * Calculates the determinant of a mat2d
	 *
	 * @param {mat2d} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat2d.determinant = function (a) {
	    return a[0] * a[3] - a[1] * a[2];
	};
	
	/**
	 * Multiplies two mat2d's
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	mat2d.multiply = function (out, a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
	    out[0] = a0 * b0 + a2 * b1;
	    out[1] = a1 * b0 + a3 * b1;
	    out[2] = a0 * b2 + a2 * b3;
	    out[3] = a1 * b2 + a3 * b3;
	    out[4] = a0 * b4 + a2 * b5 + a4;
	    out[5] = a1 * b4 + a3 * b5 + a5;
	    return out;
	};
	
	/**
	 * Alias for {@link mat2d.multiply}
	 * @function
	 */
	mat2d.mul = mat2d.multiply;
	
	/**
	 * Rotates a mat2d by the given angle
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2d} out
	 */
	mat2d.rotate = function (out, a, rad) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        s = Math.sin(rad),
	        c = Math.cos(rad);
	    out[0] = a0 *  c + a2 * s;
	    out[1] = a1 *  c + a3 * s;
	    out[2] = a0 * -s + a2 * c;
	    out[3] = a1 * -s + a3 * c;
	    out[4] = a4;
	    out[5] = a5;
	    return out;
	};
	
	/**
	 * Scales the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2d} out
	 **/
	mat2d.scale = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0 * v0;
	    out[1] = a1 * v0;
	    out[2] = a2 * v1;
	    out[3] = a3 * v1;
	    out[4] = a4;
	    out[5] = a5;
	    return out;
	};
	
	/**
	 * Translates the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to translate the matrix by
	 * @returns {mat2d} out
	 **/
	mat2d.translate = function(out, a, v) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
	        v0 = v[0], v1 = v[1];
	    out[0] = a0;
	    out[1] = a1;
	    out[2] = a2;
	    out[3] = a3;
	    out[4] = a0 * v0 + a2 * v1 + a4;
	    out[5] = a1 * v0 + a3 * v1 + a5;
	    return out;
	};
	
	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.rotate(dest, dest, rad);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2d} out
	 */
	mat2d.fromRotation = function(out, rad) {
	    var s = Math.sin(rad), c = Math.cos(rad);
	    out[0] = c;
	    out[1] = s;
	    out[2] = -s;
	    out[3] = c;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	}
	
	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.scale(dest, dest, vec);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat2d} out
	 */
	mat2d.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = v[1];
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	}
	
	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.translate(dest, dest, vec);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {vec2} v Translation vector
	 * @returns {mat2d} out
	 */
	mat2d.fromTranslation = function(out, v) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = v[0];
	    out[5] = v[1];
	    return out;
	}
	
	/**
	 * Returns a string representation of a mat2d
	 *
	 * @param {mat2d} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat2d.str = function (a) {
	    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
	                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
	};
	
	/**
	 * Returns Frobenius norm of a mat2d
	 *
	 * @param {mat2d} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat2d.frob = function (a) { 
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
	}; 
	
	/**
	 * Adds two mat2d's
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	mat2d.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    out[4] = a[4] + b[4];
	    out[5] = a[5] + b[5];
	    return out;
	};
	
	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	mat2d.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    out[4] = a[4] - b[4];
	    out[5] = a[5] - b[5];
	    return out;
	};
	
	/**
	 * Alias for {@link mat2d.subtract}
	 * @function
	 */
	mat2d.sub = mat2d.subtract;
	
	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat2d} out
	 */
	mat2d.multiplyScalar = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    out[4] = a[4] * b;
	    out[5] = a[5] * b;
	    return out;
	};
	
	/**
	 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat2d} out the receiving vector
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat2d} out
	 */
	mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    out[4] = a[4] + (b[4] * scale);
	    out[5] = a[5] + (b[5] * scale);
	    return out;
	};
	
	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat2d} a The first matrix.
	 * @param {mat2d} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat2d.exactEquals = function (a, b) {
	    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
	};
	
	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat2d} a The first matrix.
	 * @param {mat2d} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat2d.equals = function (a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
	    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
	            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
	            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
	            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
	            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
	            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
	};
	
	module.exports = mat2d;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	
	/**
	 * @class 3x3 Matrix
	 * @name mat3
	 */
	var mat3 = {};
	
	/**
	 * Creates a new identity mat3
	 *
	 * @returns {mat3} a new 3x3 matrix
	 */
	mat3.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(9);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};
	
	/**
	 * Copies the upper-left 3x3 values into the given mat3.
	 *
	 * @param {mat3} out the receiving 3x3 matrix
	 * @param {mat4} a   the source 4x4 matrix
	 * @returns {mat3} out
	 */
	mat3.fromMat4 = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[4];
	    out[4] = a[5];
	    out[5] = a[6];
	    out[6] = a[8];
	    out[7] = a[9];
	    out[8] = a[10];
	    return out;
	};
	
	/**
	 * Creates a new mat3 initialized with values from an existing matrix
	 *
	 * @param {mat3} a matrix to clone
	 * @returns {mat3} a new 3x3 matrix
	 */
	mat3.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(9);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};
	
	/**
	 * Copy the values from one mat3 to another
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};
	
	/**
	 * Create a new mat3 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m10 Component in column 1, row 0 position (index 3)
	 * @param {Number} m11 Component in column 1, row 1 position (index 4)
	 * @param {Number} m12 Component in column 1, row 2 position (index 5)
	 * @param {Number} m20 Component in column 2, row 0 position (index 6)
	 * @param {Number} m21 Component in column 2, row 1 position (index 7)
	 * @param {Number} m22 Component in column 2, row 2 position (index 8)
	 * @returns {mat3} A new mat3
	 */
	mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
	    var out = new glMatrix.ARRAY_TYPE(9);
	    out[0] = m00;
	    out[1] = m01;
	    out[2] = m02;
	    out[3] = m10;
	    out[4] = m11;
	    out[5] = m12;
	    out[6] = m20;
	    out[7] = m21;
	    out[8] = m22;
	    return out;
	};
	
	/**
	 * Set the components of a mat3 to the given values
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m10 Component in column 1, row 0 position (index 3)
	 * @param {Number} m11 Component in column 1, row 1 position (index 4)
	 * @param {Number} m12 Component in column 1, row 2 position (index 5)
	 * @param {Number} m20 Component in column 2, row 0 position (index 6)
	 * @param {Number} m21 Component in column 2, row 1 position (index 7)
	 * @param {Number} m22 Component in column 2, row 2 position (index 8)
	 * @returns {mat3} out
	 */
	mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
	    out[0] = m00;
	    out[1] = m01;
	    out[2] = m02;
	    out[3] = m10;
	    out[4] = m11;
	    out[5] = m12;
	    out[6] = m20;
	    out[7] = m21;
	    out[8] = m22;
	    return out;
	};
	
	/**
	 * Set a mat3 to the identity matrix
	 *
	 * @param {mat3} out the receiving matrix
	 * @returns {mat3} out
	 */
	mat3.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};
	
	/**
	 * Transpose the values of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a12 = a[5];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a01;
	        out[5] = a[7];
	        out[6] = a02;
	        out[7] = a12;
	    } else {
	        out[0] = a[0];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a[1];
	        out[4] = a[4];
	        out[5] = a[7];
	        out[6] = a[2];
	        out[7] = a[5];
	        out[8] = a[8];
	    }
	    
	    return out;
	};
	
	/**
	 * Inverts a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],
	
	        b01 = a22 * a11 - a12 * a21,
	        b11 = -a22 * a10 + a12 * a20,
	        b21 = a21 * a10 - a11 * a20,
	
	        // Calculate the determinant
	        det = a00 * b01 + a01 * b11 + a02 * b21;
	
	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;
	
	    out[0] = b01 * det;
	    out[1] = (-a22 * a01 + a02 * a21) * det;
	    out[2] = (a12 * a01 - a02 * a11) * det;
	    out[3] = b11 * det;
	    out[4] = (a22 * a00 - a02 * a20) * det;
	    out[5] = (-a12 * a00 + a02 * a10) * det;
	    out[6] = b21 * det;
	    out[7] = (-a21 * a00 + a01 * a20) * det;
	    out[8] = (a11 * a00 - a01 * a10) * det;
	    return out;
	};
	
	/**
	 * Calculates the adjugate of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	mat3.adjoint = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];
	
	    out[0] = (a11 * a22 - a12 * a21);
	    out[1] = (a02 * a21 - a01 * a22);
	    out[2] = (a01 * a12 - a02 * a11);
	    out[3] = (a12 * a20 - a10 * a22);
	    out[4] = (a00 * a22 - a02 * a20);
	    out[5] = (a02 * a10 - a00 * a12);
	    out[6] = (a10 * a21 - a11 * a20);
	    out[7] = (a01 * a20 - a00 * a21);
	    out[8] = (a00 * a11 - a01 * a10);
	    return out;
	};
	
	/**
	 * Calculates the determinant of a mat3
	 *
	 * @param {mat3} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat3.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];
	
	    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
	};
	
	/**
	 * Multiplies two mat3's
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	mat3.multiply = function (out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],
	
	        b00 = b[0], b01 = b[1], b02 = b[2],
	        b10 = b[3], b11 = b[4], b12 = b[5],
	        b20 = b[6], b21 = b[7], b22 = b[8];
	
	    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
	    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
	    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
	
	    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
	    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
	    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
	
	    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
	    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
	    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
	    return out;
	};
	
	/**
	 * Alias for {@link mat3.multiply}
	 * @function
	 */
	mat3.mul = mat3.multiply;
	
	/**
	 * Translate a mat3 by the given vector
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to translate
	 * @param {vec2} v vector to translate by
	 * @returns {mat3} out
	 */
	mat3.translate = function(out, a, v) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],
	        x = v[0], y = v[1];
	
	    out[0] = a00;
	    out[1] = a01;
	    out[2] = a02;
	
	    out[3] = a10;
	    out[4] = a11;
	    out[5] = a12;
	
	    out[6] = x * a00 + y * a10 + a20;
	    out[7] = x * a01 + y * a11 + a21;
	    out[8] = x * a02 + y * a12 + a22;
	    return out;
	};
	
	/**
	 * Rotates a mat3 by the given angle
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat3} out
	 */
	mat3.rotate = function (out, a, rad) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],
	
	        s = Math.sin(rad),
	        c = Math.cos(rad);
	
	    out[0] = c * a00 + s * a10;
	    out[1] = c * a01 + s * a11;
	    out[2] = c * a02 + s * a12;
	
	    out[3] = c * a10 - s * a00;
	    out[4] = c * a11 - s * a01;
	    out[5] = c * a12 - s * a02;
	
	    out[6] = a20;
	    out[7] = a21;
	    out[8] = a22;
	    return out;
	};
	
	/**
	 * Scales the mat3 by the dimensions in the given vec2
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat3} out
	 **/
	mat3.scale = function(out, a, v) {
	    var x = v[0], y = v[1];
	
	    out[0] = x * a[0];
	    out[1] = x * a[1];
	    out[2] = x * a[2];
	
	    out[3] = y * a[3];
	    out[4] = y * a[4];
	    out[5] = y * a[5];
	
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};
	
	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.translate(dest, dest, vec);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {vec2} v Translation vector
	 * @returns {mat3} out
	 */
	mat3.fromTranslation = function(out, v) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = v[0];
	    out[7] = v[1];
	    out[8] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.rotate(dest, dest, rad);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat3} out
	 */
	mat3.fromRotation = function(out, rad) {
	    var s = Math.sin(rad), c = Math.cos(rad);
	
	    out[0] = c;
	    out[1] = s;
	    out[2] = 0;
	
	    out[3] = -s;
	    out[4] = c;
	    out[5] = 0;
	
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.scale(dest, dest, vec);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat3} out
	 */
	mat3.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	
	    out[3] = 0;
	    out[4] = v[1];
	    out[5] = 0;
	
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	}
	
	/**
	 * Copies the values from a mat2d into a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat2d} a the matrix to copy
	 * @returns {mat3} out
	 **/
	mat3.fromMat2d = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = 0;
	
	    out[3] = a[2];
	    out[4] = a[3];
	    out[5] = 0;
	
	    out[6] = a[4];
	    out[7] = a[5];
	    out[8] = 1;
	    return out;
	};
	
	/**
	* Calculates a 3x3 matrix from the given quaternion
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {quat} q Quaternion to create matrix from
	*
	* @returns {mat3} out
	*/
	mat3.fromQuat = function (out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,
	
	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;
	
	    out[0] = 1 - yy - zz;
	    out[3] = yx - wz;
	    out[6] = zx + wy;
	
	    out[1] = yx + wz;
	    out[4] = 1 - xx - zz;
	    out[7] = zy - wx;
	
	    out[2] = zx - wy;
	    out[5] = zy + wx;
	    out[8] = 1 - xx - yy;
	
	    return out;
	};
	
	/**
	* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {mat4} a Mat4 to derive the normal matrix from
	*
	* @returns {mat3} out
	*/
	mat3.normalFromMat4 = function (out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],
	
	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,
	
	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	
	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;
	
	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	
	    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	
	    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	
	    return out;
	};
	
	/**
	 * Returns a string representation of a mat3
	 *
	 * @param {mat3} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat3.str = function (a) {
	    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
	                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
	                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
	};
	
	/**
	 * Returns Frobenius norm of a mat3
	 *
	 * @param {mat3} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat3.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
	};
	
	/**
	 * Adds two mat3's
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	mat3.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    out[4] = a[4] + b[4];
	    out[5] = a[5] + b[5];
	    out[6] = a[6] + b[6];
	    out[7] = a[7] + b[7];
	    out[8] = a[8] + b[8];
	    return out;
	};
	
	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	mat3.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    out[4] = a[4] - b[4];
	    out[5] = a[5] - b[5];
	    out[6] = a[6] - b[6];
	    out[7] = a[7] - b[7];
	    out[8] = a[8] - b[8];
	    return out;
	};
	
	/**
	 * Alias for {@link mat3.subtract}
	 * @function
	 */
	mat3.sub = mat3.subtract;
	
	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat3} out
	 */
	mat3.multiplyScalar = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    out[4] = a[4] * b;
	    out[5] = a[5] * b;
	    out[6] = a[6] * b;
	    out[7] = a[7] * b;
	    out[8] = a[8] * b;
	    return out;
	};
	
	/**
	 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat3} out the receiving vector
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat3} out
	 */
	mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    out[4] = a[4] + (b[4] * scale);
	    out[5] = a[5] + (b[5] * scale);
	    out[6] = a[6] + (b[6] * scale);
	    out[7] = a[7] + (b[7] * scale);
	    out[8] = a[8] + (b[8] * scale);
	    return out;
	};
	
	/*
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat3} a The first matrix.
	 * @param {mat3} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat3.exactEquals = function (a, b) {
	    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
	           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
	           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
	};
	
	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat3} a The first matrix.
	 * @param {mat3} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat3.equals = function (a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
	    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
	            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
	            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
	            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
	            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
	            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
	            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
	            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
	            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
	};
	
	
	module.exports = mat3;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	
	/**
	 * @class 4x4 Matrix
	 * @name mat4
	 */
	var mat4 = {
	  scalar: {},
	  SIMD: {},
	};
	
	/**
	 * Creates a new identity mat4
	 *
	 * @returns {mat4} a new 4x4 matrix
	 */
	mat4.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(16);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};
	
	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {mat4} a matrix to clone
	 * @returns {mat4} a new 4x4 matrix
	 */
	mat4.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(16);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};
	
	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};
	
	/**
	 * Create a new mat4 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m03 Component in column 0, row 3 position (index 3)
	 * @param {Number} m10 Component in column 1, row 0 position (index 4)
	 * @param {Number} m11 Component in column 1, row 1 position (index 5)
	 * @param {Number} m12 Component in column 1, row 2 position (index 6)
	 * @param {Number} m13 Component in column 1, row 3 position (index 7)
	 * @param {Number} m20 Component in column 2, row 0 position (index 8)
	 * @param {Number} m21 Component in column 2, row 1 position (index 9)
	 * @param {Number} m22 Component in column 2, row 2 position (index 10)
	 * @param {Number} m23 Component in column 2, row 3 position (index 11)
	 * @param {Number} m30 Component in column 3, row 0 position (index 12)
	 * @param {Number} m31 Component in column 3, row 1 position (index 13)
	 * @param {Number} m32 Component in column 3, row 2 position (index 14)
	 * @param {Number} m33 Component in column 3, row 3 position (index 15)
	 * @returns {mat4} A new mat4
	 */
	mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	    var out = new glMatrix.ARRAY_TYPE(16);
	    out[0] = m00;
	    out[1] = m01;
	    out[2] = m02;
	    out[3] = m03;
	    out[4] = m10;
	    out[5] = m11;
	    out[6] = m12;
	    out[7] = m13;
	    out[8] = m20;
	    out[9] = m21;
	    out[10] = m22;
	    out[11] = m23;
	    out[12] = m30;
	    out[13] = m31;
	    out[14] = m32;
	    out[15] = m33;
	    return out;
	};
	
	/**
	 * Set the components of a mat4 to the given values
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m03 Component in column 0, row 3 position (index 3)
	 * @param {Number} m10 Component in column 1, row 0 position (index 4)
	 * @param {Number} m11 Component in column 1, row 1 position (index 5)
	 * @param {Number} m12 Component in column 1, row 2 position (index 6)
	 * @param {Number} m13 Component in column 1, row 3 position (index 7)
	 * @param {Number} m20 Component in column 2, row 0 position (index 8)
	 * @param {Number} m21 Component in column 2, row 1 position (index 9)
	 * @param {Number} m22 Component in column 2, row 2 position (index 10)
	 * @param {Number} m23 Component in column 2, row 3 position (index 11)
	 * @param {Number} m30 Component in column 3, row 0 position (index 12)
	 * @param {Number} m31 Component in column 3, row 1 position (index 13)
	 * @param {Number} m32 Component in column 3, row 2 position (index 14)
	 * @param {Number} m33 Component in column 3, row 3 position (index 15)
	 * @returns {mat4} out
	 */
	mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	    out[0] = m00;
	    out[1] = m01;
	    out[2] = m02;
	    out[3] = m03;
	    out[4] = m10;
	    out[5] = m11;
	    out[6] = m12;
	    out[7] = m13;
	    out[8] = m20;
	    out[9] = m21;
	    out[10] = m22;
	    out[11] = m23;
	    out[12] = m30;
	    out[13] = m31;
	    out[14] = m32;
	    out[15] = m33;
	    return out;
	};
	
	
	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */
	mat4.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};
	
	/**
	 * Transpose the values of a mat4 not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.scalar.transpose = function(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a03 = a[3],
	            a12 = a[6], a13 = a[7],
	            a23 = a[11];
	
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a01;
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a02;
	        out[9] = a12;
	        out[11] = a[14];
	        out[12] = a03;
	        out[13] = a13;
	        out[14] = a23;
	    } else {
	        out[0] = a[0];
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a[1];
	        out[5] = a[5];
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a[2];
	        out[9] = a[6];
	        out[10] = a[10];
	        out[11] = a[14];
	        out[12] = a[3];
	        out[13] = a[7];
	        out[14] = a[11];
	        out[15] = a[15];
	    }
	
	    return out;
	};
	
	/**
	 * Transpose the values of a mat4 using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.SIMD.transpose = function(out, a) {
	    var a0, a1, a2, a3,
	        tmp01, tmp23,
	        out0, out1, out2, out3;
	
	    a0 = SIMD.Float32x4.load(a, 0);
	    a1 = SIMD.Float32x4.load(a, 4);
	    a2 = SIMD.Float32x4.load(a, 8);
	    a3 = SIMD.Float32x4.load(a, 12);
	
	    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
	    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
	    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
	    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
	    SIMD.Float32x4.store(out, 0,  out0);
	    SIMD.Float32x4.store(out, 4,  out1);
	
	    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
	    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
	    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
	    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
	    SIMD.Float32x4.store(out, 8,  out2);
	    SIMD.Float32x4.store(out, 12, out3);
	
	    return out;
	};
	
	/**
	 * Transpse a mat4 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;
	
	/**
	 * Inverts a mat4 not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.scalar.invert = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],
	
	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,
	
	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	
	    if (!det) {
	        return null;
	    }
	    det = 1.0 / det;
	
	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	
	    return out;
	};
	
	/**
	 * Inverts a mat4 using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.SIMD.invert = function(out, a) {
	  var row0, row1, row2, row3,
	      tmp1,
	      minor0, minor1, minor2, minor3,
	      det,
	      a0 = SIMD.Float32x4.load(a, 0),
	      a1 = SIMD.Float32x4.load(a, 4),
	      a2 = SIMD.Float32x4.load(a, 8),
	      a3 = SIMD.Float32x4.load(a, 12);
	
	  // Compute matrix adjugate
	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
	  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
	  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
	  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
	  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
	  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
	  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);
	
	  tmp1   = SIMD.Float32x4.mul(row2, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.mul(row1, tmp1);
	  minor1 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
	  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
	  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);
	
	  tmp1   = SIMD.Float32x4.mul(row1, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
	  minor3 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
	  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);
	
	  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
	  minor2 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
	  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);
	
	  tmp1   = SIMD.Float32x4.mul(row0, row1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));
	
	  tmp1   = SIMD.Float32x4.mul(row0, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
	  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));
	
	  tmp1   = SIMD.Float32x4.mul(row0, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);
	
	  // Compute matrix determinant
	  det   = SIMD.Float32x4.mul(row0, minor0);
	  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
	  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
	  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
	  det   = SIMD.Float32x4.sub(
	               SIMD.Float32x4.add(tmp1, tmp1),
	               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
	  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
	  if (!det) {
	      return null;
	  }
	
	  // Compute matrix inverse
	  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
	  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
	  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
	  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
	  return out;
	}
	
	/**
	 * Inverts a mat4 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;
	
	/**
	 * Calculates the adjugate of a mat4 not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.scalar.adjoint = function(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
	
	    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
	    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
	    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
	    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
	    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
	    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
	    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
	    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
	    return out;
	};
	
	/**
	 * Calculates the adjugate of a mat4 using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	mat4.SIMD.adjoint = function(out, a) {
	  var a0, a1, a2, a3;
	  var row0, row1, row2, row3;
	  var tmp1;
	  var minor0, minor1, minor2, minor3;
	
	  var a0 = SIMD.Float32x4.load(a, 0);
	  var a1 = SIMD.Float32x4.load(a, 4);
	  var a2 = SIMD.Float32x4.load(a, 8);
	  var a3 = SIMD.Float32x4.load(a, 12);
	
	  // Transpose the source matrix.  Sort of.  Not a true transpose operation
	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
	  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
	  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
	  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
	
	  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
	  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
	  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
	  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);
	
	  tmp1   = SIMD.Float32x4.mul(row2, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.mul(row1, tmp1);
	  minor1 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
	  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
	  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);
	
	  tmp1   = SIMD.Float32x4.mul(row1, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
	  minor3 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
	  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);
	
	  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
	  minor2 = SIMD.Float32x4.mul(row0, tmp1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
	  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);
	
	  tmp1   = SIMD.Float32x4.mul(row0, row1);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));
	
	  tmp1   = SIMD.Float32x4.mul(row0, row3);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
	  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
	  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));
	
	  tmp1   = SIMD.Float32x4.mul(row0, row2);
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
	  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
	  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
	  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
	  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
	  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);
	
	  SIMD.Float32x4.store(out, 0,  minor0);
	  SIMD.Float32x4.store(out, 4,  minor1);
	  SIMD.Float32x4.store(out, 8,  minor2);
	  SIMD.Float32x4.store(out, 12, minor3);
	  return out;
	};
	
	/**
	 * Calculates the adjugate of a mat4 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;
	
	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {mat4} a the source matrix
	 * @returns {Number} determinant of a
	 */
	mat4.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],
	
	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32;
	
	    // Calculate the determinant
	    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	};
	
	/**
	 * Multiplies two mat4's explicitly using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand, must be a Float32Array
	 * @param {mat4} b the second operand, must be a Float32Array
	 * @returns {mat4} out
	 */
	mat4.SIMD.multiply = function (out, a, b) {
	    var a0 = SIMD.Float32x4.load(a, 0);
	    var a1 = SIMD.Float32x4.load(a, 4);
	    var a2 = SIMD.Float32x4.load(a, 8);
	    var a3 = SIMD.Float32x4.load(a, 12);
	
	    var b0 = SIMD.Float32x4.load(b, 0);
	    var out0 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
	                       SIMD.Float32x4.add(
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 0, out0);
	
	    var b1 = SIMD.Float32x4.load(b, 4);
	    var out1 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
	                       SIMD.Float32x4.add(
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
	                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 4, out1);
	
	    var b2 = SIMD.Float32x4.load(b, 8);
	    var out2 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
	                       SIMD.Float32x4.add(
	                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
	                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 8, out2);
	
	    var b3 = SIMD.Float32x4.load(b, 12);
	    var out3 = SIMD.Float32x4.add(
	                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
	                   SIMD.Float32x4.add(
	                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
	                        SIMD.Float32x4.add(
	                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
	                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
	    SIMD.Float32x4.store(out, 12, out3);
	
	    return out;
	};
	
	/**
	 * Multiplies two mat4's explicitly not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	mat4.scalar.multiply = function (out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
	
	    // Cache only the current line of the second matrix
	    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	
	    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
	    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	
	    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
	    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	
	    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
	    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	    return out;
	};
	
	/**
	 * Multiplies two mat4's using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;
	
	/**
	 * Alias for {@link mat4.multiply}
	 * @function
	 */
	mat4.mul = mat4.multiply;
	
	/**
	 * Translate a mat4 by the given vector not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	mat4.scalar.translate = function (out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;
	
	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
	
	        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
	
	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }
	
	    return out;
	};
	
	/**
	 * Translates a mat4 by the given vector using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	mat4.SIMD.translate = function (out, a, v) {
	    var a0 = SIMD.Float32x4.load(a, 0),
	        a1 = SIMD.Float32x4.load(a, 4),
	        a2 = SIMD.Float32x4.load(a, 8),
	        a3 = SIMD.Float32x4.load(a, 12),
	        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);
	
	    if (a !== out) {
	        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
	        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
	        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
	    }
	
	    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
	    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
	    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));
	
	    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
	    SIMD.Float32x4.store(out, 12, t0);
	
	    return out;
	};
	
	/**
	 * Translates a mat4 by the given vector using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;
	
	/**
	 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	mat4.scalar.scale = function(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];
	
	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};
	
	/**
	 * Scales the mat4 by the dimensions in the given vec3 using vectorization
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	mat4.SIMD.scale = function(out, a, v) {
	    var a0, a1, a2;
	    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);
	
	    a0 = SIMD.Float32x4.load(a, 0);
	    SIMD.Float32x4.store(
	        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));
	
	    a1 = SIMD.Float32x4.load(a, 4);
	    SIMD.Float32x4.store(
	        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));
	
	    a2 = SIMD.Float32x4.load(a, 8);
	    SIMD.Float32x4.store(
	        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));
	
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};
	
	/**
	 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 */
	mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;
	
	/**
	 * Rotates a mat4 by the given angle around the given axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	mat4.rotate = function (out, a, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t,
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23,
	        b00, b01, b02,
	        b10, b11, b12,
	        b20, b21, b22;
	
	    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
	
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;
	
	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;
	
	    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
	
	    // Construct the elements of the rotation matrix
	    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
	    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
	    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;
	
	    // Perform rotation-specific matrix multiplication
	    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
	
	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    return out;
	};
	
	/**
	 * Rotates a matrix by the given angle around the X axis not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.scalar.rotateX = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];
	
	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[0]  = a[0];
	        out[1]  = a[1];
	        out[2]  = a[2];
	        out[3]  = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	
	    // Perform axis-specific matrix multiplication
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	};
	
	/**
	 * Rotates a matrix by the given angle around the X axis using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.SIMD.rotateX = function (out, a, rad) {
	    var s = SIMD.Float32x4.splat(Math.sin(rad)),
	        c = SIMD.Float32x4.splat(Math.cos(rad));
	
	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	      out[0]  = a[0];
	      out[1]  = a[1];
	      out[2]  = a[2];
	      out[3]  = a[3];
	      out[12] = a[12];
	      out[13] = a[13];
	      out[14] = a[14];
	      out[15] = a[15];
	    }
	
	    // Perform axis-specific matrix multiplication
	    var a_1 = SIMD.Float32x4.load(a, 4);
	    var a_2 = SIMD.Float32x4.load(a, 8);
	    SIMD.Float32x4.store(out, 4,
	                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
	    SIMD.Float32x4.store(out, 8,
	                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
	    return out;
	};
	
	/**
	 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;
	
	/**
	 * Rotates a matrix by the given angle around the Y axis not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.scalar.rotateY = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];
	
	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	
	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c - a20 * s;
	    out[1] = a01 * c - a21 * s;
	    out[2] = a02 * c - a22 * s;
	    out[3] = a03 * c - a23 * s;
	    out[8] = a00 * s + a20 * c;
	    out[9] = a01 * s + a21 * c;
	    out[10] = a02 * s + a22 * c;
	    out[11] = a03 * s + a23 * c;
	    return out;
	};
	
	/**
	 * Rotates a matrix by the given angle around the Y axis using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.SIMD.rotateY = function (out, a, rad) {
	    var s = SIMD.Float32x4.splat(Math.sin(rad)),
	        c = SIMD.Float32x4.splat(Math.cos(rad));
	
	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	
	    // Perform axis-specific matrix multiplication
	    var a_0 = SIMD.Float32x4.load(a, 0);
	    var a_2 = SIMD.Float32x4.load(a, 8);
	    SIMD.Float32x4.store(out, 0,
	                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
	    SIMD.Float32x4.store(out, 8,
	                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
	    return out;
	};
	
	/**
	 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;
	
	/**
	 * Rotates a matrix by the given angle around the Z axis not using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.scalar.rotateZ = function (out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7];
	
	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	
	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	};
	
	/**
	 * Rotates a matrix by the given angle around the Z axis using SIMD
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.SIMD.rotateZ = function (out, a, rad) {
	    var s = SIMD.Float32x4.splat(Math.sin(rad)),
	        c = SIMD.Float32x4.splat(Math.cos(rad));
	
	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	
	    // Perform axis-specific matrix multiplication
	    var a_0 = SIMD.Float32x4.load(a, 0);
	    var a_1 = SIMD.Float32x4.load(a, 4);
	    SIMD.Float32x4.store(out, 0,
	                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
	    SIMD.Float32x4.store(out, 4,
	                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
	    return out;
	};
	
	/**
	 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;
	
	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	mat4.fromTranslation = function(out, v) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.scale(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Scaling vector
	 * @returns {mat4} out
	 */
	mat4.fromScaling = function(out, v) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = v[1];
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = v[2];
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from a given angle around a given axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotate(dest, dest, rad, axis);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	mat4.fromRotation = function(out, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t;
	
	    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
	
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;
	
	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;
	
	    // Perform rotation-specific matrix multiplication
	    out[0] = x * x * t + c;
	    out[1] = y * x * t + z * s;
	    out[2] = z * x * t - y * s;
	    out[3] = 0;
	    out[4] = x * y * t - z * s;
	    out[5] = y * y * t + c;
	    out[6] = z * y * t + x * s;
	    out[7] = 0;
	    out[8] = x * z * t + y * s;
	    out[9] = y * z * t - x * s;
	    out[10] = z * z * t + c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from the given angle around the X axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateX(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.fromXRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	
	    // Perform axis-specific matrix multiplication
	    out[0]  = 1;
	    out[1]  = 0;
	    out[2]  = 0;
	    out[3]  = 0;
	    out[4] = 0;
	    out[5] = c;
	    out[6] = s;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = -s;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from the given angle around the Y axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateY(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.fromYRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	
	    // Perform axis-specific matrix multiplication
	    out[0]  = c;
	    out[1]  = 0;
	    out[2]  = -s;
	    out[3]  = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = s;
	    out[9] = 0;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from the given angle around the Z axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateZ(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	mat4.fromZRotation = function(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	
	    // Perform axis-specific matrix multiplication
	    out[0]  = c;
	    out[1]  = s;
	    out[2]  = 0;
	    out[3]  = 0;
	    out[4] = -s;
	    out[5] = c;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}
	
	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	mat4.fromRotationTranslation = function (out, q, v) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,
	
	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;
	
	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	
	    return out;
	};
	
	/**
	 * Returns the translation vector component of a transformation
	 *  matrix. If a matrix is built with fromRotationTranslation,
	 *  the returned vector will be the same as the translation vector
	 *  originally supplied.
	 * @param  {vec3} out Vector to receive translation component
	 * @param  {mat4} mat Matrix to be decomposed (input)
	 * @return {vec3} out
	 */
	mat4.getTranslation = function (out, mat) {
	  out[0] = mat[12];
	  out[1] = mat[13];
	  out[2] = mat[14];
	
	  return out;
	};
	
	/**
	 * Returns a quaternion representing the rotational component
	 *  of a transformation matrix. If a matrix is built with
	 *  fromRotationTranslation, the returned quaternion will be the
	 *  same as the quaternion originally supplied.
	 * @param {quat} out Quaternion to receive the rotation component
	 * @param {mat4} mat Matrix to be decomposed (input)
	 * @return {quat} out
	 */
	mat4.getRotation = function (out, mat) {
	  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	  var trace = mat[0] + mat[5] + mat[10];
	  var S = 0;
	
	  if (trace > 0) { 
	    S = Math.sqrt(trace + 1.0) * 2;
	    out[3] = 0.25 * S;
	    out[0] = (mat[6] - mat[9]) / S;
	    out[1] = (mat[8] - mat[2]) / S; 
	    out[2] = (mat[1] - mat[4]) / S; 
	  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
	    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
	    out[3] = (mat[6] - mat[9]) / S;
	    out[0] = 0.25 * S;
	    out[1] = (mat[1] + mat[4]) / S; 
	    out[2] = (mat[8] + mat[2]) / S; 
	  } else if (mat[5] > mat[10]) { 
	    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
	    out[3] = (mat[8] - mat[2]) / S;
	    out[0] = (mat[1] + mat[4]) / S; 
	    out[1] = 0.25 * S;
	    out[2] = (mat[6] + mat[9]) / S; 
	  } else { 
	    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
	    out[3] = (mat[1] - mat[4]) / S;
	    out[0] = (mat[8] + mat[2]) / S;
	    out[1] = (mat[6] + mat[9]) / S;
	    out[2] = 0.25 * S;
	  }
	
	  return out;
	};
	
	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @param {vec3} s Scaling vector
	 * @returns {mat4} out
	 */
	mat4.fromRotationTranslationScale = function (out, q, v, s) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,
	
	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2,
	        sx = s[0],
	        sy = s[1],
	        sz = s[2];
	
	    out[0] = (1 - (yy + zz)) * sx;
	    out[1] = (xy + wz) * sx;
	    out[2] = (xz - wy) * sx;
	    out[3] = 0;
	    out[4] = (xy - wz) * sy;
	    out[5] = (1 - (xx + zz)) * sy;
	    out[6] = (yz + wx) * sy;
	    out[7] = 0;
	    out[8] = (xz + wy) * sz;
	    out[9] = (yz - wx) * sz;
	    out[10] = (1 - (xx + yy)) * sz;
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	
	    return out;
	};
	
	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     mat4.translate(dest, origin);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *     mat4.translate(dest, negativeOrigin);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @param {vec3} s Scaling vector
	 * @param {vec3} o The origin vector around which to scale and rotate
	 * @returns {mat4} out
	 */
	mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
	  // Quaternion math
	  var x = q[0], y = q[1], z = q[2], w = q[3],
	      x2 = x + x,
	      y2 = y + y,
	      z2 = z + z,
	
	      xx = x * x2,
	      xy = x * y2,
	      xz = x * z2,
	      yy = y * y2,
	      yz = y * z2,
	      zz = z * z2,
	      wx = w * x2,
	      wy = w * y2,
	      wz = w * z2,
	
	      sx = s[0],
	      sy = s[1],
	      sz = s[2],
	
	      ox = o[0],
	      oy = o[1],
	      oz = o[2];
	
	  out[0] = (1 - (yy + zz)) * sx;
	  out[1] = (xy + wz) * sx;
	  out[2] = (xz - wy) * sx;
	  out[3] = 0;
	  out[4] = (xy - wz) * sy;
	  out[5] = (1 - (xx + zz)) * sy;
	  out[6] = (yz + wx) * sy;
	  out[7] = 0;
	  out[8] = (xz + wy) * sz;
	  out[9] = (yz - wx) * sz;
	  out[10] = (1 - (xx + yy)) * sz;
	  out[11] = 0;
	  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
	  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
	  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
	  out[15] = 1;
	
	  return out;
	};
	
	/**
	 * Calculates a 4x4 matrix from the given quaternion
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat} q Quaternion to create matrix from
	 *
	 * @returns {mat4} out
	 */
	mat4.fromQuat = function (out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,
	
	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;
	
	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;
	
	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;
	
	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;
	
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	
	    return out;
	};
	
	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.frustum = function (out, left, right, bottom, top, near, far) {
	    var rl = 1 / (right - left),
	        tb = 1 / (top - bottom),
	        nf = 1 / (near - far);
	    out[0] = (near * 2) * rl;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = (near * 2) * tb;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = (right + left) * rl;
	    out[9] = (top + bottom) * tb;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (far * near * 2) * nf;
	    out[15] = 0;
	    return out;
	};
	
	/**
	 * Generates a perspective projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.perspective = function (out, fovy, aspect, near, far) {
	    var f = 1.0 / Math.tan(fovy / 2),
	        nf = 1 / (near - far);
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (2 * far * near) * nf;
	    out[15] = 0;
	    return out;
	};
	
	/**
	 * Generates a perspective projection matrix with the given field of view.
	 * This is primarily useful for generating projection matrices to be used
	 * with the still experiemental WebVR API.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
	    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
	        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
	        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
	        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
	        xScale = 2.0 / (leftTan + rightTan),
	        yScale = 2.0 / (upTan + downTan);
	
	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = ((upTan - downTan) * yScale * 0.5);
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = (far * near) / (near - far);
	    out[15] = 0.0;
	    return out;
	}
	
	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	mat4.ortho = function (out, left, right, bottom, top, near, far) {
	    var lr = 1 / (left - right),
	        bt = 1 / (bottom - top),
	        nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	};
	
	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	mat4.lookAt = function (out, eye, center, up) {
	    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
	        eyex = eye[0],
	        eyey = eye[1],
	        eyez = eye[2],
	        upx = up[0],
	        upy = up[1],
	        upz = up[2],
	        centerx = center[0],
	        centery = center[1],
	        centerz = center[2];
	
	    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
	        Math.abs(eyey - centery) < glMatrix.EPSILON &&
	        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
	        return mat4.identity(out);
	    }
	
	    z0 = eyex - centerx;
	    z1 = eyey - centery;
	    z2 = eyez - centerz;
	
	    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;
	
	    x0 = upy * z2 - upz * z1;
	    x1 = upz * z0 - upx * z2;
	    x2 = upx * z1 - upy * z0;
	    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	    if (!len) {
	        x0 = 0;
	        x1 = 0;
	        x2 = 0;
	    } else {
	        len = 1 / len;
	        x0 *= len;
	        x1 *= len;
	        x2 *= len;
	    }
	
	    y0 = z1 * x2 - z2 * x1;
	    y1 = z2 * x0 - z0 * x2;
	    y2 = z0 * x1 - z1 * x0;
	
	    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	    if (!len) {
	        y0 = 0;
	        y1 = 0;
	        y2 = 0;
	    } else {
	        len = 1 / len;
	        y0 *= len;
	        y1 *= len;
	        y2 *= len;
	    }
	
	    out[0] = x0;
	    out[1] = y0;
	    out[2] = z0;
	    out[3] = 0;
	    out[4] = x1;
	    out[5] = y1;
	    out[6] = z1;
	    out[7] = 0;
	    out[8] = x2;
	    out[9] = y2;
	    out[10] = z2;
	    out[11] = 0;
	    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	    out[15] = 1;
	
	    return out;
	};
	
	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {mat4} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	mat4.str = function (a) {
	    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
	                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
	                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
	                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
	};
	
	/**
	 * Returns Frobenius norm of a mat4
	 *
	 * @param {mat4} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	mat4.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
	};
	
	/**
	 * Adds two mat4's
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	mat4.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    out[4] = a[4] + b[4];
	    out[5] = a[5] + b[5];
	    out[6] = a[6] + b[6];
	    out[7] = a[7] + b[7];
	    out[8] = a[8] + b[8];
	    out[9] = a[9] + b[9];
	    out[10] = a[10] + b[10];
	    out[11] = a[11] + b[11];
	    out[12] = a[12] + b[12];
	    out[13] = a[13] + b[13];
	    out[14] = a[14] + b[14];
	    out[15] = a[15] + b[15];
	    return out;
	};
	
	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	mat4.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    out[4] = a[4] - b[4];
	    out[5] = a[5] - b[5];
	    out[6] = a[6] - b[6];
	    out[7] = a[7] - b[7];
	    out[8] = a[8] - b[8];
	    out[9] = a[9] - b[9];
	    out[10] = a[10] - b[10];
	    out[11] = a[11] - b[11];
	    out[12] = a[12] - b[12];
	    out[13] = a[13] - b[13];
	    out[14] = a[14] - b[14];
	    out[15] = a[15] - b[15];
	    return out;
	};
	
	/**
	 * Alias for {@link mat4.subtract}
	 * @function
	 */
	mat4.sub = mat4.subtract;
	
	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat4} out
	 */
	mat4.multiplyScalar = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    out[4] = a[4] * b;
	    out[5] = a[5] * b;
	    out[6] = a[6] * b;
	    out[7] = a[7] * b;
	    out[8] = a[8] * b;
	    out[9] = a[9] * b;
	    out[10] = a[10] * b;
	    out[11] = a[11] * b;
	    out[12] = a[12] * b;
	    out[13] = a[13] * b;
	    out[14] = a[14] * b;
	    out[15] = a[15] * b;
	    return out;
	};
	
	/**
	 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat4} out the receiving vector
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat4} out
	 */
	mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    out[4] = a[4] + (b[4] * scale);
	    out[5] = a[5] + (b[5] * scale);
	    out[6] = a[6] + (b[6] * scale);
	    out[7] = a[7] + (b[7] * scale);
	    out[8] = a[8] + (b[8] * scale);
	    out[9] = a[9] + (b[9] * scale);
	    out[10] = a[10] + (b[10] * scale);
	    out[11] = a[11] + (b[11] * scale);
	    out[12] = a[12] + (b[12] * scale);
	    out[13] = a[13] + (b[13] * scale);
	    out[14] = a[14] + (b[14] * scale);
	    out[15] = a[15] + (b[15] * scale);
	    return out;
	};
	
	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat4} a The first matrix.
	 * @param {mat4} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat4.exactEquals = function (a, b) {
	    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
	           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
	           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
	           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
	};
	
	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat4} a The first matrix.
	 * @param {mat4} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	mat4.equals = function (a, b) {
	    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
	        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
	        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
	        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
	
	    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
	        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
	        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
	        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
	
	    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
	            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
	            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
	            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
	            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
	            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
	            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
	            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
	            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
	            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
	            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
	            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
	            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
	            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
	            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
	            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
	};
	
	
	
	module.exports = mat4;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	var mat3 = __webpack_require__(223);
	var vec3 = __webpack_require__(226);
	var vec4 = __webpack_require__(227);
	
	/**
	 * @class Quaternion
	 * @name quat
	 */
	var quat = {};
	
	/**
	 * Creates a new identity quat
	 *
	 * @returns {quat} a new quaternion
	 */
	quat.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};
	
	/**
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {quat} out the receiving quaternion.
	 * @param {vec3} a the initial vector
	 * @param {vec3} b the destination vector
	 * @returns {quat} out
	 */
	quat.rotationTo = (function() {
	    var tmpvec3 = vec3.create();
	    var xUnitVec3 = vec3.fromValues(1,0,0);
	    var yUnitVec3 = vec3.fromValues(0,1,0);
	
	    return function(out, a, b) {
	        var dot = vec3.dot(a, b);
	        if (dot < -0.999999) {
	            vec3.cross(tmpvec3, xUnitVec3, a);
	            if (vec3.length(tmpvec3) < 0.000001)
	                vec3.cross(tmpvec3, yUnitVec3, a);
	            vec3.normalize(tmpvec3, tmpvec3);
	            quat.setAxisAngle(out, tmpvec3, Math.PI);
	            return out;
	        } else if (dot > 0.999999) {
	            out[0] = 0;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            return out;
	        } else {
	            vec3.cross(tmpvec3, a, b);
	            out[0] = tmpvec3[0];
	            out[1] = tmpvec3[1];
	            out[2] = tmpvec3[2];
	            out[3] = 1 + dot;
	            return quat.normalize(out, out);
	        }
	    };
	})();
	
	/**
	 * Sets the specified quaternion with values corresponding to the given
	 * axes. Each axis is a vec3 and is expected to be unit length and
	 * perpendicular to all other specified axes.
	 *
	 * @param {vec3} view  the vector representing the viewing direction
	 * @param {vec3} right the vector representing the local "right" direction
	 * @param {vec3} up    the vector representing the local "up" direction
	 * @returns {quat} out
	 */
	quat.setAxes = (function() {
	    var matr = mat3.create();
	
	    return function(out, view, right, up) {
	        matr[0] = right[0];
	        matr[3] = right[1];
	        matr[6] = right[2];
	
	        matr[1] = up[0];
	        matr[4] = up[1];
	        matr[7] = up[2];
	
	        matr[2] = -view[0];
	        matr[5] = -view[1];
	        matr[8] = -view[2];
	
	        return quat.normalize(out, quat.fromMat3(out, matr));
	    };
	})();
	
	/**
	 * Creates a new quat initialized with values from an existing quaternion
	 *
	 * @param {quat} a quaternion to clone
	 * @returns {quat} a new quaternion
	 * @function
	 */
	quat.clone = vec4.clone;
	
	/**
	 * Creates a new quat initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} a new quaternion
	 * @function
	 */
	quat.fromValues = vec4.fromValues;
	
	/**
	 * Copy the values from one quat to another
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the source quaternion
	 * @returns {quat} out
	 * @function
	 */
	quat.copy = vec4.copy;
	
	/**
	 * Set the components of a quat to the given values
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} out
	 * @function
	 */
	quat.set = vec4.set;
	
	/**
	 * Set a quat to the identity quaternion
	 *
	 * @param {quat} out the receiving quaternion
	 * @returns {quat} out
	 */
	quat.identity = function(out) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};
	
	/**
	 * Sets a quat from the given angle and rotation axis,
	 * then returns it.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {vec3} axis the axis around which to rotate
	 * @param {Number} rad the angle in radians
	 * @returns {quat} out
	 **/
	quat.setAxisAngle = function(out, axis, rad) {
	    rad = rad * 0.5;
	    var s = Math.sin(rad);
	    out[0] = s * axis[0];
	    out[1] = s * axis[1];
	    out[2] = s * axis[2];
	    out[3] = Math.cos(rad);
	    return out;
	};
	
	/**
	 * Gets the rotation axis and angle for a given
	 *  quaternion. If a quaternion is created with
	 *  setAxisAngle, this method will return the same
	 *  values as providied in the original parameter list
	 *  OR functionally equivalent values.
	 * Example: The quaternion formed by axis [0, 0, 1] and
	 *  angle -90 is the same as the quaternion formed by
	 *  [0, 0, 1] and 270. This method favors the latter.
	 * @param  {vec3} out_axis  Vector receiving the axis of rotation
	 * @param  {quat} q     Quaternion to be decomposed
	 * @return {Number}     Angle, in radians, of the rotation
	 */
	quat.getAxisAngle = function(out_axis, q) {
	    var rad = Math.acos(q[3]) * 2.0;
	    var s = Math.sin(rad / 2.0);
	    if (s != 0.0) {
	        out_axis[0] = q[0] / s;
	        out_axis[1] = q[1] / s;
	        out_axis[2] = q[2] / s;
	    } else {
	        // If s is zero, return any axis (no rotation - axis does not matter)
	        out_axis[0] = 1;
	        out_axis[1] = 0;
	        out_axis[2] = 0;
	    }
	    return rad;
	};
	
	/**
	 * Adds two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 * @function
	 */
	quat.add = vec4.add;
	
	/**
	 * Multiplies two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 */
	quat.multiply = function(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];
	
	    out[0] = ax * bw + aw * bx + ay * bz - az * by;
	    out[1] = ay * bw + aw * by + az * bx - ax * bz;
	    out[2] = az * bw + aw * bz + ax * by - ay * bx;
	    out[3] = aw * bw - ax * bx - ay * by - az * bz;
	    return out;
	};
	
	/**
	 * Alias for {@link quat.multiply}
	 * @function
	 */
	quat.mul = quat.multiply;
	
	/**
	 * Scales a quat by a scalar number
	 *
	 * @param {quat} out the receiving vector
	 * @param {quat} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {quat} out
	 * @function
	 */
	quat.scale = vec4.scale;
	
	/**
	 * Rotates a quaternion by the given angle about the X axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateX = function (out, a, rad) {
	    rad *= 0.5; 
	
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = Math.sin(rad), bw = Math.cos(rad);
	
	    out[0] = ax * bw + aw * bx;
	    out[1] = ay * bw + az * bx;
	    out[2] = az * bw - ay * bx;
	    out[3] = aw * bw - ax * bx;
	    return out;
	};
	
	/**
	 * Rotates a quaternion by the given angle about the Y axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateY = function (out, a, rad) {
	    rad *= 0.5; 
	
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        by = Math.sin(rad), bw = Math.cos(rad);
	
	    out[0] = ax * bw - az * by;
	    out[1] = ay * bw + aw * by;
	    out[2] = az * bw + ax * by;
	    out[3] = aw * bw - ay * by;
	    return out;
	};
	
	/**
	 * Rotates a quaternion by the given angle about the Z axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	quat.rotateZ = function (out, a, rad) {
	    rad *= 0.5; 
	
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bz = Math.sin(rad), bw = Math.cos(rad);
	
	    out[0] = ax * bw + ay * bz;
	    out[1] = ay * bw - ax * bz;
	    out[2] = az * bw + aw * bz;
	    out[3] = aw * bw - az * bz;
	    return out;
	};
	
	/**
	 * Calculates the W component of a quat from the X, Y, and Z components.
	 * Assumes that quaternion is 1 unit in length.
	 * Any existing W component will be ignored.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate W component of
	 * @returns {quat} out
	 */
	quat.calculateW = function (out, a) {
	    var x = a[0], y = a[1], z = a[2];
	
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
	    return out;
	};
	
	/**
	 * Calculates the dot product of two quat's
	 *
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {Number} dot product of a and b
	 * @function
	 */
	quat.dot = vec4.dot;
	
	/**
	 * Performs a linear interpolation between two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 * @function
	 */
	quat.lerp = vec4.lerp;
	
	/**
	 * Performs a spherical linear interpolation between two quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 */
	quat.slerp = function (out, a, b, t) {
	    // benchmarks:
	    //    http://jsperf.com/quaternion-slerp-implementations
	
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];
	
	    var        omega, cosom, sinom, scale0, scale1;
	
	    // calc cosine
	    cosom = ax * bx + ay * by + az * bz + aw * bw;
	    // adjust signs (if necessary)
	    if ( cosom < 0.0 ) {
	        cosom = -cosom;
	        bx = - bx;
	        by = - by;
	        bz = - bz;
	        bw = - bw;
	    }
	    // calculate coefficients
	    if ( (1.0 - cosom) > 0.000001 ) {
	        // standard case (slerp)
	        omega  = Math.acos(cosom);
	        sinom  = Math.sin(omega);
	        scale0 = Math.sin((1.0 - t) * omega) / sinom;
	        scale1 = Math.sin(t * omega) / sinom;
	    } else {        
	        // "from" and "to" quaternions are very close 
	        //  ... so we can do a linear interpolation
	        scale0 = 1.0 - t;
	        scale1 = t;
	    }
	    // calculate final values
	    out[0] = scale0 * ax + scale1 * bx;
	    out[1] = scale0 * ay + scale1 * by;
	    out[2] = scale0 * az + scale1 * bz;
	    out[3] = scale0 * aw + scale1 * bw;
	    
	    return out;
	};
	
	/**
	 * Performs a spherical linear interpolation with two control points
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {quat} c the third operand
	 * @param {quat} d the fourth operand
	 * @param {Number} t interpolation amount
	 * @returns {quat} out
	 */
	quat.sqlerp = (function () {
	  var temp1 = quat.create();
	  var temp2 = quat.create();
	  
	  return function (out, a, b, c, d, t) {
	    quat.slerp(temp1, a, d, t);
	    quat.slerp(temp2, b, c, t);
	    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
	    
	    return out;
	  };
	}());
	
	/**
	 * Calculates the inverse of a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate inverse of
	 * @returns {quat} out
	 */
	quat.invert = function(out, a) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
	        invDot = dot ? 1.0/dot : 0;
	    
	    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
	
	    out[0] = -a0*invDot;
	    out[1] = -a1*invDot;
	    out[2] = -a2*invDot;
	    out[3] = a3*invDot;
	    return out;
	};
	
	/**
	 * Calculates the conjugate of a quat
	 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate conjugate of
	 * @returns {quat} out
	 */
	quat.conjugate = function (out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = a[3];
	    return out;
	};
	
	/**
	 * Calculates the length of a quat
	 *
	 * @param {quat} a vector to calculate length of
	 * @returns {Number} length of a
	 * @function
	 */
	quat.length = vec4.length;
	
	/**
	 * Alias for {@link quat.length}
	 * @function
	 */
	quat.len = quat.length;
	
	/**
	 * Calculates the squared length of a quat
	 *
	 * @param {quat} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @function
	 */
	quat.squaredLength = vec4.squaredLength;
	
	/**
	 * Alias for {@link quat.squaredLength}
	 * @function
	 */
	quat.sqrLen = quat.squaredLength;
	
	/**
	 * Normalize a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quaternion to normalize
	 * @returns {quat} out
	 * @function
	 */
	quat.normalize = vec4.normalize;
	
	/**
	 * Creates a quaternion from the given 3x3 rotation matrix.
	 *
	 * NOTE: The resultant quaternion is not normalized, so you should be sure
	 * to renormalize the quaternion yourself where necessary.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {mat3} m rotation matrix
	 * @returns {quat} out
	 * @function
	 */
	quat.fromMat3 = function(out, m) {
	    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
	    // article "Quaternion Calculus and Fast Animation".
	    var fTrace = m[0] + m[4] + m[8];
	    var fRoot;
	
	    if ( fTrace > 0.0 ) {
	        // |w| > 1/2, may as well choose w > 1/2
	        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
	        out[3] = 0.5 * fRoot;
	        fRoot = 0.5/fRoot;  // 1/(4w)
	        out[0] = (m[5]-m[7])*fRoot;
	        out[1] = (m[6]-m[2])*fRoot;
	        out[2] = (m[1]-m[3])*fRoot;
	    } else {
	        // |w| <= 1/2
	        var i = 0;
	        if ( m[4] > m[0] )
	          i = 1;
	        if ( m[8] > m[i*3+i] )
	          i = 2;
	        var j = (i+1)%3;
	        var k = (i+2)%3;
	        
	        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
	        out[i] = 0.5 * fRoot;
	        fRoot = 0.5 / fRoot;
	        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
	        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
	        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
	    }
	    
	    return out;
	};
	
	/**
	 * Returns a string representation of a quatenion
	 *
	 * @param {quat} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	quat.str = function (a) {
	    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};
	
	/**
	 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {quat} a The first quaternion.
	 * @param {quat} b The second quaternion.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	quat.exactEquals = vec4.exactEquals;
	
	/**
	 * Returns whether or not the quaternions have approximately the same elements in the same position.
	 *
	 * @param {quat} a The first vector.
	 * @param {quat} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	quat.equals = vec4.equals;
	
	module.exports = quat;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	
	/**
	 * @class 3 Dimensional Vector
	 * @name vec3
	 */
	var vec3 = {};
	
	/**
	 * Creates a new, empty vec3
	 *
	 * @returns {vec3} a new 3D vector
	 */
	vec3.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(3);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    return out;
	};
	
	/**
	 * Creates a new vec3 initialized with values from an existing vector
	 *
	 * @param {vec3} a vector to clone
	 * @returns {vec3} a new 3D vector
	 */
	vec3.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(3);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};
	
	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} a new 3D vector
	 */
	vec3.fromValues = function(x, y, z) {
	    var out = new glMatrix.ARRAY_TYPE(3);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};
	
	/**
	 * Copy the values from one vec3 to another
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the source vector
	 * @returns {vec3} out
	 */
	vec3.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};
	
	/**
	 * Set the components of a vec3 to the given values
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} out
	 */
	vec3.set = function(out, x, y, z) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};
	
	/**
	 * Adds two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    return out;
	};
	
	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    return out;
	};
	
	/**
	 * Alias for {@link vec3.subtract}
	 * @function
	 */
	vec3.sub = vec3.subtract;
	
	/**
	 * Multiplies two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    return out;
	};
	
	/**
	 * Alias for {@link vec3.multiply}
	 * @function
	 */
	vec3.mul = vec3.multiply;
	
	/**
	 * Divides two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    return out;
	};
	
	/**
	 * Alias for {@link vec3.divide}
	 * @function
	 */
	vec3.div = vec3.divide;
	
	/**
	 * Math.ceil the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to ceil
	 * @returns {vec3} out
	 */
	vec3.ceil = function (out, a) {
	    out[0] = Math.ceil(a[0]);
	    out[1] = Math.ceil(a[1]);
	    out[2] = Math.ceil(a[2]);
	    return out;
	};
	
	/**
	 * Math.floor the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to floor
	 * @returns {vec3} out
	 */
	vec3.floor = function (out, a) {
	    out[0] = Math.floor(a[0]);
	    out[1] = Math.floor(a[1]);
	    out[2] = Math.floor(a[2]);
	    return out;
	};
	
	/**
	 * Returns the minimum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    return out;
	};
	
	/**
	 * Returns the maximum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    return out;
	};
	
	/**
	 * Math.round the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to round
	 * @returns {vec3} out
	 */
	vec3.round = function (out, a) {
	    out[0] = Math.round(a[0]);
	    out[1] = Math.round(a[1]);
	    out[2] = Math.round(a[2]);
	    return out;
	};
	
	/**
	 * Scales a vec3 by a scalar number
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec3} out
	 */
	vec3.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    return out;
	};
	
	/**
	 * Adds two vec3's after scaling the second operand by a scalar value
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec3} out
	 */
	vec3.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    return out;
	};
	
	/**
	 * Calculates the euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec3.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};
	
	/**
	 * Alias for {@link vec3.distance}
	 * @function
	 */
	vec3.dist = vec3.distance;
	
	/**
	 * Calculates the squared euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec3.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return x*x + y*y + z*z;
	};
	
	/**
	 * Alias for {@link vec3.squaredDistance}
	 * @function
	 */
	vec3.sqrDist = vec3.squaredDistance;
	
	/**
	 * Calculates the length of a vec3
	 *
	 * @param {vec3} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec3.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};
	
	/**
	 * Alias for {@link vec3.length}
	 * @function
	 */
	vec3.len = vec3.length;
	
	/**
	 * Calculates the squared length of a vec3
	 *
	 * @param {vec3} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec3.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return x*x + y*y + z*z;
	};
	
	/**
	 * Alias for {@link vec3.squaredLength}
	 * @function
	 */
	vec3.sqrLen = vec3.squaredLength;
	
	/**
	 * Negates the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to negate
	 * @returns {vec3} out
	 */
	vec3.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    return out;
	};
	
	/**
	 * Returns the inverse of the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to invert
	 * @returns {vec3} out
	 */
	vec3.inverse = function(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  return out;
	};
	
	/**
	 * Normalize a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to normalize
	 * @returns {vec3} out
	 */
	vec3.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    var len = x*x + y*y + z*z;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	        out[2] = a[2] * len;
	    }
	    return out;
	};
	
	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec3.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	};
	
	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	vec3.cross = function(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2],
	        bx = b[0], by = b[1], bz = b[2];
	
	    out[0] = ay * bz - az * by;
	    out[1] = az * bx - ax * bz;
	    out[2] = ax * by - ay * bx;
	    return out;
	};
	
	/**
	 * Performs a linear interpolation between two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	vec3.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    return out;
	};
	
	/**
	 * Performs a hermite interpolation with two control points
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {vec3} c the third operand
	 * @param {vec3} d the fourth operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	vec3.hermite = function (out, a, b, c, d, t) {
	  var factorTimes2 = t * t,
	      factor1 = factorTimes2 * (2 * t - 3) + 1,
	      factor2 = factorTimes2 * (t - 2) + t,
	      factor3 = factorTimes2 * (t - 1),
	      factor4 = factorTimes2 * (3 - 2 * t);
	  
	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
	  
	  return out;
	};
	
	/**
	 * Performs a bezier interpolation with two control points
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {vec3} c the third operand
	 * @param {vec3} d the fourth operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec3} out
	 */
	vec3.bezier = function (out, a, b, c, d, t) {
	  var inverseFactor = 1 - t,
	      inverseFactorTimesTwo = inverseFactor * inverseFactor,
	      factorTimes2 = t * t,
	      factor1 = inverseFactorTimesTwo * inverseFactor,
	      factor2 = 3 * t * inverseFactorTimesTwo,
	      factor3 = 3 * factorTimes2 * inverseFactor,
	      factor4 = factorTimes2 * t;
	  
	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
	  
	  return out;
	};
	
	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec3} out
	 */
	vec3.random = function (out, scale) {
	    scale = scale || 1.0;
	
	    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
	    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
	    var zScale = Math.sqrt(1.0-z*z) * scale;
	
	    out[0] = Math.cos(r) * zScale;
	    out[1] = Math.sin(r) * zScale;
	    out[2] = z * scale;
	    return out;
	};
	
	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec3} out
	 */
	vec3.transformMat4 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2],
	        w = m[3] * x + m[7] * y + m[11] * z + m[15];
	    w = w || 1.0;
	    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
	    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
	    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
	    return out;
	};
	
	/**
	 * Transforms the vec3 with a mat3.
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m the 3x3 matrix to transform with
	 * @returns {vec3} out
	 */
	vec3.transformMat3 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2];
	    out[0] = x * m[0] + y * m[3] + z * m[6];
	    out[1] = x * m[1] + y * m[4] + z * m[7];
	    out[2] = x * m[2] + y * m[5] + z * m[8];
	    return out;
	};
	
	/**
	 * Transforms the vec3 with a quat
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec3} out
	 */
	vec3.transformQuat = function(out, a, q) {
	    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
	
	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],
	
	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;
	
	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return out;
	};
	
	/**
	 * Rotate a 3D vector around the x-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	vec3.rotateX = function(out, a, b, c){
	   var p = [], r=[];
		  //Translate point to the origin
		  p[0] = a[0] - b[0];
		  p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	
		  //perform rotation
		  r[0] = p[0];
		  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
		  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);
	
		  //translate to correct position
		  out[0] = r[0] + b[0];
		  out[1] = r[1] + b[1];
		  out[2] = r[2] + b[2];
	
	  	return out;
	};
	
	/**
	 * Rotate a 3D vector around the y-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	vec3.rotateY = function(out, a, b, c){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
	  	r[1] = p[1];
	  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};
	
	/**
	 * Rotate a 3D vector around the z-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	vec3.rotateZ = function(out, a, b, c){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
	  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
	  	r[2] = p[2];
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};
	
	/**
	 * Perform some operation over an array of vec3s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec3.forEach = (function() {
	    var vec = vec3.create();
	
	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 3;
	        }
	
	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }
	
	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
	        }
	        
	        return a;
	    };
	})();
	
	/**
	 * Get the angle between two 3D vectors
	 * @param {vec3} a The first operand
	 * @param {vec3} b The second operand
	 * @returns {Number} The angle in radians
	 */
	vec3.angle = function(a, b) {
	   
	    var tempA = vec3.fromValues(a[0], a[1], a[2]);
	    var tempB = vec3.fromValues(b[0], b[1], b[2]);
	 
	    vec3.normalize(tempA, tempA);
	    vec3.normalize(tempB, tempB);
	 
	    var cosine = vec3.dot(tempA, tempB);
	
	    if(cosine > 1.0){
	        return 0;
	    } else {
	        return Math.acos(cosine);
	    }     
	};
	
	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec3} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec3.str = function (a) {
	    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
	};
	
	/**
	 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {vec3} a The first vector.
	 * @param {vec3} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	vec3.exactEquals = function (a, b) {
	    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
	};
	
	/**
	 * Returns whether or not the vectors have approximately the same elements in the same position.
	 *
	 * @param {vec3} a The first vector.
	 * @param {vec3} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	vec3.equals = function (a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2];
	    var b0 = b[0], b1 = b[1], b2 = b[2];
	    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
	            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
	            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
	};
	
	module.exports = vec3;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	
	/**
	 * @class 4 Dimensional Vector
	 * @name vec4
	 */
	var vec4 = {};
	
	/**
	 * Creates a new, empty vec4
	 *
	 * @returns {vec4} a new 4D vector
	 */
	vec4.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    return out;
	};
	
	/**
	 * Creates a new vec4 initialized with values from an existing vector
	 *
	 * @param {vec4} a vector to clone
	 * @returns {vec4} a new 4D vector
	 */
	vec4.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};
	
	/**
	 * Creates a new vec4 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} a new 4D vector
	 */
	vec4.fromValues = function(x, y, z, w) {
	    var out = new glMatrix.ARRAY_TYPE(4);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};
	
	/**
	 * Copy the values from one vec4 to another
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the source vector
	 * @returns {vec4} out
	 */
	vec4.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};
	
	/**
	 * Set the components of a vec4 to the given values
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} out
	 */
	vec4.set = function(out, x, y, z, w) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};
	
	/**
	 * Adds two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    return out;
	};
	
	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    return out;
	};
	
	/**
	 * Alias for {@link vec4.subtract}
	 * @function
	 */
	vec4.sub = vec4.subtract;
	
	/**
	 * Multiplies two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    out[3] = a[3] * b[3];
	    return out;
	};
	
	/**
	 * Alias for {@link vec4.multiply}
	 * @function
	 */
	vec4.mul = vec4.multiply;
	
	/**
	 * Divides two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    out[3] = a[3] / b[3];
	    return out;
	};
	
	/**
	 * Alias for {@link vec4.divide}
	 * @function
	 */
	vec4.div = vec4.divide;
	
	/**
	 * Math.ceil the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to ceil
	 * @returns {vec4} out
	 */
	vec4.ceil = function (out, a) {
	    out[0] = Math.ceil(a[0]);
	    out[1] = Math.ceil(a[1]);
	    out[2] = Math.ceil(a[2]);
	    out[3] = Math.ceil(a[3]);
	    return out;
	};
	
	/**
	 * Math.floor the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to floor
	 * @returns {vec4} out
	 */
	vec4.floor = function (out, a) {
	    out[0] = Math.floor(a[0]);
	    out[1] = Math.floor(a[1]);
	    out[2] = Math.floor(a[2]);
	    out[3] = Math.floor(a[3]);
	    return out;
	};
	
	/**
	 * Returns the minimum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    out[3] = Math.min(a[3], b[3]);
	    return out;
	};
	
	/**
	 * Returns the maximum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	vec4.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    out[3] = Math.max(a[3], b[3]);
	    return out;
	};
	
	/**
	 * Math.round the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to round
	 * @returns {vec4} out
	 */
	vec4.round = function (out, a) {
	    out[0] = Math.round(a[0]);
	    out[1] = Math.round(a[1]);
	    out[2] = Math.round(a[2]);
	    out[3] = Math.round(a[3]);
	    return out;
	};
	
	/**
	 * Scales a vec4 by a scalar number
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec4} out
	 */
	vec4.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    return out;
	};
	
	/**
	 * Adds two vec4's after scaling the second operand by a scalar value
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec4} out
	 */
	vec4.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    return out;
	};
	
	/**
	 * Calculates the euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec4.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};
	
	/**
	 * Alias for {@link vec4.distance}
	 * @function
	 */
	vec4.dist = vec4.distance;
	
	/**
	 * Calculates the squared euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec4.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return x*x + y*y + z*z + w*w;
	};
	
	/**
	 * Alias for {@link vec4.squaredDistance}
	 * @function
	 */
	vec4.sqrDist = vec4.squaredDistance;
	
	/**
	 * Calculates the length of a vec4
	 *
	 * @param {vec4} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec4.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};
	
	/**
	 * Alias for {@link vec4.length}
	 * @function
	 */
	vec4.len = vec4.length;
	
	/**
	 * Calculates the squared length of a vec4
	 *
	 * @param {vec4} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec4.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return x*x + y*y + z*z + w*w;
	};
	
	/**
	 * Alias for {@link vec4.squaredLength}
	 * @function
	 */
	vec4.sqrLen = vec4.squaredLength;
	
	/**
	 * Negates the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to negate
	 * @returns {vec4} out
	 */
	vec4.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = -a[3];
	    return out;
	};
	
	/**
	 * Returns the inverse of the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to invert
	 * @returns {vec4} out
	 */
	vec4.inverse = function(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  out[3] = 1.0 / a[3];
	  return out;
	};
	
	/**
	 * Normalize a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to normalize
	 * @returns {vec4} out
	 */
	vec4.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    var len = x*x + y*y + z*z + w*w;
	    if (len > 0) {
	        len = 1 / Math.sqrt(len);
	        out[0] = x * len;
	        out[1] = y * len;
	        out[2] = z * len;
	        out[3] = w * len;
	    }
	    return out;
	};
	
	/**
	 * Calculates the dot product of two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec4.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	};
	
	/**
	 * Performs a linear interpolation between two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec4} out
	 */
	vec4.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2],
	        aw = a[3];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    out[3] = aw + t * (b[3] - aw);
	    return out;
	};
	
	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec4} out
	 */
	vec4.random = function (out, scale) {
	    scale = scale || 1.0;
	
	    //TODO: This is a pretty awful way of doing this. Find something better.
	    out[0] = glMatrix.RANDOM();
	    out[1] = glMatrix.RANDOM();
	    out[2] = glMatrix.RANDOM();
	    out[3] = glMatrix.RANDOM();
	    vec4.normalize(out, out);
	    vec4.scale(out, out, scale);
	    return out;
	};
	
	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec4} out
	 */
	vec4.transformMat4 = function(out, a, m) {
	    var x = a[0], y = a[1], z = a[2], w = a[3];
	    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	    return out;
	};
	
	/**
	 * Transforms the vec4 with a quat
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec4} out
	 */
	vec4.transformQuat = function(out, a, q) {
	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],
	
	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;
	
	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    out[3] = a[3];
	    return out;
	};
	
	/**
	 * Perform some operation over an array of vec4s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec4.forEach = (function() {
	    var vec = vec4.create();
	
	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 4;
	        }
	
	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }
	
	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
	        }
	        
	        return a;
	    };
	})();
	
	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec4} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec4.str = function (a) {
	    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};
	
	/**
	 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {vec4} a The first vector.
	 * @param {vec4} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	vec4.exactEquals = function (a, b) {
	    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
	};
	
	/**
	 * Returns whether or not the vectors have approximately the same elements in the same position.
	 *
	 * @param {vec4} a The first vector.
	 * @param {vec4} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	vec4.equals = function (a, b) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
	    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
	    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
	            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
	            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
	            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
	};
	
	module.exports = vec4;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */
	
	var glMatrix = __webpack_require__(220);
	
	/**
	 * @class 2 Dimensional Vector
	 * @name vec2
	 */
	var vec2 = {};
	
	/**
	 * Creates a new, empty vec2
	 *
	 * @returns {vec2} a new 2D vector
	 */
	vec2.create = function() {
	    var out = new glMatrix.ARRAY_TYPE(2);
	    out[0] = 0;
	    out[1] = 0;
	    return out;
	};
	
	/**
	 * Creates a new vec2 initialized with values from an existing vector
	 *
	 * @param {vec2} a vector to clone
	 * @returns {vec2} a new 2D vector
	 */
	vec2.clone = function(a) {
	    var out = new glMatrix.ARRAY_TYPE(2);
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};
	
	/**
	 * Creates a new vec2 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} a new 2D vector
	 */
	vec2.fromValues = function(x, y) {
	    var out = new glMatrix.ARRAY_TYPE(2);
	    out[0] = x;
	    out[1] = y;
	    return out;
	};
	
	/**
	 * Copy the values from one vec2 to another
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the source vector
	 * @returns {vec2} out
	 */
	vec2.copy = function(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    return out;
	};
	
	/**
	 * Set the components of a vec2 to the given values
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} out
	 */
	vec2.set = function(out, x, y) {
	    out[0] = x;
	    out[1] = y;
	    return out;
	};
	
	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.add = function(out, a, b) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    return out;
	};
	
	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.subtract = function(out, a, b) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    return out;
	};
	
	/**
	 * Alias for {@link vec2.subtract}
	 * @function
	 */
	vec2.sub = vec2.subtract;
	
	/**
	 * Multiplies two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.multiply = function(out, a, b) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    return out;
	};
	
	/**
	 * Alias for {@link vec2.multiply}
	 * @function
	 */
	vec2.mul = vec2.multiply;
	
	/**
	 * Divides two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.divide = function(out, a, b) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    return out;
	};
	
	/**
	 * Alias for {@link vec2.divide}
	 * @function
	 */
	vec2.div = vec2.divide;
	
	/**
	 * Math.ceil the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to ceil
	 * @returns {vec2} out
	 */
	vec2.ceil = function (out, a) {
	    out[0] = Math.ceil(a[0]);
	    out[1] = Math.ceil(a[1]);
	    return out;
	};
	
	/**
	 * Math.floor the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to floor
	 * @returns {vec2} out
	 */
	vec2.floor = function (out, a) {
	    out[0] = Math.floor(a[0]);
	    out[1] = Math.floor(a[1]);
	    return out;
	};
	
	/**
	 * Returns the minimum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.min = function(out, a, b) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    return out;
	};
	
	/**
	 * Returns the maximum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	vec2.max = function(out, a, b) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    return out;
	};
	
	/**
	 * Math.round the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to round
	 * @returns {vec2} out
	 */
	vec2.round = function (out, a) {
	    out[0] = Math.round(a[0]);
	    out[1] = Math.round(a[1]);
	    return out;
	};
	
	/**
	 * Scales a vec2 by a scalar number
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec2} out
	 */
	vec2.scale = function(out, a, b) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    return out;
	};
	
	/**
	 * Adds two vec2's after scaling the second operand by a scalar value
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec2} out
	 */
	vec2.scaleAndAdd = function(out, a, b, scale) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    return out;
	};
	
	/**
	 * Calculates the euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} distance between a and b
	 */
	vec2.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return Math.sqrt(x*x + y*y);
	};
	
	/**
	 * Alias for {@link vec2.distance}
	 * @function
	 */
	vec2.dist = vec2.distance;
	
	/**
	 * Calculates the squared euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	vec2.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1];
	    return x*x + y*y;
	};
	
	/**
	 * Alias for {@link vec2.squaredDistance}
	 * @function
	 */
	vec2.sqrDist = vec2.squaredDistance;
	
	/**
	 * Calculates the length of a vec2
	 *
	 * @param {vec2} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	vec2.length = function (a) {
	    var x = a[0],
	        y = a[1];
	    return Math.sqrt(x*x + y*y);
	};
	
	/**
	 * Alias for {@link vec2.length}
	 * @function
	 */
	vec2.len = vec2.length;
	
	/**
	 * Calculates the squared length of a vec2
	 *
	 * @param {vec2} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	vec2.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1];
	    return x*x + y*y;
	};
	
	/**
	 * Alias for {@link vec2.squaredLength}
	 * @function
	 */
	vec2.sqrLen = vec2.squaredLength;
	
	/**
	 * Negates the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to negate
	 * @returns {vec2} out
	 */
	vec2.negate = function(out, a) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    return out;
	};
	
	/**
	 * Returns the inverse of the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to invert
	 * @returns {vec2} out
	 */
	vec2.inverse = function(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  return out;
	};
	
	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to normalize
	 * @returns {vec2} out
	 */
	vec2.normalize = function(out, a) {
	    var x = a[0],
	        y = a[1];
	    var len = x*x + y*y;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	    }
	    return out;
	};
	
	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	vec2.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	};
	
	/**
	 * Computes the cross product of two vec2's
	 * Note that the cross product must by definition produce a 3D vector
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec3} out
	 */
	vec2.cross = function(out, a, b) {
	    var z = a[0] * b[1] - a[1] * b[0];
	    out[0] = out[1] = 0;
	    out[2] = z;
	    return out;
	};
	
	/**
	 * Performs a linear interpolation between two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec2} out
	 */
	vec2.lerp = function (out, a, b, t) {
	    var ax = a[0],
	        ay = a[1];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    return out;
	};
	
	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec2} out
	 */
	vec2.random = function (out, scale) {
	    scale = scale || 1.0;
	    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
	    out[0] = Math.cos(r) * scale;
	    out[1] = Math.sin(r) * scale;
	    return out;
	};
	
	/**
	 * Transforms the vec2 with a mat2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat2 = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[2] * y;
	    out[1] = m[1] * x + m[3] * y;
	    return out;
	};
	
	/**
	 * Transforms the vec2 with a mat2d
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2d} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat2d = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[2] * y + m[4];
	    out[1] = m[1] * x + m[3] * y + m[5];
	    return out;
	};
	
	/**
	 * Transforms the vec2 with a mat3
	 * 3rd vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat3} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat3 = function(out, a, m) {
	    var x = a[0],
	        y = a[1];
	    out[0] = m[0] * x + m[3] * y + m[6];
	    out[1] = m[1] * x + m[4] * y + m[7];
	    return out;
	};
	
	/**
	 * Transforms the vec2 with a mat4
	 * 3rd vector component is implicitly '0'
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec2} out
	 */
	vec2.transformMat4 = function(out, a, m) {
	    var x = a[0], 
	        y = a[1];
	    out[0] = m[0] * x + m[4] * y + m[12];
	    out[1] = m[1] * x + m[5] * y + m[13];
	    return out;
	};
	
	/**
	 * Perform some operation over an array of vec2s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	vec2.forEach = (function() {
	    var vec = vec2.create();
	
	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 2;
	        }
	
	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }
	
	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1];
	            fn(vec, vec, arg);
	            a[i] = vec[0]; a[i+1] = vec[1];
	        }
	        
	        return a;
	    };
	})();
	
	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec2} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	vec2.str = function (a) {
	    return 'vec2(' + a[0] + ', ' + a[1] + ')';
	};
	
	/**
	 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
	 *
	 * @param {vec2} a The first vector.
	 * @param {vec2} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	vec2.exactEquals = function (a, b) {
	    return a[0] === b[0] && a[1] === b[1];
	};
	
	/**
	 * Returns whether or not the vectors have approximately the same elements in the same position.
	 *
	 * @param {vec2} a The first vector.
	 * @param {vec2} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	vec2.equals = function (a, b) {
	    var a0 = a[0], a1 = a[1];
	    var b0 = b[0], b1 = b[1];
	    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
	            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
	};
	
	module.exports = vec2;


/***/ },
/* 229 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = FrameHistory;
	
	function FrameHistory() {
	    this.changeTimes = new Float64Array(256);
	    this.changeOpacities = new Uint8Array(256);
	    this.opacities = new Uint8ClampedArray(256);
	    this.array = new Uint8Array(this.opacities.buffer);
	
	    this.fadeDuration = 300;
	    this.previousZoom = 0;
	    this.firstFrame = true;
	}
	
	FrameHistory.prototype.record = function(zoom) {
	    var now = Date.now();
	
	    if (this.firstFrame) {
	        now = 0;
	        this.firstFrame = false;
	    }
	
	    zoom = Math.floor(zoom * 10);
	
	    var z;
	    if (zoom < this.previousZoom) {
	        for (z = zoom + 1; z <= this.previousZoom; z++) {
	            this.changeTimes[z] = now;
	            this.changeOpacities[z] = this.opacities[z];
	        }
	    } else {
	        for (z = zoom; z > this.previousZoom; z--) {
	            this.changeTimes[z] = now;
	            this.changeOpacities[z] = this.opacities[z];
	        }
	    }
	
	    for (z = 0; z < 256; z++) {
	        var timeSince = now - this.changeTimes[z];
	        var opacityChange = timeSince / this.fadeDuration * 255;
	        if (z <= zoom) {
	            this.opacities[z] = this.changeOpacities[z] + opacityChange;
	        } else {
	            this.opacities[z] = this.changeOpacities[z] - opacityChange;
	        }
	    }
	
	    this.changed = true;
	    this.previousZoom = zoom;
	};
	
	FrameHistory.prototype.bind = function(gl) {
	    if (!this.texture) {
	        this.texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, 256, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this.array);
	
	    } else {
	        gl.bindTexture(gl.TEXTURE_2D, this.texture);
	        if (this.changed) {
	            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 256, 1, gl.ALPHA, gl.UNSIGNED_BYTE, this.array);
	            this.changed = false;
	        }
	    }
	};


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Bucket = __webpack_require__(157);
	
	/**
	 * Converts a pixel value at a the given zoom level to tile units.
	 *
	 * The shaders mostly calculate everything in tile units so style
	 * properties need to be converted from pixels to tile units using this.
	 *
	 * For example, a translation by 30 pixels at zoom 6.5 will be a
	 * translation by pixelsToTileUnits(30, 6.5) tile units.
	 *
	 * @param {object} tile a {Tile object} will work well, but any object that follows the format {coord: {TileCord object}, tileSize: {number}} will work
	 * @param {number} pixelValue
	 * @param {number} z
	 * @returns {number} value in tile units
	 * @private
	 */
	module.exports = function(tile, pixelValue, z) {
	    return pixelValue * (Bucket.EXTENT / (tile.tileSize * Math.pow(2, z - tile.coord.z)));
	};
	


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var path = __webpack_require__(232);
	var assert = __webpack_require__(160);
	var util = __webpack_require__(82);
	
	// readFileSync calls must be written out long-form for brfs.
	var definitions = {
	    debug: {
	        fragmentSource: "precision mediump float;\n\nuniform lowp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
	        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n}\n"
	    },
	    fill: {
	        fragmentSource: "precision mediump float;\n\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\n\nvoid main() {\n    gl_FragColor = u_color * u_opacity;\n}\n",
	        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n"
	    },
	    circle: {
	        fragmentSource: "precision mediump float;\n\nuniform lowp float u_blur;\nuniform lowp float u_opacity;\n\nvarying lowp vec4 v_color;\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\n\nvoid main() {\n    float t = smoothstep(1.0 - max(u_blur, v_antialiasblur), 1.0, length(v_extrude));\n    gl_FragColor = v_color * (1.0 - t) * u_opacity;\n}\n",
	        vertexSource: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_devicepixelratio;\n\nattribute vec2 a_pos;\n\n#ifdef ATTRIBUTE_A_COLOR\nattribute lowp vec4 a_color;\n#else\nuniform lowp vec4 a_color;\n#endif\n\n#ifdef ATTRIBUTE_A_RADIUS\nattribute mediump float a_radius;\n#else\nuniform mediump float a_radius;\n#endif\n\nvarying vec2 v_extrude;\nvarying lowp vec4 v_color;\nvarying lowp float v_antialiasblur;\n\nvoid main(void) {\n\n#ifdef ATTRIBUTE_A_RADIUS\n    mediump float radius = a_radius / 10.0;\n#else\n    mediump float radius = a_radius;\n#endif\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    v_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    vec4 extrude = u_exmatrix * vec4(v_extrude * radius, 0, 0);\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5), 0, 1);\n\n    // gl_Position is divided by gl_Position.w after this shader runs.\n    // Multiply the extrude by it so that it isn't affected by it.\n    gl_Position += extrude * gl_Position.w;\n\n#ifdef ATTRIBUTE_A_COLOR\n    v_color = a_color / 255.0;\n#else\n    v_color = a_color;\n#endif\n\n    // This is a minimum blur distance that serves as a faux-antialiasing for\n    // the circle. since blur is a ratio of the circle's size and the intent is\n    // to keep the blur at roughly 1px, the two are inversely related.\n    v_antialiasblur = 1.0 / u_devicepixelratio / radius;\n}\n"
	    },
	    line: {
	        fragmentSource: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform float u_blur;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    gl_FragColor = u_color * (alpha * u_opacity);\n}\n",
	        vertexSource: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_ratio;\nuniform mediump vec2 u_linewidth;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
	    },
	    linepattern: {
	        fragmentSource: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform float u_point;\nuniform float u_blur;\n\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_fade;\nuniform float u_opacity;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n    float y_a = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * u_linewidth.s / u_pattern_size_b.y);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, vec2(x_a, y_a));\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos), texture2D(u_image, pos2), u_fade);\n\n    alpha *= u_opacity;\n\n    gl_FragColor = color * alpha;\n}\n",
	        vertexSource: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump vec2 u_linewidth;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 extrude = a_extrude * scale;\n    mediump vec2 dist = u_linewidth.s * extrude;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n    v_linesofar = a_linesofar;\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
	    },
	    linesdfpattern: {
	        fragmentSource: "precision mediump float;\n\nuniform vec2 u_linewidth;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform float u_blur;\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * u_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (u_linewidth.t - blur), u_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma, 0.5 + u_sdfgamma, sdfdist);\n\n    gl_FragColor = u_color * (alpha * u_opacity);\n}\n",
	        vertexSource: "precision highp float;\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump vec2 u_linewidth;\nuniform mediump float u_ratio;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec4 dist = vec4(u_linewidth.s * a_extrude * scale, 0.0, 0.0);\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist.xy) / u_ratio, 0.0, 1.0);\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
	    },
	    outline: {
	        fragmentSource: "precision mediump float;\n\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    gl_FragColor = u_color * (alpha * u_opacity);\n}\n",
	        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy/gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
	    },
	    outlinepattern: {
	        fragmentSource: "precision mediump float;\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\nvoid main() {\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    // find distance to outline for alpha interpolation\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    \n\n    gl_FragColor = mix(color1, color2, u_mix) * alpha * u_opacity;\n}\n",
	        vertexSource: "precision highp float;\n\nuniform vec2 u_patternscale_a;\nuniform vec2 u_patternscale_b;\nuniform vec2 u_offset_a;\nuniform vec2 u_offset_b;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos_a = u_patternscale_a * a_pos + u_offset_a;\n    v_pos_b = u_patternscale_b * a_pos + u_offset_b;\n    v_pos = (gl_Position.xy/gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
	    },
	    pattern: {
	        fragmentSource: "precision mediump float;\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * u_opacity;\n}\n",
	        vertexSource: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform vec2 u_patternscale_a;\nuniform vec2 u_patternscale_b;\nuniform vec2 u_offset_a;\nuniform vec2 u_offset_b;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos_a = u_patternscale_a * a_pos + u_offset_a;\n    v_pos_b = u_patternscale_b * a_pos + u_offset_b;\n}\n"
	    },
	    raster: {
	        fragmentSource: "precision mediump float;\n\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    vec4 color = color0 * u_opacity0 + color1 * u_opacity1;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb), color.a);\n}\n",
	        vertexSource: "precision highp float;\n\nuniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos0 = (((a_texture_pos / 32767.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n"
	    },
	    icon: {
	        fragmentSource: "precision mediump float;\n\nuniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp float u_opacity;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    lowp float alpha = texture2D(u_fadetexture, v_fade_tex).a * u_opacity;\n    gl_FragColor = texture2D(u_texture, v_tex) * alpha;\n}\n",
	        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform mediump float u_zoom;\nuniform bool u_skewed;\nuniform float u_extra;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    mediump float a_labelminzoom = a_data1[2];\n    mediump vec2 a_zoom = a_data2.st;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    float a_fadedist = 10.0;\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    if (u_skewed) {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, 0, 0);\n        gl_Position = u_matrix * vec4(a_pos + extrude.xy, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, z, 0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + extrude;\n    }\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"
	    },
	    sdf: {
	        fragmentSource: "precision mediump float;\n\nuniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform lowp float u_buffer;\nuniform lowp float u_gamma;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    lowp float dist = texture2D(u_texture, v_tex).a;\n    lowp float fade_alpha = texture2D(u_fadetexture, v_fade_tex).a;\n    lowp float gamma = u_gamma * v_gamma_scale;\n    lowp float alpha = smoothstep(u_buffer - gamma, u_buffer + gamma, dist) * fade_alpha;\n    gl_FragColor = u_color * (alpha * u_opacity);\n}\n",
	        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\n\n\n// matrix is for the vertex position, exmatrix is for rotating and projecting\n// the extrusion vector.\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\n\nuniform mediump float u_zoom;\nuniform bool u_skewed;\nuniform float u_extra;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_tex = a_data1.xy;\n    mediump float a_labelminzoom = a_data1[2];\n    mediump vec2 a_zoom = a_data2.st;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    if (u_skewed) {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, 0, 0);\n        gl_Position = u_matrix * vec4(a_pos + extrude.xy, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        vec4 extrude = u_exmatrix * vec4(a_offset / 64.0, z, 0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + extrude;\n    }\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - y * u_extra);\n    v_gamma_scale = perspective_scale;\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"
	    },
	    collisionbox: {
	        fragmentSource: "precision mediump float;\n\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) * alpha;\n\n    if (v_placement_zoom > u_zoom) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n    }\n\n    if (u_zoom >= v_max_zoom) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) * alpha * 0.25;\n    }\n\n    if (v_placement_zoom >= u_maxzoom) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0) * alpha * 0.2;\n    }\n}\n",
	        vertexSource: "precision highp float;\n\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_scale;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n     gl_Position = u_matrix * vec4(a_pos + a_extrude / u_scale, 0.0, 1.0);\n\n     v_max_zoom = a_data.x;\n     v_placement_zoom = a_data.y;\n}\n"
	    }
	};
	
	module.exports._createProgram = function(name, macros) {
	    var gl = this.gl;
	    var program = gl.createProgram();
	    var definition = definitions[name];
	
	    var defines = '';
	    if (macros) {
	        for (var m = 0; m < macros.length; m++) {
	            defines += '#define ' + macros[m] + '\n';
	        }
	    }
	
	    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	    gl.shaderSource(fragmentShader, defines + definition.fragmentSource);
	    gl.compileShader(fragmentShader);
	    assert(gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(fragmentShader));
	    gl.attachShader(program, fragmentShader);
	
	    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	    gl.shaderSource(vertexShader, defines + definition.vertexSource);
	    gl.compileShader(vertexShader);
	    assert(gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(vertexShader));
	    gl.attachShader(program, vertexShader);
	
	    gl.linkProgram(program);
	    assert(gl.getProgramParameter(program, gl.LINK_STATUS), gl.getProgramInfoLog(program));
	
	    var attributes = {};
	    var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	    for (var i = 0; i < numAttributes; i++) {
	        var attribute = gl.getActiveAttrib(program, i);
	        attributes[attribute.name] = i;
	    }
	
	    var uniforms = {};
	    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	    for (var ui = 0; ui < numUniforms; ui++) {
	        var uniform = gl.getActiveUniform(program, ui);
	        uniforms[uniform.name] = gl.getUniformLocation(program, uniform.name);
	    }
	
	    return util.extend({
	        program: program,
	        definition: definition,
	        attributes: attributes,
	        numAttributes: numAttributes
	    }, attributes, uniforms);
	};
	
	module.exports._createProgramCached = function(name, macros) {
	    this.cache = this.cache || {};
	    var key = JSON.stringify({name: name, macros: macros});
	    if (!this.cache[key]) {
	        this.cache[key] = this._createProgram(name, macros);
	    }
	    return this.cache[key];
	};
	
	module.exports.useProgram = function (nextProgramName, macros) {
	    var gl = this.gl;
	
	    var nextProgram = this._createProgramCached(nextProgramName, macros);
	    var previousProgram = this.currentProgram;
	
	    if (previousProgram !== nextProgram) {
	        gl.useProgram(nextProgram.program);
	
	        var numNextAttributes = nextProgram.numAttributes;
	        var numPrevAttributes = previousProgram ? previousProgram.numAttributes : 0;
	        var i;
	
	        // Disable all attributes from the previous program that aren't used in
	        // the new program. Note: attribute indices are *not* program specific!
	        // WebGL breaks if you disable attribute 0. http://stackoverflow.com/questions/20305231
	        for (i = Math.max(1, numNextAttributes); i < numPrevAttributes; i++) {
	            gl.disableVertexAttribArray(i);
	        }
	        // Enable all attributes for the new program.
	        for (i = numPrevAttributes; i < numNextAttributes; i++) {
	            gl.enableVertexAttribArray(i);
	        }
	
	        this.currentProgram = nextProgram;
	    }
	
	    return nextProgram;
	};


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var mat4 = __webpack_require__(219).mat4;
	
	var browser = __webpack_require__(85);
	var drawCollisionDebug = __webpack_require__(234);
	var util = __webpack_require__(82);
	var pixelsToTileUnits = __webpack_require__(230);
	
	
	module.exports = drawSymbols;
	
	function drawSymbols(painter, source, layer, coords) {
	    if (painter.isOpaquePass) return;
	
	    var drawAcrossEdges = !(layer.layout['text-allow-overlap'] || layer.layout['icon-allow-overlap'] ||
	        layer.layout['text-ignore-placement'] || layer.layout['icon-ignore-placement']);
	
	    var gl = painter.gl;
	
	    // Disable the stencil test so that labels aren't clipped to tile boundaries.
	    //
	    // Layers with features that may be drawn overlapping aren't clipped. These
	    // layers are sorted in the y direction, and to draw the correct ordering near
	    // tile edges the icons are included in both tiles and clipped when drawing.
	    if (drawAcrossEdges) {
	        gl.disable(gl.STENCIL_TEST);
	    } else {
	        gl.enable(gl.STENCIL_TEST);
	    }
	
	    painter.setDepthSublayer(0);
	    painter.depthMask(false);
	    gl.disable(gl.DEPTH_TEST);
	
	    var tile, elementGroups, bucket;
	
	    for (var i = 0; i < coords.length; i++) {
	        tile = source.getTile(coords[i]);
	        bucket = tile.getBucket(layer);
	        if (!bucket) continue;
	        elementGroups = bucket.elementGroups;
	        if (!elementGroups.icon.length) continue;
	
	        painter.enableTileClippingMask(coords[i]);
	        drawSymbol(painter, layer, coords[i].posMatrix, tile, bucket, elementGroups.icon, 'icon', elementGroups.sdfIcons, elementGroups.iconsNeedLinear);
	    }
	
	    for (var j = 0; j < coords.length; j++) {
	        tile = source.getTile(coords[j]);
	        bucket = tile.getBucket(layer);
	        if (!bucket) continue;
	        elementGroups = bucket.elementGroups;
	        if (!elementGroups.glyph.length) continue;
	
	        painter.enableTileClippingMask(coords[j]);
	        drawSymbol(painter, layer, coords[j].posMatrix, tile, bucket, elementGroups.glyph, 'text', true, false);
	    }
	
	    gl.enable(gl.DEPTH_TEST);
	
	    drawCollisionDebug(painter, source, layer, coords);
	}
	
	var defaultSizes = {
	    icon: 1,
	    text: 24
	};
	
	function drawSymbol(painter, layer, posMatrix, tile, bucket, elementGroups, prefix, sdf, iconsNeedLinear) {
	    var gl = painter.gl;
	
	    posMatrix = painter.translatePosMatrix(posMatrix, tile, layer.paint[prefix + '-translate'], layer.paint[prefix + '-translate-anchor']);
	    var programInterfaceName = prefix === 'text' ? 'glyph' : 'icon';
	
	    var tr = painter.transform;
	    var alignedWithMap = layer.layout[prefix + '-rotation-alignment'] === 'map';
	    var skewed = alignedWithMap;
	    var exMatrix, s, gammaScale;
	
	    if (skewed) {
	        exMatrix = mat4.create();
	        s = pixelsToTileUnits(tile, 1, painter.transform.zoom);
	        gammaScale = 1 / Math.cos(tr._pitch);
	    } else {
	        exMatrix = mat4.clone(painter.transform.exMatrix);
	        s = painter.transform.altitude;
	        gammaScale = 1;
	    }
	    mat4.scale(exMatrix, exMatrix, [s, s, 1]);
	
	    var fontSize = layer.layout[prefix + '-size'];
	    var fontScale = fontSize / defaultSizes[prefix];
	    mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);
	
	    // calculate how much longer the real world distance is at the top of the screen
	    // than at the middle of the screen.
	    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
	    var x = tr.height / 2 * Math.tan(tr._pitch);
	    var extra = (topedgelength + x) / topedgelength - 1;
	
	    var text = prefix === 'text';
	
	    if (!text && !painter.style.sprite.loaded())
	        return;
	
	    gl.activeTexture(gl.TEXTURE0);
	
	    var program = painter.useProgram(sdf ? 'sdf' : 'icon');
	    painter.setPosMatrix(posMatrix);
	    painter.setExMatrix(exMatrix);
	
	    var texsize;
	    if (text) {
	        // use the fonstack used when parsing the tile, not the fontstack
	        // at the current zoom level (layout['text-font']).
	        var fontstack = elementGroups.fontstack;
	        var glyphAtlas = fontstack && painter.glyphSource.getGlyphAtlas(fontstack);
	        if (!glyphAtlas) return;
	
	        glyphAtlas.updateTexture(gl);
	        texsize = [glyphAtlas.width / 4, glyphAtlas.height / 4];
	    } else {
	        var mapMoving = painter.options.rotating || painter.options.zooming;
	        var iconScaled = fontScale !== 1 || browser.devicePixelRatio !== painter.spriteAtlas.pixelRatio || iconsNeedLinear;
	        var iconTransformed = alignedWithMap || painter.transform.pitch;
	        painter.spriteAtlas.bind(gl, sdf || mapMoving || iconScaled || iconTransformed);
	        texsize = [painter.spriteAtlas.width / 4, painter.spriteAtlas.height / 4];
	    }
	
	    gl.uniform1i(program.u_texture, 0);
	    gl.uniform2fv(program.u_texsize, texsize);
	    gl.uniform1i(program.u_skewed, skewed);
	    gl.uniform1f(program.u_extra, extra);
	
	    // adjust min/max zooms for variable font sizes
	    var zoomAdjust = Math.log(fontSize / elementGroups.adjustedSize) / Math.LN2 || 0;
	
	
	    gl.uniform1f(program.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level
	
	    gl.activeTexture(gl.TEXTURE1);
	    painter.frameHistory.bind(gl);
	    gl.uniform1i(program.u_fadetexture, 1);
	
	    var group, count;
	
	    bucket.bindLayoutBuffers(programInterfaceName, gl);
	
	    if (sdf) {
	        var sdfPx = 8;
	        var blurOffset = 1.19;
	        var haloOffset = 6;
	        var gamma = 0.105 * defaultSizes[prefix] / fontSize / browser.devicePixelRatio;
	
	        if (layer.paint[prefix + '-halo-width']) {
	            var haloColor = util.premultiply(layer.paint[prefix + '-halo-color']);
	
	            // Draw halo underneath the text.
	            gl.uniform1f(program.u_gamma, (layer.paint[prefix + '-halo-blur'] * blurOffset / fontScale / sdfPx + gamma) * gammaScale);
	            gl.uniform4fv(program.u_color, haloColor);
	            gl.uniform1f(program.u_opacity, layer.paint[prefix + '-opacity']);
	            gl.uniform1f(program.u_buffer, (haloOffset - layer.paint[prefix + '-halo-width'] / fontScale) / sdfPx);
	
	            for (var j = 0; j < elementGroups.length; j++) {
	                group = elementGroups[j];
	                bucket.setAttribPointers(programInterfaceName, gl, program, group.vertexOffset, layer);
	
	                count = group.elementLength * 3;
	                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, group.elementOffset);
	            }
	        }
	
	        var color = util.premultiply(layer.paint[prefix + '-color']);
	        gl.uniform1f(program.u_gamma, gamma * gammaScale);
	        gl.uniform4fv(program.u_color, color);
	        gl.uniform1f(program.u_opacity, layer.paint[prefix + '-opacity']);
	        gl.uniform1f(program.u_buffer, (256 - 64) / 256);
	
	        for (var i = 0; i < elementGroups.length; i++) {
	            group = elementGroups[i];
	            bucket.bindLayoutBuffers(programInterfaceName, gl);
	            bucket.setAttribPointers(programInterfaceName, gl, program, group.vertexOffset, layer);
	
	            count = group.elementLength * 3;
	            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, group.elementOffset);
	        }
	
	    } else {
	        gl.uniform1f(program.u_opacity, layer.paint['icon-opacity']);
	        for (var k = 0; k < elementGroups.length; k++) {
	            group = elementGroups[k];
	            bucket.setAttribPointers(programInterfaceName, gl, program, group.vertexOffset, layer);
	
	            count = group.elementLength * 3;
	            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, group.elementOffset);
	        }
	    }
	}


/***/ },
/* 234 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = drawCollisionDebug;
	
	function drawCollisionDebug(painter, source, layer, coords) {
	    var gl = painter.gl;
	    gl.enable(gl.STENCIL_TEST);
	    var program = painter.useProgram('collisionbox');
	
	    for (var i = 0; i < coords.length; i++) {
	        var coord = coords[i];
	        var tile = source.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket) continue;
	        var elementGroups = bucket.elementGroups.collisionBox;
	
	        if (!elementGroups) continue;
	        if (!bucket.buffers) continue;
	        if (elementGroups[0].vertexLength === 0) continue;
	
	        bucket.bindLayoutBuffers('collisionBox', gl);
	        bucket.setAttribPointers('collisionBox', gl, program, elementGroups[0].vertexOffset, layer);
	
	        painter.setPosMatrix(coord.posMatrix);
	
	        painter.enableTileClippingMask(coord);
	
	        painter.lineWidth(1);
	        gl.uniform1f(program.u_scale, Math.pow(2, painter.transform.zoom - tile.coord.z));
	        gl.uniform1f(program.u_zoom, painter.transform.zoom * 10);
	        gl.uniform1f(program.u_maxzoom, (tile.coord.z + 1) * 10);
	
	        gl.drawArrays(
	            gl.LINES,
	            elementGroups[0].vertexStartIndex,
	            elementGroups[0].vertexLength
	        );
	
	    }
	}


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var browser = __webpack_require__(85);
	
	module.exports = drawCircles;
	
	function drawCircles(painter, source, layer, coords) {
	    if (painter.isOpaquePass) return;
	
	    var gl = painter.gl;
	
	    painter.setDepthSublayer(0);
	    painter.depthMask(false);
	
	    // Allow circles to be drawn across boundaries, so that
	    // large circles are not clipped to tiles
	    gl.disable(gl.STENCIL_TEST);
	
	    for (var i = 0; i < coords.length; i++) {
	        var coord = coords[i];
	
	        var tile = source.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket) continue;
	        var elementGroups = bucket.elementGroups.circle;
	        if (!elementGroups) continue;
	
	        var program = painter.useProgram('circle', bucket.getProgramMacros('circle', layer));
	
	        gl.uniform1f(program.u_blur, layer.paint['circle-blur']);
	        gl.uniform1f(program.u_devicepixelratio, browser.devicePixelRatio);
	        gl.uniform1f(program.u_opacity, layer.paint['circle-opacity']);
	
	        painter.setPosMatrix(painter.translatePosMatrix(
	            coord.posMatrix,
	            tile,
	            layer.paint['circle-translate'],
	            layer.paint['circle-translate-anchor']
	        ));
	        painter.setExMatrix(painter.transform.exMatrix);
	
	        for (var k = 0; k < elementGroups.length; k++) {
	            var group = elementGroups[k];
	            var count = group.elementLength * 3;
	            bucket.bindLayoutBuffers('circle', gl);
	            bucket.setAttribPointers('circle', gl, program, group.vertexOffset);
	            bucket.bindPaintBuffer(gl, 'circle', layer.id, program, group.vertexStartIndex);
	            bucket.setUniforms(gl, 'circle', program, layer, {zoom: painter.transform.zoom});
	            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, group.elementOffset);
	        }
	    }
	}


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var browser = __webpack_require__(85);
	var mat2 = __webpack_require__(219).mat2;
	var util = __webpack_require__(82);
	var pixelsToTileUnits = __webpack_require__(230);
	
	/**
	 * Draw a line. Under the hood this will read elements from
	 * a tile, dash textures from a lineAtlas, and style properties from a layer.
	 * @param {Object} painter
	 * @param {Object} layer
	 * @param {Object} posMatrix
	 * @param {Tile} tile
	 * @returns {undefined} draws with the painter
	 * @private
	 */
	module.exports = function drawLine(painter, source, layer, coords) {
	    if (painter.isOpaquePass) return;
	    painter.setDepthSublayer(0);
	    painter.depthMask(false);
	
	    var gl = painter.gl;
	    gl.enable(gl.STENCIL_TEST);
	
	    // don't draw zero-width lines
	    if (layer.paint['line-width'] <= 0) return;
	
	    // the distance over which the line edge fades out.
	    // Retina devices need a smaller distance to avoid aliasing.
	    var antialiasing = 1 / browser.devicePixelRatio;
	
	    var blur = layer.paint['line-blur'] + antialiasing;
	    var edgeWidth = layer.paint['line-width'] / 2;
	    var inset = -1;
	    var offset = 0;
	    var shift = 0;
	
	    if (layer.paint['line-gap-width'] > 0) {
	        inset = layer.paint['line-gap-width'] / 2 + antialiasing * 0.5;
	        edgeWidth = layer.paint['line-width'];
	
	        // shift outer lines half a pixel towards the middle to eliminate the crack
	        offset = inset - antialiasing / 2;
	    }
	
	    var outset = offset + edgeWidth + antialiasing / 2 + shift;
	    var color = util.premultiply(layer.paint['line-color']);
	
	    var tr = painter.transform;
	
	    var antialiasingMatrix = mat2.create();
	    mat2.scale(antialiasingMatrix, antialiasingMatrix, [1, Math.cos(tr._pitch)]);
	    mat2.rotate(antialiasingMatrix, antialiasingMatrix, painter.transform.angle);
	
	    // calculate how much longer the real world distance is at the top of the screen
	    // than at the middle of the screen.
	    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
	    var x = tr.height / 2 * Math.tan(tr._pitch);
	    var extra = (topedgelength + x) / topedgelength - 1;
	
	    var dasharray = layer.paint['line-dasharray'];
	    var image = layer.paint['line-pattern'];
	    var program, posA, posB, imagePosA, imagePosB;
	
	    if (dasharray) {
	        program = painter.useProgram('linesdfpattern');
	
	        gl.uniform2fv(program.u_linewidth, [ outset, inset ]);
	        gl.uniform1f(program.u_blur, blur);
	        gl.uniform4fv(program.u_color, color);
	        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);
	
	        posA = painter.lineAtlas.getDash(dasharray.from, layer.layout['line-cap'] === 'round');
	        posB = painter.lineAtlas.getDash(dasharray.to, layer.layout['line-cap'] === 'round');
	
	        gl.uniform1i(program.u_image, 0);
	        gl.activeTexture(gl.TEXTURE0);
	        painter.lineAtlas.bind(gl);
	
	        gl.uniform1f(program.u_tex_y_a, posA.y);
	        gl.uniform1f(program.u_tex_y_b, posB.y);
	        gl.uniform1f(program.u_mix, dasharray.t);
	        gl.uniform1f(program.u_extra, extra);
	        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
	        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);
	
	    } else if (image) {
	        imagePosA = painter.spriteAtlas.getPosition(image.from, true);
	        imagePosB = painter.spriteAtlas.getPosition(image.to, true);
	        if (!imagePosA || !imagePosB) return;
	
	        program = painter.useProgram('linepattern');
	
	        gl.uniform1i(program.u_image, 0);
	        gl.activeTexture(gl.TEXTURE0);
	        painter.spriteAtlas.bind(gl, true);
	
	        gl.uniform2fv(program.u_linewidth, [ outset, inset ]);
	        gl.uniform1f(program.u_blur, blur);
	        gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
	        gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
	        gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
	        gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
	        gl.uniform1f(program.u_fade, image.t);
	        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);
	        gl.uniform1f(program.u_extra, extra);
	        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
	        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);
	
	    } else {
	        program = painter.useProgram('line');
	
	        gl.uniform2fv(program.u_linewidth, [ outset, inset ]);
	        gl.uniform1f(program.u_blur, blur);
	        gl.uniform1f(program.u_extra, extra);
	        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
	        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);
	        gl.uniform4fv(program.u_color, color);
	        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);
	    }
	
	    for (var k = 0; k < coords.length; k++) {
	        var coord = coords[k];
	        var tile = source.getTile(coord);
	        var bucket = tile.getBucket(layer);
	        if (!bucket) continue;
	        var elementGroups = bucket.elementGroups.line;
	        if (!elementGroups) continue;
	
	        painter.enableTileClippingMask(coord);
	
	        // set uniforms that are different for each tile
	        var posMatrix = painter.translatePosMatrix(coord.posMatrix, tile, layer.paint['line-translate'], layer.paint['line-translate-anchor']);
	
	        painter.setPosMatrix(posMatrix);
	        painter.setExMatrix(painter.transform.exMatrix);
	        var ratio = 1 / pixelsToTileUnits(tile, 1, painter.transform.zoom);
	
	        if (dasharray) {
	            var widthA = posA.width * dasharray.fromScale;
	            var widthB = posB.width * dasharray.toScale;
	            var scaleA = [1 / pixelsToTileUnits(tile, widthA, painter.transform.tileZoom), -posA.height / 2];
	            var scaleB = [1 / pixelsToTileUnits(tile, widthB, painter.transform.tileZoom), -posB.height / 2];
	            var gamma = painter.lineAtlas.width / (Math.min(widthA, widthB) * 256 * browser.devicePixelRatio) / 2;
	            gl.uniform1f(program.u_ratio, ratio);
	            gl.uniform2fv(program.u_patternscale_a, scaleA);
	            gl.uniform2fv(program.u_patternscale_b, scaleB);
	            gl.uniform1f(program.u_sdfgamma, gamma);
	
	        } else if (image) {
	            gl.uniform1f(program.u_ratio, ratio);
	            gl.uniform2fv(program.u_pattern_size_a, [
	                pixelsToTileUnits(tile, imagePosA.size[0] * image.fromScale, painter.transform.tileZoom),
	                imagePosB.size[1]
	            ]);
	            gl.uniform2fv(program.u_pattern_size_b, [
	                pixelsToTileUnits(tile, imagePosB.size[0] * image.toScale, painter.transform.tileZoom),
	                imagePosB.size[1]
	            ]);
	
	        } else {
	            gl.uniform1f(program.u_ratio, ratio);
	        }
	
	        bucket.bindLayoutBuffers('line', gl);
	
	        for (var i = 0; i < elementGroups.length; i++) {
	            var group = elementGroups[i];
	            bucket.setAttribPointers('line', gl, program, group.vertexOffset, layer);
	
	            var count = group.elementLength * 3;
	            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, group.elementOffset);
	        }
	    }
	
	};


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var pixelsToTileUnits = __webpack_require__(230);
	
	module.exports = draw;
	
	function draw(painter, source, layer, coords) {
	    var gl = painter.gl;
	    gl.enable(gl.STENCIL_TEST);
	
	    var color = util.premultiply(layer.paint['fill-color']);
	    var image = layer.paint['fill-pattern'];
	    var strokeColor = util.premultiply(layer.paint['fill-outline-color']);
	    var opacity = layer.paint['fill-opacity'];
	
	    // Draw fill
	    if (image ? !painter.isOpaquePass : painter.isOpaquePass === (color[3] === 1 && opacity === 1)) {
	        // Once we switch to earcut drawing we can pull most of the WebGL setup
	        // outside of this coords loop.
	        for (var i = 0; i < coords.length; i++) {
	            drawFill(painter, source, layer, coords[i]);
	        }
	    }
	
	    // Draw stroke
	    if (!painter.isOpaquePass && layer.paint['fill-antialias']) {
	        if (strokeColor || !layer.paint['fill-pattern']) {
	            var outlineProgram = painter.useProgram('outline');
	            painter.lineWidth(2);
	            painter.depthMask(false);
	
	            if (strokeColor) {
	                // If we defined a different color for the fill outline, we are
	                // going to ignore the bits in 0x07 and just care about the global
	                // clipping mask.
	                painter.setDepthSublayer(2);
	            } else {
	                // Otherwise, we only want to drawFill the antialiased parts that are
	                // *outside* the current shape. This is important in case the fill
	                // or stroke color is translucent. If we wouldn't clip to outside
	                // the current shape, some pixels from the outline stroke overlapped
	                // the (non-antialiased) fill.
	                painter.setDepthSublayer(0);
	            }
	            gl.uniform2f(outlineProgram.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
	            gl.uniform4fv(outlineProgram.u_color, strokeColor ? strokeColor : color);
	            gl.uniform1f(outlineProgram.u_opacity, opacity);
	
	            for (var j = 0; j < coords.length; j++) {
	                drawStroke(painter, source, layer, coords[j]);
	            }
	        } else {
	            var outlinePatternProgram = painter.useProgram('outlinepattern');
	            painter.lineWidth(2);
	            painter.depthMask(false);
	            // Otherwise, we only want to drawFill the antialiased parts that are
	            // *outside* the current shape. This is important in case the fill
	            // or stroke color is translucent. If we wouldn't clip to outside
	            // the current shape, some pixels from the outline stroke overlapped
	            // the (non-antialiased) fill.
	            painter.setDepthSublayer(0);
	            gl.uniform2f(outlinePatternProgram.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
	
	            for (var k = 0; k < coords.length; k++) {
	                drawStroke(painter, source, layer, coords[k]);
	            }
	        }
	
	    }
	}
	
	function drawFill(painter, source, layer, coord) {
	    var tile = source.getTile(coord);
	    var bucket = tile.getBucket(layer);
	    if (!bucket) return;
	    var elementGroups = bucket.elementGroups.fill;
	    if (!elementGroups) return;
	
	    var gl = painter.gl;
	
	    var color = util.premultiply(layer.paint['fill-color']);
	    var image = layer.paint['fill-pattern'];
	    var opacity = layer.paint['fill-opacity'];
	
	    var posMatrix = coord.posMatrix;
	    var translatedPosMatrix = painter.translatePosMatrix(posMatrix, tile, layer.paint['fill-translate'], layer.paint['fill-translate-anchor']);
	
	    // Draw the stencil mask.
	    painter.setDepthSublayer(1);
	
	    // We're only drawFilling to the first seven bits (== support a maximum of
	    // 8 overlapping polygons in one place before we get rendering errors).
	    gl.stencilMask(0x07);
	    gl.clear(gl.STENCIL_BUFFER_BIT);
	
	    // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
	    // increasing the lower 7 bits by one if the triangle is a front-facing
	    // triangle. This means that all visible polygons should be in CCW
	    // orientation, while all holes (see below) are in CW orientation.
	    painter.enableTileClippingMask(coord);
	
	    // When we do a nonzero fill, we count the number of times a pixel is
	    // covered by a counterclockwise polygon, and subtract the number of
	    // times it is "uncovered" by a clockwise polygon.
	    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.INCR_WRAP);
	    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.DECR_WRAP);
	
	    // When drawFilling a shape, we first drawFill all shapes to the stencil buffer
	    // and incrementing all areas where polygons are
	    gl.colorMask(false, false, false, false);
	    painter.depthMask(false);
	
	    // Draw the actual triangle fan into the stencil buffer.
	    var fillProgram = painter.useProgram('fill');
	    painter.setPosMatrix(translatedPosMatrix);
	
	    bucket.bindLayoutBuffers('fill', gl);
	
	    for (var i = 0; i < elementGroups.length; i++) {
	        var group = elementGroups[i];
	        bucket.setAttribPointers('fill', gl, fillProgram, group.vertexOffset, layer);
	
	        var count = group.elementLength * 3;
	        gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, group.elementOffset);
	    }
	
	    // Now that we have the stencil mask in the stencil buffer, we can start
	    // writing to the color buffer.
	    gl.colorMask(true, true, true, true);
	    painter.depthMask(true);
	
	    // From now on, we don't want to update the stencil buffer anymore.
	    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	    gl.stencilMask(0x0);
	    var program;
	
	    if (image) {
	        // Draw texture fill
	        program = painter.useProgram('pattern');
	        setPattern(image, opacity, tile, coord, painter, program);
	
	        gl.activeTexture(gl.TEXTURE0);
	        painter.spriteAtlas.bind(gl, true);
	
	    } else {
	        // Draw filling rectangle.
	        program = painter.useProgram('fill');
	        gl.uniform4fv(fillProgram.u_color, color);
	        gl.uniform1f(fillProgram.u_opacity, opacity);
	    }
	
	    painter.setPosMatrix(posMatrix);
	
	    // Only draw regions that we marked
	    gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x07);
	    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
	    gl.vertexAttribPointer(program.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
	    gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);
	
	    gl.stencilMask(0x00);
	}
	
	function drawStroke(painter, source, layer, coord) {
	    var tile = source.getTile(coord);
	    var bucket = tile.getBucket(layer);
	    if (!bucket) return;
	
	    var gl = painter.gl;
	    var elementGroups = bucket.elementGroups.fill;
	
	    var image = layer.paint['fill-pattern'];
	    var opacity = layer.paint['fill-opacity'];
	    var program = image ? painter.useProgram('outlinepattern') : painter.useProgram('outline');
	
	    painter.setPosMatrix(painter.translatePosMatrix(
	        coord.posMatrix,
	        tile,
	        layer.paint['fill-translate'],
	        layer.paint['fill-translate-anchor']
	    ));
	
	    if (image) { setPattern(image, opacity, tile, coord, painter, program); }
	
	    // Draw all buffers
	    bucket.bindLayoutBuffers('fill', gl, {secondElement: true});
	
	    painter.enableTileClippingMask(coord);
	
	    for (var k = 0; k < elementGroups.length; k++) {
	        var group = elementGroups[k];
	        bucket.setAttribPointers('fill', gl, program, group.vertexOffset, layer);
	
	        var count = group.secondElementLength * 2;
	        gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, group.secondElementOffset);
	    }
	}
	
	
	function setPattern(image, opacity, tile, coord, painter, program) {
	    var gl = painter.gl;
	
	    var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
	    var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
	    if (!imagePosA || !imagePosB) return;
	
	
	    gl.uniform1i(program.u_image, 0);
	    gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
	    gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
	    gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
	    gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
	    gl.uniform1f(program.u_opacity, opacity);
	    gl.uniform1f(program.u_mix, image.t);
	
	    var imageSizeScaledA = [
	        (imagePosA.size[0] * image.fromScale),
	        (imagePosA.size[1] * image.fromScale)
	    ];
	    var imageSizeScaledB = [
	        (imagePosB.size[0] * image.toScale),
	        (imagePosB.size[1] * image.toScale)
	    ];
	
	    gl.uniform2fv(program.u_patternscale_a, [
	        1 / pixelsToTileUnits(tile, imageSizeScaledA[0], painter.transform.tileZoom),
	        1 / pixelsToTileUnits(tile, imageSizeScaledA[1], painter.transform.tileZoom)
	    ]);
	
	    gl.uniform2fv(program.u_patternscale_b, [
	        1 / pixelsToTileUnits(tile, imageSizeScaledB[0], painter.transform.tileZoom),
	        1 / pixelsToTileUnits(tile, imageSizeScaledB[1], painter.transform.tileZoom)
	    ]);
	
	    var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom - tile.coord.z);
	
	    // shift images to match at tile boundaries
	    var offsetAx = ((tileSizeAtNearestZoom / imageSizeScaledA[0]) % 1) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
	    var offsetAy = ((tileSizeAtNearestZoom / imageSizeScaledA[1]) % 1) * tile.coord.y;
	
	    var offsetBx = ((tileSizeAtNearestZoom / imageSizeScaledB[0]) % 1) * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
	    var offsetBy = ((tileSizeAtNearestZoom / imageSizeScaledB[1]) % 1) * tile.coord.y;
	
	    gl.uniform2fv(program.u_offset_a, [offsetAx, offsetAy]);
	    gl.uniform2fv(program.u_offset_b, [offsetBx, offsetBy]);
	
	    gl.activeTexture(gl.TEXTURE0);
	    painter.spriteAtlas.bind(gl, true);
	}


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	
	module.exports = drawRaster;
	
	function drawRaster(painter, source, layer, coords) {
	    if (painter.isOpaquePass) return;
	
	    var gl = painter.gl;
	
	    gl.enable(gl.DEPTH_TEST);
	    painter.depthMask(true);
	
	    // Change depth function to prevent double drawing in areas where tiles overlap.
	    gl.depthFunc(gl.LESS);
	
	    var minTileZ = coords.length && coords[0].z;
	
	    for (var i = 0; i < coords.length; i++) {
	        var coord = coords[i];
	        // set the lower zoom level to sublayer 0, and higher zoom levels to higher sublayers
	        painter.setDepthSublayer(coord.z - minTileZ);
	        drawRasterTile(painter, source, layer, coord);
	    }
	
	    gl.depthFunc(gl.LEQUAL);
	}
	
	function drawRasterTile(painter, source, layer, coord) {
	
	    var gl = painter.gl;
	
	    gl.disable(gl.STENCIL_TEST);
	
	    var tile = source.getTile(coord);
	    var posMatrix = painter.transform.calculatePosMatrix(coord, source.maxzoom);
	
	    var program = painter.useProgram('raster');
	    painter.setPosMatrix(posMatrix);
	
	    // color parameters
	    gl.uniform1f(program.u_brightness_low, layer.paint['raster-brightness-min']);
	    gl.uniform1f(program.u_brightness_high, layer.paint['raster-brightness-max']);
	    gl.uniform1f(program.u_saturation_factor, saturationFactor(layer.paint['raster-saturation']));
	    gl.uniform1f(program.u_contrast_factor, contrastFactor(layer.paint['raster-contrast']));
	    gl.uniform3fv(program.u_spin_weights, spinWeights(layer.paint['raster-hue-rotate']));
	
	    var parentTile = tile.source && tile.source._pyramid.findLoadedParent(coord, 0, {}),
	        opacities = getOpacities(tile, parentTile, layer, painter.transform);
	
	    var parentScaleBy, parentTL;
	
	    gl.activeTexture(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_2D, tile.texture);
	
	    if (parentTile) {
	        gl.activeTexture(gl.TEXTURE1);
	        gl.bindTexture(gl.TEXTURE_2D, parentTile.texture);
	
	        parentScaleBy = Math.pow(2, parentTile.coord.z - tile.coord.z);
	        parentTL = [tile.coord.x * parentScaleBy % 1, tile.coord.y * parentScaleBy % 1];
	    } else {
	        opacities[1] = 0;
	    }
	
	    // cross-fade parameters
	    gl.uniform2fv(program.u_tl_parent, parentTL || [0, 0]);
	    gl.uniform1f(program.u_scale_parent, parentScaleBy || 1);
	    gl.uniform1f(program.u_buffer_scale, 1);
	    gl.uniform1f(program.u_opacity0, opacities[0]);
	    gl.uniform1f(program.u_opacity1, opacities[1]);
	    gl.uniform1i(program.u_image0, 0);
	    gl.uniform1i(program.u_image1, 1);
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, tile.boundsBuffer || painter.tileExtentBuffer);
	
	    gl.vertexAttribPointer(program.a_pos,         2, gl.SHORT, false, 8, 0);
	    gl.vertexAttribPointer(program.a_texture_pos, 2, gl.SHORT, false, 8, 4);
	    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	}
	
	function spinWeights(angle) {
	    angle *= Math.PI / 180;
	    var s = Math.sin(angle);
	    var c = Math.cos(angle);
	    return [
	        (2 * c + 1) / 3,
	        (-Math.sqrt(3) * s - c + 1) / 3,
	        (Math.sqrt(3) * s - c + 1) / 3
	    ];
	}
	
	function contrastFactor(contrast) {
	    return contrast > 0 ?
	        1 / (1 - contrast) :
	        1 + contrast;
	}
	
	function saturationFactor(saturation) {
	    return saturation > 0 ?
	        1 - 1 / (1.001 - saturation) :
	        -saturation;
	}
	
	function getOpacities(tile, parentTile, layer, transform) {
	    var opacity = [1, 0];
	    var fadeDuration = layer.paint['raster-fade-duration'];
	
	    if (tile.source && fadeDuration > 0) {
	        var now = new Date().getTime();
	
	        var sinceTile = (now - tile.timeAdded) / fadeDuration;
	        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;
	
	        var idealZ = tile.source._pyramid.coveringZoomLevel(transform);
	        var parentFurther = parentTile ? Math.abs(parentTile.coord.z - idealZ) > Math.abs(tile.coord.z - idealZ) : false;
	
	        if (!parentTile || parentFurther) {
	            // if no parent or parent is older
	            opacity[0] = util.clamp(sinceTile, 0, 1);
	            opacity[1] = 1 - opacity[0];
	        } else {
	            // parent is younger, zooming out
	            opacity[0] = util.clamp(1 - sinceParent, 0, 1);
	            opacity[1] = 1 - opacity[0];
	        }
	    }
	
	    var op = layer.paint['raster-opacity'];
	    opacity[0] *= op;
	    opacity[1] *= op;
	
	    return opacity;
	}


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var TilePyramid = __webpack_require__(207);
	var pyramid = new TilePyramid({ tileSize: 512 });
	var util = __webpack_require__(82);
	var pixelsToTileUnits = __webpack_require__(230);
	
	module.exports = drawBackground;
	
	function drawBackground(painter, source, layer) {
	    var gl = painter.gl;
	    var transform = painter.transform;
	    var color = util.premultiply(layer.paint['background-color']);
	    var image = layer.paint['background-pattern'];
	    var opacity = layer.paint['background-opacity'];
	    var program;
	
	    var imagePosA = image ? painter.spriteAtlas.getPosition(image.from, true) : null;
	    var imagePosB = image ? painter.spriteAtlas.getPosition(image.to, true) : null;
	
	    painter.setDepthSublayer(0);
	    if (imagePosA && imagePosB) {
	
	        if (painter.isOpaquePass) return;
	
	        // Draw texture fill
	        program = painter.useProgram('pattern');
	        gl.uniform1i(program.u_image, 0);
	        gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
	        gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
	        gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
	        gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
	        gl.uniform1f(program.u_opacity, opacity);
	
	        gl.uniform1f(program.u_mix, image.t);
	
	        painter.spriteAtlas.bind(gl, true);
	
	    } else {
	        // Draw filling rectangle.
	        if (painter.isOpaquePass !== (color[3] === 1)) return;
	
	        program = painter.useProgram('fill');
	        gl.uniform4fv(program.u_color, color);
	        gl.uniform1f(program.u_opacity, opacity);
	    }
	
	    gl.disable(gl.STENCIL_TEST);
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
	    gl.vertexAttribPointer(program.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
	
	    // We need to draw the background in tiles in order to use calculatePosMatrix
	    // which applies the projection matrix (transform.projMatrix). Otherwise
	    // the depth and stencil buffers get into a bad state.
	    // This can be refactored into a single draw call once earcut lands and
	    // we don't have so much going on in the stencil buffer.
	    var coords = pyramid.coveringTiles(transform);
	    for (var c = 0; c < coords.length; c++) {
	        var coord = coords[c];
	        var tileSize = 512;
	        // var pixelsToTileUnitsBound = pixelsToTileUnits.bind({coord:coord, tileSize: tileSize});
	        if (imagePosA && imagePosB) {
	            var imageSizeScaledA = [
	                (imagePosA.size[0] * image.fromScale),
	                (imagePosA.size[1] * image.fromScale)
	            ];
	            var imageSizeScaledB = [
	                (imagePosB.size[0] * image.toScale),
	                (imagePosB.size[1] * image.toScale)
	            ];
	            var tile = {coord:coord, tileSize: tileSize};
	
	            gl.uniform2fv(program.u_patternscale_a, [
	                1 / pixelsToTileUnits(tile, imageSizeScaledA[0], painter.transform.tileZoom),
	                1 / pixelsToTileUnits(tile, imageSizeScaledA[1], painter.transform.tileZoom)
	            ]);
	
	            gl.uniform2fv(program.u_patternscale_b, [
	                1 / pixelsToTileUnits(tile, imageSizeScaledB[0], painter.transform.tileZoom),
	                1 / pixelsToTileUnits(tile, imageSizeScaledB[1], painter.transform.tileZoom)
	            ]);
	            var tileSizeAtNearestZoom = tileSize * Math.pow(2, painter.transform.tileZoom - coord.z);
	
	            var offsetAx = ((tileSizeAtNearestZoom / imageSizeScaledA[0]) % 1) * (coord.x + coord.w * Math.pow(2, coord.z));
	            var offsetAy = ((tileSizeAtNearestZoom / imageSizeScaledA[1]) % 1) * coord.y;
	
	            var offsetBx = ((tileSizeAtNearestZoom / imageSizeScaledB[0]) % 1) * (coord.x + coord.w * Math.pow(2, coord.z));
	            var offsetBy = ((tileSizeAtNearestZoom / imageSizeScaledB[1]) % 1) * coord.y;
	
	            gl.uniform2fv(program.u_offset_a, [offsetAx, offsetAy]);
	            gl.uniform2fv(program.u_offset_b, [offsetBx, offsetBy]);
	        }
	
	        painter.setPosMatrix(painter.transform.calculatePosMatrix(coord));
	        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);
	    }
	
	    gl.stencilMask(0x00);
	    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
	}


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var textVertices = __webpack_require__(241);
	var browser = __webpack_require__(85);
	var mat4 = __webpack_require__(219).mat4;
	var EXTENT = __webpack_require__(157).EXTENT;
	
	module.exports = drawDebug;
	
	function drawDebug(painter, source, coords) {
	    if (painter.isOpaquePass) return;
	    if (!painter.options.debug) return;
	
	    for (var i = 0; i < coords.length; i++) {
	        drawDebugTile(painter, source, coords[i]);
	    }
	}
	
	function drawDebugTile(painter, source, coord) {
	    var gl = painter.gl;
	
	    gl.disable(gl.STENCIL_TEST);
	    painter.lineWidth(1 * browser.devicePixelRatio);
	
	    var posMatrix = coord.posMatrix;
	    var program = painter.useProgram('debug');
	    painter.setPosMatrix(posMatrix);
	
	    // draw bounding rectangle
	    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
	    gl.vertexAttribPointer(program.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
	    gl.uniform4f(program.u_color, 1, 0, 0, 1);
	    gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);
	
	    var vertices = textVertices(coord.toString(), 50, 200, 5);
	    gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
	    gl.vertexAttribPointer(program.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
	    gl.uniform4f(program.u_color, 1, 1, 1, 1);
	
	    // Draw the halo with multiple 1px lines instead of one wider line because
	    // the gl spec doesn't guarantee support for lines with width > 1.
	    var tileSize = source.getTile(coord).tileSize;
	    var onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.z) * tileSize);
	    var translations = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
	    for (var i = 0; i < translations.length; i++) {
	        var translation = translations[i];
	        painter.setPosMatrix(mat4.translate([], posMatrix, [onePixel * translation[0], onePixel * translation[1], 0]));
	        gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
	    }
	
	    gl.uniform4f(program.u_color, 0, 0, 0, 1);
	    painter.setPosMatrix(posMatrix);
	    gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
	}


/***/ },
/* 241 */
/***/ function(module, exports) {

	'use strict';
	
	// Font data From Hershey Simplex Font
	// http://paulbourke.net/dataformats/hershey/
	var simplexFont = {
	    " ": [16, []],
	    "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
	    "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
	    "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
	    "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
	    "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
	    "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
	    "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
	    "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
	    ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
	    "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
	    "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
	    ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
	    "-": [26, [4, 9, 22, 9]],
	    ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
	    "/": [22, [20, 25, 2, -7]],
	    "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
	    "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
	    "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
	    "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
	    "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
	    "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
	    "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
	    "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
	    "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
	    "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
	    ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
	    ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
	    "<": [24, [20, 18, 4, 9, 20, 0]],
	    "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
	    ">": [24, [4, 18, 20, 9, 4, 0]],
	    "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
	    "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
	    "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
	    "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
	    "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
	    "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
	    "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
	    "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
	    "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
	    "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
	    "I": [8, [4, 21, 4, 0]],
	    "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
	    "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
	    "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
	    "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
	    "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
	    "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
	    "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
	    "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
	    "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
	    "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
	    "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
	    "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
	    "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
	    "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
	    "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
	    "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
	    "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
	    "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
	    "\\": [14, [0, 21, 14, -3]],
	    "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
	    "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
	    "_": [16, [0, -2, 16, -2]],
	    "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
	    "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
	    "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
	    "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
	    "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
	    "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
	    "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
	    "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
	    "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
	    "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
	    "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
	    "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
	    "l": [8, [4, 21, 4, 0]],
	    "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
	    "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
	    "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
	    "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
	    "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
	    "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
	    "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
	    "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
	    "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
	    "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
	    "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
	    "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
	    "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
	    "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
	    "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
	    "|": [8, [4, 25, 4, -7]],
	    "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
	    "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]
	};
	
	module.exports = function textVertices(text, left, baseline, scale) {
	    scale = scale || 1;
	
	    var strokes = [],
	        i, len, j, len2, glyph, x, y, prev;
	
	    for (i = 0, len = text.length; i < len; i++) {
	        glyph = simplexFont[text[i]];
	        if (!glyph) continue;
	        prev = null;
	
	        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
	            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
	                prev = null;
	
	            } else {
	                x = left + glyph[1][j] * scale;
	                y = baseline - glyph[1][j + 1] * scale;
	                if (prev) {
	                    strokes.push(prev.x, prev.y, x, y);
	                }
	                prev = {x: x, y: y};
	            }
	        }
	        left += glyph[0] * scale;
	    }
	
	    return strokes;
	};


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var LngLat = __webpack_require__(216),
	    Point = __webpack_require__(88),
	    Coordinate = __webpack_require__(84),
	    wrap = __webpack_require__(82).wrap,
	    interp = __webpack_require__(92),
	    TileCoord = __webpack_require__(209),
	    EXTENT = __webpack_require__(157).EXTENT,
	    glmatrix = __webpack_require__(219);
	
	var vec4 = glmatrix.vec4,
	    mat4 = glmatrix.mat4,
	    mat2 = glmatrix.mat2;
	
	module.exports = Transform;
	
	/**
	 * A single transform, generally used for a single tile to be
	 * scaled, rotated, and zoomed.
	 *
	 * @param {number} minZoom
	 * @param {number} maxZoom
	 * @private
	 */
	function Transform(minZoom, maxZoom) {
	    this.tileSize = 512; // constant
	
	    this._minZoom = minZoom || 0;
	    this._maxZoom = maxZoom || 22;
	
	    this.latRange = [-85.05113, 85.05113];
	
	    this.width = 0;
	    this.height = 0;
	    this._center = new LngLat(0, 0);
	    this.zoom = 0;
	    this.angle = 0;
	    this._altitude = 1.5;
	    this._pitch = 0;
	    this._unmodified = true;
	}
	
	Transform.prototype = {
	    get minZoom() { return this._minZoom; },
	    set minZoom(zoom) {
	        if (this._minZoom === zoom) return;
	        this._minZoom = zoom;
	        this.zoom = Math.max(this.zoom, zoom);
	    },
	
	    get maxZoom() { return this._maxZoom; },
	    set maxZoom(zoom) {
	        if (this._maxZoom === zoom) return;
	        this._maxZoom = zoom;
	        this.zoom = Math.min(this.zoom, zoom);
	    },
	
	    get worldSize() {
	        return this.tileSize * this.scale;
	    },
	
	    get centerPoint() {
	        return this.size._div(2);
	    },
	
	    get size() {
	        return new Point(this.width, this.height);
	    },
	
	    get bearing() {
	        return -this.angle / Math.PI * 180;
	    },
	    set bearing(bearing) {
	        var b = -wrap(bearing, -180, 180) * Math.PI / 180;
	        if (this.angle === b) return;
	        this._unmodified = false;
	        this.angle = b;
	        this._calcProjMatrix();
	
	        // 2x2 matrix for rotating points
	        this.rotationMatrix = mat2.create();
	        mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
	    },
	
	    get pitch() {
	        return this._pitch / Math.PI * 180;
	    },
	    set pitch(pitch) {
	        var p = Math.min(60, pitch) / 180 * Math.PI;
	        if (this._pitch === p) return;
	        this._unmodified = false;
	        this._pitch = p;
	        this._calcProjMatrix();
	    },
	
	    get altitude() {
	        return this._altitude;
	    },
	    set altitude(altitude) {
	        var a = Math.max(0.75, altitude);
	        if (this._altitude === a) return;
	        this._unmodified = false;
	        this._altitude = a;
	        this._calcProjMatrix();
	    },
	
	    get zoom() { return this._zoom; },
	    set zoom(zoom) {
	        var z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
	        if (this._zoom === z) return;
	        this._unmodified = false;
	        this._zoom = z;
	        this.scale = this.zoomScale(z);
	        this.tileZoom = Math.floor(z);
	        this.zoomFraction = z - this.tileZoom;
	        this._calcProjMatrix();
	        this._constrain();
	    },
	
	    get center() { return this._center; },
	    set center(center) {
	        if (center.lat === this._center.lat && center.lng === this._center.lng) return;
	        this._unmodified = false;
	        this._center = center;
	        this._calcProjMatrix();
	        this._constrain();
	    },
	
	    resize: function(width, height) {
	        this.width = width;
	        this.height = height;
	
	        // The extrusion matrix
	        this.exMatrix = mat4.create();
	        mat4.ortho(this.exMatrix, 0, width, height, 0, 0, -1);
	
	        this._calcProjMatrix();
	        this._constrain();
	    },
	
	    get unmodified() { return this._unmodified; },
	
	    zoomScale: function(zoom) { return Math.pow(2, zoom); },
	    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },
	
	    project: function(lnglat, worldSize) {
	        return new Point(
	            this.lngX(lnglat.lng, worldSize),
	            this.latY(lnglat.lat, worldSize));
	    },
	
	    unproject: function(point, worldSize) {
	        return new LngLat(
	            this.xLng(point.x, worldSize),
	            this.yLat(point.y, worldSize));
	    },
	
	    get x() { return this.lngX(this.center.lng); },
	    get y() { return this.latY(this.center.lat); },
	
	    get point() { return new Point(this.x, this.y); },
	
	    /**
	     * latitude to absolute x coord
	     * @param {number} lon
	     * @param {number} [worldSize=this.worldSize]
	     * @returns {number} pixel coordinate
	     * @private
	     */
	    lngX: function(lng, worldSize) {
	        return (180 + lng) * (worldSize || this.worldSize) / 360;
	    },
	    /**
	     * latitude to absolute y coord
	     * @param {number} lat
	     * @param {number} [worldSize=this.worldSize]
	     * @returns {number} pixel coordinate
	     * @private
	     */
	    latY: function(lat, worldSize) {
	        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
	        return (180 - y) * (worldSize || this.worldSize) / 360;
	    },
	
	    xLng: function(x, worldSize) {
	        return x * 360 / (worldSize || this.worldSize) - 180;
	    },
	    yLat: function(y, worldSize) {
	        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
	        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
	    },
	
	    panBy: function(offset) {
	        var point = this.centerPoint._add(offset);
	        this.center = this.pointLocation(point);
	    },
	
	    setLocationAtPoint: function(lnglat, point) {
	        var c = this.locationCoordinate(lnglat);
	        var coordAtPoint = this.pointCoordinate(point);
	        var coordCenter = this.pointCoordinate(this.centerPoint);
	        var translate = coordAtPoint._sub(c);
	        this._unmodified = false;
	        this.center = this.coordinateLocation(coordCenter._sub(translate));
	    },
	
	    /**
	     * Given a location, return the screen point that corresponds to it
	     * @param {LngLat} lnglat location
	     * @returns {Point} screen point
	     * @private
	     */
	    locationPoint: function(lnglat) {
	        return this.coordinatePoint(this.locationCoordinate(lnglat));
	    },
	
	    /**
	     * Given a point on screen, return its lnglat
	     * @param {Point} p screen point
	     * @returns {LngLat} lnglat location
	     * @private
	     */
	    pointLocation: function(p) {
	        return this.coordinateLocation(this.pointCoordinate(p));
	    },
	
	    /**
	     * Given a geographical lnglat, return an unrounded
	     * coordinate that represents it at this transform's zoom level and
	     * worldsize.
	     * @param {LngLat} lnglat
	     * @returns {Coordinate}
	     * @private
	     */
	    locationCoordinate: function(lnglat) {
	        var k = this.zoomScale(this.tileZoom) / this.worldSize,
	            ll = LngLat.convert(lnglat);
	
	        return new Coordinate(
	            this.lngX(ll.lng) * k,
	            this.latY(ll.lat) * k,
	            this.tileZoom);
	    },
	
	    /**
	     * Given a Coordinate, return its geographical position.
	     * @param {Coordinate} coord
	     * @returns {LngLat} lnglat
	     * @private
	     */
	    coordinateLocation: function(coord) {
	        var worldSize = this.zoomScale(coord.zoom);
	        return new LngLat(
	            this.xLng(coord.column, worldSize),
	            this.yLat(coord.row, worldSize));
	    },
	
	    pointCoordinate: function(p) {
	
	        var targetZ = 0;
	
	        var matrix = this.coordinatePointMatrix(this.tileZoom);
	        mat4.invert(matrix, matrix);
	
	        if (!matrix) throw new Error("failed to invert matrix");
	
	        // since we don't know the correct projected z value for the point,
	        // unproject two points to get a line and then find the point on that
	        // line with z=0
	
	        var coord0 = [p.x, p.y, 0, 1];
	        var coord1 = [p.x, p.y, 1, 1];
	
	        vec4.transformMat4(coord0, coord0, matrix);
	        vec4.transformMat4(coord1, coord1, matrix);
	
	        var w0 = coord0[3];
	        var w1 = coord1[3];
	        var x0 = coord0[0] / w0;
	        var x1 = coord1[0] / w1;
	        var y0 = coord0[1] / w0;
	        var y1 = coord1[1] / w1;
	        var z0 = coord0[2] / w0;
	        var z1 = coord1[2] / w1;
	
	
	        var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
	
	        return new Coordinate(
	            interp(x0, x1, t),
	            interp(y0, y1, t),
	            this.tileZoom);
	    },
	
	    /**
	     * Given a coordinate, return the screen point that corresponds to it
	     * @param {Coordinate} coord
	     * @returns {Point} screen point
	     * @private
	     */
	    coordinatePoint: function(coord) {
	        var matrix = this.coordinatePointMatrix(coord.zoom);
	        var p = [coord.column, coord.row, 0, 1];
	        vec4.transformMat4(p, p, matrix);
	        return new Point(p[0] / p[3], p[1] / p[3]);
	    },
	
	    coordinatePointMatrix: function(z) {
	        var proj = mat4.copy(new Float64Array(16), this.projMatrix);
	        var scale = this.worldSize / this.zoomScale(z);
	        mat4.scale(proj, proj, [scale, scale, 1]);
	        mat4.multiply(proj, this.getPixelMatrix(), proj);
	        return proj;
	    },
	
	    /**
	     * converts gl coordinates -1..1 to pixels 0..width
	     * @returns {Object} matrix
	     * @private
	     */
	    getPixelMatrix: function() {
	        var m = mat4.create();
	        mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
	        mat4.translate(m, m, [1, -1, 0]);
	        return m;
	    },
	
	    /**
	     * Calculate the posMatrix that, given a tile coordinate, would be used to display the tile on a map.
	     * @param {TileCoord|Coordinate} coord
	     * @param {Number} maxZoom maximum source zoom to account for overscaling
	     * @private
	     */
	    calculatePosMatrix: function(coord, maxZoom) {
	        if (coord instanceof TileCoord) coord = coord.toCoordinate();
	        if (maxZoom === undefined) maxZoom = Infinity;
	
	        // Initialize model-view matrix that converts from the tile coordinates to screen coordinates.
	
	        // if z > maxzoom then the tile is actually a overscaled maxzoom tile,
	        // so calculate the matrix the maxzoom tile would use.
	        var z = Math.min(coord.zoom, maxZoom);
	
	        var scale = this.worldSize / Math.pow(2, z);
	        var posMatrix = new Float64Array(16);
	
	        mat4.identity(posMatrix);
	        mat4.translate(posMatrix, posMatrix, [coord.column * scale, coord.row * scale, 0]);
	        mat4.scale(posMatrix, posMatrix, [ scale / EXTENT, scale / EXTENT, 1 ]);
	        mat4.multiply(posMatrix, this.projMatrix, posMatrix);
	
	        return new Float32Array(posMatrix);
	    },
	
	    _constrain: function() {
	        if (!this.center || !this.width || !this.height || this._constraining) return;
	
	        this._constraining = true;
	
	        var minY, maxY, minX, maxX, sy, sx, x2, y2,
	            size = this.size,
	            unmodified = this._unmodified;
	
	        if (this.latRange) {
	            minY = this.latY(this.latRange[1]);
	            maxY = this.latY(this.latRange[0]);
	            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
	        }
	
	        if (this.lngRange) {
	            minX = this.lngX(this.lngRange[0]);
	            maxX = this.lngX(this.lngRange[1]);
	            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
	        }
	
	        // how much the map should scale to fit the screen into given latitude/longitude ranges
	        var s = Math.max(sx || 0, sy || 0);
	
	        if (s) {
	            this.center = this.unproject(new Point(
	                sx ? (maxX + minX) / 2 : this.x,
	                sy ? (maxY + minY) / 2 : this.y));
	            this.zoom += this.scaleZoom(s);
	            this._unmodified = unmodified;
	            this._constraining = false;
	            return;
	        }
	
	        if (this.latRange) {
	            var y = this.y,
	                h2 = size.y / 2;
	
	            if (y - h2 < minY) y2 = minY + h2;
	            if (y + h2 > maxY) y2 = maxY - h2;
	        }
	
	        if (this.lngRange) {
	            var x = this.x,
	                w2 = size.x / 2;
	
	            if (x - w2 < minX) x2 = minX + w2;
	            if (x + w2 > maxX) x2 = maxX - w2;
	        }
	
	        // pan the map if the screen goes off the range
	        if (x2 !== undefined || y2 !== undefined) {
	            this.center = this.unproject(new Point(
	                x2 !== undefined ? x2 : this.x,
	                y2 !== undefined ? y2 : this.y));
	        }
	
	        this._unmodified = unmodified;
	        this._constraining = false;
	    },
	
	    _calcProjMatrix: function() {
	        var m = new Float64Array(16);
	
	        // Find the distance from the center point to the center top in altitude units using law of sines.
	        var halfFov = Math.atan(0.5 / this.altitude);
	        var topHalfSurfaceDistance = Math.sin(halfFov) * this.altitude / Math.sin(Math.PI / 2 - this._pitch - halfFov);
	
	        // Calculate z value of the farthest fragment that should be rendered.
	        var farZ = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.altitude;
	
	        mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, farZ);
	
	        mat4.translate(m, m, [0, 0, -this.altitude]);
	
	        // After the rotateX, z values are in pixel units. Convert them to
	        // altitude units. 1 altitude unit = the screen height.
	        mat4.scale(m, m, [1, -1, 1 / this.height]);
	
	        mat4.rotateX(m, m, this._pitch);
	        mat4.rotateZ(m, m, this.angle);
	        mat4.translate(m, m, [-this.x, -this.y, 0]);
	
	        this.projMatrix = m;
	    }
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*
	 * Adds positional coordinates to URL hashes. Passed as an option to the map object
	 *
	 * @class mapboxgl.Hash
	 * @returns {Hash} `this`
	 */
	module.exports = Hash;
	
	var util = __webpack_require__(82);
	
	function Hash() {
	    util.bindAll([
	        '_onHashChange',
	        '_updateHash'
	    ], this);
	}
	
	Hash.prototype = {
	    /* Map element to listen for coordinate changes
	     *
	     * @param {Object} map
	     * @returns {Hash} `this`
	     */
	    addTo: function(map) {
	        this._map = map;
	        window.addEventListener('hashchange', this._onHashChange, false);
	        this._map.on('moveend', this._updateHash);
	        return this;
	    },
	
	    /* Removes hash
	     *
	     * @returns {Popup} `this`
	     */
	    remove: function() {
	        window.removeEventListener('hashchange', this._onHashChange, false);
	        this._map.off('moveend', this._updateHash);
	        delete this._map;
	        return this;
	    },
	
	    _onHashChange: function() {
	        var loc = location.hash.replace('#', '').split('/');
	        if (loc.length >= 3) {
	            this._map.jumpTo({
	                center: [+loc[2], +loc[1]],
	                zoom: +loc[0],
	                bearing: +(loc[3] || 0)
	            });
	            return true;
	        }
	        return false;
	    },
	
	    _updateHash: function() {
	        var center = this._map.getCenter(),
	            zoom = this._map.getZoom(),
	            bearing = this._map.getBearing(),
	            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),
	
	            hash = '#' + (Math.round(zoom * 100) / 100) +
	                '/' + center.lat.toFixed(precision) +
	                '/' + center.lng.toFixed(precision) +
	                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');
	
	        window.history.replaceState('', '', hash);
	    }
	};


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var handlers = {
	    scrollZoom: __webpack_require__(245),
	    boxZoom: __webpack_require__(246),
	    dragRotate: __webpack_require__(248),
	    dragPan: __webpack_require__(249),
	    keyboard: __webpack_require__(250),
	    doubleClickZoom: __webpack_require__(251),
	    touchZoomRotate: __webpack_require__(252)
	};
	
	var DOM = __webpack_require__(87),
	    util = __webpack_require__(82),
	    Point = __webpack_require__(88);
	
	module.exports = Interaction;
	
	function Interaction(map) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	
	    for (var name in handlers) {
	        map[name] = new handlers[name](map);
	    }
	
	    util.bindHandlers(this);
	}
	
	Interaction.prototype = {
	    enable: function () {
	        var options = this._map.options,
	            el = this._el;
	
	        for (var name in handlers) {
	            if (options[name]) this._map[name].enable();
	        }
	
	        el.addEventListener('mousedown', this._onMouseDown, false);
	        el.addEventListener('mouseup', this._onMouseUp, false);
	        el.addEventListener('mousemove', this._onMouseMove, false);
	        el.addEventListener('touchstart', this._onTouchStart, false);
	        el.addEventListener('touchend', this._onTouchEnd, false);
	        el.addEventListener('touchmove', this._onTouchMove, false);
	        el.addEventListener('touchcancel', this._onTouchCancel, false);
	        el.addEventListener('click', this._onClick, false);
	        el.addEventListener('dblclick', this._onDblClick, false);
	        el.addEventListener('contextmenu', this._onContextMenu, false);
	    },
	
	    disable: function () {
	        var options = this._map.options,
	            el = this._el;
	
	        for (var name in handlers) {
	            if (options[name]) this._map[name].disable();
	        }
	
	        el.removeEventListener('mousedown', this._onMouseDown);
	        el.removeEventListener('mouseup', this._onMouseUp);
	        el.removeEventListener('mousemove', this._onMouseMove);
	        el.removeEventListener('touchstart', this._onTouchStart);
	        el.removeEventListener('touchend', this._onTouchEnd);
	        el.removeEventListener('touchmove', this._onTouchMove);
	        el.removeEventListener('touchcancel', this._onTouchCancel);
	        el.removeEventListener('click', this._onClick);
	        el.removeEventListener('dblclick', this._onDblClick);
	        el.removeEventListener('contextmenu', this._onContextMenu);
	    },
	
	    _onMouseDown: function (e) {
	        this._map.stop();
	        this._startPos = DOM.mousePos(this._el, e);
	        this._fireMouseEvent('mousedown', e);
	    },
	
	    _onMouseUp: function (e) {
	        var map = this._map,
	            rotating = map.dragRotate && map.dragRotate.isActive();
	
	        if (this._contextMenuEvent && !rotating) {
	            this._fireMouseEvent('contextmenu', this._contextMenuEvent);
	        }
	
	        this._contextMenuEvent = null;
	        this._fireMouseEvent('mouseup', e);
	    },
	
	    _onMouseMove: function (e) {
	        var map = this._map,
	            el = this._el;
	
	        if (map.dragPan && map.dragPan.isActive()) return;
	        if (map.dragRotate && map.dragRotate.isActive()) return;
	
	        var target = e.toElement || e.target;
	        while (target && target !== el) target = target.parentNode;
	        if (target !== el) return;
	
	        this._fireMouseEvent('mousemove', e);
	    },
	
	    _onTouchStart: function (e) {
	        this._map.stop();
	        this._fireTouchEvent('touchstart', e);
	
	        if (!e.touches || e.touches.length > 1) return;
	
	        if (!this._tapped) {
	            this._tapped = setTimeout(this._onTouchTimeout, 300);
	
	        } else {
	            clearTimeout(this._tapped);
	            this._tapped = null;
	            this._fireMouseEvent('dblclick', e);
	        }
	    },
	
	    _onTouchMove: function (e) {
	        this._fireTouchEvent('touchmove', e);
	    },
	
	    _onTouchEnd: function (e) {
	        this._fireTouchEvent('touchend', e);
	    },
	
	    _onTouchCancel: function (e) {
	        this._fireTouchEvent('touchcancel', e);
	    },
	
	    _onTouchTimeout: function () {
	        this._tapped = null;
	    },
	
	    _onClick: function (e) {
	        var pos = DOM.mousePos(this._el, e);
	
	        if (pos.equals(this._startPos)) {
	            this._fireMouseEvent('click', e);
	        }
	    },
	
	    _onDblClick: function (e) {
	        this._fireMouseEvent('dblclick', e);
	        e.preventDefault();
	    },
	
	    _onContextMenu: function (e) {
	        this._contextMenuEvent = e;
	        e.preventDefault();
	    },
	
	    _fireMouseEvent: function (type, e) {
	        var pos = DOM.mousePos(this._el, e);
	
	        return this._map.fire(type, {
	            lngLat: this._map.unproject(pos),
	            point: pos,
	            originalEvent: e
	        });
	    },
	
	    _fireTouchEvent: function (type, e) {
	        var touches = DOM.touchPos(this._el, e),
	            singular = touches.reduce(function (prev, curr, i, arr) {
	                return prev.add(curr.div(arr.length));
	            }, new Point(0, 0));
	
	        return this._map.fire(type, {
	            lngLat: this._map.unproject(singular),
	            point: singular,
	            lngLats: touches.map(function(t) { return this._map.unproject(t); }, this),
	            points: touches,
	            originalEvent: e
	        });
	    }
	};
	
	
	/**
	 * When an event [fires]{@link #Evented.fire} as a result of a
	 * user interaction, the event will be called with an EventData
	 * object containing the original DOM event along with coordinates of
	 * the event target.
	 *
	 * @typedef {Object} EventData
	 * @property {Event} originalEvent The original DOM event
	 * @property {Point} point The pixel location of the event
	 * @property {LngLat} lngLat The geographic location of the event
	 * @example
	 * map.on('click', function(data) {
	 *   var e = data && data.originalEvent;
	 *   console.log('got click ' + (e ? 'button = ' + e.button : ''));
	 * });
	 */
	
	/**
	 * Mouse down event.
	 *
	 * @event mousedown
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Mouse up event.
	 *
	 * @event mouseup
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Mouse move event.
	 *
	 * @event mousemove
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Touch start event.
	 *
	 * @event touchstart
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Touch end event.
	 *
	 * @event touchend
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Touch move event.
	 *
	 * @event touchmove
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Touch cancel event.
	 *
	 * @event touchcancel
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Click event.
	 *
	 * @event click
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Double click event.
	 *
	 * @event dblclick
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Context menu event.
	 *
	 * @event contextmenu
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data, if available
	 */
	
	/**
	 * Load event. This event is emitted immediately after all necessary resources have been downloaded
	 * and the first visually complete rendering has occurred.
	 *
	 * @event load
	 * @memberof Map
	 * @instance
	 * @type {Object}
	 */
	
	/**
	 * Move start event. This event is emitted just before the map begins a transition from one
	 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
	 *
	 * @event movestart
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data, if fired interactively
	 */
	
	/**
	 * Move event. This event is emitted repeatedly during animated transitions from one view to
	 * another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
	 *
	 * @event move
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data, if fired interactively
	 */
	
	/**
	 * Move end event. This event is emitted just after the map completes a transition from one
	 * view to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
	 *
	 * @event moveend
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data, if fired interactively
	 */


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var DOM = __webpack_require__(87),
	    browser = __webpack_require__(85),
	    util = __webpack_require__(82);
	
	module.exports = ScrollZoomHandler;
	
	
	var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '',
	    firefox = ua.indexOf('firefox') !== -1,
	    safari = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') === -1;
	
	
	/**
	 * The `ScrollZoomHandler` allows a user to zoom the map by scrolling.
	 * @class ScrollZoomHandler
	 */
	function ScrollZoomHandler(map) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	
	    util.bindHandlers(this);
	}
	
	ScrollZoomHandler.prototype = {
	
	    _enabled: false,
	
	    /**
	     * Returns the current enabled/disabled state of the "scroll to zoom" interaction.
	     * @returns {boolean} enabled state
	     */
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    /**
	     * Enable the "scroll to zoom" interaction.
	     * @example
	     *   map.scrollZoom.enable();
	     */
	    enable: function () {
	        if (this.isEnabled()) return;
	        this._el.addEventListener('wheel', this._onWheel, false);
	        this._el.addEventListener('mousewheel', this._onWheel, false);
	        this._enabled = true;
	    },
	
	    /**
	     * Disable the "scroll to zoom" interaction.
	     * @example
	     *   map.scrollZoom.disable();
	     */
	    disable: function () {
	        if (!this.isEnabled()) return;
	        this._el.removeEventListener('wheel', this._onWheel);
	        this._el.removeEventListener('mousewheel', this._onWheel);
	        this._enabled = false;
	    },
	
	    _onWheel: function (e) {
	        var value;
	
	        if (e.type === 'wheel') {
	            value = e.deltaY;
	            // Firefox doubles the values on retina screens...
	            if (firefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) value /= browser.devicePixelRatio;
	            if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) value *= 40;
	
	        } else if (e.type === 'mousewheel') {
	            value = -e.wheelDeltaY;
	            if (safari) value = value / 3;
	        }
	
	        var now = browser.now(),
	            timeDelta = now - (this._time || 0);
	
	        this._pos = DOM.mousePos(this._el, e);
	        this._time = now;
	
	        if (value !== 0 && (value % 4.000244140625) === 0) {
	            // This one is definitely a mouse wheel event.
	            this._type = 'wheel';
	            // Normalize this value to match trackpad.
	            value = Math.floor(value / 4);
	
	        } else if (value !== 0 && Math.abs(value) < 4) {
	            // This one is definitely a trackpad event because it is so small.
	            this._type = 'trackpad';
	
	        } else if (timeDelta > 400) {
	            // This is likely a new scroll action.
	            this._type = null;
	            this._lastValue = value;
	
	            // Start a timeout in case this was a singular event, and dely it by up to 40ms.
	            this._timeout = setTimeout(this._onTimeout, 40);
	
	        } else if (!this._type) {
	            // This is a repeating event, but we don't know the type of event just yet.
	            // If the delta per time is small, we assume it's a fast trackpad; otherwise we switch into wheel mode.
	            this._type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';
	
	            // Make sure our delayed event isn't fired again, because we accumulate
	            // the previous event (which was less than 40ms ago) into this event.
	            if (this._timeout) {
	                clearTimeout(this._timeout);
	                this._timeout = null;
	                value += this._lastValue;
	            }
	        }
	
	        // Slow down zoom if shift key is held for more precise zooming
	        if (e.shiftKey && value) value = value / 4;
	
	        // Only fire the callback if we actually know what type of scrolling device the user uses.
	        if (this._type) this._zoom(-value, e);
	
	        e.preventDefault();
	    },
	
	    _onTimeout: function () {
	        this._type = 'wheel';
	        this._zoom(-this._lastValue);
	    },
	
	    _zoom: function (delta, e) {
	        if (delta === 0) return;
	        var map = this._map;
	
	        // Scale by sigmoid of scroll wheel delta.
	        var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
	        if (delta < 0 && scale !== 0) scale = 1 / scale;
	
	        var fromScale = map.ease ? map.ease.to : map.transform.scale,
	            targetZoom = map.transform.scaleZoom(fromScale * scale);
	
	        map.zoomTo(targetZoom, {
	            duration: 0,
	            around: map.unproject(this._pos),
	            delayEndEvents: 200
	        }, { originalEvent: e });
	    }
	};
	
	
	/**
	 * Zoom start event. This event is emitted just before the map begins a transition from one
	 * zoom level to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
	 *
	 * @event zoomstart
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data, if fired interactively
	 */
	
	/**
	 * Zoom event. This event is emitted repeatedly during animated transitions from one zoom level to
	 * another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
	 *
	 * @event zoom
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data, if fired interactively
	 */
	
	/**
	 * Zoom end event. This event is emitted just after the map completes a transition from one
	 * zoom level to another, either as a result of user interaction or the use of methods such as `Map#jumpTo`.
	 *
	 * @event zoomend
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data, if fired interactively
	 */


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var DOM = __webpack_require__(87),
	    LngLatBounds = __webpack_require__(247),
	    util = __webpack_require__(82);
	
	module.exports = BoxZoomHandler;
	
	/**
	 * The `BoxZoomHandler` allows a user to zoom the map to fit a bounding box.
	 * The bounding box is defined by holding `shift` while dragging the cursor.
	 * @class BoxZoomHandler
	 */
	function BoxZoomHandler(map) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	    this._container = map.getContainer();
	
	    util.bindHandlers(this);
	}
	
	BoxZoomHandler.prototype = {
	
	    _enabled: false,
	    _active: false,
	
	    /**
	     * Returns the current enabled/disabled state of the "box zoom" interaction.
	     * @returns {boolean} enabled state
	     */
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    /**
	     * Returns true if the "box zoom" interaction is currently active, i.e. currently being used.
	     * @returns {boolean} active state
	     */
	    isActive: function () {
	        return this._active;
	    },
	
	    /**
	     * Enable the "box zoom" interaction.
	     * @example
	     *   map.boxZoom.enable();
	     */
	    enable: function () {
	        if (this.isEnabled()) return;
	        this._el.addEventListener('mousedown', this._onMouseDown, false);
	        this._enabled = true;
	    },
	
	    /**
	     * Disable the "box zoom" interaction.
	     * @example
	     *   map.boxZoom.disable();
	     */
	    disable: function () {
	        if (!this.isEnabled()) return;
	        this._el.removeEventListener('mousedown', this._onMouseDown);
	        this._enabled = false;
	    },
	
	    _onMouseDown: function (e) {
	        if (!(e.shiftKey && e.button === 0)) return;
	
	        document.addEventListener('mousemove', this._onMouseMove, false);
	        document.addEventListener('keydown', this._onKeyDown, false);
	        document.addEventListener('mouseup', this._onMouseUp, false);
	
	        DOM.disableDrag();
	        this._startPos = DOM.mousePos(this._el, e);
	        this._active = true;
	    },
	
	    _onMouseMove: function (e) {
	        var p0 = this._startPos,
	            p1 = DOM.mousePos(this._el, e);
	
	        if (!this._box) {
	            this._box = DOM.create('div', 'mapboxgl-boxzoom', this._container);
	            this._container.classList.add('mapboxgl-crosshair');
	            this._fireEvent('boxzoomstart', e);
	        }
	
	        var minX = Math.min(p0.x, p1.x),
	            maxX = Math.max(p0.x, p1.x),
	            minY = Math.min(p0.y, p1.y),
	            maxY = Math.max(p0.y, p1.y);
	
	        DOM.setTransform(this._box, 'translate(' + minX + 'px,' + minY + 'px)');
	
	        this._box.style.width = (maxX - minX) + 'px';
	        this._box.style.height = (maxY - minY) + 'px';
	    },
	
	    _onMouseUp: function (e) {
	        if (e.button !== 0) return;
	
	        var p0 = this._startPos,
	            p1 = DOM.mousePos(this._el, e),
	            bounds = new LngLatBounds(this._map.unproject(p0), this._map.unproject(p1));
	
	        this._finish();
	
	        if (p0.x === p1.x && p0.y === p1.y) {
	            this._fireEvent('boxzoomcancel', e);
	        } else {
	            this._map
	                .fitBounds(bounds, {linear: true})
	                .fire('boxzoomend', { originalEvent: e, boxZoomBounds: bounds });
	        }
	    },
	
	    _onKeyDown: function (e) {
	        if (e.keyCode === 27) {
	            this._finish();
	            this._fireEvent('boxzoomcancel', e);
	        }
	    },
	
	    _finish: function () {
	        this._active = false;
	
	        document.removeEventListener('mousemove', this._onMouseMove, false);
	        document.removeEventListener('keydown', this._onKeyDown, false);
	        document.removeEventListener('mouseup', this._onMouseUp, false);
	
	        this._container.classList.remove('mapboxgl-crosshair');
	
	        if (this._box) {
	            this._box.parentNode.removeChild(this._box);
	            this._box = null;
	        }
	
	        DOM.enableDrag();
	    },
	
	    _fireEvent: function (type, e) {
	        return this._map.fire(type, { originalEvent: e });
	    }
	};
	
	
	/**
	 * Boxzoom start event. This event is emitted at the start of a box zoom interaction.
	 *
	 * @event boxzoomstart
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Boxzoom end event. This event is emitted at the end of a box zoom interaction
	 *
	 * @event boxzoomend
	 * @memberof Map
	 * @instance
	 * @type {Object}
	 * @property {Event} originalEvent the original DOM event
	 * @property {LngLatBounds} boxZoomBounds the bounds of the box zoom target
	 */
	
	/**
	 * Boxzoom cancel event.  This event is emitted when the user cancels a box zoom interaction,
	 *   or when the box zoom does not meet the minimum size threshold.
	 *
	 * @event boxzoomcancel
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = LngLatBounds;
	
	var LngLat = __webpack_require__(216);
	
	/**
	 * Creates a bounding box from the given pair of points. If parameteres are omitted, a `null` bounding box is created.
	 *
	 * @class LngLatBounds
	 * @classdesc A representation of rectangular box on the earth, defined by its southwest and northeast points in longitude and latitude.
	 * @param {LngLat} sw southwest
	 * @param {LngLat} ne northeast
	 * @example
	 * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);
	 * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);
	 * var llb = new mapboxgl.LngLatBounds(sw, ne);
	 */
	function LngLatBounds(sw, ne) {
	    if (!sw) {
	        return;
	    } else if (ne) {
	        this.extend(sw).extend(ne);
	    } else if (sw.length === 4) {
	        this.extend([sw[0], sw[1]]).extend([sw[2], sw[3]]);
	    } else {
	        this.extend(sw[0]).extend(sw[1]);
	    }
	}
	
	LngLatBounds.prototype = {
	
	    /**
	     * Extend the bounds to include a given LngLat or LngLatBounds.
	     *
	     * @param {LngLat|LngLatBounds} obj object to extend to
	     * @returns {LngLatBounds} `this`
	     */
	    extend: function(obj) {
	        var sw = this._sw,
	            ne = this._ne,
	            sw2, ne2;
	
	        if (obj instanceof LngLat) {
	            sw2 = obj;
	            ne2 = obj;
	
	        } else if (obj instanceof LngLatBounds) {
	            sw2 = obj._sw;
	            ne2 = obj._ne;
	
	            if (!sw2 || !ne2) return this;
	
	        } else {
	            return obj ? this.extend(LngLat.convert(obj) || LngLatBounds.convert(obj)) : this;
	        }
	
	        if (!sw && !ne) {
	            this._sw = new LngLat(sw2.lng, sw2.lat);
	            this._ne = new LngLat(ne2.lng, ne2.lat);
	
	        } else {
	            sw.lng = Math.min(sw2.lng, sw.lng);
	            sw.lat = Math.min(sw2.lat, sw.lat);
	            ne.lng = Math.max(ne2.lng, ne.lng);
	            ne.lat = Math.max(ne2.lat, ne.lat);
	        }
	
	        return this;
	    },
	
	    /**
	     * Get the point equidistant from this box's corners
	     * @returns {LngLat} centerpoint
	     * @example
	     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
	     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
	     */
	    getCenter: function() {
	        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
	    },
	
	    /**
	     * Get southwest corner
	     * @returns {LngLat} southwest
	     */
	    getSouthWest: function() { return this._sw; },
	
	    /**
	     * Get northeast corner
	     * @returns {LngLat} northeast
	     */
	    getNorthEast: function() { return this._ne; },
	
	    /**
	     * Get northwest corner
	     * @returns {LngLat} northwest
	     */
	    getNorthWest: function() { return new LngLat(this.getWest(), this.getNorth()); },
	
	    /**
	     * Get southeast corner
	     * @returns {LngLat} southeast
	     */
	    getSouthEast: function() { return new LngLat(this.getEast(), this.getSouth()); },
	
	    /**
	     * Get west edge longitude
	     * @returns {number} west
	     */
	    getWest:  function() { return this._sw.lng; },
	
	    /**
	     * Get south edge latitude
	     * @returns {number} south
	     */
	    getSouth: function() { return this._sw.lat; },
	
	    /**
	     * Get east edge longitude
	     * @returns {number} east
	     */
	    getEast:  function() { return this._ne.lng; },
	
	    /**
	     * Get north edge latitude
	     * @returns {number} north
	     */
	    getNorth: function() { return this._ne.lat; },
	
	    /**
	     * Return a `LngLatBounds` as an array
	     *
	     * @returns {array} [lng, lat]
	     * @example
	     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
	     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
	     */
	    toArray: function () {
	        return [this._sw.toArray(), this._ne.toArray()];
	    },
	
	    /**
	     * Return a `LngLatBounds` as a string
	     *
	     * @returns {string} "LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))"
	     * @example
	     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
	     * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
	     */
	    toString: function () {
	        return 'LngLatBounds(' + this._sw.toString() + ', ' + this._ne.toString() + ')';
	    }
	};
	
	/**
	 * Convert an array to a `LngLatBounds` object, or return an existing
	 * `LngLatBounds` object unchanged.
	 *
	 * Calls `LngLat#convert` internally to convert arrays as `LngLat` values.
	 *
	 * @param {LngLatBounds|Array<number>|Array<Array<number>>} input input to convert to a LngLatBounds
	 * @returns {LngLatBounds} LngLatBounds object or original input
	 * @example
	 * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
	 * var llb = mapboxgl.LngLatBounds.convert(arr);
	 * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
	 */
	LngLatBounds.convert = function (input) {
	    if (!input || input instanceof LngLatBounds) return input;
	    return new LngLatBounds(input);
	};


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var DOM = __webpack_require__(87),
	    Point = __webpack_require__(88),
	    util = __webpack_require__(82);
	
	module.exports = DragRotateHandler;
	
	var inertiaLinearity = 0.25,
	    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
	    inertiaMaxSpeed = 180, // deg/s
	    inertiaDeceleration = 720; // deg/s^2
	
	
	/**
	 * The `DragRotateHandler` allows a user to rotate the map by clicking and
	 * dragging the cursor while holding the right mouse button or the `ctrl` key.
	 * @class DragRotateHandler
	 */
	function DragRotateHandler(map) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	
	    util.bindHandlers(this);
	}
	
	DragRotateHandler.prototype = {
	
	    _enabled: false,
	    _active: false,
	
	    /**
	     * Returns the current enabled/disabled state of the "drag to rotate" interaction.
	     * @returns {boolean} enabled state
	     */
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    /**
	     * Returns true if the "drag to rotate" interaction is currently active, i.e. currently being used.
	     * @returns {boolean} active state
	     */
	    isActive: function () {
	        return this._active;
	    },
	
	    /**
	     * Enable the "drag to rotate" interaction.
	     * @example
	     *   map.dragRotate.enable();
	     */
	    enable: function () {
	        if (this.isEnabled()) return;
	        this._el.addEventListener('mousedown', this._onDown);
	        this._enabled = true;
	    },
	
	    /**
	     * Disable the "drag to rotate" interaction.
	     * @example
	     *   map.dragRotate.disable();
	     */
	    disable: function () {
	        if (!this.isEnabled()) return;
	        this._el.removeEventListener('mousedown', this._onDown);
	        this._enabled = false;
	    },
	
	    _onDown: function (e) {
	        if (this._ignoreEvent(e)) return;
	        if (this.isActive()) return;
	
	        document.addEventListener('mousemove', this._onMove);
	        document.addEventListener('mouseup', this._onUp);
	
	        this._active = false;
	        this._inertia = [[Date.now(), this._map.getBearing()]];
	        this._startPos = this._pos = DOM.mousePos(this._el, e);
	        this._center = this._map.transform.centerPoint;  // Center of rotation
	
	        // If the first click was too close to the center, move the center of rotation by 200 pixels
	        // in the direction of the click.
	        var startToCenter = this._startPos.sub(this._center),
	            startToCenterDist = startToCenter.mag();
	
	        if (startToCenterDist < 200) {
	            this._center = this._startPos.add(new Point(-200, 0)._rotate(startToCenter.angle()));
	        }
	
	        e.preventDefault();
	    },
	
	    _onMove: function (e) {
	        if (this._ignoreEvent(e)) return;
	
	        if (!this.isActive()) {
	            this._active = true;
	            this._fireEvent('rotatestart', e);
	            this._fireEvent('movestart', e);
	        }
	
	        var map = this._map;
	        map.stop();
	
	        var p1 = this._pos,
	            p2 = DOM.mousePos(this._el, e),
	            center = this._center,
	            bearingDiff = p1.sub(center).angleWith(p2.sub(center)) / Math.PI * 180,
	            bearing = map.getBearing() - bearingDiff,
	            inertia = this._inertia,
	            last = inertia[inertia.length - 1];
	
	        this._drainInertiaBuffer();
	        inertia.push([Date.now(), map._normalizeBearing(bearing, last[1])]);
	
	        map.transform.bearing = bearing;
	
	        this._fireEvent('rotate', e);
	        this._fireEvent('move', e);
	
	        this._pos = p2;
	    },
	
	    _onUp: function (e) {
	        if (this._ignoreEvent(e)) return;
	        document.removeEventListener('mousemove', this._onMove);
	        document.removeEventListener('mouseup', this._onUp);
	
	        if (!this.isActive()) return;
	
	        this._active = false;
	        this._fireEvent('rotateend', e);
	        this._drainInertiaBuffer();
	
	        var map = this._map,
	            mapBearing = map.getBearing(),
	            inertia = this._inertia;
	
	        var finish = function() {
	            if (Math.abs(mapBearing) < map.options.bearingSnap) {
	                map.resetNorth({noMoveStart: true}, { originalEvent: e });
	            } else {
	                this._fireEvent('moveend', e);
	            }
	        }.bind(this);
	
	        if (inertia.length < 2) {
	            finish();
	            return;
	        }
	
	        var first = inertia[0],
	            last = inertia[inertia.length - 1],
	            previous = inertia[inertia.length - 2],
	            bearing = map._normalizeBearing(mapBearing, previous[1]),
	            flingDiff = last[1] - first[1],
	            sign = flingDiff < 0 ? -1 : 1,
	            flingDuration = (last[0] - first[0]) / 1000;
	
	        if (flingDiff === 0 || flingDuration === 0) {
	            finish();
	            return;
	        }
	
	        var speed = Math.abs(flingDiff * (inertiaLinearity / flingDuration));  // deg/s
	        if (speed > inertiaMaxSpeed) {
	            speed = inertiaMaxSpeed;
	        }
	
	        var duration = speed / (inertiaDeceleration * inertiaLinearity),
	            offset = sign * speed * (duration / 2);
	
	        bearing += offset;
	
	        if (Math.abs(map._normalizeBearing(bearing, 0)) < map.options.bearingSnap) {
	            bearing = map._normalizeBearing(0, bearing);
	        }
	
	        map.rotateTo(bearing, {
	            duration: duration * 1000,
	            easing: inertiaEasing,
	            noMoveStart: true
	        }, { originalEvent: e });
	    },
	
	    _fireEvent: function (type, e) {
	        return this._map.fire(type, { originalEvent: e });
	    },
	
	    _ignoreEvent: function (e) {
	        var map = this._map;
	
	        if (map.boxZoom && map.boxZoom.isActive()) return true;
	        if (map.dragPan && map.dragPan.isActive()) return true;
	        if (e.touches) {
	            return (e.touches.length > 1);
	        } else {
	            var buttons = (e.ctrlKey ? 1 : 2),  // ? ctrl+left button : right button
	                button = (e.ctrlKey ? 0 : 2);   // ? ctrl+left button : right button
	            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
	        }
	    },
	
	    _drainInertiaBuffer: function () {
	        var inertia = this._inertia,
	            now = Date.now(),
	            cutoff = 160;   //msec
	
	        while (inertia.length > 0 && now - inertia[0][0] > cutoff)
	            inertia.shift();
	    }
	
	};
	
	
	/**
	 * Rotate start event. This event is emitted at the start of a user-initiated rotate interaction.
	 *
	 * @event rotatestart
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Rotate event. This event is emitted repeatedly during a user-initiated rotate interaction.
	 *
	 * @event rotate
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Rotate end event. This event is emitted at the end of a user-initiated rotate interaction.
	 *
	 * @event rotateend
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var DOM = __webpack_require__(87),
	    util = __webpack_require__(82);
	
	module.exports = DragPanHandler;
	
	var inertiaLinearity = 0.3,
	    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
	    inertiaMaxSpeed = 1400, // px/s
	    inertiaDeceleration = 2500; // px/s^2
	
	
	/**
	 * The `DragPanHandler` allows a user to pan the map by clicking and dragging
	 * the cursor.
	 * @class DragPanHandler
	 */
	function DragPanHandler(map) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	
	    util.bindHandlers(this);
	}
	
	DragPanHandler.prototype = {
	
	    _enabled: false,
	    _active: false,
	
	    /**
	     * Returns the current enabled/disabled state of the "drag to pan" interaction.
	     * @returns {boolean} enabled state
	     */
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    /**
	     * Returns true if the "drag to pan" interaction is currently active, i.e. currently being used.
	     * @returns {boolean} active state
	     */
	    isActive: function () {
	        return this._active;
	    },
	
	    /**
	     * Enable the "drag to pan" interaction.
	     * @example
	     *   map.dragPan.enable();
	     */
	    enable: function () {
	        if (this.isEnabled()) return;
	        this._el.addEventListener('mousedown', this._onDown);
	        this._el.addEventListener('touchstart', this._onDown);
	        this._enabled = true;
	    },
	
	    /**
	     * Disable the "drag to pan" interaction.
	     * @example
	     *   map.dragPan.disable();
	     */
	    disable: function () {
	        if (!this.isEnabled()) return;
	        this._el.removeEventListener('mousedown', this._onDown);
	        this._el.removeEventListener('touchstart', this._onDown);
	        this._enabled = false;
	    },
	
	    _onDown: function (e) {
	        if (this._ignoreEvent(e)) return;
	        if (this.isActive()) return;
	
	        if (e.touches) {
	            document.addEventListener('touchmove', this._onMove);
	            document.addEventListener('touchend', this._onTouchEnd);
	        } else {
	            document.addEventListener('mousemove', this._onMove);
	            document.addEventListener('mouseup', this._onMouseUp);
	        }
	
	        this._active = false;
	        this._startPos = this._pos = DOM.mousePos(this._el, e);
	        this._inertia = [[Date.now(), this._pos]];
	    },
	
	    _onMove: function (e) {
	        if (this._ignoreEvent(e)) return;
	
	        if (!this.isActive()) {
	            this._active = true;
	            this._fireEvent('dragstart', e);
	            this._fireEvent('movestart', e);
	        }
	
	        var pos = DOM.mousePos(this._el, e),
	            map = this._map;
	
	        map.stop();
	        this._drainInertiaBuffer();
	        this._inertia.push([Date.now(), pos]);
	
	        map.transform.setLocationAtPoint(map.transform.pointLocation(this._pos), pos);
	
	        this._fireEvent('drag', e);
	        this._fireEvent('move', e);
	
	        this._pos = pos;
	
	        e.preventDefault();
	    },
	
	    _onUp: function (e) {
	        if (!this.isActive()) return;
	
	        this._active = false;
	        this._fireEvent('dragend', e);
	        this._drainInertiaBuffer();
	
	        var finish = function() {
	            this._fireEvent('moveend', e);
	        }.bind(this);
	
	        var inertia = this._inertia;
	        if (inertia.length < 2) {
	            finish();
	            return;
	        }
	
	        var last = inertia[inertia.length - 1],
	            first = inertia[0],
	            flingOffset = last[1].sub(first[1]),
	            flingDuration = (last[0] - first[0]) / 1000;
	
	        if (flingDuration === 0 || last[1].equals(first[1])) {
	            finish();
	            return;
	        }
	
	        // calculate px/s velocity & adjust for increased initial animation speed when easing out
	        var velocity = flingOffset.mult(inertiaLinearity / flingDuration),
	            speed = velocity.mag(); // px/s
	
	        if (speed > inertiaMaxSpeed) {
	            speed = inertiaMaxSpeed;
	            velocity._unit()._mult(speed);
	        }
	
	        var duration = speed / (inertiaDeceleration * inertiaLinearity),
	            offset = velocity.mult(-duration / 2);
	
	        this._map.panBy(offset, {
	            duration: duration * 1000,
	            easing: inertiaEasing,
	            noMoveStart: true
	        }, { originalEvent: e });
	    },
	
	    _onMouseUp: function (e) {
	        if (this._ignoreEvent(e)) return;
	        this._onUp(e);
	        document.removeEventListener('mousemove', this._onMove);
	        document.removeEventListener('mouseup', this._onMouseUp);
	    },
	
	    _onTouchEnd: function (e) {
	        if (this._ignoreEvent(e)) return;
	        this._onUp(e);
	        document.removeEventListener('touchmove', this._onMove);
	        document.removeEventListener('touchend', this._onTouchEnd);
	    },
	
	    _fireEvent: function (type, e) {
	        return this._map.fire(type, { originalEvent: e });
	    },
	
	    _ignoreEvent: function (e) {
	        var map = this._map;
	
	        if (map.boxZoom && map.boxZoom.isActive()) return true;
	        if (map.dragRotate && map.dragRotate.isActive()) return true;
	        if (e.touches) {
	            return (e.touches.length > 1);
	        } else {
	            if (e.ctrlKey) return true;
	            var buttons = 1,  // left button
	                button = 0;   // left button
	            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
	        }
	    },
	
	    _drainInertiaBuffer: function () {
	        var inertia = this._inertia,
	            now = Date.now(),
	            cutoff = 160;   // msec
	
	        while (inertia.length > 0 && now - inertia[0][0] > cutoff) inertia.shift();
	    }
	};
	
	
	/**
	 * Drag start event. This event is emitted at the start of a user-initiated pan interaction.
	 *
	 * @event dragstart
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Drag event. This event is emitted repeatedly during a user-initiated pan interaction.
	 *
	 * @event drag
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */
	
	/**
	 * Drag end event. This event is emitted at the end of a user-initiated pan interaction.
	 *
	 * @event dragend
	 * @memberof Map
	 * @instance
	 * @property {EventData} data Original event data
	 */


/***/ },
/* 250 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = KeyboardHandler;
	
	
	var panDelta = 80,
	    rotateDelta = 2,
	    pitchDelta = 5;
	
	/**
	 * The `KeyboardHandler` allows a user to zoom, rotate, and pan the map using
	 * following keyboard shortcuts:
	 *  * `=` / `+`: increase zoom level by 1
	 *  * `Shift-=` / `Shift-+`: increase zoom level by 2
	 *  * `-`: decrease zoom level by 1
	 *  * `Shift--`: decrease zoom level by 2
	 *  * Arrow keys: pan by 80 pixels
	 *  * `Shift+`: increase rotation by 2 degrees
	 *  * `Shift+`: decrease rotation by 2 degrees
	 *  * `Shift+`: increase pitch by 5 degrees
	 *  * `Shift+`: decrease pitch by 5 degrees
	 * @class KeyboardHandler
	 */
	function KeyboardHandler(map) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	
	    this._onKeyDown = this._onKeyDown.bind(this);
	}
	
	KeyboardHandler.prototype = {
	
	    _enabled: false,
	
	    /**
	     * Returns the current enabled/disabled state of keyboard interaction.
	     * @returns {boolean} enabled state
	     */
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    /**
	     * Enable the ability to interact with the map using keyboard input.
	     * @example
	     *   map.keyboard.enable();
	     */
	    enable: function () {
	        if (this.isEnabled()) return;
	        this._el.addEventListener('keydown', this._onKeyDown, false);
	        this._enabled = true;
	    },
	
	    /**
	     * Disable the ability to interact with the map using keyboard input.
	     * @example
	     *   map.keyboard.disable();
	     */
	    disable: function () {
	        if (!this.isEnabled()) return;
	        this._el.removeEventListener('keydown', this._onKeyDown);
	        this._enabled = false;
	    },
	
	    _onKeyDown: function (e) {
	        if (e.altKey || e.ctrlKey || e.metaKey) return;
	
	        var map = this._map,
	            eventData = { originalEvent: e };
	
	        switch (e.keyCode) {
	        case 61:
	        case 107:
	        case 171:
	        case 187:
	            map.zoomTo(Math.round(map.getZoom()) + (e.shiftKey ? 2 : 1), eventData);
	            break;
	
	        case 189:
	        case 109:
	        case 173:
	            map.zoomTo(Math.round(map.getZoom()) - (e.shiftKey ? 2 : 1), eventData);
	            break;
	
	        case 37:
	            if (e.shiftKey) {
	                map.easeTo({ bearing: map.getBearing() - rotateDelta }, eventData);
	            } else {
	                e.preventDefault();
	                map.panBy([-panDelta, 0], eventData);
	            }
	            break;
	
	        case 39:
	            if (e.shiftKey) {
	                map.easeTo({ bearing: map.getBearing() + rotateDelta }, eventData);
	            } else {
	                e.preventDefault();
	                map.panBy([panDelta, 0], eventData);
	            }
	            break;
	
	        case 38:
	            if (e.shiftKey) {
	                map.easeTo({ pitch: map.getPitch() + pitchDelta }, eventData);
	            } else {
	                e.preventDefault();
	                map.panBy([0, -panDelta], eventData);
	            }
	            break;
	
	        case 40:
	            if (e.shiftKey) {
	                map.easeTo({ pitch: Math.max(map.getPitch() - pitchDelta, 0) }, eventData);
	            } else {
	                e.preventDefault();
	                map.panBy([0, panDelta], eventData);
	            }
	            break;
	        }
	    }
	};


/***/ },
/* 251 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = DoubleClickZoomHandler;
	
	/**
	 * The `DoubleClickZoomHandler` allows a user to zoom the map around point by
	 * double clicking.
	 * @class DoubleClickZoomHandler
	 */
	function DoubleClickZoomHandler(map) {
	    this._map = map;
	    this._onDblClick = this._onDblClick.bind(this);
	}
	
	DoubleClickZoomHandler.prototype = {
	
	    _enabled: false,
	
	    /**
	     * Returns the current enabled/disabled state of the "double click to zoom" interaction.
	     * @returns {boolean} enabled state
	     */
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    /**
	     * Enable the "double click to zoom" interaction.
	     * @example
	     *   map.doubleClickZoom.enable();
	     */
	    enable: function () {
	        if (this.isEnabled()) return;
	        this._map.on('dblclick', this._onDblClick);
	        this._enabled = true;
	    },
	
	    /**
	     * Disable the "double click to zoom" interaction.
	     * @example
	     *   map.doubleClickZoom.disable();
	     */
	    disable: function () {
	        if (!this.isEnabled()) return;
	        this._map.off('dblclick', this._onDblClick);
	        this._enabled = false;
	    },
	
	    _onDblClick: function (e) {
	        this._map.zoomTo(this._map.getZoom() +
	            (e.originalEvent.shiftKey ? -1 : 1), {around: e.lngLat});
	    }
	};


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var DOM = __webpack_require__(87),
	    util = __webpack_require__(82);
	
	module.exports = TouchZoomRotateHandler;
	
	var inertiaLinearity = 0.15,
	    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
	    inertiaDeceleration = 12, // scale / s^2
	    inertiaMaxSpeed = 2.5, // scale / s
	    significantScaleThreshold = 0.15,
	    significantRotateThreshold = 4;
	
	
	/**
	 * The `TouchZoomRotateHandler` allows a user to zoom and rotate the map by
	 * pinching on a touchscreen.
	 * @class TouchZoomRotateHandler
	 */
	function TouchZoomRotateHandler(map) {
	    this._map = map;
	    this._el = map.getCanvasContainer();
	
	    util.bindHandlers(this);
	}
	
	TouchZoomRotateHandler.prototype = {
	
	    _enabled: false,
	
	    /**
	     * Returns the current enabled/disabled state of the "pinch to rotate and zoom" interaction.
	     * @returns {boolean} enabled state
	     */
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    /**
	     * Enable the "pinch to rotate and zoom" interaction.
	     * @example
	     *   map.touchZoomRotate.enable();
	     */
	    enable: function () {
	        if (this.isEnabled()) return;
	        this._el.addEventListener('touchstart', this._onStart, false);
	        this._enabled = true;
	    },
	
	    /**
	     * Disable the "pinch to rotate and zoom" interaction.
	     * @example
	     *   map.touchZoomRotate.disable();
	     */
	    disable: function () {
	        if (!this.isEnabled()) return;
	        this._el.removeEventListener('touchstart', this._onStart);
	        this._enabled = false;
	    },
	
	    /**
	     * Disable the "pinch to rotate" interaction, leaving the "pinch to zoom"
	     * interaction enabled.
	     * @example
	     *   map.touchZoomRotate.disableRotation();
	     */
	    disableRotation: function() {
	        this._rotationDisabled = true;
	    },
	
	    /**
	     * Enable the "pinch to rotate" interaction, undoing a call to
	     * `disableRotation`.
	     * @example
	     *   map.touchZoomRotate.enable();
	     *   map.touchZoomRotate.enableRotation();
	     */
	    enableRotation: function() {
	        this._rotationDisabled = false;
	    },
	
	    _onStart: function (e) {
	        if (e.touches.length !== 2) return;
	
	        var p0 = DOM.mousePos(this._el, e.touches[0]),
	            p1 = DOM.mousePos(this._el, e.touches[1]);
	
	        this._startVec = p0.sub(p1);
	        this._startScale = this._map.transform.scale;
	        this._startBearing = this._map.transform.bearing;
	        this._gestureIntent = undefined;
	        this._inertia = [];
	
	        document.addEventListener('touchmove', this._onMove, false);
	        document.addEventListener('touchend', this._onEnd, false);
	    },
	
	    _onMove: function (e) {
	        if (e.touches.length !== 2) return;
	
	        var p0 = DOM.mousePos(this._el, e.touches[0]),
	            p1 = DOM.mousePos(this._el, e.touches[1]),
	            p = p0.add(p1).div(2),
	            vec = p0.sub(p1),
	            scale = vec.mag() / this._startVec.mag(),
	            bearing = this._rotationDisabled ? 0 : vec.angleWith(this._startVec) * 180 / Math.PI,
	            map = this._map;
	
	        // Determine 'intent' by whichever threshold is surpassed first,
	        // then keep that state for the duration of this gesture.
	        if (!this._gestureIntent) {
	            var scalingSignificantly = (Math.abs(1 - scale) > significantScaleThreshold),
	                rotatingSignificantly = (Math.abs(bearing) > significantRotateThreshold);
	
	            if (rotatingSignificantly) {
	                this._gestureIntent = 'rotate';
	            } else if (scalingSignificantly) {
	                this._gestureIntent = 'zoom';
	            }
	
	            if (this._gestureIntent) {
	                this._startVec = vec;
	                this._startScale = map.transform.scale;
	                this._startBearing = map.transform.bearing;
	            }
	
	        } else {
	            var param = { duration: 0, around: map.unproject(p) };
	
	            if (this._gestureIntent === 'rotate') {
	                param.bearing = this._startBearing + bearing;
	            }
	            if (this._gestureIntent === 'zoom' || this._gestureIntent === 'rotate') {
	                param.zoom = map.transform.scaleZoom(this._startScale * scale);
	            }
	
	            map.stop();
	            this._drainInertiaBuffer();
	            this._inertia.push([Date.now(), scale, p]);
	
	            map.easeTo(param, { originalEvent: e });
	        }
	
	        e.preventDefault();
	    },
	
	    _onEnd: function (e) {
	        document.removeEventListener('touchmove', this._onMove);
	        document.removeEventListener('touchend', this._onEnd);
	        this._drainInertiaBuffer();
	
	        var inertia = this._inertia,
	            map = this._map;
	
	        if (inertia.length < 2) {
	            map.snapToNorth({}, { originalEvent: e });
	            return;
	        }
	
	        var last = inertia[inertia.length - 1],
	            first = inertia[0],
	            lastScale = map.transform.scaleZoom(this._startScale * last[1]),
	            firstScale = map.transform.scaleZoom(this._startScale * first[1]),
	            scaleOffset = lastScale - firstScale,
	            scaleDuration = (last[0] - first[0]) / 1000,
	            p = last[2];
	
	        if (scaleDuration === 0 || lastScale === firstScale) {
	            map.snapToNorth({}, { originalEvent: e });
	            return;
	        }
	
	        // calculate scale/s speed and adjust for increased initial animation speed when easing
	        var speed = scaleOffset * inertiaLinearity / scaleDuration; // scale/s
	
	        if (Math.abs(speed) > inertiaMaxSpeed) {
	            if (speed > 0) {
	                speed = inertiaMaxSpeed;
	            } else {
	                speed = -inertiaMaxSpeed;
	            }
	        }
	
	        var duration = Math.abs(speed / (inertiaDeceleration * inertiaLinearity)) * 1000,
	            targetScale = lastScale + speed * duration / 2000;
	
	        if (targetScale < 0) {
	            targetScale = 0;
	        }
	
	        map.easeTo({
	            zoom: targetScale,
	            duration: duration,
	            easing: inertiaEasing,
	            around: map.unproject(p)
	        }, { originalEvent: e });
	    },
	
	    _drainInertiaBuffer: function() {
	        var inertia = this._inertia,
	            now = Date.now(),
	            cutoff = 160; // msec
	
	        while (inertia.length > 2 && now - inertia[0][0] > cutoff) inertia.shift();
	    }
	};


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(82);
	var interpolate = __webpack_require__(92);
	var browser = __webpack_require__(85);
	var LngLat = __webpack_require__(216);
	var LngLatBounds = __webpack_require__(247);
	var Point = __webpack_require__(88);
	
	/**
	 * Options common to Map#jumpTo, Map#easeTo, and Map#flyTo, controlling the destination
	 * location, zoom level, bearing and pitch. All properties are options; unspecified
	 * options will default to the current value for that property.
	 *
	 * @typedef {Object} CameraOptions
	 * @property {LngLat} center Map center
	 * @property {number} zoom Map zoom level
	 * @property {number} bearing Map rotation bearing in degrees counter-clockwise from north
	 * @property {number} pitch Map angle in degrees at which the camera is looking at the ground
	 * @property {LngLat} around If zooming, the zoom center (defaults to map center)
	 */
	
	/**
	 * Options common to map movement methods that involve animation, such as Map#panBy and
	 * Map#easeTo, controlling the duration of the animation and easing function. All properties
	 * are optional.
	 *
	 * @typedef {Object} AnimationOptions
	 * @property {number} duration Number in milliseconds
	 * @property {Function} easing
	 * @property {Array} offset point, origin of movement relative to map center
	 * @property {boolean} animate When set to false, no animation happens
	 */
	
	var Camera = module.exports = function() {};
	
	util.extend(Camera.prototype, /** @lends Map.prototype */{
	    /**
	     * Get the current view geographical point.
	     * @returns {LngLat}
	     */
	    getCenter: function() { return this.transform.center; },
	
	    /**
	     * Sets a map location. Equivalent to `jumpTo({center: center})`.
	     *
	     * @param {LngLat} center Map center to jump to
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     * @example
	     * map.setCenter([-74, 38]);
	     */
	    setCenter: function(center, eventData) {
	        this.jumpTo({center: center}, eventData);
	        return this;
	    },
	
	    /**
	     * Pan by a certain number of pixels
	     *
	     * @param {Array<number>} offset [x, y]
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    panBy: function(offset, options, eventData) {
	        this.panTo(this.transform.center,
	            util.extend({offset: Point.convert(offset).mult(-1)}, options), eventData);
	        return this;
	    },
	
	    /**
	     * Pan to a certain location with easing
	     *
	     * @param {LngLat} lnglat Location to pan to
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    panTo: function(lnglat, options, eventData) {
	        return this.easeTo(util.extend({
	            center: lnglat
	        }, options), eventData);
	    },
	
	
	    /**
	     * Get the current zoom
	     * @returns {number}
	     */
	    getZoom: function() { return this.transform.zoom; },
	
	    /**
	     * Sets a map zoom. Equivalent to `jumpTo({zoom: zoom})`.
	     *
	     * @param {number} zoom Map zoom level
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires zoomstart
	     * @fires move
	     * @fires zoom
	     * @fires moveend
	     * @fires zoomend
	     * @returns {Map} `this`
	     * @example
	     * // zoom the map to 5
	     * map.setZoom(5);
	     */
	    setZoom: function(zoom, eventData) {
	        this.jumpTo({zoom: zoom}, eventData);
	        return this;
	    },
	
	    /**
	     * Zooms to a certain zoom level with easing.
	     *
	     * @param {number} zoom
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires zoomstart
	     * @fires move
	     * @fires zoom
	     * @fires moveend
	     * @fires zoomend
	     * @returns {Map} `this`
	     */
	    zoomTo: function(zoom, options, eventData) {
	        return this.easeTo(util.extend({
	            zoom: zoom
	        }, options), eventData);
	    },
	
	    /**
	     * Zoom in by 1 level
	     *
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires zoomstart
	     * @fires move
	     * @fires zoom
	     * @fires moveend
	     * @fires zoomend
	     * @returns {Map} `this`
	     */
	    zoomIn: function(options, eventData) {
	        this.zoomTo(this.getZoom() + 1, options, eventData);
	        return this;
	    },
	
	    /**
	     * Zoom out by 1 level
	     *
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires zoomstart
	     * @fires move
	     * @fires zoom
	     * @fires moveend
	     * @fires zoomend
	     * @returns {Map} `this`
	     */
	    zoomOut: function(options, eventData) {
	        this.zoomTo(this.getZoom() - 1, options, eventData);
	        return this;
	    },
	
	
	    /**
	     * Get the current bearing in degrees
	     * @returns {number}
	     */
	    getBearing: function() { return this.transform.bearing; },
	
	    /**
	     * Sets a map rotation. Equivalent to `jumpTo({bearing: bearing})`.
	     *
	     * @param {number} bearing Map rotation bearing in degrees counter-clockwise from north
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     * @example
	     * // rotate the map to 90 degrees
	     * map.setBearing(90);
	     */
	    setBearing: function(bearing, eventData) {
	        this.jumpTo({bearing: bearing}, eventData);
	        return this;
	    },
	
	    /**
	     * Rotate bearing by a certain number of degrees with easing
	     *
	     * @param {number} bearing
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    rotateTo: function(bearing, options, eventData) {
	        return this.easeTo(util.extend({
	            bearing: bearing
	        }, options), eventData);
	    },
	
	    /**
	     * Sets map bearing to 0 (north) with easing
	     *
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    resetNorth: function(options, eventData) {
	        this.rotateTo(0, util.extend({duration: 1000}, options), eventData);
	        return this;
	    },
	
	    /**
	     * Animates map bearing to 0 (north) if it's already close to it.
	     *
	     * @param {AnimationOptions} [options]
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    snapToNorth: function(options, eventData) {
	        if (Math.abs(this.getBearing()) < this.options.bearingSnap) {
	            return this.resetNorth(options, eventData);
	        }
	        return this;
	    },
	
	    /**
	     * Get the current angle in degrees
	     * @returns {number}
	     */
	    getPitch: function() { return this.transform.pitch; },
	
	    /**
	     * Sets a map angle. Equivalent to `jumpTo({pitch: pitch})`.
	     *
	     * @param {number} pitch The angle at which the camera is looking at the ground
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    setPitch: function(pitch, eventData) {
	        this.jumpTo({pitch: pitch}, eventData);
	        return this;
	    },
	
	
	    /**
	     * Zoom to contain certain geographical bounds
	     *
	     * @param {LngLatBounds|Array<Array<number>>} bounds [[minLng, minLat], [maxLng, maxLat]]
	     * @param {Object} options
	     * @param {boolean} [options.linear] When true, the map transitions to the new camera using
	     *     {@link #Map.easeTo}. When false, the map transitions using {@link #Map.flyTo}. See
	     *     {@link #Map.flyTo} for information on options specific to that animation transition.
	     * @param {Function} options.easing
	     * @param {number} options.padding how much padding there is around the given bounds on each side in pixels
	     * @param {number} options.maxZoom The resulting zoom level will be at most
	     *     this value.
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    fitBounds: function(bounds, options, eventData) {
	
	        options = util.extend({
	            padding: 0,
	            offset: [0, 0],
	            maxZoom: Infinity
	        }, options);
	
	        bounds = LngLatBounds.convert(bounds);
	
	        var offset = Point.convert(options.offset),
	            tr = this.transform,
	            nw = tr.project(bounds.getNorthWest()),
	            se = tr.project(bounds.getSouthEast()),
	            size = se.sub(nw),
	            scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
	            scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y;
	
	        options.center = tr.unproject(nw.add(se).div(2));
	        options.zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
	        options.bearing = 0;
	
	        return options.linear ?
	            this.easeTo(options, eventData) :
	            this.flyTo(options, eventData);
	    },
	
	    /**
	     * Change any combination of center, zoom, bearing, and pitch, without
	     * a transition. The map will retain the current values for any options
	     * not included in `options`.
	     *
	     * @param {CameraOptions} options map view options
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires zoomstart
	     * @fires move
	     * @fires zoom
	     * @fires rotate
	     * @fires pitch
	     * @fires zoomend
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    jumpTo: function(options, eventData) {
	        this.stop();
	
	        var tr = this.transform,
	            zoomChanged = false,
	            bearingChanged = false,
	            pitchChanged = false;
	
	        if ('zoom' in options && tr.zoom !== +options.zoom) {
	            zoomChanged = true;
	            tr.zoom = +options.zoom;
	        }
	
	        if ('center' in options) {
	            tr.center = LngLat.convert(options.center);
	        }
	
	        if ('bearing' in options && tr.bearing !== +options.bearing) {
	            bearingChanged = true;
	            tr.bearing = +options.bearing;
	        }
	
	        if ('pitch' in options && tr.pitch !== +options.pitch) {
	            pitchChanged = true;
	            tr.pitch = +options.pitch;
	        }
	
	        this.fire('movestart', eventData)
	            .fire('move', eventData);
	
	        if (zoomChanged) {
	            this.fire('zoomstart', eventData)
	                .fire('zoom', eventData)
	                .fire('zoomend', eventData);
	        }
	
	        if (bearingChanged) {
	            this.fire('rotate', eventData);
	        }
	
	        if (pitchChanged) {
	            this.fire('pitch', eventData);
	        }
	
	        return this.fire('moveend', eventData);
	    },
	
	    /**
	     * Change any combination of center, zoom, bearing, and pitch, with a smooth animation
	     * between old and new values. The map will retain the current values for any options
	     * not included in `options`.
	     *
	     * @param {CameraOptions|AnimationOptions} options map view and animation options
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires zoomstart
	     * @fires move
	     * @fires zoom
	     * @fires rotate
	     * @fires pitch
	     * @fires zoomend
	     * @fires moveend
	     * @returns {Map} `this`
	     */
	    easeTo: function(options, eventData) {
	        this.stop();
	
	        options = util.extend({
	            offset: [0, 0],
	            duration: 500,
	            easing: util.ease
	        }, options);
	
	        var tr = this.transform,
	            offset = Point.convert(options.offset),
	            startZoom = this.getZoom(),
	            startBearing = this.getBearing(),
	            startPitch = this.getPitch(),
	
	            zoom = 'zoom' in options ? +options.zoom : startZoom,
	            bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,
	            pitch = 'pitch' in options ? +options.pitch : startPitch,
	
	            toLngLat,
	            toPoint;
	
	        if ('center' in options) {
	            toLngLat = LngLat.convert(options.center);
	            toPoint = tr.centerPoint.add(offset);
	        } else if ('around' in options) {
	            toLngLat = LngLat.convert(options.around);
	            toPoint = tr.locationPoint(toLngLat);
	        } else {
	            toPoint = tr.centerPoint.add(offset);
	            toLngLat = tr.pointLocation(toPoint);
	        }
	
	        var fromPoint = tr.locationPoint(toLngLat);
	
	        if (options.animate === false) options.duration = 0;
	
	        this.zooming = (zoom !== startZoom);
	        this.rotating = (startBearing !== bearing);
	        this.pitching = (pitch !== startPitch);
	
	        if (!options.noMoveStart) {
	            this.fire('movestart', eventData);
	        }
	        if (this.zooming) {
	            this.fire('zoomstart', eventData);
	        }
	
	        clearTimeout(this._onEaseEnd);
	
	        this._ease(function (k) {
	            if (this.zooming) {
	                tr.zoom = interpolate(startZoom, zoom, k);
	            }
	
	            if (this.rotating) {
	                tr.bearing = interpolate(startBearing, bearing, k);
	            }
	
	            if (this.pitching) {
	                tr.pitch = interpolate(startPitch, pitch, k);
	            }
	
	            tr.setLocationAtPoint(toLngLat, fromPoint.add(toPoint.sub(fromPoint)._mult(k)));
	
	            this.fire('move', eventData);
	            if (this.zooming) {
	                this.fire('zoom', eventData);
	            }
	            if (this.rotating) {
	                this.fire('rotate', eventData);
	            }
	            if (this.pitching) {
	                this.fire('pitch', eventData);
	            }
	        }, function() {
	            if (options.delayEndEvents) {
	                this._onEaseEnd = setTimeout(this._easeToEnd.bind(this, eventData), options.delayEndEvents);
	            } else {
	                this._easeToEnd(eventData);
	            }
	        }.bind(this), options);
	
	        return this;
	    },
	
	    _easeToEnd: function(eventData) {
	        if (this.zooming) {
	            this.fire('zoomend', eventData);
	        }
	        this.fire('moveend', eventData);
	
	        this.zooming = false;
	        this.rotating = false;
	        this.pitching = false;
	    },
	
	    /**
	     * Change any combination of center, zoom, bearing, and pitch, animated along a curve that
	     * evokes flight. The transition animation seamlessly incorporates zooming and panning to help
	     * the user find his or her bearings even after traversing a great distance.
	     *
	     * @param {CameraOptions|AnimationOptions} options map view and animation options
	     * @param {number} [options.curve=1.42] Relative amount of zooming that takes place along the
	     *     flight path. A high value maximizes zooming for an exaggerated animation, while a low
	     *     value minimizes zooming for something closer to {@link #Map.easeTo}. 1.42 is the average
	     *     value selected by participants in the user study in
	     *     [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
	     *     `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
	     *     value of 1 would produce a circular motion.
	     * @param {number} [options.minZoom] Zero-based zoom level at the peak of the flight path. If
	     *     `options.curve` is specified, this option is ignored.
	     * @param {number} [options.speed=1.2] Average speed of the animation. A speed of 1.2 means that
	     *     the map appears to move along the flight path by 1.2 times `options.curve` screenfuls every
	     *     second. A _screenful_ is the visible span in pixels. It does not correspond to a fixed
	     *     physical distance but rather varies by zoom level.
	     * @param {number} [options.screenSpeed] Average speed of the animation, measured in screenfuls
	     *     per second, assuming a linear timing curve. If `options.speed` is specified, this option
	     *     is ignored.
	     * @param {Function} [options.easing] Transition timing curve
	     * @param {EventData} [eventData] Data to propagate to any event receivers
	     * @fires movestart
	     * @fires zoomstart
	     * @fires move
	     * @fires zoom
	     * @fires rotate
	     * @fires pitch
	     * @fires zoomend
	     * @fires moveend
	     * @returns {this}
	     * @example
	     * // fly with default options to null island
	     * map.flyTo({center: [0, 0], zoom: 9});
	     * // using flyTo options
	     * map.flyTo({
	     *   center: [0, 0],
	     *   zoom: 9,
	     *   speed: 0.2,
	     *   curve: 1,
	     *   easing: function(t) {
	     *     return t;
	     *   }
	     * });
	     */
	    flyTo: function(options, eventData) {
	        // This method implements an optimal path animation, as detailed in:
	        //
	        // Van Wijk, Jarke J.; Nuij, Wim A. A. Smooth and efficient zooming and panning. INFOVIS
	        //   03. pp. 1522. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.
	        //
	        // Where applicable, local variable documentation begins with the associated variable or
	        // function in van Wijk (2003).
	
	        this.stop();
	
	        options = util.extend({
	            offset: [0, 0],
	            speed: 1.2,
	            curve: 1.42,
	            easing: util.ease
	        }, options);
	
	        var tr = this.transform,
	            offset = Point.convert(options.offset),
	            startZoom = this.getZoom(),
	            startBearing = this.getBearing(),
	            startPitch = this.getPitch();
	
	        var center = 'center' in options ? LngLat.convert(options.center) : this.getCenter();
	        var zoom = 'zoom' in options ?  +options.zoom : startZoom;
	        var bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
	        var pitch = 'pitch' in options ? +options.pitch : startPitch;
	
	        // If a path crossing the antimeridian would be shorter, extend the final coordinate so that
	        // interpolating between the two endpoints will cross it.
	        if (Math.abs(tr.center.lng) + Math.abs(center.lng) > 180) {
	            if (tr.center.lng > 0 && center.lng < 0) {
	                center.lng += 360;
	            } else if (tr.center.lng < 0 && center.lng > 0) {
	                center.lng -= 360;
	            }
	        }
	
	        var scale = tr.zoomScale(zoom - startZoom),
	            from = tr.point,
	            to = 'center' in options ? tr.project(center).sub(offset.div(scale)) : from;
	
	        var startWorldSize = tr.worldSize,
	            rho = options.curve,
	
	            // w: Initial visible span, measured in pixels at the initial scale.
	            w0 = Math.max(tr.width, tr.height),
	            // w: Final visible span, measured in pixels with respect to the initial scale.
	            w1 = w0 / scale,
	            // Length of the flight path as projected onto the ground plane, measured in pixels from
	            // the world image origin at the initial scale.
	            u1 = to.sub(from).mag();
	
	        if ('minZoom' in options) {
	            var minZoom = util.clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
	            // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial
	            // scale.
	            var wMax = w0 / tr.zoomScale(minZoom - startZoom);
	            rho = Math.sqrt(wMax / u1 * 2);
	        }
	
	        // 
	        var rho2 = rho * rho;
	
	        /**
	         * r: Returns the zoom-out factor at one end of the animation.
	         *
	         * @param i 0 for the ascent or 1 for the descent.
	         * @private
	         */
	        function r(i) {
	            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
	            return Math.log(Math.sqrt(b * b + 1) - b);
	        }
	
	        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
	        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
	        function tanh(n) { return sinh(n) / cosh(n); }
	
	        // r: Zoom-out factor during ascent.
	        var r0 = r(0),
	            /**
	             * w(s): Returns the visible span on the ground, measured in pixels with respect to the
	             * initial scale.
	             *
	             * Assumes an angular field of view of 2 arctan   53.
	             * @private
	             */
	            w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
	            /**
	             * u(s): Returns the distance along the flight path as projected onto the ground plane,
	             * measured in pixels from the world image origin at the initial scale.
	             * @private
	             */
	            u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
	            // S: Total length of the flight path, measured in -screenfuls.
	            S = (r(1) - r0) / rho;
	
	        // When u = u, the optimal path doesnt require both ascent and descent.
	        if (Math.abs(u1) < 0.000001) {
	            // Perform a more or less instantaneous transition if the path is too short.
	            if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options);
	
	            var k = w1 < w0 ? -1 : 1;
	            S = Math.abs(Math.log(w1 / w0)) / rho;
	
	            u = function() { return 0; };
	            w = function(s) { return Math.exp(k * rho * s); };
	        }
	
	        if ('duration' in options) {
	            options.duration = +options.duration;
	        } else {
	            var V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
	            options.duration = 1000 * S / V;
	        }
	
	        this.zooming = true;
	        if (startBearing !== bearing) this.rotating = true;
	        if (startPitch !== pitch) this.pitching = true;
	
	        this.fire('movestart', eventData);
	        this.fire('zoomstart', eventData);
	
	        this._ease(function (k) {
	            // s: The distance traveled along the flight path, measured in -screenfuls.
	            var s = k * S,
	                us = u(s);
	
	            tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
	            tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);
	
	            if (this.rotating) {
	                tr.bearing = interpolate(startBearing, bearing, k);
	            }
	            if (this.pitching) {
	                tr.pitch = interpolate(startPitch, pitch, k);
	            }
	
	            this.fire('move', eventData);
	            this.fire('zoom', eventData);
	            if (this.rotating) {
	                this.fire('rotate', eventData);
	            }
	            if (this.pitching) {
	                this.fire('pitch', eventData);
	            }
	        }, function() {
	            this.fire('zoomend', eventData);
	            this.fire('moveend', eventData);
	            this.zooming = false;
	            this.rotating = false;
	            this.pitching = false;
	        }, options);
	
	        return this;
	    },
	
	    isEasing: function() {
	        return !!this._abortFn;
	    },
	
	    /**
	     * Stop current animation
	     *
	     * @returns {Map} `this`
	     */
	    stop: function() {
	        if (this._abortFn) {
	            this._abortFn();
	            this._finishEase();
	        }
	        return this;
	    },
	
	    _ease: function(frame, finish, options) {
	        this._finishFn = finish;
	        this._abortFn = browser.timed(function (t) {
	            frame.call(this, options.easing(t));
	            if (t === 1) {
	                this._finishEase();
	            }
	        }, options.animate === false ? 0 : options.duration, this);
	    },
	
	    _finishEase: function() {
	        delete this._abortFn;
	        // The finish function might emit events which trigger new eases, which
	        // set a new _finishFn. Ensure we don't delete it unintentionally.
	        var finish = this._finishFn;
	        delete this._finishFn;
	        finish.call(this);
	    },
	
	    // convert bearing so that it's numerically close to the current one so that it interpolates properly
	    _normalizeBearing: function(bearing, currentBearing) {
	        bearing = util.wrap(bearing, -180, 180);
	        var diff = Math.abs(bearing - currentBearing);
	        if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;
	        if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;
	        return bearing;
	    },
	
	    _updateEasing: function(duration, zoom, bezier) {
	        var easing;
	
	        if (this.ease) {
	            var ease = this.ease,
	                t = (Date.now() - ease.start) / ease.duration,
	                speed = ease.easing(t + 0.01) - ease.easing(t),
	
	                // Quick hack to make new bezier that is continuous with last
	                x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
	                y = Math.sqrt(0.27 * 0.27 - x * x);
	
	            easing = util.bezier(x, y, 0.25, 1);
	        } else {
	            easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
	        }
	
	        // store information on current easing
	        this.ease = {
	            start: (new Date()).getTime(),
	            to: Math.pow(2, zoom),
	            duration: duration,
	            easing: easing
	        };
	
	        return easing;
	    }
	});


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Control = __webpack_require__(255);
	var DOM = __webpack_require__(87);
	var util = __webpack_require__(82);
	
	module.exports = Attribution;
	
	/**
	 * Creates an attribution control
	 * @class Attribution
	 * @param {Object} [options]
	 * @param {string} [options.position='bottom-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
	 * @example
	 * var map = new mapboxgl.Map({attributionControl: false})
	 *     .addControl(new mapboxgl.Attribution({position: 'top-left'}));
	 */
	function Attribution(options) {
	    util.setOptions(this, options);
	}
	
	Attribution.prototype = util.inherit(Control, {
	    options: {
	        position: 'bottom-right'
	    },
	
	    onAdd: function(map) {
	        var className = 'mapboxgl-ctrl-attrib',
	            container = this._container = DOM.create('div', className, map.getContainer());
	
	        this._update();
	        map.on('source.load', this._update.bind(this));
	        map.on('source.change', this._update.bind(this));
	        map.on('source.remove', this._update.bind(this));
	        map.on('moveend', this._updateEditLink.bind(this));
	
	        return container;
	    },
	
	    _update: function() {
	        var attributions = [];
	
	        if (this._map.style) {
	            for (var id in this._map.style.sources) {
	                var source = this._map.style.sources[id];
	                if (source.attribution && attributions.indexOf(source.attribution) < 0) {
	                    attributions.push(source.attribution);
	                }
	            }
	        }
	
	        this._container.innerHTML = attributions.join(' | ');
	        this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
	        this._updateEditLink();
	    },
	
	    _updateEditLink: function() {
	        if (this._editLink) {
	            var center = this._map.getCenter();
	            this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
	                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
	        }
	    }
	});


/***/ },
/* 255 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = Control;
	
	/**
	 * A base class for map-related interface elements.
	 *
	 * @class Control
	 */
	function Control() {}
	
	Control.prototype = {
	    /**
	     * Add this control to the map, returning the control itself
	     * for chaining. This will insert the control's DOM element into
	     * the map's DOM element if the control has a `position` specified.
	     *
	     * @param {Map} map
	     * @returns {Control} `this`
	     */
	    addTo: function(map) {
	        this._map = map;
	        var container = this._container = this.onAdd(map);
	        if (this.options && this.options.position) {
	            var pos = this.options.position;
	            var corner = map._controlCorners[pos];
	            container.className += ' mapboxgl-ctrl';
	            if (pos.indexOf('bottom') !== -1) {
	                corner.insertBefore(container, corner.firstChild);
	            } else {
	                corner.appendChild(container);
	            }
	        }
	
	        return this;
	    },
	
	    /**
	     * Remove this control from the map it has been added to.
	     *
	     * @returns {Control} `this`
	     */
	    remove: function() {
	        this._container.parentNode.removeChild(this._container);
	        if (this.onRemove) this.onRemove(this._map);
	        this._map = null;
	        return this;
	    }
	};


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Control = __webpack_require__(255);
	var DOM = __webpack_require__(87);
	var util = __webpack_require__(82);
	
	module.exports = Navigation;
	
	/**
	 * Creates a navigation control with zoom buttons and a compass
	 * @class Navigation
	 * @param {Object} [options]
	 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
	 * @example
	 * map.addControl(new mapboxgl.Navigation({position: 'top-left'})); // position is optional
	 */
	function Navigation(options) {
	    util.setOptions(this, options);
	}
	
	Navigation.prototype = util.inherit(Control, {
	    options: {
	        position: 'top-right'
	    },
	
	    onAdd: function(map) {
	        var className = 'mapboxgl-ctrl';
	
	        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
	        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));
	
	        this._zoomInButton = this._createButton(className + '-icon ' + className + '-zoom-in', map.zoomIn.bind(map));
	        this._zoomOutButton = this._createButton(className + '-icon ' + className + '-zoom-out', map.zoomOut.bind(map));
	        this._compass = this._createButton(className + '-icon ' + className + '-compass', map.resetNorth.bind(map));
	
	        this._compassArrow = DOM.create('div', 'arrow', this._compass);
	
	        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
	        this._onCompassMove = this._onCompassMove.bind(this);
	        this._onCompassUp = this._onCompassUp.bind(this);
	
	        map.on('rotate', this._rotateCompassArrow.bind(this));
	        this._rotateCompassArrow();
	
	        this._el = map.getCanvasContainer();
	
	        return container;
	    },
	
	    _onContextMenu: function(e) {
	        e.preventDefault();
	    },
	
	    _onCompassDown: function(e) {
	        if (e.button !== 0) return;
	
	        DOM.disableDrag();
	        document.addEventListener('mousemove', this._onCompassMove);
	        document.addEventListener('mouseup', this._onCompassUp);
	
	        this._el.dispatchEvent(copyMouseEvent(e));
	        e.stopPropagation();
	    },
	
	    _onCompassMove: function(e) {
	        if (e.button !== 0) return;
	
	        this._el.dispatchEvent(copyMouseEvent(e));
	        e.stopPropagation();
	    },
	
	    _onCompassUp: function(e) {
	        if (e.button !== 0) return;
	
	        document.removeEventListener('mousemove', this._onCompassMove);
	        document.removeEventListener('mouseup', this._onCompassUp);
	        DOM.enableDrag();
	
	        this._el.dispatchEvent(copyMouseEvent(e));
	        e.stopPropagation();
	    },
	
	    _createButton: function(className, fn) {
	        var a = DOM.create('button', className, this._container);
	        a.addEventListener('click', function() { fn(); });
	        return a;
	    },
	
	    _rotateCompassArrow: function() {
	        var rotate = 'rotate(' + (this._map.transform.angle * (180 / Math.PI)) + 'deg)';
	        this._compassArrow.style.transform = rotate;
	    }
	});
	
	
	function copyMouseEvent(e) {
	    return new MouseEvent(e.type, {
	        button: 2,    // right click
	        buttons: 2,   // right click
	        bubbles: true,
	        cancelable: true,
	        detail: e.detail,
	        view: e.view,
	        screenX: e.screenX,
	        screenY: e.screenY,
	        clientX: e.clientX,
	        clientY: e.clientY,
	        movementX: e.movementX,
	        movementY: e.movementY,
	        ctrlKey: e.ctrlKey,
	        shiftKey: e.shiftKey,
	        altKey: e.altKey,
	        metaKey: e.metaKey
	    });
	}
	


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Control = __webpack_require__(255);
	var browser = __webpack_require__(85);
	var DOM = __webpack_require__(87);
	var util = __webpack_require__(82);
	
	module.exports = Geolocate;
	
	var geoOptions = { enableHighAccuracy: false, timeout: 6000 /* 6sec */ };
	
	
	/**
	 * Creates a geolocation control
	 * @class Geolocate
	 * @param {Object} [options]
	 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
	 * @example
	 * map.addControl(new mapboxgl.Geolocate({position: 'top-left'})); // position is optional
	 */
	function Geolocate(options) {
	    util.setOptions(this, options);
	}
	
	Geolocate.prototype = util.inherit(Control, {
	    options: {
	        position: 'top-right'
	    },
	
	    onAdd: function(map) {
	        var className = 'mapboxgl-ctrl';
	
	        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
	        if (!browser.supportsGeolocation) return container;
	
	        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));
	
	        this._geolocateButton = DOM.create('button', (className + '-icon ' + className + '-geolocate'), this._container);
	        this._geolocateButton.addEventListener('click', this._onClickGeolocate.bind(this));
	        return container;
	    },
	
	    _onContextMenu: function(e) {
	        e.preventDefault();
	    },
	
	    _onClickGeolocate: function() {
	        navigator.geolocation.getCurrentPosition(this._success.bind(this), this._error.bind(this), geoOptions);
	
	        // This timeout ensures that we still call finish() even if
	        // the user declines to share their location in Firefox
	        this._timeoutId = setTimeout(this._finish.bind(this), 10000 /* 10sec */);
	    },
	
	    _success: function(position) {
	        this._map.jumpTo({
	            center: [position.coords.longitude, position.coords.latitude],
	            zoom: 17,
	            bearing: 0,
	            pitch: 0
	        });
	        this._finish();
	    },
	
	    _error: function() {
	        this._finish();
	    },
	
	    _finish: function() {
	        if (this._timeoutId) { clearTimeout(this._timeoutId); }
	        this._timeoutId = undefined;
	    }
	
	});
	


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = Popup;
	
	var util = __webpack_require__(82);
	var Evented = __webpack_require__(86);
	var DOM = __webpack_require__(87);
	var LngLat = __webpack_require__(216);
	
	/**
	 * Creates a popup component
	 * @class Popup
	 * @param {Object} options
	 * @param {boolean} options.closeButton
	 * @param {boolean} options.closeOnClick
	 * @param {string} options.anchor - One of "top", "bottom", "left", "right", "top-left",
	 * "top-right", "bottom-left", or "bottom-right", describing where the popup's anchor
	 * relative to the coordinate set via `setLngLat`.
	 * @example
	 * var tooltip = new mapboxgl.Popup()
	 *   .setLngLat(e.lngLat)
	 *   .setHTML("<h1>Hello World!</h1>")
	 *   .addTo(map);
	 */
	function Popup(options) {
	    util.setOptions(this, options);
	    util.bindAll([
	        '_update',
	        '_onClickClose'],
	        this);
	}
	
	Popup.prototype = util.inherit(Evented, /** @lends Popup.prototype */{
	    options: {
	        closeButton: true,
	        closeOnClick: true
	    },
	
	    /**
	     * Attaches the popup to a map
	     * @param {Map} map
	     * @returns {Popup} `this`
	     */
	    addTo: function(map) {
	        this._map = map;
	        this._map.on('move', this._update);
	        if (this.options.closeOnClick) {
	            this._map.on('click', this._onClickClose);
	        }
	        this._update();
	        return this;
	    },
	
	    /**
	     * Removes the popup from the map
	     * @example
	     * var popup = new mapboxgl.Popup().addTo(map);
	     * popup.remove();
	     * @returns {Popup} `this`
	     */
	    remove: function() {
	        if (this._content && this._content.parentNode) {
	            this._content.parentNode.removeChild(this._content);
	        }
	
	        if (this._container) {
	            this._container.parentNode.removeChild(this._container);
	            delete this._container;
	        }
	
	        if (this._map) {
	            this._map.off('move', this._update);
	            this._map.off('click', this._onClickClose);
	            delete this._map;
	        }
	
	        return this;
	    },
	
	    /**
	     * Get the current coordinates of popup element relative to map
	     * @returns {LngLat}
	     */
	    getLngLat: function() {
	        return this._lngLat;
	    },
	
	    /**
	     * Set the coordinates of a popup element to a map
	     * @param {LngLat} lnglat
	     * @returns {Popup} `this`
	     */
	    setLngLat: function(lnglat) {
	        this._lngLat = LngLat.convert(lnglat);
	        this._update();
	        return this;
	    },
	
	    /**
	     * Fill a popup element with text only content
	     * @param {string} text
	     * @returns {Popup} `this`
	     */
	    setText: function(text) {
	        return this.setDOMContent(document.createTextNode(text));
	    },
	
	    /**
	     * Fill a popup element with HTML content
	     * @param {string} html
	     * @returns {Popup} `this`
	     */
	    setHTML: function(html) {
	        var frag = document.createDocumentFragment();
	        var temp = document.createElement('body'), child;
	        temp.innerHTML = html;
	        while (true) {
	            child = temp.firstChild;
	            if (!child) break;
	            frag.appendChild(child);
	        }
	
	        return this.setDOMContent(frag);
	    },
	
	    /**
	     * Fill a popup element with DOM content
	     * @param {Node} htmlNode Popup content as a DOM node
	     * @returns {Popup} `this`
	     */
	    setDOMContent: function(htmlNode) {
	        this._createContent();
	        this._content.appendChild(htmlNode);
	        this._update();
	        return this;
	    },
	
	    _createContent: function() {
	        if (this._content && this._content.parentNode) {
	            this._content.parentNode.removeChild(this._content);
	        }
	
	        this._content = DOM.create('div', 'mapboxgl-popup-content', this._container);
	
	        if (this.options.closeButton) {
	            this._closeButton = DOM.create('button', 'mapboxgl-popup-close-button', this._content);
	            this._closeButton.innerHTML = '&#215;';
	            this._closeButton.addEventListener('click', this._onClickClose);
	        }
	    },
	
	    _update: function() {
	        if (!this._map || !this._lngLat || !this._content) { return; }
	
	        if (!this._container) {
	            this._container = DOM.create('div', 'mapboxgl-popup', this._map.getContainer());
	            this._tip       = DOM.create('div', 'mapboxgl-popup-tip', this._container);
	            this._container.appendChild(this._content);
	        }
	
	        var pos = this._map.project(this._lngLat).round(),
	            anchor = this.options.anchor;
	
	        if (!anchor) {
	            var width = this._container.offsetWidth,
	                height = this._container.offsetHeight;
	
	            if (pos.y < height) {
	                anchor = ['top'];
	            } else if (pos.y > this._map.transform.height - height) {
	                anchor = ['bottom'];
	            } else {
	                anchor = [];
	            }
	
	            if (pos.x < width / 2) {
	                anchor.push('left');
	            } else if (pos.x > this._map.transform.width - width / 2) {
	                anchor.push('right');
	            }
	
	            if (anchor.length === 0) {
	                anchor = 'bottom';
	            } else {
	                anchor = anchor.join('-');
	            }
	        }
	
	        var anchorTranslate = {
	            'top': 'translate(-50%,0)',
	            'top-left': 'translate(0,0)',
	            'top-right': 'translate(-100%,0)',
	            'bottom': 'translate(-50%,-100%)',
	            'bottom-left': 'translate(0,-100%)',
	            'bottom-right': 'translate(-100%,-100%)',
	            'left': 'translate(0,-50%)',
	            'right': 'translate(-100%,-50%)'
	        };
	
	        var classList = this._container.classList;
	        for (var key in anchorTranslate) {
	            classList.remove('mapboxgl-popup-anchor-' + key);
	        }
	        classList.add('mapboxgl-popup-anchor-' + anchor);
	
	        DOM.setTransform(this._container, anchorTranslate[anchor] + ' translate(' + pos.x + 'px,' + pos.y + 'px)');
	    },
	
	    _onClickClose: function() {
	        this.remove();
	    }
	});


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, console, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 3.3.5
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};
	
	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule");
	var Queue = _dereq_("./queue");
	var util = _dereq_("./util");
	
	function Async() {
	    this._customScheduler = false;
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._haveDrainedQueues = false;
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule = schedule;
	}
	
	Async.prototype.setScheduler = function(fn) {
	    var prev = this._schedule;
	    this._schedule = fn;
	    this._customScheduler = true;
	    return prev;
	};
	
	Async.prototype.hasCustomScheduler = function() {
	    return this._customScheduler;
	};
	
	Async.prototype.enableTrampoline = function() {
	    this._trampolineEnabled = true;
	};
	
	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};
	
	Async.prototype.haveItemsQueued = function () {
	    return this._isTickUsed || this._haveDrainedQueues;
	};
	
	
	Async.prototype.fatalError = function(e, isNode) {
	    if (isNode) {
	        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
	            "\n");
	        process.exit(2);
	    } else {
	        this.throwLater(e);
	    }
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	};
	
	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}
	
	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };
	
	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };
	
	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}
	
	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._haveDrainedQueues = true;
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = Async;
	module.exports.firstLineError = firstLineError;
	
	},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
	var calledBind = false;
	var rejectThis = function(_, e) {
	    this._reject(e);
	};
	
	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};
	
	var bindingResolved = function(thisArg, context) {
	    if (((this._bitField & 50397184) === 0)) {
	        this._resolveCallback(context.target);
	    }
	};
	
	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};
	
	Promise.prototype.bind = function (thisArg) {
	    if (!calledBind) {
	        calledBind = true;
	        Promise.prototype._propagateFrom = debug.propagateFromFunction();
	        Promise.prototype._boundValue = debug.boundValueFunction();
	    }
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, undefined, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, undefined, ret, context);
	        ret._setOnCancel(maybePromise);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 2097152;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~2097152);
	    }
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 2097152) === 2097152;
	};
	
	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	};
	
	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;
	
	},{"./promise":22}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var args = [].slice.call(arguments, 1);;
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};
	
	},{"./util":36}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;
	
	Promise.prototype["break"] = Promise.prototype.cancel = function() {
	    if (!debug.cancellation()) return this._warn("cancellation is disabled");
	
	    var promise = this;
	    var child = promise;
	    while (promise.isCancellable()) {
	        if (!promise._cancelBy(child)) {
	            if (child._isFollowing()) {
	                child._followee().cancel();
	            } else {
	                child._cancelBranched();
	            }
	            break;
	        }
	
	        var parent = promise._cancellationParent;
	        if (parent == null || !parent.isCancellable()) {
	            if (promise._isFollowing()) {
	                promise._followee().cancel();
	            } else {
	                promise._cancelBranched();
	            }
	            break;
	        } else {
	            if (promise._isFollowing()) promise._followee().cancel();
	            child = promise;
	            promise = parent;
	        }
	    }
	};
	
	Promise.prototype._branchHasCancelled = function() {
	    this._branchesRemainingToCancel--;
	};
	
	Promise.prototype._enoughBranchesHaveCancelled = function() {
	    return this._branchesRemainingToCancel === undefined ||
	           this._branchesRemainingToCancel <= 0;
	};
	
	Promise.prototype._cancelBy = function(canceller) {
	    if (canceller === this) {
	        this._branchesRemainingToCancel = 0;
	        this._invokeOnCancel();
	        return true;
	    } else {
	        this._branchHasCancelled();
	        if (this._enoughBranchesHaveCancelled()) {
	            this._invokeOnCancel();
	            return true;
	        }
	    }
	    return false;
	};
	
	Promise.prototype._cancelBranched = function() {
	    if (this._enoughBranchesHaveCancelled()) {
	        this._cancel();
	    }
	};
	
	Promise.prototype._cancel = function() {
	    if (!this.isCancellable()) return;
	
	    this._setCancelled();
	    async.invoke(this._cancelPromises, this, undefined);
	};
	
	Promise.prototype._cancelPromises = function() {
	    if (this._length() > 0) this._settlePromises();
	};
	
	Promise.prototype._unsetOnCancel = function() {
	    this._onCancelField = undefined;
	};
	
	Promise.prototype.isCancellable = function() {
	    return this.isPending() && !this.isCancelled();
	};
	
	Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
	    if (util.isArray(onCancelCallback)) {
	        for (var i = 0; i < onCancelCallback.length; ++i) {
	            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
	        }
	    } else if (onCancelCallback !== undefined) {
	        if (typeof onCancelCallback === "function") {
	            if (!internalOnly) {
	                var e = tryCatch(onCancelCallback).call(this._boundValue());
	                if (e === errorObj) {
	                    this._attachExtraTrace(e.e);
	                    async.throwLater(e.e);
	                }
	            }
	        } else {
	            onCancelCallback._resultCancelled(this);
	        }
	    }
	};
	
	Promise.prototype._invokeOnCancel = function() {
	    var onCancelCallback = this._onCancel();
	    this._unsetOnCancel();
	    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
	};
	
	Promise.prototype._invokeInternalOnCancel = function() {
	    if (this.isCancellable()) {
	        this._doInvokeOnCancel(this._onCancel(), true);
	        this._unsetOnCancel();
	    }
	};
	
	Promise.prototype._resultCancelled = function() {
	    this.cancel();
	};
	
	};
	
	},{"./util":36}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util");
	var getKeys = _dereq_("./es5").keys;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function catchFilter(instances, cb, promise) {
	    return function(e) {
	        var boundTo = promise._boundValue();
	        predicateLoop: for (var i = 0; i < instances.length; ++i) {
	            var item = instances[i];
	
	            if (item === Error ||
	                (item != null && item.prototype instanceof Error)) {
	                if (e instanceof item) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (typeof item === "function") {
	                var matchesPredicate = tryCatch(item).call(boundTo, e);
	                if (matchesPredicate === errorObj) {
	                    return matchesPredicate;
	                } else if (matchesPredicate) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (util.isObject(e)) {
	                var keys = getKeys(item);
	                for (var j = 0; j < keys.length; ++j) {
	                    var key = keys[j];
	                    if (item[key] != e[key]) {
	                        continue predicateLoop;
	                    }
	                }
	                return tryCatch(cb).call(boundTo, e);
	            }
	        }
	        return NEXT_FILTER;
	    };
	}
	
	return catchFilter;
	};
	
	},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var longStackTraces = false;
	var contextStack = [];
	
	Promise.prototype._promiseCreated = function() {};
	Promise.prototype._pushContext = function() {};
	Promise.prototype._popContext = function() {return null;};
	Promise._peekContext = Promise.prototype._peekContext = function() {};
	
	function Context() {
	    this._trace = new Context.CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (this._trace !== undefined) {
	        this._trace._promiseCreated = null;
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (this._trace !== undefined) {
	        var trace = contextStack.pop();
	        var ret = trace._promiseCreated;
	        trace._promiseCreated = null;
	        return ret;
	    }
	    return null;
	};
	
	function createContext() {
	    if (longStackTraces) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	Context.CapturedTrace = null;
	Context.create = createContext;
	Context.deactivateLongStackTraces = function() {};
	Context.activateLongStackTraces = function() {
	    var Promise_pushContext = Promise.prototype._pushContext;
	    var Promise_popContext = Promise.prototype._popContext;
	    var Promise_PeekContext = Promise._peekContext;
	    var Promise_peekContext = Promise.prototype._peekContext;
	    var Promise_promiseCreated = Promise.prototype._promiseCreated;
	    Context.deactivateLongStackTraces = function() {
	        Promise.prototype._pushContext = Promise_pushContext;
	        Promise.prototype._popContext = Promise_popContext;
	        Promise._peekContext = Promise_PeekContext;
	        Promise.prototype._peekContext = Promise_peekContext;
	        Promise.prototype._promiseCreated = Promise_promiseCreated;
	        longStackTraces = false;
	    };
	    longStackTraces = true;
	    Promise.prototype._pushContext = Context.prototype._pushContext;
	    Promise.prototype._popContext = Context.prototype._popContext;
	    Promise._peekContext = Promise.prototype._peekContext = peekContext;
	    Promise.prototype._promiseCreated = function() {
	        var ctx = this._peekContext();
	        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
	    };
	};
	return Context;
	};
	
	},{}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, Context) {
	var getDomain = Promise._getDomain;
	var async = Promise._async;
	var Warning = _dereq_("./errors").Warning;
	var util = _dereq_("./util");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var printWarning;
	var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
	                        (true ||
	                         util.env("BLUEBIRD_DEBUG") ||
	                         util.env("NODE_ENV") === "development"));
	
	var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
	    (debugging || util.env("BLUEBIRD_WARNINGS")));
	
	var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
	    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
	
	var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
	    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
	
	Promise.prototype.suppressUnhandledRejections = function() {
	    var target = this._target();
	    target._bitField = ((target._bitField & (~1048576)) |
	                      524288);
	};
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 524288) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._setReturnedNonUndefined = function() {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._returnedNonUndefined = function() {
	    return (this._bitField & 268435456) !== 0;
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue();
	        this._setUnhandledRejectionIsNotified();
	        fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 262144;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~262144);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 262144) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 1048576;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~1048576);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
	    return warn(message, shouldUseOwnTrace, promise || this);
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};
	
	var disableLongStackTraces = function() {};
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() && !config.longStackTraces) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (!config.longStackTraces && longStackTracesIsSupported()) {
	        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
	        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
	        config.longStackTraces = true;
	        disableLongStackTraces = function() {
	            if (async.haveItemsQueued() && !config.longStackTraces) {
	                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	            }
	            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
	            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
	            Context.deactivateLongStackTraces();
	            async.enableTrampoline();
	            config.longStackTraces = false;
	        };
	        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
	        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
	        Context.activateLongStackTraces();
	        async.disableTrampolineIfNecessary();
	    }
	};
	
	Promise.hasLongStackTraces = function () {
	    return config.longStackTraces && longStackTracesIsSupported();
	};
	
	var fireDomEvent = (function() {
	    try {
	        var event = document.createEvent("CustomEvent");
	        event.initCustomEvent("testingtheevent", false, true, {});
	        util.global.dispatchEvent(event);
	        return function(name, event) {
	            var domEvent = document.createEvent("CustomEvent");
	            domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
	            return !util.global.dispatchEvent(domEvent);
	        };
	    } catch (e) {}
	    return function() {
	        return false;
	    };
	})();
	
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function() {
	            return process.emit.apply(process, arguments);
	        };
	    } else {
	        if (!util.global) {
	            return function() {
	                return false;
	            };
	        }
	        return function(name) {
	            var methodName = "on" + name.toLowerCase();
	            var method = util.global[methodName];
	            if (!method) return false;
	            method.apply(util.global, [].slice.call(arguments, 1));
	            return true;
	        };
	    }
	})();
	
	function generatePromiseLifecycleEventObject(name, promise) {
	    return {promise: promise};
	}
	
	var eventToObjectGenerator = {
	    promiseCreated: generatePromiseLifecycleEventObject,
	    promiseFulfilled: generatePromiseLifecycleEventObject,
	    promiseRejected: generatePromiseLifecycleEventObject,
	    promiseResolved: generatePromiseLifecycleEventObject,
	    promiseCancelled: generatePromiseLifecycleEventObject,
	    promiseChained: function(name, promise, child) {
	        return {promise: promise, child: child};
	    },
	    warning: function(name, warning) {
	        return {warning: warning};
	    },
	    unhandledRejection: function (name, reason, promise) {
	        return {reason: reason, promise: promise};
	    },
	    rejectionHandled: generatePromiseLifecycleEventObject
	};
	
	var activeFireEvent = function (name) {
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent.apply(null, arguments);
	    } catch (e) {
	        async.throwLater(e);
	        globalEventFired = true;
	    }
	
	    var domEventFired = false;
	    try {
	        domEventFired = fireDomEvent(name,
	                    eventToObjectGenerator[name].apply(null, arguments));
	    } catch (e) {
	        async.throwLater(e);
	        domEventFired = true;
	    }
	
	    return domEventFired || globalEventFired;
	};
	
	Promise.config = function(opts) {
	    opts = Object(opts);
	    if ("longStackTraces" in opts) {
	        if (opts.longStackTraces) {
	            Promise.longStackTraces();
	        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
	            disableLongStackTraces();
	        }
	    }
	    if ("warnings" in opts) {
	        var warningsOption = opts.warnings;
	        config.warnings = !!warningsOption;
	        wForgottenReturn = config.warnings;
	
	        if (util.isObject(warningsOption)) {
	            if ("wForgottenReturn" in warningsOption) {
	                wForgottenReturn = !!warningsOption.wForgottenReturn;
	            }
	        }
	    }
	    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
	        if (async.haveItemsQueued()) {
	            throw new Error(
	                "cannot enable cancellation after promises are in use");
	        }
	        Promise.prototype._clearCancellationData =
	            cancellationClearCancellationData;
	        Promise.prototype._propagateFrom = cancellationPropagateFrom;
	        Promise.prototype._onCancel = cancellationOnCancel;
	        Promise.prototype._setOnCancel = cancellationSetOnCancel;
	        Promise.prototype._attachCancellationCallback =
	            cancellationAttachCancellationCallback;
	        Promise.prototype._execute = cancellationExecute;
	        propagateFromFunction = cancellationPropagateFrom;
	        config.cancellation = true;
	    }
	    if ("monitoring" in opts) {
	        if (opts.monitoring && !config.monitoring) {
	            config.monitoring = true;
	            Promise.prototype._fireEvent = activeFireEvent;
	        } else if (!opts.monitoring && config.monitoring) {
	            config.monitoring = false;
	            Promise.prototype._fireEvent = defaultFireEvent;
	        }
	    }
	};
	
	function defaultFireEvent() { return false; }
	
	Promise.prototype._fireEvent = defaultFireEvent;
	Promise.prototype._execute = function(executor, resolve, reject) {
	    try {
	        executor(resolve, reject);
	    } catch (e) {
	        return e;
	    }
	};
	Promise.prototype._onCancel = function () {};
	Promise.prototype._setOnCancel = function (handler) { ; };
	Promise.prototype._attachCancellationCallback = function(onCancel) {
	    ;
	};
	Promise.prototype._captureStackTrace = function () {};
	Promise.prototype._attachExtraTrace = function () {};
	Promise.prototype._clearCancellationData = function() {};
	Promise.prototype._propagateFrom = function (parent, flags) {
	    ;
	    ;
	};
	
	function cancellationExecute(executor, resolve, reject) {
	    var promise = this;
	    try {
	        executor(resolve, reject, function(onCancel) {
	            if (typeof onCancel !== "function") {
	                throw new TypeError("onCancel must be a function, got: " +
	                                    util.toString(onCancel));
	            }
	            promise._attachCancellationCallback(onCancel);
	        });
	    } catch (e) {
	        return e;
	    }
	}
	
	function cancellationAttachCancellationCallback(onCancel) {
	    if (!this.isCancellable()) return this;
	
	    var previousOnCancel = this._onCancel();
	    if (previousOnCancel !== undefined) {
	        if (util.isArray(previousOnCancel)) {
	            previousOnCancel.push(onCancel);
	        } else {
	            this._setOnCancel([previousOnCancel, onCancel]);
	        }
	    } else {
	        this._setOnCancel(onCancel);
	    }
	}
	
	function cancellationOnCancel() {
	    return this._onCancelField;
	}
	
	function cancellationSetOnCancel(onCancel) {
	    this._onCancelField = onCancel;
	}
	
	function cancellationClearCancellationData() {
	    this._cancellationParent = undefined;
	    this._onCancelField = undefined;
	}
	
	function cancellationPropagateFrom(parent, flags) {
	    if ((flags & 1) !== 0) {
	        this._cancellationParent = parent;
	        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
	        if (branchesRemainingToCancel === undefined) {
	            branchesRemainingToCancel = 0;
	        }
	        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
	    }
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	
	function bindingPropagateFrom(parent, flags) {
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	var propagateFromFunction = bindingPropagateFrom;
	
	function boundValueFunction() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	}
	
	function longStackTracesCaptureStackTrace() {
	    this._trace = new CapturedTrace(this._peekContext());
	}
	
	function longStackTracesAttachExtraTrace(error, ignoreSelf) {
	    if (canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	}
	
	function checkForgottenReturns(returnValue, promiseCreated, name, promise,
	                               parent) {
	    if (returnValue === undefined && promiseCreated !== null &&
	        wForgottenReturn) {
	        if (parent !== undefined && parent._returnedNonUndefined()) return;
	        if ((promise._bitField & 65535) === 0) return;
	
	        if (name) name = name + " ";
	        var msg = "a promise was created in a " + name +
	            "handler but was not returned from it";
	        promise._warn(msg, true, promiseCreated);
	    }
	}
	
	function deprecated(name, replacement) {
	    var message = name +
	        " is deprecated and will be removed in a future version.";
	    if (replacement) message += " Use " + replacement + " instead.";
	    return warn(message);
	}
	
	function warn(message, shouldUseOwnTrace, promise) {
	    if (!config.warnings) return;
	    var warning = new Warning(message);
	    var ctx;
	    if (shouldUseOwnTrace) {
	        promise._attachExtraTrace(warning);
	    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	
	    if (!activeFireEvent("warning", warning)) {
	        formatAndLogError(warning, "", true);
	    }
	}
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = "    (No stack trace)" === line ||
	            stackFramePattern.test(line);
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	function parseStackAndMessage(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	}
	
	function formatAndLogError(error, title, isSoft) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (util.isObject(error)) {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof printWarning === "function") {
	            printWarning(message, isSoft);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	}
	
	function fireRejectionEvent(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    if (name === "unhandledRejection") {
	        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
	            formatAndLogError(reason, "Unhandled rejection ");
	        }
	    } else {
	        activeFireEvent(name, promise);
	    }
	}
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj && typeof obj.toString === "function"
	            ? obj.toString() : util.toString(obj);
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	function longStackTracesIsSupported() {
	    return typeof captureStackTrace === "function";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	
	function setBounds(firstLineError, lastLineError) {
	    if (!longStackTracesIsSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    this._promisesCreated = 0;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	Context.CapturedTrace = CapturedTrace;
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit += 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit += 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit -= 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit += 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit -= 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    printWarning = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        printWarning = function(message, isSoft) {
	            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
	            console.warn(color + message + "\u001b[0m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        printWarning = function(message, isSoft) {
	            console.warn("%c" + message,
	                        isSoft ? "color: darkorange" : "color: red");
	        };
	    }
	}
	
	var config = {
	    warnings: warnings,
	    longStackTraces: false,
	    cancellation: false,
	    monitoring: false
	};
	
	if (longStackTraces) Promise.longStackTraces();
	
	return {
	    longStackTraces: function() {
	        return config.longStackTraces;
	    },
	    warnings: function() {
	        return config.warnings;
	    },
	    cancellation: function() {
	        return config.cancellation;
	    },
	    monitoring: function() {
	        return config.monitoring;
	    },
	    propagateFromFunction: function() {
	        return propagateFromFunction;
	    },
	    boundValueFunction: function() {
	        return boundValueFunction;
	    },
	    checkForgottenReturns: checkForgottenReturns,
	    setBounds: setBounds,
	    warn: warn,
	    deprecated: deprecated,
	    CapturedTrace: CapturedTrace,
	    fireDomEvent: fireDomEvent,
	    fireGlobalEvent: fireGlobalEvent
	};
	};
	
	},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function returner() {
	    return this.value;
	}
	function thrower() {
	    throw this.reason;
	}
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value instanceof Promise) value.suppressUnhandledRejections();
	    return this._then(
	        returner, undefined, undefined, {value: value}, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    return this._then(
	        thrower, undefined, undefined, {reason: reason}, undefined);
	};
	
	Promise.prototype.catchThrow = function (reason) {
	    if (arguments.length <= 1) {
	        return this._then(
	            undefined, thrower, undefined, {reason: reason}, undefined);
	    } else {
	        var _reason = arguments[1];
	        var handler = function() {throw _reason;};
	        return this.caught(reason, handler);
	    }
	};
	
	Promise.prototype.catchReturn = function (value) {
	    if (arguments.length <= 1) {
	        if (value instanceof Promise) value.suppressUnhandledRejections();
	        return this._then(
	            undefined, returner, undefined, {value: value}, undefined);
	    } else {
	        var _value = arguments[1];
	        if (_value instanceof Promise) _value.suppressUnhandledRejections();
	        var handler = function() {return _value;};
	        return this.caught(value, handler);
	    }
	};
	};
	
	},{}],11:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	var PromiseAll = Promise.all;
	
	function promiseAllThis() {
	    return PromiseAll(this);
	}
	
	function PromiseMapSeries(promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
	}
	
	Promise.prototype.each = function (fn) {
	    return this.mapSeries(fn)
	            ._then(promiseAllThis, undefined, undefined, this, undefined);
	};
	
	Promise.prototype.mapSeries = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseMapSeries(promises, fn)
	            ._then(promiseAllThis, undefined, undefined, promises, undefined);
	};
	
	Promise.mapSeries = PromiseMapSeries;
	};
	
	},{}],12:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
	        value: errorTypes,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};
	
	},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}
	
	},{}],14:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};
	
	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, tryConvertToPromise) {
	var util = _dereq_("./util");
	var CancellationError = Promise.CancellationError;
	var errorObj = util.errorObj;
	
	function PassThroughHandlerContext(promise, type, handler) {
	    this.promise = promise;
	    this.type = type;
	    this.handler = handler;
	    this.called = false;
	    this.cancelPromise = null;
	}
	
	PassThroughHandlerContext.prototype.isFinallyHandler = function() {
	    return this.type === 0;
	};
	
	function FinallyHandlerCancelReaction(finallyHandler) {
	    this.finallyHandler = finallyHandler;
	}
	
	FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
	    checkCancel(this.finallyHandler);
	};
	
	function checkCancel(ctx, reason) {
	    if (ctx.cancelPromise != null) {
	        if (arguments.length > 1) {
	            ctx.cancelPromise._reject(reason);
	        } else {
	            ctx.cancelPromise._cancel();
	        }
	        ctx.cancelPromise = null;
	        return true;
	    }
	    return false;
	}
	
	function succeed() {
	    return finallyHandler.call(this, this.promise._target()._settledValue());
	}
	function fail(reason) {
	    if (checkCancel(this, reason)) return;
	    errorObj.e = reason;
	    return errorObj;
	}
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    if (!this.called) {
	        this.called = true;
	        var ret = this.isFinallyHandler()
	            ? handler.call(promise._boundValue())
	            : handler.call(promise._boundValue(), reasonOrValue);
	        if (ret !== undefined) {
	            promise._setReturnedNonUndefined();
	            var maybePromise = tryConvertToPromise(ret, promise);
	            if (maybePromise instanceof Promise) {
	                if (this.cancelPromise != null) {
	                    if (maybePromise.isCancelled()) {
	                        var reason =
	                            new CancellationError("late cancellation observer");
	                        promise._attachExtraTrace(reason);
	                        errorObj.e = reason;
	                        return errorObj;
	                    } else if (maybePromise.isPending()) {
	                        maybePromise._attachCancellationCallback(
	                            new FinallyHandlerCancelReaction(this));
	                    }
	                }
	                return maybePromise._then(
	                    succeed, fail, undefined, this, undefined);
	            }
	        }
	    }
	
	    if (promise.isRejected()) {
	        checkCancel(this);
	        errorObj.e = reasonOrValue;
	        return errorObj;
	    } else {
	        checkCancel(this);
	        return reasonOrValue;
	    }
	}
	
	Promise.prototype._passThrough = function(handler, type, success, fail) {
	    if (typeof handler !== "function") return this.then();
	    return this._then(success,
	                      fail,
	                      undefined,
	                      new PassThroughHandlerContext(this, type, handler),
	                      undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThrough(handler,
	                             0,
	                             finallyHandler,
	                             finallyHandler);
	};
	
	Promise.prototype.tap = function (handler) {
	    return this._passThrough(handler, 1, finallyHandler);
	};
	
	return PassThroughHandlerContext;
	};
	
	},{"./util":36}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise,
	                          Proxyable,
	                          debug) {
	var errors = _dereq_("./errors");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    if (debug.cancellation()) {
	        var internal = new Promise(INTERNAL);
	        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
	        this._promise = internal.lastly(function() {
	            return _finallyPromise;
	        });
	        internal._captureStackTrace();
	        internal._setOnCancel(this);
	    } else {
	        var promise = this._promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	    }
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	    this._yieldedPromise = null;
	    this._cancellationPhase = false;
	}
	util.inherits(PromiseSpawn, Proxyable);
	
	PromiseSpawn.prototype._isResolved = function() {
	    return this._promise === null;
	};
	
	PromiseSpawn.prototype._cleanup = function() {
	    this._promise = this._generator = null;
	    if (debug.cancellation() && this._finallyPromise !== null) {
	        this._finallyPromise._fulfill();
	        this._finallyPromise = null;
	    }
	};
	
	PromiseSpawn.prototype._promiseCancelled = function() {
	    if (this._isResolved()) return;
	    var implementsReturn = typeof this._generator["return"] !== "undefined";
	
	    var result;
	    if (!implementsReturn) {
	        var reason = new Promise.CancellationError(
	            "generator .return() sentinel");
	        Promise.coroutine.returnSentinel = reason;
	        this._promise._attachExtraTrace(reason);
	        this._promise._pushContext();
	        result = tryCatch(this._generator["throw"]).call(this._generator,
	                                                         reason);
	        this._promise._popContext();
	    } else {
	        this._promise._pushContext();
	        result = tryCatch(this._generator["return"]).call(this._generator,
	                                                          undefined);
	        this._promise._popContext();
	    }
	    this._cancellationPhase = true;
	    this._yieldedPromise = null;
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseFulfilled = function(value) {
	    this._yieldedPromise = null;
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseRejected = function(reason) {
	    this._yieldedPromise = null;
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._resultCancelled = function() {
	    if (this._yieldedPromise instanceof Promise) {
	        var promise = this._yieldedPromise;
	        this._yieldedPromise = null;
	        promise.cancel();
	    }
	};
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._promiseFulfilled(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    var promise = this._promise;
	    if (result === errorObj) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._rejectCallback(result.e, false);
	        }
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._resolveCallback(value);
	        }
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._promiseRejected(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise = maybePromise._target();
	        var bitField = maybePromise._bitField;
	        ;
	        if (((bitField & 50397184) === 0)) {
	            this._yieldedPromise = maybePromise;
	            maybePromise._proxy(this, null);
	        } else if (((bitField & 33554432) !== 0)) {
	            this._promiseFulfilled(maybePromise._value());
	        } else if (((bitField & 16777216) !== 0)) {
	            this._promiseRejected(maybePromise._reason());
	        } else {
	            this._promiseCancelled();
	        }
	    }
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        var ret = spawn.promise();
	        spawn._generator = generator;
	        spawn._promiseFulfilled(undefined);
	        return ret;
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};
	
	},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var promiseSetter = function(i) {
	        return new Function("promise", "holder", "                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g, i));
	    };
	
	    var generateHolderClass = function(total) {
	        var props = new Array(total);
	        for (var i = 0; i < props.length; ++i) {
	            props[i] = "this.p" + (i+1);
	        }
	        var assignment = props.join(" = ") + " = null;";
	        var cancellationCode= "var promise;\n" + props.map(function(prop) {
	            return "                                                         \n\
	                promise = " + prop + ";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";
	        }).join("\n");
	        var passedArguments = props.join(", ");
	        var name = "Holder$" + total;
	
	
	        var code = "return function(tryCatch, errorObj, Promise) {           \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    promise._pushContext();                                  \n\
	                    var callback = this.fn;                                  \n\
	                    var ret = tryCatch(callback)([ThePassedArguments]);      \n\
	                    promise._popContext();                                   \n\
	                    if (ret === errorObj) {                                  \n\
	                        promise._rejectCallback(ret.e, false);               \n\
	                    } else {                                                 \n\
	                        promise._resolveCallback(ret);                       \n\
	                    }                                                        \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise);                                      \n\
	        ";
	
	        code = code.replace(/\[TheName\]/g, name)
	            .replace(/\[TheTotal\]/g, total)
	            .replace(/\[ThePassedArguments\]/g, passedArguments)
	            .replace(/\[TheProperties\]/g, assignment)
	            .replace(/\[CancellationCode\]/g, cancellationCode);
	
	        return new Function("tryCatch", "errorObj", "Promise", code)
	                           (tryCatch, errorObj, Promise);
	    };
	
	    var holderClasses = [];
	    var thenCallbacks = [];
	    var promiseSetters = [];
	
	    for (var i = 0; i < 8; ++i) {
	        holderClasses.push(generateHolderClass(i + 1));
	        thenCallbacks.push(thenCallback(i + 1));
	        promiseSetters.push(promiseSetter(i + 1));
	    }
	
	    reject = function (reason) {
	        this._reject(reason);
	    };
	}}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last <= 8 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var HolderClass = holderClasses[last - 1];
	                var holder = new HolderClass(fn);
	                var callbacks = thenCallbacks;
	
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        var bitField = maybePromise._bitField;
	                        ;
	                        if (((bitField & 50397184) === 0)) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                            promiseSetters[i](maybePromise, holder);
	                        } else if (((bitField & 33554432) !== 0)) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else if (((bitField & 16777216) !== 0)) {
	                            ret._reject(maybePromise._reason());
	                        } else {
	                            ret._cancel();
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                if (!ret._isFateSealed()) {
	                    ret._setAsyncGuaranteed();
	                    ret._setOnCancel(holder);
	                }
	                return ret;
	            }
	        }
	    }
	    var args = [].slice.call(arguments);;
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};
	
	},{"./util":36}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var EMPTY_ARRAY = [];
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    this._init$(undefined, -2);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	
	    if (index < 0) {
	        index = (index * -1) - 1;
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return true;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return false;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var promise = this._promise;
	        var callback = this._callback;
	        var receiver = promise._boundValue();
	        promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        var promiseCreated = promise._popContext();
	        debug.checkForgottenReturns(
	            ret,
	            promiseCreated,
	            preservedValues !== null ? "Promise.filter" : "Promise.map",
	            promise
	        );
	        if (ret === errorObj) {
	            this._reject(ret.e);
	            return true;
	        }
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            var bitField = maybePromise._bitField;
	            ;
	            if (((bitField & 50397184) === 0)) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = maybePromise;
	                maybePromise._proxy(this, (index + 1) * -1);
	                return false;
	            } else if (((bitField & 33554432) !== 0)) {
	                ret = maybePromise._value();
	            } else if (((bitField & 16777216) !== 0)) {
	                this._reject(maybePromise._reason());
	                return true;
	            } else {
	                this._cancel();
	                return true;
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	        return true;
	    }
	    return false;
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
	}
	
	Promise.prototype.map = function (fn, options) {
	    return map(this, fn, options, null);
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    return map(promises, fn, options, _filter);
	};
	
	
	};
	
	},{"./util":36}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        var promiseCreated = ret._popContext();
	        debug.checkForgottenReturns(
	            value, promiseCreated, "Promise.method", ret);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value;
	    if (arguments.length > 1) {
	        debug.deprecated("calling Promise.try with more than 1 argument");
	        var arg = arguments[1];
	        var ctx = arguments[2];
	        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
	                                  : tryCatch(fn).call(ctx, arg);
	    } else {
	        value = tryCatch(fn)();
	    }
	    var promiseCreated = ret._popContext();
	    debug.checkForgottenReturns(
	        value, promiseCreated, "Promise.try", ret);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};
	
	},{"./util":36}],20:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors");
	var OperationalError = errors.OperationalError;
	var es5 = _dereq_("./es5");
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise, multiArgs) {
	    return function(err, value) {
	        if (promise === null) return;
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (!multiArgs) {
	            promise._fulfill(value);
	        } else {
	            var args = [].slice.call(arguments, 1);;
	            promise._fulfill(args);
	        }
	        promise = null;
	    };
	}
	
	module.exports = nodebackForPromise;
	
	},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var async = Promise._async;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var newReason = new Error(reason + "");
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
	                                                                     options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};
	
	},{"./util":36}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var reflectHandler = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	function Proxyable() {}
	var UNDEFINED_BINDING = {};
	var util = _dereq_("./util");
	
	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);
	
	var es5 = _dereq_("./es5");
	var Async = _dereq_("./async");
	var async = new Async();
	es5.defineProperty(Promise, "_async", {value: async});
	var errors = _dereq_("./errors");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	var CancellationError = Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {};
	var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array")(Promise, INTERNAL,
	                               tryConvertToPromise, apiRejection, Proxyable);
	var Context = _dereq_("./context")(Promise);
	 /*jshint unused:false*/
	var createContext = Context.create;
	var debug = _dereq_("./debuggability")(Promise, Context);
	var CapturedTrace = debug.CapturedTrace;
	var PassThroughHandlerContext =
	    _dereq_("./finally")(Promise, tryConvertToPromise);
	var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
	var nodebackForPromise = _dereq_("./nodeback");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function check(self, executor) {
	    if (typeof executor !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(executor));
	    }
	    if (self.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	}
	
	function Promise(executor) {
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    if (executor !== INTERNAL) {
	        check(this, executor);
	        this._resolveFromExecutor(executor);
	    }
	    this._promiseCreated();
	    this._fireEvent("promiseCreated", this);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return apiRejection("expecting an object but got " + util.classString(item));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        return this.then(undefined, catchFilter(catchInstances, fn, this));
	    }
	    return this.then(undefined, fn);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflectHandler,
	        reflectHandler, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject) {
	    if (debug.warnings() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, undefined, undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject) {
	    var promise =
	        this._then(didFulfill, didReject, undefined, undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    if (arguments.length > 0) {
	        this._warn(".all() was passed arguments but it does not take any");
	    }
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = Promise.fromCallback = function(fn) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
	                                         : false;
	    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true);
	    }
	    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._setFulfilled();
	        ret._rejectionHandler0 = obj;
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return async.setScheduler(fn);
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    _,    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
	    var target = this._target();
	    var bitField = target._bitField;
	
	    if (!haveInternalData) {
	        promise._propagateFrom(this, 3);
	        promise._captureStackTrace();
	        if (receiver === undefined &&
	            ((this._bitField & 2097152) !== 0)) {
	            if (!((bitField & 50397184) === 0)) {
	                receiver = this._boundValue();
	            } else {
	                receiver = target === this ? undefined : this._boundTo;
	            }
	        }
	        this._fireEvent("promiseChained", this, promise);
	    }
	
	    var domain = getDomain();
	    if (!((bitField & 50397184) === 0)) {
	        var handler, value, settler = target._settlePromiseCtx;
	        if (((bitField & 33554432) !== 0)) {
	            value = target._rejectionHandler0;
	            handler = didFulfill;
	        } else if (((bitField & 16777216) !== 0)) {
	            value = target._fulfillmentHandler0;
	            handler = didReject;
	            target._unsetRejectionIsUnhandled();
	        } else {
	            settler = target._settlePromiseLateCancellationObserver;
	            value = new CancellationError("late cancellation observer");
	            target._attachExtraTrace(value);
	            handler = didReject;
	        }
	
	        async.invoke(settler, target, {
	            handler: domain === null ? handler
	                : (typeof handler === "function" && domain.bind(handler)),
	            promise: promise,
	            receiver: receiver,
	            value: value
	        });
	    } else {
	        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
	    }
	
	    return promise;
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 65535;
	};
	
	Promise.prototype._isFateSealed = function () {
	    return (this._bitField & 117506048) !== 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 67108864) === 67108864;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -65536) |
	        (len & 65535);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 33554432;
	    this._fireEvent("promiseFulfilled", this);
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 16777216;
	    this._fireEvent("promiseRejected", this);
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 67108864;
	    this._fireEvent("promiseResolved", this);
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._unsetCancelled = function() {
	    this._bitField = this._bitField & (~65536);
	};
	
	Promise.prototype._setCancelled = function() {
	    this._bitField = this._bitField | 65536;
	    this._fireEvent("promiseCancelled", this);
	};
	
	Promise.prototype._setAsyncGuaranteed = function() {
	    if (async.hasCustomScheduler()) return;
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0 ? this._receiver0 : this[
	            index * 4 - 4 + 3];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return this[
	            index * 4 - 4 + 2];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 1];
	};
	
	Promise.prototype._boundValue = function() {};
	
	Promise.prototype._migrateCallback0 = function (follower) {
	    var bitField = follower._bitField;
	    var fulfill = follower._fulfillmentHandler0;
	    var reject = follower._rejectionHandler0;
	    var promise = follower._promise0;
	    var receiver = follower._receiverAt(0);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._migrateCallbackAt = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();
	
	    if (index >= 65535 - 4) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        this._receiver0 = receiver;
	        if (typeof fulfill === "function") {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : domain.bind(reject);
	        }
	    } else {
	        var base = index * 4 - 4;
	        this[base + 2] = promise;
	        this[base + 3] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : domain.bind(reject);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._proxy = function (proxyable, arg) {
	    this._addCallbacks(undefined, undefined, arg, proxyable, null);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (((this._bitField & 117506048) !== 0)) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    if (shouldBind) this._propagateFrom(maybePromise, 2);
	
	    var promise = maybePromise._target();
	
	    if (promise === this) {
	        this._reject(makeSelfResolutionError());
	        return;
	    }
	
	    var bitField = promise._bitField;
	    if (((bitField & 50397184) === 0)) {
	        var len = this._length();
	        if (len > 0) promise._migrateCallback0(this);
	        for (var i = 1; i < len; ++i) {
	            promise._migrateCallbackAt(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (((bitField & 33554432) !== 0)) {
	        this._fulfill(promise._value());
	    } else if (((bitField & 16777216) !== 0)) {
	        this._reject(promise._reason());
	    } else {
	        var reason = new CancellationError("late cancellation observer");
	        promise._attachExtraTrace(reason);
	        this._reject(reason);
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, ignoreNonErrorWarnings) {
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
	        var message = "a promise was rejected with a non-error: " +
	            util.classString(reason);
	        this._warn(message, true);
	    }
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason);
	};
	
	Promise.prototype._resolveFromExecutor = function (executor) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = this._execute(executor, function(value) {
	        promise._resolveCallback(value);
	    }, function (reason) {
	        promise._rejectCallback(reason, synchronous);
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined) {
	        promise._rejectCallback(r, true);
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    var bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY) {
	        if (!value || typeof value.length !== "number") {
	            x = errorObj;
	            x.e = new TypeError("cannot .spread() a non-array: " +
	                                    util.classString(value));
	        } else {
	            x = tryCatch(handler).apply(this._boundValue(), value);
	        }
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    var promiseCreated = promise._popContext();
	    bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	
	    if (x === NEXT_FILTER) {
	        promise._reject(value);
	    } else if (x === errorObj) {
	        promise._rejectCallback(x.e, false);
	    } else {
	        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
	    var isPromise = promise instanceof Promise;
	    var bitField = this._bitField;
	    var asyncGuaranteed = ((bitField & 134217728) !== 0);
	    if (((bitField & 65536) !== 0)) {
	        if (isPromise) promise._invokeInternalOnCancel();
	
	        if (receiver instanceof PassThroughHandlerContext &&
	            receiver.isFinallyHandler()) {
	            receiver.cancelPromise = promise;
	            if (tryCatch(handler).call(receiver, value) === errorObj) {
	                promise._reject(errorObj.e);
	            }
	        } else if (handler === reflectHandler) {
	            promise._fulfill(reflectHandler.call(receiver));
	        } else if (receiver instanceof Proxyable) {
	            receiver._promiseCancelled(promise);
	        } else if (isPromise || promise instanceof PromiseArray) {
	            promise._cancel();
	        } else {
	            receiver.cancel();
	        }
	    } else if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            if (asyncGuaranteed) promise._setAsyncGuaranteed();
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof Proxyable) {
	        if (!receiver._isResolved()) {
	            if (((bitField & 33554432) !== 0)) {
	                receiver._promiseFulfilled(value, promise);
	            } else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (asyncGuaranteed) promise._setAsyncGuaranteed();
	        if (((bitField & 33554432) !== 0)) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value);
	        }
	    }
	};
	
	Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
	    var handler = ctx.handler;
	    var promise = ctx.promise;
	    var receiver = ctx.receiver;
	    var value = ctx.value;
	    if (typeof handler === "function") {
	        if (!(promise instanceof Promise)) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (promise instanceof Promise) {
	        promise._reject(value);
	    }
	};
	
	Promise.prototype._settlePromiseCtx = function(ctx) {
	    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
	};
	
	Promise.prototype._settlePromise0 = function(handler, value, bitField) {
	    var promise = this._promise0;
	    var receiver = this._receiverAt(0);
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settlePromise(promise, handler, receiver, value);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    var base = index * 4 - 4;
	    this[base + 2] =
	    this[base + 3] =
	    this[base + 0] =
	    this[base + 1] = undefined;
	};
	
	Promise.prototype._fulfill = function (value) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._reject(err);
	    }
	    this._setFulfilled();
	    this._rejectionHandler0 = value;
	
	    if ((bitField & 65535) > 0) {
	        if (((bitField & 134217728) !== 0)) {
	            this._settlePromises();
	        } else {
	            async.settlePromises(this);
	        }
	    }
	};
	
	Promise.prototype._reject = function (reason) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    this._setRejected();
	    this._fulfillmentHandler0 = reason;
	
	    if (this._isFinal()) {
	        return async.fatalError(reason, util.isNode);
	    }
	
	    if ((bitField & 65535) > 0) {
	        async.settlePromises(this);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._fulfillPromises = function (len, value) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._fulfillmentHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, value);
	    }
	};
	
	Promise.prototype._rejectPromises = function (len, reason) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._rejectionHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, reason);
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    var bitField = this._bitField;
	    var len = (bitField & 65535);
	
	    if (len > 0) {
	        if (((bitField & 16842752) !== 0)) {
	            var reason = this._fulfillmentHandler0;
	            this._settlePromise0(this._rejectionHandler0, reason, bitField);
	            this._rejectPromises(len, reason);
	        } else {
	            var value = this._rejectionHandler0;
	            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
	            this._fulfillPromises(len, value);
	        }
	        this._setLength(0);
	    }
	    this._clearCancellationData();
	};
	
	Promise.prototype._settledValue = function() {
	    var bitField = this._bitField;
	    if (((bitField & 33554432) !== 0)) {
	        return this._rejectionHandler0;
	    } else if (((bitField & 16777216) !== 0)) {
	        return this._fulfillmentHandler0;
	    }
	};
	
	function deferResolve(v) {this.promise._resolveCallback(v);}
	function deferReject(v) {this.promise._rejectCallback(v, false);}
	
	Promise.defer = Promise.pending = function() {
	    debug.deprecated("Promise.defer", "new Promise");
	    var promise = new Promise(INTERNAL);
	    return {
	        promise: promise,
	        resolve: deferResolve,
	        reject: deferReject
	    };
	};
	
	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);
	
	_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
	    debug);
	_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
	_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
	_dereq_("./direct_resolve")(Promise);
	_dereq_("./synchronous_inspection")(Promise);
	_dereq_("./join")(
	    Promise, PromiseArray, tryConvertToPromise, INTERNAL, debug);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
	_dereq_('./timers.js')(Promise, INTERNAL, debug);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./settle.js')(Promise, PromiseArray, debug);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./filter.js')(Promise, INTERNAL);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    debug.setBounds(Async.firstLineError, util.lastLineError);               
	    return Promise;                                                          
	
	};
	
	},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection, Proxyable) {
	var util = _dereq_("./util");
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    if (values instanceof Promise) {
	        promise._propagateFrom(values, 3);
	    }
	    promise._setOnCancel(this);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	util.inherits(PromiseArray, Proxyable);
	
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        var bitField = values._bitField;
	        ;
	        this._values = values;
	
	        if (((bitField & 50397184) === 0)) {
	            this._promise._setAsyncGuaranteed();
	            return values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	        } else if (((bitField & 33554432) !== 0)) {
	            values = values._value();
	        } else if (((bitField & 16777216) !== 0)) {
	            return this._reject(values._reason());
	        } else {
	            return this._cancel();
	        }
	    }
	    values = util.asArray(values);
	    if (values === null) {
	        var err = apiRejection(
	            "expecting an array or an iterable object but got " + util.classString(values)).reason();
	        this._promise._rejectCallback(err, false);
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    this._iterate(values);
	};
	
	PromiseArray.prototype._iterate = function(values) {
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var result = this._promise;
	    var isResolved = false;
	    var bitField = null;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = tryConvertToPromise(values[i], result);
	
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            bitField = maybePromise._bitField;
	        } else {
	            bitField = null;
	        }
	
	        if (isResolved) {
	            if (bitField !== null) {
	                maybePromise.suppressUnhandledRejections();
	            }
	        } else if (bitField !== null) {
	            if (((bitField & 50397184) === 0)) {
	                maybePromise._proxy(this, i);
	                this._values[i] = maybePromise;
	            } else if (((bitField & 33554432) !== 0)) {
	                isResolved = this._promiseFulfilled(maybePromise._value(), i);
	            } else if (((bitField & 16777216) !== 0)) {
	                isResolved = this._promiseRejected(maybePromise._reason(), i);
	            } else {
	                isResolved = this._promiseCancelled(i);
	            }
	        } else {
	            isResolved = this._promiseFulfilled(maybePromise, i);
	        }
	    }
	    if (!isResolved) result._setAsyncGuaranteed();
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype._cancel = function() {
	    if (this._isResolved() || !this._promise.isCancellable()) return;
	    this._values = null;
	    this._promise._cancel();
	};
	
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false);
	};
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	PromiseArray.prototype._promiseCancelled = function() {
	    this._cancel();
	    return true;
	};
	
	PromiseArray.prototype._promiseRejected = function (reason) {
	    this._totalResolved++;
	    this._reject(reason);
	    return true;
	};
	
	PromiseArray.prototype._resultCancelled = function() {
	    if (this._isResolved()) return;
	    var values = this._values;
	    this._cancel();
	    if (values instanceof Promise) {
	        values.cancel();
	    } else {
	        for (var i = 0; i < values.length; ++i) {
	            if (values[i] instanceof Promise) {
	                values[i].cancel();
	            }
	        }
	    }
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};
	
	},{"./util":36}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util");
	var nodebackForPromise = _dereq_("./nodeback");
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
	
	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn, _, multiArgs) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	    var body = "'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode);
	    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL",
	                        body)(
	                    Promise,
	                    fn,
	                    receiver,
	                    withAppended,
	                    maybeWrapAsError,
	                    nodebackForPromise,
	                    util.tryCatch,
	                    util.errorObj,
	                    util.notEnumerableProp,
	                    INTERNAL);
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise, multiArgs);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key,
	                                           fn, suffix, multiArgs);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver, multiArgs) {
	    return makeNodePromisified(callback, receiver, undefined,
	                                callback, null, multiArgs);
	}
	
	Promise.promisify = function (fn, options) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    options = Object(options);
	    var receiver = options.context === undefined ? THIS : options.context;
	    var multiArgs = !!options.multiArgs;
	    var ret = promisify(fn, receiver, multiArgs);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    options = Object(options);
	    var multiArgs = !!options.multiArgs;
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier,
	                multiArgs);
	            promisifyAll(value, suffix, filter, promisifier, multiArgs);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
	};
	};
	
	
	},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5");
	var Es6Map;
	if (typeof Map === "function") Es6Map = Map;
	
	var mapToEntries = (function() {
	    var index = 0;
	    var size = 0;
	
	    function extractEntry(value, key) {
	        this[index] = value;
	        this[index + size] = key;
	        index++;
	    }
	
	    return function mapToEntries(map) {
	        size = map.size;
	        index = 0;
	        var ret = new Array(map.size * 2);
	        map.forEach(extractEntry, ret);
	        return ret;
	    };
	})();
	
	var entriesToMap = function(entries) {
	    var ret = new Es6Map();
	    var length = entries.length / 2 | 0;
	    for (var i = 0; i < length; ++i) {
	        var key = entries[length + i];
	        var value = entries[i];
	        ret.set(key, value);
	    }
	    return ret;
	};
	
	function PropertiesPromiseArray(obj) {
	    var isMap = false;
	    var entries;
	    if (Es6Map !== undefined && obj instanceof Es6Map) {
	        entries = mapToEntries(obj);
	        isMap = true;
	    } else {
	        var keys = es5.keys(obj);
	        var len = keys.length;
	        entries = new Array(len * 2);
	        for (var i = 0; i < len; ++i) {
	            var key = keys[i];
	            entries[i] = obj[key];
	            entries[i + len] = key;
	        }
	    }
	    this.constructor$(entries);
	    this._isMap = isMap;
	    this._init$(undefined, -3);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val;
	        if (this._isMap) {
	            val = entriesToMap(this._values);
	        } else {
	            val = {};
	            var keyOffset = this.length();
	            for (var i = 0, len = this.length(); i < len; ++i) {
	                val[this._values[i + keyOffset]] = this._values[i];
	            }
	        }
	        this._resolve(val);
	        return true;
	    }
	    return false;
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 2);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};
	
	},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};
	
	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;
	
	},{}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else {
	        promises = util.asArray(promises);
	        if (promises === null)
	            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 3);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};
	
	},{"./util":36}],28:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	
	function ReductionPromiseArray(promises, fn, initialValue, _each) {
	    this.constructor$(promises);
	    var domain = getDomain();
	    this._fn = domain === null ? fn : domain.bind(fn);
	    if (initialValue !== undefined) {
	        initialValue = Promise.resolve(initialValue);
	        initialValue._attachCancellationCallback(this);
	    }
	    this._initialValue = initialValue;
	    this._currentCancellable = null;
	    this._eachValues = _each === INTERNAL ? [] : undefined;
	    this._promise._captureStackTrace();
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._gotAccum = function(accum) {
	    if (this._eachValues !== undefined && accum !== INTERNAL) {
	        this._eachValues.push(accum);
	    }
	};
	
	ReductionPromiseArray.prototype._eachComplete = function(value) {
	    this._eachValues.push(value);
	    return this._eachValues;
	};
	
	ReductionPromiseArray.prototype._init = function() {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function() {
	    this._resolve(this._eachValues !== undefined ? this._eachValues
	                                                 : this._initialValue);
	};
	
	ReductionPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	ReductionPromiseArray.prototype._resolve = function(value) {
	    this._promise._resolveCallback(value);
	    this._values = null;
	};
	
	ReductionPromiseArray.prototype._resultCancelled = function(sender) {
	    if (sender === this._initialValue) return this._cancel();
	    if (this._isResolved()) return;
	    this._resultCancelled$();
	    if (this._currentCancellable instanceof Promise) {
	        this._currentCancellable.cancel();
	    }
	    if (this._initialValue instanceof Promise) {
	        this._initialValue.cancel();
	    }
	};
	
	ReductionPromiseArray.prototype._iterate = function (values) {
	    this._values = values;
	    var value;
	    var i;
	    var length = values.length;
	    if (this._initialValue !== undefined) {
	        value = this._initialValue;
	        i = 0;
	    } else {
	        value = Promise.resolve(values[0]);
	        i = 1;
	    }
	
	    this._currentCancellable = value;
	
	    if (!value.isRejected()) {
	        for (; i < length; ++i) {
	            var ctx = {
	                accum: null,
	                value: values[i],
	                index: i,
	                length: length,
	                array: this
	            };
	            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
	        }
	    }
	
	    if (this._eachValues !== undefined) {
	        value = value
	            ._then(this._eachComplete, undefined, undefined, this, undefined);
	    }
	    value._then(completed, completed, undefined, value, this);
	};
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	
	function completed(valueOrReason, array) {
	    if (this.isFulfilled()) {
	        array._resolve(valueOrReason);
	    } else {
	        array._reject(valueOrReason);
	    }
	}
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	function gotAccum(accum) {
	    this.accum = accum;
	    this.array._gotAccum(accum);
	    var value = tryConvertToPromise(this.value, this.array._promise);
	    if (value instanceof Promise) {
	        this.array._currentCancellable = value;
	        return value._then(gotValue, undefined, undefined, this, undefined);
	    } else {
	        return gotValue.call(this, value);
	    }
	}
	
	function gotValue(value) {
	    var array = this.array;
	    var promise = array._promise;
	    var fn = tryCatch(array._fn);
	    promise._pushContext();
	    var ret;
	    if (array._eachValues !== undefined) {
	        ret = fn.call(promise._boundValue(), value, this.index, this.length);
	    } else {
	        ret = fn.call(promise._boundValue(),
	                              this.accum, value, this.index, this.length);
	    }
	    if (ret instanceof Promise) {
	        array._currentCancellable = ret;
	    }
	    var promiseCreated = promise._popContext();
	    debug.checkForgottenReturns(
	        ret,
	        promiseCreated,
	        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
	        promise
	    );
	    return ret;
	}
	};
	
	},{"./util":36}],29:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var NativePromise = util.getNativePromise();
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof NativePromise === "function") {
	    var nativePromise = NativePromise.resolve();
	    schedule = function(fn) {
	        nativePromise.then(fn);
	    };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            window.navigator.standalone)) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var opts = {attributes: true};
	        var toggleScheduled = false;
	        var div2 = document.createElement("div");
	        var o2 = new MutationObserver(function() {
	            div.classList.toggle("foo");
	            toggleScheduled = false;
	        });
	        o2.observe(div2, opts);
	
	        var scheduleToggle = function() {
	            if (toggleScheduled) return;
	                toggleScheduled = true;
	                div2.classList.toggle("foo");
	            };
	
	            return function schedule(fn) {
	            var o = new MutationObserver(function() {
	                o.disconnect();
	                fn();
	            });
	            o.observe(div, opts);
	            scheduleToggle();
	        };
	    })();
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;
	
	},{"./util":36}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray, debug) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util");
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 33554432;
	    ret._settledValueField = value;
	    return this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 16777216;
	    ret._settledValueField = reason;
	    return this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    debug.deprecated(".settle()", ".reflect()");
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return Promise.settle(this);
	};
	};
	
	},{"./util":36}],31:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util");
	var RangeError = _dereq_("./errors").RangeError;
	var AggregateError = _dereq_("./errors").AggregateError;
	var isArray = util.isArray;
	var CANCELLATION = {};
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	        return true;
	    }
	    return false;
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._promiseCancelled = function () {
	    if (this._values instanceof Promise || this._values == null) {
	        return this._cancel();
	    }
	    this._addRejected(CANCELLATION);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._checkOutcome = function() {
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            if (this._values[i] !== CANCELLATION) {
	                e.push(this._values[i]);
	            }
	        }
	        if (e.length > 0) {
	            this._reject(e);
	        } else {
	            this._cancel();
	        }
	        return true;
	    }
	    return false;
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};
	
	},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValueField = promise._isFateSealed()
	            ? promise._settledValue() : undefined;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValueField = undefined;
	    }
	}
	
	PromiseInspection.prototype._settledValue = function() {
	    return this._settledValueField;
	};
	
	var value = PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var reason = PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
	    return (this._bitField & 33554432) !== 0;
	};
	
	var isRejected = PromiseInspection.prototype.isRejected = function () {
	    return (this._bitField & 16777216) !== 0;
	};
	
	var isPending = PromiseInspection.prototype.isPending = function () {
	    return (this._bitField & 50397184) === 0;
	};
	
	var isResolved = PromiseInspection.prototype.isResolved = function () {
	    return (this._bitField & 50331648) !== 0;
	};
	
	PromiseInspection.prototype.isCancelled =
	Promise.prototype._isCancelled = function() {
	    return (this._bitField & 65536) === 65536;
	};
	
	Promise.prototype.isCancelled = function() {
	    return this._target()._isCancelled();
	};
	
	Promise.prototype.isPending = function() {
	    return isPending.call(this._target());
	};
	
	Promise.prototype.isRejected = function() {
	    return isRejected.call(this._target());
	};
	
	Promise.prototype.isFulfilled = function() {
	    return isFulfilled.call(this._target());
	};
	
	Promise.prototype.isResolved = function() {
	    return isResolved.call(this._target());
	};
	
	Promise.prototype.value = function() {
	    return value.call(this._target());
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    target._unsetRejectionIsUnhandled();
	    return reason.call(target);
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue();
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue();
	};
	
	Promise.PromiseInspection = PromiseInspection;
	};
	
	},{}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) return obj;
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            if (isAnyBluebirdPromise(obj)) {
	                var ret = new Promise(INTERNAL);
	                obj._then(
	                    ret._fulfill,
	                    ret._reject,
	                    undefined,
	                    ret,
	                    null
	                );
	                return ret;
	            }
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function doGetThen(obj) {
	    return obj.then;
	}
	
	function getThen(obj) {
	    try {
	        return doGetThen(obj);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x, resolve, reject);
	    synchronous = false;
	
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolve(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }
	
	    function reject(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};
	
	},{"./util":36}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, debug) {
	var util = _dereq_("./util");
	var TimeoutError = Promise.TimeoutError;
	
	function HandleWrapper(handle)  {
	    this.handle = handle;
	}
	
	HandleWrapper.prototype._resultCancelled = function() {
	    clearTimeout(this.handle);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (ms, value) {
	    var ret;
	    var handle;
	    if (value !== undefined) {
	        ret = Promise.resolve(value)
	                ._then(afterValue, null, null, ms, undefined);
	        if (debug.cancellation() && value instanceof Promise) {
	            ret._setOnCancel(value);
	        }
	    } else {
	        ret = new Promise(INTERNAL);
	        handle = setTimeout(function() { ret._fulfill(); }, +ms);
	        if (debug.cancellation()) {
	            ret._setOnCancel(new HandleWrapper(handle));
	        }
	    }
	    ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(ms, this);
	};
	
	var afterTimeout = function (promise, message, parent) {
	    var err;
	    if (typeof message !== "string") {
	        if (message instanceof Error) {
	            err = message;
	        } else {
	            err = new TimeoutError("operation timed out");
	        }
	    } else {
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._reject(err);
	
	    if (parent != null) {
	        parent.cancel();
	    }
	};
	
	function successClear(value) {
	    clearTimeout(this.handle);
	    return value;
	}
	
	function failureClear(reason) {
	    clearTimeout(this.handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret, parent;
	
	    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
	        if (ret.isPending()) {
	            afterTimeout(ret, message, parent);
	        }
	    }, ms));
	
	    if (debug.cancellation()) {
	        parent = this.then();
	        ret = parent._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	        ret._setOnCancel(handleWrapper);
	    } else {
	        ret = this._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	    }
	
	    return ret;
	};
	
	};
	
	},{"./util":36}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext, INTERNAL, debug) {
	    var util = _dereq_("./util");
	    var TypeError = _dereq_("./errors").TypeError;
	    var inherits = _dereq_("./util").inherits;
	    var errorObj = util.errorObj;
	    var tryCatch = util.tryCatch;
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = new Promise(INTERNAL);
	        function iterator() {
	            if (i >= len) return ret._fulfill();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret;
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    function ResourceList(length) {
	        this.length = length;
	        this.promise = null;
	        this[length-1] = null;
	    }
	
	    ResourceList.prototype._resultCancelled = function() {
	        var len = this.length;
	        for (var i = 0; i < len; ++i) {
	            var item = this[i];
	            if (item instanceof Promise) {
	                item.cancel();
	            }
	        }
	    };
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") {
	            return apiRejection("expecting a function but got " + util.classString(fn));
	        }
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new ResourceList(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var reflectedResources = new Array(resources.length);
	        for (var i = 0; i < reflectedResources.length; ++i) {
	            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
	        }
	
	        var resultPromise = Promise.all(reflectedResources)
	            .then(function(inspections) {
	                for (var i = 0; i < inspections.length; ++i) {
	                    var inspection = inspections[i];
	                    if (inspection.isRejected()) {
	                        errorObj.e = inspection.error();
	                        return errorObj;
	                    } else if (!inspection.isFulfilled()) {
	                        resultPromise.cancel();
	                        return;
	                    }
	                    inspections[i] = inspection.value();
	                }
	                promise._pushContext();
	
	                fn = tryCatch(fn);
	                var ret = spreadArgs
	                    ? fn.apply(undefined, inspections) : fn(inspections);
	                var promiseCreated = promise._popContext();
	                debug.checkForgottenReturns(
	                    ret, promiseCreated, "Promise.using", promise);
	                return ret;
	            });
	
	        var promise = resultPromise.lastly(function() {
	            var inspection = new Promise.PromiseInspection(resultPromise);
	            return dispose(resources, inspection);
	        });
	        resources.promise = promise;
	        promise._setOnCancel(resources);
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 131072;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 131072) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~131072);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};
	
	},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var canEvaluate = typeof navigator == "undefined";
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	var globalObject = typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    typeof global !== "undefined" ? global :
	    this !== undefined ? this : null;
	
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return typeof value === "function" ||
	           typeof value === "object" && value !== null;
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];
	
	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];
	
	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }
	
	})();
	
	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	
	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
	
	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function FakeConstructor() {}
	    FakeConstructor.prototype = obj;
	    var l = 8;
	    while (l--) new FakeConstructor();
	    return obj;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function isError(obj) {
	    return obj !== null &&
	           typeof obj === "object" &&
	           typeof obj.message === "string" &&
	           typeof obj.name === "string";
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return isError(obj) && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}
	
	var asArray = function(v) {
	    if (es5.isArray(v)) {
	        return v;
	    }
	    return null;
	};
	
	if (typeof Symbol !== "undefined" && Symbol.iterator) {
	    var ArrayFrom = typeof Array.from === "function" ? function(v) {
	        return Array.from(v);
	    } : function(v) {
	        var ret = [];
	        var it = v[Symbol.iterator]();
	        var itResult;
	        while (!((itResult = it.next()).done)) {
	            ret.push(itResult.value);
	        }
	        return ret;
	    };
	
	    asArray = function(v) {
	        if (es5.isArray(v)) {
	            return v;
	        } else if (v != null && typeof v[Symbol.iterator] === "function") {
	            return ArrayFrom(v);
	        }
	        return null;
	    };
	}
	
	var isNode = typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]";
	
	function env(key, def) {
	    return isNode ? process.env[key] : def;
	}
	
	function getNativePromise() {
	    if (typeof Promise === "function") {
	        try {
	            var promise = new Promise(function(){});
	            if ({}.toString.call(promise) === "[object Promise]") {
	                return Promise;
	            }
	        } catch (e) {}
	    }
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    asArray: asArray,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    isError: isError,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: isNode,
	    env: env,
	    global: globalObject,
	    getNativePromise: getNativePromise
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();
	
	if (ret.isNode) ret.toFastProperties(process);
	
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	},{"./es5":13}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(4), (function() { return this; }()), __webpack_require__(260).setImmediate))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(3).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(260).setImmediate, __webpack_require__(260).clearImmediate))

/***/ },
/* 261 */
/***/ function(module, exports) {

	;(function() {
	"use strict";
	
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * A component handler interface using the revealing module design pattern.
	 * More details on this design pattern here:
	 * https://github.com/jasonmayes/mdl-component-design-pattern
	 *
	 * @author Jason Mayes.
	 */
	/* exported componentHandler */
	
	// Pre-defining the componentHandler interface, for closure documentation and
	// static verification.
	var componentHandler = {
	  /**
	   * Searches existing DOM for elements of our component type and upgrades them
	   * if they have not already been upgraded.
	   *
	   * @param {string=} optJsClass the programatic name of the element class we
	   * need to create a new instance of.
	   * @param {string=} optCssClass the name of the CSS class elements of this
	   * type will have.
	   */
	  upgradeDom: function(optJsClass, optCssClass) {},
	  /**
	   * Upgrades a specific element rather than all in the DOM.
	   *
	   * @param {!Element} element The element we wish to upgrade.
	   * @param {string=} optJsClass Optional name of the class we want to upgrade
	   * the element to.
	   */
	  upgradeElement: function(element, optJsClass) {},
	  /**
	   * Upgrades a specific list of elements rather than all in the DOM.
	   *
	   * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements
	   * The elements we wish to upgrade.
	   */
	  upgradeElements: function(elements) {},
	  /**
	   * Upgrades all registered components found in the current DOM. This is
	   * automatically called on window load.
	   */
	  upgradeAllRegistered: function() {},
	  /**
	   * Allows user to be alerted to any upgrades that are performed for a given
	   * component type
	   *
	   * @param {string} jsClass The class name of the MDL component we wish
	   * to hook into for any upgrades performed.
	   * @param {function(!HTMLElement)} callback The function to call upon an
	   * upgrade. This function should expect 1 parameter - the HTMLElement which
	   * got upgraded.
	   */
	  registerUpgradedCallback: function(jsClass, callback) {},
	  /**
	   * Registers a class for future use and attempts to upgrade existing DOM.
	   *
	   * @param {componentHandler.ComponentConfigPublic} config the registration configuration
	   */
	  register: function(config) {},
	  /**
	   * Downgrade either a given node, an array of nodes, or a NodeList.
	   *
	   * @param {!Node|!Array<!Node>|!NodeList} nodes
	   */
	  downgradeElements: function(nodes) {}
	};
	
	componentHandler = (function() {
	  'use strict';
	
	  /** @type {!Array<componentHandler.ComponentConfig>} */
	  var registeredComponents_ = [];
	
	  /** @type {!Array<componentHandler.Component>} */
	  var createdComponents_ = [];
	
	  var componentConfigProperty_ = 'mdlComponentConfigInternal_';
	
	  /**
	   * Searches registered components for a class we are interested in using.
	   * Optionally replaces a match with passed object if specified.
	   *
	   * @param {string} name The name of a class we want to use.
	   * @param {componentHandler.ComponentConfig=} optReplace Optional object to replace match with.
	   * @return {!Object|boolean}
	   * @private
	   */
	  function findRegisteredClass_(name, optReplace) {
	    for (var i = 0; i < registeredComponents_.length; i++) {
	      if (registeredComponents_[i].className === name) {
	        if (typeof optReplace !== 'undefined') {
	          registeredComponents_[i] = optReplace;
	        }
	        return registeredComponents_[i];
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Returns an array of the classNames of the upgraded classes on the element.
	   *
	   * @param {!Element} element The element to fetch data from.
	   * @return {!Array<string>}
	   * @private
	   */
	  function getUpgradedListOfElement_(element) {
	    var dataUpgraded = element.getAttribute('data-upgraded');
	    // Use `['']` as default value to conform the `,name,name...` style.
	    return dataUpgraded === null ? [''] : dataUpgraded.split(',');
	  }
	
	  /**
	   * Returns true if the given element has already been upgraded for the given
	   * class.
	   *
	   * @param {!Element} element The element we want to check.
	   * @param {string} jsClass The class to check for.
	   * @returns {boolean}
	   * @private
	   */
	  function isElementUpgraded_(element, jsClass) {
	    var upgradedList = getUpgradedListOfElement_(element);
	    return upgradedList.indexOf(jsClass) !== -1;
	  }
	
	  /**
	   * Searches existing DOM for elements of our component type and upgrades them
	   * if they have not already been upgraded.
	   *
	   * @param {string=} optJsClass the programatic name of the element class we
	   * need to create a new instance of.
	   * @param {string=} optCssClass the name of the CSS class elements of this
	   * type will have.
	   */
	  function upgradeDomInternal(optJsClass, optCssClass) {
	    if (typeof optJsClass === 'undefined' &&
	        typeof optCssClass === 'undefined') {
	      for (var i = 0; i < registeredComponents_.length; i++) {
	        upgradeDomInternal(registeredComponents_[i].className,
	            registeredComponents_[i].cssClass);
	      }
	    } else {
	      var jsClass = /** @type {string} */ (optJsClass);
	      if (typeof optCssClass === 'undefined') {
	        var registeredClass = findRegisteredClass_(jsClass);
	        if (registeredClass) {
	          optCssClass = registeredClass.cssClass;
	        }
	      }
	
	      var elements = document.querySelectorAll('.' + optCssClass);
	      for (var n = 0; n < elements.length; n++) {
	        upgradeElementInternal(elements[n], jsClass);
	      }
	    }
	  }
	
	  /**
	   * Upgrades a specific element rather than all in the DOM.
	   *
	   * @param {!Element} element The element we wish to upgrade.
	   * @param {string=} optJsClass Optional name of the class we want to upgrade
	   * the element to.
	   */
	  function upgradeElementInternal(element, optJsClass) {
	    // Verify argument type.
	    if (!(typeof element === 'object' && element instanceof Element)) {
	      throw new Error('Invalid argument provided to upgrade MDL element.');
	    }
	    var upgradedList = getUpgradedListOfElement_(element);
	    var classesToUpgrade = [];
	    // If jsClass is not provided scan the registered components to find the
	    // ones matching the element's CSS classList.
	    if (!optJsClass) {
	      var classList = element.classList;
	      registeredComponents_.forEach(function(component) {
	        // Match CSS & Not to be upgraded & Not upgraded.
	        if (classList.contains(component.cssClass) &&
	            classesToUpgrade.indexOf(component) === -1 &&
	            !isElementUpgraded_(element, component.className)) {
	          classesToUpgrade.push(component);
	        }
	      });
	    } else if (!isElementUpgraded_(element, optJsClass)) {
	      classesToUpgrade.push(findRegisteredClass_(optJsClass));
	    }
	
	    // Upgrade the element for each classes.
	    for (var i = 0, n = classesToUpgrade.length, registeredClass; i < n; i++) {
	      registeredClass = classesToUpgrade[i];
	      if (registeredClass) {
	        // Mark element as upgraded.
	        upgradedList.push(registeredClass.className);
	        element.setAttribute('data-upgraded', upgradedList.join(','));
	        var instance = new registeredClass.classConstructor(element);
	        instance[componentConfigProperty_] = registeredClass;
	        createdComponents_.push(instance);
	        // Call any callbacks the user has registered with this component type.
	        for (var j = 0, m = registeredClass.callbacks.length; j < m; j++) {
	          registeredClass.callbacks[j](element);
	        }
	
	        if (registeredClass.widget) {
	          // Assign per element instance for control over API
	          element[registeredClass.className] = instance;
	        }
	      } else {
	        throw new Error(
	          'Unable to find a registered component for the given class.');
	      }
	
	      var ev;
	      if ('CustomEvent' in window && typeof window.CustomEvent === 'function') {
	        ev = new Event('mdl-componentupgraded', {
	          'bubbles': true, 'cancelable': false
	        });
	      } else {
	        ev = document.createEvent('Events');
	        ev.initEvent('mdl-componentupgraded', true, true);
	      }
	      element.dispatchEvent(ev);
	    }
	  }
	
	  /**
	   * Upgrades a specific list of elements rather than all in the DOM.
	   *
	   * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements
	   * The elements we wish to upgrade.
	   */
	  function upgradeElementsInternal(elements) {
	    if (!Array.isArray(elements)) {
	      if (typeof elements.item === 'function') {
	        elements = Array.prototype.slice.call(/** @type {Array} */ (elements));
	      } else {
	        elements = [elements];
	      }
	    }
	    for (var i = 0, n = elements.length, element; i < n; i++) {
	      element = elements[i];
	      if (element instanceof HTMLElement) {
	        upgradeElementInternal(element);
	        if (element.children.length > 0) {
	          upgradeElementsInternal(element.children);
	        }
	      }
	    }
	  }
	
	  /**
	   * Registers a class for future use and attempts to upgrade existing DOM.
	   *
	   * @param {componentHandler.ComponentConfigPublic} config
	   */
	  function registerInternal(config) {
	    // In order to support both Closure-compiled and uncompiled code accessing
	    // this method, we need to allow for both the dot and array syntax for
	    // property access. You'll therefore see the `foo.bar || foo['bar']`
	    // pattern repeated across this method.
	    var widgetMissing = (typeof config.widget === 'undefined' &&
	        typeof config['widget'] === 'undefined');
	    var widget = true;
	
	    if (!widgetMissing) {
	      widget = config.widget || config['widget'];
	    }
	
	    var newConfig = /** @type {componentHandler.ComponentConfig} */ ({
	      classConstructor: config.constructor || config['constructor'],
	      className: config.classAsString || config['classAsString'],
	      cssClass: config.cssClass || config['cssClass'],
	      widget: widget,
	      callbacks: []
	    });
	
	    registeredComponents_.forEach(function(item) {
	      if (item.cssClass === newConfig.cssClass) {
	        throw new Error('The provided cssClass has already been registered: ' + item.cssClass);
	      }
	      if (item.className === newConfig.className) {
	        throw new Error('The provided className has already been registered');
	      }
	    });
	
	    if (config.constructor.prototype
	        .hasOwnProperty(componentConfigProperty_)) {
	      throw new Error(
	          'MDL component classes must not have ' + componentConfigProperty_ +
	          ' defined as a property.');
	    }
	
	    var found = findRegisteredClass_(config.classAsString, newConfig);
	
	    if (!found) {
	      registeredComponents_.push(newConfig);
	    }
	  }
	
	  /**
	   * Allows user to be alerted to any upgrades that are performed for a given
	   * component type
	   *
	   * @param {string} jsClass The class name of the MDL component we wish
	   * to hook into for any upgrades performed.
	   * @param {function(!HTMLElement)} callback The function to call upon an
	   * upgrade. This function should expect 1 parameter - the HTMLElement which
	   * got upgraded.
	   */
	  function registerUpgradedCallbackInternal(jsClass, callback) {
	    var regClass = findRegisteredClass_(jsClass);
	    if (regClass) {
	      regClass.callbacks.push(callback);
	    }
	  }
	
	  /**
	   * Upgrades all registered components found in the current DOM. This is
	   * automatically called on window load.
	   */
	  function upgradeAllRegisteredInternal() {
	    for (var n = 0; n < registeredComponents_.length; n++) {
	      upgradeDomInternal(registeredComponents_[n].className);
	    }
	  }
	
	  /**
	   * Check the component for the downgrade method.
	   * Execute if found.
	   * Remove component from createdComponents list.
	   *
	   * @param {?componentHandler.Component} component
	   */
	  function deconstructComponentInternal(component) {
	    if (component) {
	      var componentIndex = createdComponents_.indexOf(component);
	      createdComponents_.splice(componentIndex, 1);
	
	      var upgrades = component.element_.getAttribute('data-upgraded').split(',');
	      var componentPlace = upgrades.indexOf(component[componentConfigProperty_].classAsString);
	      upgrades.splice(componentPlace, 1);
	      component.element_.setAttribute('data-upgraded', upgrades.join(','));
	
	      var ev;
	      if ('CustomEvent' in window && typeof window.CustomEvent === 'function') {
	        ev = new Event('mdl-componentdowngraded', {
	          'bubbles': true, 'cancelable': false
	        });
	      } else {
	        ev = document.createEvent('Events');
	        ev.initEvent('mdl-componentdowngraded', true, true);
	      }
	    }
	  }
	
	  /**
	   * Downgrade either a given node, an array of nodes, or a NodeList.
	   *
	   * @param {!Node|!Array<!Node>|!NodeList} nodes
	   */
	  function downgradeNodesInternal(nodes) {
	    /**
	     * Auxiliary function to downgrade a single node.
	     * @param  {!Node} node the node to be downgraded
	     */
	    var downgradeNode = function(node) {
	      createdComponents_.filter(function(item) {
	        return item.element_ === node;
	      }).forEach(deconstructComponentInternal);
	    };
	    if (nodes instanceof Array || nodes instanceof NodeList) {
	      for (var n = 0; n < nodes.length; n++) {
	        downgradeNode(nodes[n]);
	      }
	    } else if (nodes instanceof Node) {
	      downgradeNode(nodes);
	    } else {
	      throw new Error('Invalid argument provided to downgrade MDL nodes.');
	    }
	  }
	
	  // Now return the functions that should be made public with their publicly
	  // facing names...
	  return {
	    upgradeDom: upgradeDomInternal,
	    upgradeElement: upgradeElementInternal,
	    upgradeElements: upgradeElementsInternal,
	    upgradeAllRegistered: upgradeAllRegisteredInternal,
	    registerUpgradedCallback: registerUpgradedCallbackInternal,
	    register: registerInternal,
	    downgradeElements: downgradeNodesInternal
	  };
	})();
	
	/**
	 * Describes the type of a registered component type managed by
	 * componentHandler. Provided for benefit of the Closure compiler.
	 *
	 * @typedef {{
	 *   constructor: Function,
	 *   classAsString: string,
	 *   cssClass: string,
	 *   widget: (string|boolean|undefined)
	 * }}
	 */
	componentHandler.ComponentConfigPublic;  // jshint ignore:line
	
	/**
	 * Describes the type of a registered component type managed by
	 * componentHandler. Provided for benefit of the Closure compiler.
	 *
	 * @typedef {{
	 *   constructor: !Function,
	 *   className: string,
	 *   cssClass: string,
	 *   widget: (string|boolean),
	 *   callbacks: !Array<function(!HTMLElement)>
	 * }}
	 */
	componentHandler.ComponentConfig;  // jshint ignore:line
	
	/**
	 * Created component (i.e., upgraded element) type as managed by
	 * componentHandler. Provided for benefit of the Closure compiler.
	 *
	 * @typedef {{
	 *   element_: !HTMLElement,
	 *   className: string,
	 *   classAsString: string,
	 *   cssClass: string,
	 *   widget: string
	 * }}
	 */
	componentHandler.Component;  // jshint ignore:line
	
	// Export all symbols, for the benefit of Closure compiler.
	// No effect on uncompiled code.
	componentHandler['upgradeDom'] = componentHandler.upgradeDom;
	componentHandler['upgradeElement'] = componentHandler.upgradeElement;
	componentHandler['upgradeElements'] = componentHandler.upgradeElements;
	componentHandler['upgradeAllRegistered'] =
	    componentHandler.upgradeAllRegistered;
	componentHandler['registerUpgradedCallback'] =
	    componentHandler.registerUpgradedCallback;
	componentHandler['register'] = componentHandler.register;
	componentHandler['downgradeElements'] = componentHandler.downgradeElements;
	window.componentHandler = componentHandler;
	window['componentHandler'] = componentHandler;
	
	window.addEventListener('load', function() {
	  'use strict';
	
	  /**
	   * Performs a "Cutting the mustard" test. If the browser supports the features
	   * tested, adds a mdl-js class to the <html> element. It then upgrades all MDL
	   * components requiring JavaScript.
	   */
	  if ('classList' in document.createElement('div') &&
	      'querySelector' in document &&
	      'addEventListener' in window && Array.prototype.forEach) {
	    document.documentElement.classList.add('mdl-js');
	    componentHandler.upgradeAllRegistered();
	  } else {
	    /**
	     * Dummy function to avoid JS errors.
	     */
	    componentHandler.upgradeElement = function() {};
	    /**
	     * Dummy function to avoid JS errors.
	     */
	    componentHandler.register = function() {};
	  }
	});
	
	// Source: https://github.com/darius/requestAnimationFrame/blob/master/requestAnimationFrame.js
	// Adapted from https://gist.github.com/paulirish/1579671 which derived from
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
	// requestAnimationFrame polyfill by Erik Mller.
	// Fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavi, Darius Bacon
	// MIT license
	if (!Date.now) {
	    /**
	   * Date.now polyfill.
	   * @return {number} the current Date
	   */
	    Date.now = function () {
	        return new Date().getTime();
	    };
	    Date['now'] = Date.now;
	}
	var vendors = [
	    'webkit',
	    'moz'
	];
	for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
	    var vp = vendors[i];
	    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
	    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
	    window['requestAnimationFrame'] = window.requestAnimationFrame;
	    window['cancelAnimationFrame'] = window.cancelAnimationFrame;
	}
	if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
	    var lastTime = 0;
	    /**
	   * requestAnimationFrame polyfill.
	   * @param  {!Function} callback the callback function.
	   */
	    window.requestAnimationFrame = function (callback) {
	        var now = Date.now();
	        var nextTime = Math.max(lastTime + 16, now);
	        return setTimeout(function () {
	            callback(lastTime = nextTime);
	        }, nextTime - now);
	    };
	    window.cancelAnimationFrame = clearTimeout;
	    window['requestAnimationFrame'] = window.requestAnimationFrame;
	    window['cancelAnimationFrame'] = window.cancelAnimationFrame;
	}
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Button MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialButton = function MaterialButton(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialButton'] = MaterialButton;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialButton.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialButton.prototype.CssClasses_ = {
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_CONTAINER: 'mdl-button__ripple-container',
	    RIPPLE: 'mdl-ripple'
	};
	/**
	   * Handle blur of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialButton.prototype.blurHandler_ = function (event) {
	    if (event) {
	        this.element_.blur();
	    }
	};
	// Public methods.
	/**
	   * Disable button.
	   *
	   * @public
	   */
	MaterialButton.prototype.disable = function () {
	    this.element_.disabled = true;
	};
	MaterialButton.prototype['disable'] = MaterialButton.prototype.disable;
	/**
	   * Enable button.
	   *
	   * @public
	   */
	MaterialButton.prototype.enable = function () {
	    this.element_.disabled = false;
	};
	MaterialButton.prototype['enable'] = MaterialButton.prototype.enable;
	/**
	   * Initialize element.
	   */
	MaterialButton.prototype.init = function () {
	    if (this.element_) {
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            var rippleContainer = document.createElement('span');
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleElement_ = document.createElement('span');
	            this.rippleElement_.classList.add(this.CssClasses_.RIPPLE);
	            rippleContainer.appendChild(this.rippleElement_);
	            this.boundRippleBlurHandler = this.blurHandler_.bind(this);
	            this.rippleElement_.addEventListener('mouseup', this.boundRippleBlurHandler);
	            this.element_.appendChild(rippleContainer);
	        }
	        this.boundButtonBlurHandler = this.blurHandler_.bind(this);
	        this.element_.addEventListener('mouseup', this.boundButtonBlurHandler);
	        this.element_.addEventListener('mouseleave', this.boundButtonBlurHandler);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialButton,
	    classAsString: 'MaterialButton',
	    cssClass: 'mdl-js-button',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Checkbox MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialCheckbox = function MaterialCheckbox(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialCheckbox'] = MaterialCheckbox;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialCheckbox.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialCheckbox.prototype.CssClasses_ = {
	    INPUT: 'mdl-checkbox__input',
	    BOX_OUTLINE: 'mdl-checkbox__box-outline',
	    FOCUS_HELPER: 'mdl-checkbox__focus-helper',
	    TICK_OUTLINE: 'mdl-checkbox__tick-outline',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-checkbox__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked',
	    IS_UPGRADED: 'is-upgraded'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onChange_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onMouseUp_ = function (event) {
	    this.blur_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialCheckbox.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialCheckbox.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.inputElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the inputs toggle state and update display.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.checkToggleState = function () {
	    if (this.inputElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialCheckbox.prototype['checkToggleState'] = MaterialCheckbox.prototype.checkToggleState;
	/**
	   * Check the inputs disabled state and update display.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.checkDisabled = function () {
	    if (this.inputElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialCheckbox.prototype['checkDisabled'] = MaterialCheckbox.prototype.checkDisabled;
	/**
	   * Disable checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.disable = function () {
	    this.inputElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['disable'] = MaterialCheckbox.prototype.disable;
	/**
	   * Enable checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.enable = function () {
	    this.inputElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['enable'] = MaterialCheckbox.prototype.enable;
	/**
	   * Check checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.check = function () {
	    this.inputElement_.checked = true;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['check'] = MaterialCheckbox.prototype.check;
	/**
	   * Uncheck checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.uncheck = function () {
	    this.inputElement_.checked = false;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['uncheck'] = MaterialCheckbox.prototype.uncheck;
	/**
	   * Initialize element.
	   */
	MaterialCheckbox.prototype.init = function () {
	    if (this.element_) {
	        this.inputElement_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        var boxOutline = document.createElement('span');
	        boxOutline.classList.add(this.CssClasses_.BOX_OUTLINE);
	        var tickContainer = document.createElement('span');
	        tickContainer.classList.add(this.CssClasses_.FOCUS_HELPER);
	        var tickOutline = document.createElement('span');
	        tickOutline.classList.add(this.CssClasses_.TICK_OUTLINE);
	        boxOutline.appendChild(tickOutline);
	        this.element_.appendChild(tickContainer);
	        this.element_.appendChild(boxOutline);
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            this.rippleContainerElement_ = document.createElement('span');
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            this.boundRippleMouseUp = this.onMouseUp_.bind(this);
	            this.rippleContainerElement_.addEventListener('mouseup', this.boundRippleMouseUp);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            this.rippleContainerElement_.appendChild(ripple);
	            this.element_.appendChild(this.rippleContainerElement_);
	        }
	        this.boundInputOnChange = this.onChange_.bind(this);
	        this.boundInputOnFocus = this.onFocus_.bind(this);
	        this.boundInputOnBlur = this.onBlur_.bind(this);
	        this.boundElementMouseUp = this.onMouseUp_.bind(this);
	        this.inputElement_.addEventListener('change', this.boundInputOnChange);
	        this.inputElement_.addEventListener('focus', this.boundInputOnFocus);
	        this.inputElement_.addEventListener('blur', this.boundInputOnBlur);
	        this.element_.addEventListener('mouseup', this.boundElementMouseUp);
	        this.updateClasses_();
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialCheckbox,
	    classAsString: 'MaterialCheckbox',
	    cssClass: 'mdl-js-checkbox',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for icon toggle MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialIconToggle = function MaterialIconToggle(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialIconToggle'] = MaterialIconToggle;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialIconToggle.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialIconToggle.prototype.CssClasses_ = {
	    INPUT: 'mdl-icon-toggle__input',
	    JS_RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-icon-toggle__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onChange_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onMouseUp_ = function (event) {
	    this.blur_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialIconToggle.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialIconToggle.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.inputElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the inputs toggle state and update display.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.checkToggleState = function () {
	    if (this.inputElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialIconToggle.prototype['checkToggleState'] = MaterialIconToggle.prototype.checkToggleState;
	/**
	   * Check the inputs disabled state and update display.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.checkDisabled = function () {
	    if (this.inputElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialIconToggle.prototype['checkDisabled'] = MaterialIconToggle.prototype.checkDisabled;
	/**
	   * Disable icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.disable = function () {
	    this.inputElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['disable'] = MaterialIconToggle.prototype.disable;
	/**
	   * Enable icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.enable = function () {
	    this.inputElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['enable'] = MaterialIconToggle.prototype.enable;
	/**
	   * Check icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.check = function () {
	    this.inputElement_.checked = true;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['check'] = MaterialIconToggle.prototype.check;
	/**
	   * Uncheck icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.uncheck = function () {
	    this.inputElement_.checked = false;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['uncheck'] = MaterialIconToggle.prototype.uncheck;
	/**
	   * Initialize element.
	   */
	MaterialIconToggle.prototype.init = function () {
	    if (this.element_) {
	        this.inputElement_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        if (this.element_.classList.contains(this.CssClasses_.JS_RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            this.rippleContainerElement_ = document.createElement('span');
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.JS_RIPPLE_EFFECT);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            this.boundRippleMouseUp = this.onMouseUp_.bind(this);
	            this.rippleContainerElement_.addEventListener('mouseup', this.boundRippleMouseUp);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            this.rippleContainerElement_.appendChild(ripple);
	            this.element_.appendChild(this.rippleContainerElement_);
	        }
	        this.boundInputOnChange = this.onChange_.bind(this);
	        this.boundInputOnFocus = this.onFocus_.bind(this);
	        this.boundInputOnBlur = this.onBlur_.bind(this);
	        this.boundElementOnMouseUp = this.onMouseUp_.bind(this);
	        this.inputElement_.addEventListener('change', this.boundInputOnChange);
	        this.inputElement_.addEventListener('focus', this.boundInputOnFocus);
	        this.inputElement_.addEventListener('blur', this.boundInputOnBlur);
	        this.element_.addEventListener('mouseup', this.boundElementOnMouseUp);
	        this.updateClasses_();
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialIconToggle,
	    classAsString: 'MaterialIconToggle',
	    cssClass: 'mdl-js-icon-toggle',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for dropdown MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialMenu = function MaterialMenu(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialMenu'] = MaterialMenu;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialMenu.prototype.Constant_ = {
	    // Total duration of the menu animation.
	    TRANSITION_DURATION_SECONDS: 0.3,
	    // The fraction of the total duration we want to use for menu item animations.
	    TRANSITION_DURATION_FRACTION: 0.8,
	    // How long the menu stays open after choosing an option (so the user can see
	    // the ripple).
	    CLOSE_TIMEOUT: 150
	};
	/**
	   * Keycodes, for code readability.
	   *
	   * @enum {number}
	   * @private
	   */
	MaterialMenu.prototype.Keycodes_ = {
	    ENTER: 13,
	    ESCAPE: 27,
	    SPACE: 32,
	    UP_ARROW: 38,
	    DOWN_ARROW: 40
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialMenu.prototype.CssClasses_ = {
	    CONTAINER: 'mdl-menu__container',
	    OUTLINE: 'mdl-menu__outline',
	    ITEM: 'mdl-menu__item',
	    ITEM_RIPPLE_CONTAINER: 'mdl-menu__item-ripple-container',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE: 'mdl-ripple',
	    // Statuses
	    IS_UPGRADED: 'is-upgraded',
	    IS_VISIBLE: 'is-visible',
	    IS_ANIMATING: 'is-animating',
	    // Alignment options
	    BOTTOM_LEFT: 'mdl-menu--bottom-left',
	    // This is the default.
	    BOTTOM_RIGHT: 'mdl-menu--bottom-right',
	    TOP_LEFT: 'mdl-menu--top-left',
	    TOP_RIGHT: 'mdl-menu--top-right',
	    UNALIGNED: 'mdl-menu--unaligned'
	};
	/**
	   * Initialize element.
	   */
	MaterialMenu.prototype.init = function () {
	    if (this.element_) {
	        // Create container for the menu.
	        var container = document.createElement('div');
	        container.classList.add(this.CssClasses_.CONTAINER);
	        this.element_.parentElement.insertBefore(container, this.element_);
	        this.element_.parentElement.removeChild(this.element_);
	        container.appendChild(this.element_);
	        this.container_ = container;
	        // Create outline for the menu (shadow and background).
	        var outline = document.createElement('div');
	        outline.classList.add(this.CssClasses_.OUTLINE);
	        this.outline_ = outline;
	        container.insertBefore(outline, this.element_);
	        // Find the "for" element and bind events to it.
	        var forElId = this.element_.getAttribute('for') || this.element_.getAttribute('data-mdl-for');
	        var forEl = null;
	        if (forElId) {
	            forEl = document.getElementById(forElId);
	            if (forEl) {
	                this.forElement_ = forEl;
	                forEl.addEventListener('click', this.handleForClick_.bind(this));
	                forEl.addEventListener('keydown', this.handleForKeyboardEvent_.bind(this));
	            }
	        }
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM);
	        this.boundItemKeydown_ = this.handleItemKeyboardEvent_.bind(this);
	        this.boundItemClick_ = this.handleItemClick_.bind(this);
	        for (var i = 0; i < items.length; i++) {
	            // Add a listener to each menu item.
	            items[i].addEventListener('click', this.boundItemClick_);
	            // Add a tab index to each menu item.
	            items[i].tabIndex = '-1';
	            // Add a keyboard listener to each menu item.
	            items[i].addEventListener('keydown', this.boundItemKeydown_);
	        }
	        // Add ripple classes to each item, if the user has enabled ripples.
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            for (i = 0; i < items.length; i++) {
	                var item = items[i];
	                var rippleContainer = document.createElement('span');
	                rippleContainer.classList.add(this.CssClasses_.ITEM_RIPPLE_CONTAINER);
	                var ripple = document.createElement('span');
	                ripple.classList.add(this.CssClasses_.RIPPLE);
	                rippleContainer.appendChild(ripple);
	                item.appendChild(rippleContainer);
	                item.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            }
	        }
	        // Copy alignment classes to the container, so the outline can use them.
	        if (this.element_.classList.contains(this.CssClasses_.BOTTOM_LEFT)) {
	            this.outline_.classList.add(this.CssClasses_.BOTTOM_LEFT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
	            this.outline_.classList.add(this.CssClasses_.BOTTOM_RIGHT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT)) {
	            this.outline_.classList.add(this.CssClasses_.TOP_LEFT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	            this.outline_.classList.add(this.CssClasses_.TOP_RIGHT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.UNALIGNED)) {
	            this.outline_.classList.add(this.CssClasses_.UNALIGNED);
	        }
	        container.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	/**
	   * Handles a click on the "for" element, by positioning the menu and then
	   * toggling it.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleForClick_ = function (evt) {
	    if (this.element_ && this.forElement_) {
	        var rect = this.forElement_.getBoundingClientRect();
	        var forRect = this.forElement_.parentElement.getBoundingClientRect();
	        if (this.element_.classList.contains(this.CssClasses_.UNALIGNED)) {
	        } else if (this.element_.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
	            // Position below the "for" element, aligned to its right.
	            this.container_.style.right = forRect.right - rect.right + 'px';
	            this.container_.style.top = this.forElement_.offsetTop + this.forElement_.offsetHeight + 'px';
	        } else if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT)) {
	            // Position above the "for" element, aligned to its left.
	            this.container_.style.left = this.forElement_.offsetLeft + 'px';
	            this.container_.style.bottom = forRect.bottom - rect.top + 'px';
	        } else if (this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	            // Position above the "for" element, aligned to its right.
	            this.container_.style.right = forRect.right - rect.right + 'px';
	            this.container_.style.bottom = forRect.bottom - rect.top + 'px';
	        } else {
	            // Default: position below the "for" element, aligned to its left.
	            this.container_.style.left = this.forElement_.offsetLeft + 'px';
	            this.container_.style.top = this.forElement_.offsetTop + this.forElement_.offsetHeight + 'px';
	        }
	    }
	    this.toggle(evt);
	};
	/**
	   * Handles a keyboard event on the "for" element.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleForKeyboardEvent_ = function (evt) {
	    if (this.element_ && this.container_ && this.forElement_) {
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM + ':not([disabled])');
	        if (items && items.length > 0 && this.container_.classList.contains(this.CssClasses_.IS_VISIBLE)) {
	            if (evt.keyCode === this.Keycodes_.UP_ARROW) {
	                evt.preventDefault();
	                items[items.length - 1].focus();
	            } else if (evt.keyCode === this.Keycodes_.DOWN_ARROW) {
	                evt.preventDefault();
	                items[0].focus();
	            }
	        }
	    }
	};
	/**
	   * Handles a keyboard event on an item.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleItemKeyboardEvent_ = function (evt) {
	    if (this.element_ && this.container_) {
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM + ':not([disabled])');
	        if (items && items.length > 0 && this.container_.classList.contains(this.CssClasses_.IS_VISIBLE)) {
	            var currentIndex = Array.prototype.slice.call(items).indexOf(evt.target);
	            if (evt.keyCode === this.Keycodes_.UP_ARROW) {
	                evt.preventDefault();
	                if (currentIndex > 0) {
	                    items[currentIndex - 1].focus();
	                } else {
	                    items[items.length - 1].focus();
	                }
	            } else if (evt.keyCode === this.Keycodes_.DOWN_ARROW) {
	                evt.preventDefault();
	                if (items.length > currentIndex + 1) {
	                    items[currentIndex + 1].focus();
	                } else {
	                    items[0].focus();
	                }
	            } else if (evt.keyCode === this.Keycodes_.SPACE || evt.keyCode === this.Keycodes_.ENTER) {
	                evt.preventDefault();
	                // Send mousedown and mouseup to trigger ripple.
	                var e = new MouseEvent('mousedown');
	                evt.target.dispatchEvent(e);
	                e = new MouseEvent('mouseup');
	                evt.target.dispatchEvent(e);
	                // Send click.
	                evt.target.click();
	            } else if (evt.keyCode === this.Keycodes_.ESCAPE) {
	                evt.preventDefault();
	                this.hide();
	            }
	        }
	    }
	};
	/**
	   * Handles a click event on an item.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleItemClick_ = function (evt) {
	    if (evt.target.hasAttribute('disabled')) {
	        evt.stopPropagation();
	    } else {
	        // Wait some time before closing menu, so the user can see the ripple.
	        this.closing_ = true;
	        window.setTimeout(function (evt) {
	            this.hide();
	            this.closing_ = false;
	        }.bind(this), this.Constant_.CLOSE_TIMEOUT);
	    }
	};
	/**
	   * Calculates the initial clip (for opening the menu) or final clip (for closing
	   * it), and applies it. This allows us to animate from or to the correct point,
	   * that is, the point it's aligned to in the "for" element.
	   *
	   * @param {number} height Height of the clip rectangle
	   * @param {number} width Width of the clip rectangle
	   * @private
	   */
	MaterialMenu.prototype.applyClip_ = function (height, width) {
	    if (this.element_.classList.contains(this.CssClasses_.UNALIGNED)) {
	        // Do not clip.
	        this.element_.style.clip = '';
	    } else if (this.element_.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
	        // Clip to the top right corner of the menu.
	        this.element_.style.clip = 'rect(0 ' + width + 'px ' + '0 ' + width + 'px)';
	    } else if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT)) {
	        // Clip to the bottom left corner of the menu.
	        this.element_.style.clip = 'rect(' + height + 'px 0 ' + height + 'px 0)';
	    } else if (this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	        // Clip to the bottom right corner of the menu.
	        this.element_.style.clip = 'rect(' + height + 'px ' + width + 'px ' + height + 'px ' + width + 'px)';
	    } else {
	        // Default: do not clip (same as clipping to the top left corner).
	        this.element_.style.clip = '';
	    }
	};
	/**
	   * Cleanup function to remove animation listeners.
	   *
	   * @param {Event} evt
	   * @private
	   */
	MaterialMenu.prototype.removeAnimationEndListener_ = function (evt) {
	    evt.target.classList.remove(MaterialMenu.prototype.CssClasses_.IS_ANIMATING);
	};
	/**
	   * Adds an event listener to clean up after the animation ends.
	   *
	   * @private
	   */
	MaterialMenu.prototype.addAnimationEndListener_ = function () {
	    this.element_.addEventListener('transitionend', this.removeAnimationEndListener_);
	    this.element_.addEventListener('webkitTransitionEnd', this.removeAnimationEndListener_);
	};
	/**
	   * Displays the menu.
	   *
	   * @public
	   */
	MaterialMenu.prototype.show = function (evt) {
	    if (this.element_ && this.container_ && this.outline_) {
	        // Measure the inner element.
	        var height = this.element_.getBoundingClientRect().height;
	        var width = this.element_.getBoundingClientRect().width;
	        // Apply the inner element's size to the container and outline.
	        this.container_.style.width = width + 'px';
	        this.container_.style.height = height + 'px';
	        this.outline_.style.width = width + 'px';
	        this.outline_.style.height = height + 'px';
	        var transitionDuration = this.Constant_.TRANSITION_DURATION_SECONDS * this.Constant_.TRANSITION_DURATION_FRACTION;
	        // Calculate transition delays for individual menu items, so that they fade
	        // in one at a time.
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM);
	        for (var i = 0; i < items.length; i++) {
	            var itemDelay = null;
	            if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT) || this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	                itemDelay = (height - items[i].offsetTop - items[i].offsetHeight) / height * transitionDuration + 's';
	            } else {
	                itemDelay = items[i].offsetTop / height * transitionDuration + 's';
	            }
	            items[i].style.transitionDelay = itemDelay;
	        }
	        // Apply the initial clip to the text before we start animating.
	        this.applyClip_(height, width);
	        // Wait for the next frame, turn on animation, and apply the final clip.
	        // Also make it visible. This triggers the transitions.
	        window.requestAnimationFrame(function () {
	            this.element_.classList.add(this.CssClasses_.IS_ANIMATING);
	            this.element_.style.clip = 'rect(0 ' + width + 'px ' + height + 'px 0)';
	            this.container_.classList.add(this.CssClasses_.IS_VISIBLE);
	        }.bind(this));
	        // Clean up after the animation is complete.
	        this.addAnimationEndListener_();
	        // Add a click listener to the document, to close the menu.
	        var callback = function (e) {
	            // Check to see if the document is processing the same event that
	            // displayed the menu in the first place. If so, do nothing.
	            // Also check to see if the menu is in the process of closing itself, and
	            // do nothing in that case.
	            // Also check if the clicked element is a menu item
	            // if so, do nothing.
	            if (e !== evt && !this.closing_ && e.target.parentNode !== this.element_) {
	                document.removeEventListener('click', callback);
	                this.hide();
	            }
	        }.bind(this);
	        document.addEventListener('click', callback);
	    }
	};
	MaterialMenu.prototype['show'] = MaterialMenu.prototype.show;
	/**
	   * Hides the menu.
	   *
	   * @public
	   */
	MaterialMenu.prototype.hide = function () {
	    if (this.element_ && this.container_ && this.outline_) {
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM);
	        // Remove all transition delays; menu items fade out concurrently.
	        for (var i = 0; i < items.length; i++) {
	            items[i].style.removeProperty('transition-delay');
	        }
	        // Measure the inner element.
	        var rect = this.element_.getBoundingClientRect();
	        var height = rect.height;
	        var width = rect.width;
	        // Turn on animation, and apply the final clip. Also make invisible.
	        // This triggers the transitions.
	        this.element_.classList.add(this.CssClasses_.IS_ANIMATING);
	        this.applyClip_(height, width);
	        this.container_.classList.remove(this.CssClasses_.IS_VISIBLE);
	        // Clean up after the animation is complete.
	        this.addAnimationEndListener_();
	    }
	};
	MaterialMenu.prototype['hide'] = MaterialMenu.prototype.hide;
	/**
	   * Displays or hides the menu, depending on current state.
	   *
	   * @public
	   */
	MaterialMenu.prototype.toggle = function (evt) {
	    if (this.container_.classList.contains(this.CssClasses_.IS_VISIBLE)) {
	        this.hide();
	    } else {
	        this.show(evt);
	    }
	};
	MaterialMenu.prototype['toggle'] = MaterialMenu.prototype.toggle;
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialMenu,
	    classAsString: 'MaterialMenu',
	    cssClass: 'mdl-js-menu',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Progress MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialProgress = function MaterialProgress(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialProgress'] = MaterialProgress;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialProgress.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialProgress.prototype.CssClasses_ = { INDETERMINATE_CLASS: 'mdl-progress__indeterminate' };
	/**
	   * Set the current progress of the progressbar.
	   *
	   * @param {number} p Percentage of the progress (0-100)
	   * @public
	   */
	MaterialProgress.prototype.setProgress = function (p) {
	    if (this.element_.classList.contains(this.CssClasses_.INDETERMINATE_CLASS)) {
	        return;
	    }
	    this.progressbar_.style.width = p + '%';
	};
	MaterialProgress.prototype['setProgress'] = MaterialProgress.prototype.setProgress;
	/**
	   * Set the current progress of the buffer.
	   *
	   * @param {number} p Percentage of the buffer (0-100)
	   * @public
	   */
	MaterialProgress.prototype.setBuffer = function (p) {
	    this.bufferbar_.style.width = p + '%';
	    this.auxbar_.style.width = 100 - p + '%';
	};
	MaterialProgress.prototype['setBuffer'] = MaterialProgress.prototype.setBuffer;
	/**
	   * Initialize element.
	   */
	MaterialProgress.prototype.init = function () {
	    if (this.element_) {
	        var el = document.createElement('div');
	        el.className = 'progressbar bar bar1';
	        this.element_.appendChild(el);
	        this.progressbar_ = el;
	        el = document.createElement('div');
	        el.className = 'bufferbar bar bar2';
	        this.element_.appendChild(el);
	        this.bufferbar_ = el;
	        el = document.createElement('div');
	        el.className = 'auxbar bar bar3';
	        this.element_.appendChild(el);
	        this.auxbar_ = el;
	        this.progressbar_.style.width = '0%';
	        this.bufferbar_.style.width = '100%';
	        this.auxbar_.style.width = '0%';
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialProgress,
	    classAsString: 'MaterialProgress',
	    cssClass: 'mdl-js-progress',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Radio MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialRadio = function MaterialRadio(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialRadio'] = MaterialRadio;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialRadio.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialRadio.prototype.CssClasses_ = {
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked',
	    IS_UPGRADED: 'is-upgraded',
	    JS_RADIO: 'mdl-js-radio',
	    RADIO_BTN: 'mdl-radio__button',
	    RADIO_OUTER_CIRCLE: 'mdl-radio__outer-circle',
	    RADIO_INNER_CIRCLE: 'mdl-radio__inner-circle',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-radio__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onChange_ = function (event) {
	    // Since other radio buttons don't get change events, we need to look for
	    // them to update their classes.
	    var radios = document.getElementsByClassName(this.CssClasses_.JS_RADIO);
	    for (var i = 0; i < radios.length; i++) {
	        var button = radios[i].querySelector('.' + this.CssClasses_.RADIO_BTN);
	        // Different name == different group, so no point updating those.
	        if (button.getAttribute('name') === this.btnElement_.getAttribute('name')) {
	            radios[i]['MaterialRadio'].updateClasses_();
	        }
	    }
	};
	/**
	   * Handle focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onMouseup_ = function (event) {
	    this.blur_();
	};
	/**
	   * Update classes.
	   *
	   * @private
	   */
	MaterialRadio.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialRadio.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.btnElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the components disabled state.
	   *
	   * @public
	   */
	MaterialRadio.prototype.checkDisabled = function () {
	    if (this.btnElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialRadio.prototype['checkDisabled'] = MaterialRadio.prototype.checkDisabled;
	/**
	   * Check the components toggled state.
	   *
	   * @public
	   */
	MaterialRadio.prototype.checkToggleState = function () {
	    if (this.btnElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialRadio.prototype['checkToggleState'] = MaterialRadio.prototype.checkToggleState;
	/**
	   * Disable radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.disable = function () {
	    this.btnElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialRadio.prototype['disable'] = MaterialRadio.prototype.disable;
	/**
	   * Enable radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.enable = function () {
	    this.btnElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialRadio.prototype['enable'] = MaterialRadio.prototype.enable;
	/**
	   * Check radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.check = function () {
	    this.btnElement_.checked = true;
	    this.updateClasses_();
	};
	MaterialRadio.prototype['check'] = MaterialRadio.prototype.check;
	/**
	   * Uncheck radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.uncheck = function () {
	    this.btnElement_.checked = false;
	    this.updateClasses_();
	};
	MaterialRadio.prototype['uncheck'] = MaterialRadio.prototype.uncheck;
	/**
	   * Initialize element.
	   */
	MaterialRadio.prototype.init = function () {
	    if (this.element_) {
	        this.btnElement_ = this.element_.querySelector('.' + this.CssClasses_.RADIO_BTN);
	        this.boundChangeHandler_ = this.onChange_.bind(this);
	        this.boundFocusHandler_ = this.onChange_.bind(this);
	        this.boundBlurHandler_ = this.onBlur_.bind(this);
	        this.boundMouseUpHandler_ = this.onMouseup_.bind(this);
	        var outerCircle = document.createElement('span');
	        outerCircle.classList.add(this.CssClasses_.RADIO_OUTER_CIRCLE);
	        var innerCircle = document.createElement('span');
	        innerCircle.classList.add(this.CssClasses_.RADIO_INNER_CIRCLE);
	        this.element_.appendChild(outerCircle);
	        this.element_.appendChild(innerCircle);
	        var rippleContainer;
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            rippleContainer = document.createElement('span');
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            rippleContainer.addEventListener('mouseup', this.boundMouseUpHandler_);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            rippleContainer.appendChild(ripple);
	            this.element_.appendChild(rippleContainer);
	        }
	        this.btnElement_.addEventListener('change', this.boundChangeHandler_);
	        this.btnElement_.addEventListener('focus', this.boundFocusHandler_);
	        this.btnElement_.addEventListener('blur', this.boundBlurHandler_);
	        this.element_.addEventListener('mouseup', this.boundMouseUpHandler_);
	        this.updateClasses_();
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialRadio,
	    classAsString: 'MaterialRadio',
	    cssClass: 'mdl-js-radio',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Slider MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialSlider = function MaterialSlider(element) {
	    this.element_ = element;
	    // Browser feature detection.
	    this.isIE_ = window.navigator.msPointerEnabled;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialSlider'] = MaterialSlider;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSlider.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSlider.prototype.CssClasses_ = {
	    IE_CONTAINER: 'mdl-slider__ie-container',
	    SLIDER_CONTAINER: 'mdl-slider__container',
	    BACKGROUND_FLEX: 'mdl-slider__background-flex',
	    BACKGROUND_LOWER: 'mdl-slider__background-lower',
	    BACKGROUND_UPPER: 'mdl-slider__background-upper',
	    IS_LOWEST_VALUE: 'is-lowest-value',
	    IS_UPGRADED: 'is-upgraded'
	};
	/**
	   * Handle input on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSlider.prototype.onInput_ = function (event) {
	    this.updateValueStyles_();
	};
	/**
	   * Handle change on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSlider.prototype.onChange_ = function (event) {
	    this.updateValueStyles_();
	};
	/**
	   * Handle mouseup on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSlider.prototype.onMouseUp_ = function (event) {
	    event.target.blur();
	};
	/**
	   * Handle mousedown on container element.
	   * This handler is purpose is to not require the use to click
	   * exactly on the 2px slider element, as FireFox seems to be very
	   * strict about this.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   * @suppress {missingProperties}
	   */
	MaterialSlider.prototype.onContainerMouseDown_ = function (event) {
	    // If this click is not on the parent element (but rather some child)
	    // ignore. It may still bubble up.
	    if (event.target !== this.element_.parentElement) {
	        return;
	    }
	    // Discard the original event and create a new event that
	    // is on the slider element.
	    event.preventDefault();
	    var newEvent = new MouseEvent('mousedown', {
	        target: event.target,
	        buttons: event.buttons,
	        clientX: event.clientX,
	        clientY: this.element_.getBoundingClientRect().y
	    });
	    this.element_.dispatchEvent(newEvent);
	};
	/**
	   * Handle updating of values.
	   *
	   * @private
	   */
	MaterialSlider.prototype.updateValueStyles_ = function () {
	    // Calculate and apply percentages to div structure behind slider.
	    var fraction = (this.element_.value - this.element_.min) / (this.element_.max - this.element_.min);
	    if (fraction === 0) {
	        this.element_.classList.add(this.CssClasses_.IS_LOWEST_VALUE);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_LOWEST_VALUE);
	    }
	    if (!this.isIE_) {
	        this.backgroundLower_.style.flex = fraction;
	        this.backgroundLower_.style.webkitFlex = fraction;
	        this.backgroundUpper_.style.flex = 1 - fraction;
	        this.backgroundUpper_.style.webkitFlex = 1 - fraction;
	    }
	};
	// Public methods.
	/**
	   * Disable slider.
	   *
	   * @public
	   */
	MaterialSlider.prototype.disable = function () {
	    this.element_.disabled = true;
	};
	MaterialSlider.prototype['disable'] = MaterialSlider.prototype.disable;
	/**
	   * Enable slider.
	   *
	   * @public
	   */
	MaterialSlider.prototype.enable = function () {
	    this.element_.disabled = false;
	};
	MaterialSlider.prototype['enable'] = MaterialSlider.prototype.enable;
	/**
	   * Update slider value.
	   *
	   * @param {number} value The value to which to set the control (optional).
	   * @public
	   */
	MaterialSlider.prototype.change = function (value) {
	    if (typeof value !== 'undefined') {
	        this.element_.value = value;
	    }
	    this.updateValueStyles_();
	};
	MaterialSlider.prototype['change'] = MaterialSlider.prototype.change;
	/**
	   * Initialize element.
	   */
	MaterialSlider.prototype.init = function () {
	    if (this.element_) {
	        if (this.isIE_) {
	            // Since we need to specify a very large height in IE due to
	            // implementation limitations, we add a parent here that trims it down to
	            // a reasonable size.
	            var containerIE = document.createElement('div');
	            containerIE.classList.add(this.CssClasses_.IE_CONTAINER);
	            this.element_.parentElement.insertBefore(containerIE, this.element_);
	            this.element_.parentElement.removeChild(this.element_);
	            containerIE.appendChild(this.element_);
	        } else {
	            // For non-IE browsers, we need a div structure that sits behind the
	            // slider and allows us to style the left and right sides of it with
	            // different colors.
	            var container = document.createElement('div');
	            container.classList.add(this.CssClasses_.SLIDER_CONTAINER);
	            this.element_.parentElement.insertBefore(container, this.element_);
	            this.element_.parentElement.removeChild(this.element_);
	            container.appendChild(this.element_);
	            var backgroundFlex = document.createElement('div');
	            backgroundFlex.classList.add(this.CssClasses_.BACKGROUND_FLEX);
	            container.appendChild(backgroundFlex);
	            this.backgroundLower_ = document.createElement('div');
	            this.backgroundLower_.classList.add(this.CssClasses_.BACKGROUND_LOWER);
	            backgroundFlex.appendChild(this.backgroundLower_);
	            this.backgroundUpper_ = document.createElement('div');
	            this.backgroundUpper_.classList.add(this.CssClasses_.BACKGROUND_UPPER);
	            backgroundFlex.appendChild(this.backgroundUpper_);
	        }
	        this.boundInputHandler = this.onInput_.bind(this);
	        this.boundChangeHandler = this.onChange_.bind(this);
	        this.boundMouseUpHandler = this.onMouseUp_.bind(this);
	        this.boundContainerMouseDownHandler = this.onContainerMouseDown_.bind(this);
	        this.element_.addEventListener('input', this.boundInputHandler);
	        this.element_.addEventListener('change', this.boundChangeHandler);
	        this.element_.addEventListener('mouseup', this.boundMouseUpHandler);
	        this.element_.parentElement.addEventListener('mousedown', this.boundContainerMouseDownHandler);
	        this.updateValueStyles_();
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSlider,
	    classAsString: 'MaterialSlider',
	    cssClass: 'mdl-js-slider',
	    widget: true
	});
	/**
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Snackbar MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialSnackbar = function MaterialSnackbar(element) {
	    this.element_ = element;
	    this.textElement_ = this.element_.querySelector('.' + this.cssClasses_.MESSAGE);
	    this.actionElement_ = this.element_.querySelector('.' + this.cssClasses_.ACTION);
	    if (!this.textElement_) {
	        throw new Error('There must be a message element for a snackbar.');
	    }
	    if (!this.actionElement_) {
	        throw new Error('There must be an action element for a snackbar.');
	    }
	    this.active = false;
	    this.actionHandler_ = undefined;
	    this.message_ = undefined;
	    this.actionText_ = undefined;
	    this.queuedNotifications_ = [];
	    this.setActionHidden_(true);
	};
	window['MaterialSnackbar'] = MaterialSnackbar;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSnackbar.prototype.Constant_ = {
	    // The duration of the snackbar show/hide animation, in ms.
	    ANIMATION_LENGTH: 250
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSnackbar.prototype.cssClasses_ = {
	    SNACKBAR: 'mdl-snackbar',
	    MESSAGE: 'mdl-snackbar__text',
	    ACTION: 'mdl-snackbar__action',
	    ACTIVE: 'mdl-snackbar--active'
	};
	/**
	   * Display the snackbar.
	   *
	   * @private
	   */
	MaterialSnackbar.prototype.displaySnackbar_ = function () {
	    this.element_.setAttribute('aria-hidden', 'true');
	    if (this.actionHandler_) {
	        this.actionElement_.textContent = this.actionText_;
	        this.actionElement_.addEventListener('click', this.actionHandler_);
	        this.setActionHidden_(false);
	    }
	    this.textElement_.textContent = this.message_;
	    this.element_.classList.add(this.cssClasses_.ACTIVE);
	    this.element_.setAttribute('aria-hidden', 'false');
	    setTimeout(this.cleanup_.bind(this), this.timeout_);
	};
	/**
	   * Show the snackbar.
	   *
	   * @param {Object} data The data for the notification.
	   * @public
	   */
	MaterialSnackbar.prototype.showSnackbar = function (data) {
	    if (data === undefined) {
	        throw new Error('Please provide a data object with at least a message to display.');
	    }
	    if (data['message'] === undefined) {
	        throw new Error('Please provide a message to be displayed.');
	    }
	    if (data['actionHandler'] && !data['actionText']) {
	        throw new Error('Please provide action text with the handler.');
	    }
	    if (this.active) {
	        this.queuedNotifications_.push(data);
	    } else {
	        this.active = true;
	        this.message_ = data['message'];
	        if (data['timeout']) {
	            this.timeout_ = data['timeout'];
	        } else {
	            this.timeout_ = 2750;
	        }
	        if (data['actionHandler']) {
	            this.actionHandler_ = data['actionHandler'];
	        }
	        if (data['actionText']) {
	            this.actionText_ = data['actionText'];
	        }
	        this.displaySnackbar_();
	    }
	};
	MaterialSnackbar.prototype['showSnackbar'] = MaterialSnackbar.prototype.showSnackbar;
	/**
	   * Check if the queue has items within it.
	   * If it does, display the next entry.
	   *
	   * @private
	   */
	MaterialSnackbar.prototype.checkQueue_ = function () {
	    if (this.queuedNotifications_.length > 0) {
	        this.showSnackbar(this.queuedNotifications_.shift());
	    }
	};
	/**
	   * Cleanup the snackbar event listeners and accessiblity attributes.
	   *
	   * @private
	   */
	MaterialSnackbar.prototype.cleanup_ = function () {
	    this.element_.classList.remove(this.cssClasses_.ACTIVE);
	    setTimeout(function () {
	        this.element_.setAttribute('aria-hidden', 'true');
	        this.textElement_.textContent = '';
	        if (!Boolean(this.actionElement_.getAttribute('aria-hidden'))) {
	            this.setActionHidden_(true);
	            this.actionElement_.textContent = '';
	            this.actionElement_.removeEventListener('click', this.actionHandler_);
	        }
	        this.actionHandler_ = undefined;
	        this.message_ = undefined;
	        this.actionText_ = undefined;
	        this.active = false;
	        this.checkQueue_();
	    }.bind(this), this.Constant_.ANIMATION_LENGTH);
	};
	/**
	   * Set the action handler hidden state.
	   *
	   * @param {boolean} value
	   * @private
	   */
	MaterialSnackbar.prototype.setActionHidden_ = function (value) {
	    if (value) {
	        this.actionElement_.setAttribute('aria-hidden', 'true');
	    } else {
	        this.actionElement_.removeAttribute('aria-hidden');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSnackbar,
	    classAsString: 'MaterialSnackbar',
	    cssClass: 'mdl-js-snackbar',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Spinner MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @param {HTMLElement} element The element that will be upgraded.
	   * @constructor
	   */
	var MaterialSpinner = function MaterialSpinner(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialSpinner'] = MaterialSpinner;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSpinner.prototype.Constant_ = { MDL_SPINNER_LAYER_COUNT: 4 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSpinner.prototype.CssClasses_ = {
	    MDL_SPINNER_LAYER: 'mdl-spinner__layer',
	    MDL_SPINNER_CIRCLE_CLIPPER: 'mdl-spinner__circle-clipper',
	    MDL_SPINNER_CIRCLE: 'mdl-spinner__circle',
	    MDL_SPINNER_GAP_PATCH: 'mdl-spinner__gap-patch',
	    MDL_SPINNER_LEFT: 'mdl-spinner__left',
	    MDL_SPINNER_RIGHT: 'mdl-spinner__right'
	};
	/**
	   * Auxiliary method to create a spinner layer.
	   *
	   * @param {number} index Index of the layer to be created.
	   * @public
	   */
	MaterialSpinner.prototype.createLayer = function (index) {
	    var layer = document.createElement('div');
	    layer.classList.add(this.CssClasses_.MDL_SPINNER_LAYER);
	    layer.classList.add(this.CssClasses_.MDL_SPINNER_LAYER + '-' + index);
	    var leftClipper = document.createElement('div');
	    leftClipper.classList.add(this.CssClasses_.MDL_SPINNER_CIRCLE_CLIPPER);
	    leftClipper.classList.add(this.CssClasses_.MDL_SPINNER_LEFT);
	    var gapPatch = document.createElement('div');
	    gapPatch.classList.add(this.CssClasses_.MDL_SPINNER_GAP_PATCH);
	    var rightClipper = document.createElement('div');
	    rightClipper.classList.add(this.CssClasses_.MDL_SPINNER_CIRCLE_CLIPPER);
	    rightClipper.classList.add(this.CssClasses_.MDL_SPINNER_RIGHT);
	    var circleOwners = [
	        leftClipper,
	        gapPatch,
	        rightClipper
	    ];
	    for (var i = 0; i < circleOwners.length; i++) {
	        var circle = document.createElement('div');
	        circle.classList.add(this.CssClasses_.MDL_SPINNER_CIRCLE);
	        circleOwners[i].appendChild(circle);
	    }
	    layer.appendChild(leftClipper);
	    layer.appendChild(gapPatch);
	    layer.appendChild(rightClipper);
	    this.element_.appendChild(layer);
	};
	MaterialSpinner.prototype['createLayer'] = MaterialSpinner.prototype.createLayer;
	/**
	   * Stops the spinner animation.
	   * Public method for users who need to stop the spinner for any reason.
	   *
	   * @public
	   */
	MaterialSpinner.prototype.stop = function () {
	    this.element_.classList.remove('is-active');
	};
	MaterialSpinner.prototype['stop'] = MaterialSpinner.prototype.stop;
	/**
	   * Starts the spinner animation.
	   * Public method for users who need to manually start the spinner for any reason
	   * (instead of just adding the 'is-active' class to their markup).
	   *
	   * @public
	   */
	MaterialSpinner.prototype.start = function () {
	    this.element_.classList.add('is-active');
	};
	MaterialSpinner.prototype['start'] = MaterialSpinner.prototype.start;
	/**
	   * Initialize element.
	   */
	MaterialSpinner.prototype.init = function () {
	    if (this.element_) {
	        for (var i = 1; i <= this.Constant_.MDL_SPINNER_LAYER_COUNT; i++) {
	            this.createLayer(i);
	        }
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSpinner,
	    classAsString: 'MaterialSpinner',
	    cssClass: 'mdl-js-spinner',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Checkbox MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialSwitch = function MaterialSwitch(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialSwitch'] = MaterialSwitch;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSwitch.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSwitch.prototype.CssClasses_ = {
	    INPUT: 'mdl-switch__input',
	    TRACK: 'mdl-switch__track',
	    THUMB: 'mdl-switch__thumb',
	    FOCUS_HELPER: 'mdl-switch__focus-helper',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-switch__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onChange_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onMouseUp_ = function (event) {
	    this.blur_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialSwitch.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialSwitch.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.inputElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the components disabled state.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.checkDisabled = function () {
	    if (this.inputElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialSwitch.prototype['checkDisabled'] = MaterialSwitch.prototype.checkDisabled;
	/**
	   * Check the components toggled state.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.checkToggleState = function () {
	    if (this.inputElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialSwitch.prototype['checkToggleState'] = MaterialSwitch.prototype.checkToggleState;
	/**
	   * Disable switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.disable = function () {
	    this.inputElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['disable'] = MaterialSwitch.prototype.disable;
	/**
	   * Enable switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.enable = function () {
	    this.inputElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['enable'] = MaterialSwitch.prototype.enable;
	/**
	   * Activate switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.on = function () {
	    this.inputElement_.checked = true;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['on'] = MaterialSwitch.prototype.on;
	/**
	   * Deactivate switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.off = function () {
	    this.inputElement_.checked = false;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['off'] = MaterialSwitch.prototype.off;
	/**
	   * Initialize element.
	   */
	MaterialSwitch.prototype.init = function () {
	    if (this.element_) {
	        this.inputElement_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        var track = document.createElement('div');
	        track.classList.add(this.CssClasses_.TRACK);
	        var thumb = document.createElement('div');
	        thumb.classList.add(this.CssClasses_.THUMB);
	        var focusHelper = document.createElement('span');
	        focusHelper.classList.add(this.CssClasses_.FOCUS_HELPER);
	        thumb.appendChild(focusHelper);
	        this.element_.appendChild(track);
	        this.element_.appendChild(thumb);
	        this.boundMouseUpHandler = this.onMouseUp_.bind(this);
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            this.rippleContainerElement_ = document.createElement('span');
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            this.rippleContainerElement_.addEventListener('mouseup', this.boundMouseUpHandler);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            this.rippleContainerElement_.appendChild(ripple);
	            this.element_.appendChild(this.rippleContainerElement_);
	        }
	        this.boundChangeHandler = this.onChange_.bind(this);
	        this.boundFocusHandler = this.onFocus_.bind(this);
	        this.boundBlurHandler = this.onBlur_.bind(this);
	        this.inputElement_.addEventListener('change', this.boundChangeHandler);
	        this.inputElement_.addEventListener('focus', this.boundFocusHandler);
	        this.inputElement_.addEventListener('blur', this.boundBlurHandler);
	        this.element_.addEventListener('mouseup', this.boundMouseUpHandler);
	        this.updateClasses_();
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSwitch,
	    classAsString: 'MaterialSwitch',
	    cssClass: 'mdl-js-switch',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Tabs MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {Element} element The element that will be upgraded.
	   */
	var MaterialTabs = function MaterialTabs(element) {
	    // Stores the HTML element.
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialTabs'] = MaterialTabs;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTabs.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTabs.prototype.CssClasses_ = {
	    TAB_CLASS: 'mdl-tabs__tab',
	    PANEL_CLASS: 'mdl-tabs__panel',
	    ACTIVE_CLASS: 'is-active',
	    UPGRADED_CLASS: 'is-upgraded',
	    MDL_JS_RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    MDL_RIPPLE_CONTAINER: 'mdl-tabs__ripple-container',
	    MDL_RIPPLE: 'mdl-ripple',
	    MDL_JS_RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events'
	};
	/**
	   * Handle clicks to a tabs component
	   *
	   * @private
	   */
	MaterialTabs.prototype.initTabs_ = function () {
	    if (this.element_.classList.contains(this.CssClasses_.MDL_JS_RIPPLE_EFFECT)) {
	        this.element_.classList.add(this.CssClasses_.MDL_JS_RIPPLE_EFFECT_IGNORE_EVENTS);
	    }
	    // Select element tabs, document panels
	    this.tabs_ = this.element_.querySelectorAll('.' + this.CssClasses_.TAB_CLASS);
	    this.panels_ = this.element_.querySelectorAll('.' + this.CssClasses_.PANEL_CLASS);
	    // Create new tabs for each tab element
	    for (var i = 0; i < this.tabs_.length; i++) {
	        new MaterialTab(this.tabs_[i], this);
	    }
	    this.element_.classList.add(this.CssClasses_.UPGRADED_CLASS);
	};
	/**
	   * Reset tab state, dropping active classes
	   *
	   * @private
	   */
	MaterialTabs.prototype.resetTabState_ = function () {
	    for (var k = 0; k < this.tabs_.length; k++) {
	        this.tabs_[k].classList.remove(this.CssClasses_.ACTIVE_CLASS);
	    }
	};
	/**
	   * Reset panel state, droping active classes
	   *
	   * @private
	   */
	MaterialTabs.prototype.resetPanelState_ = function () {
	    for (var j = 0; j < this.panels_.length; j++) {
	        this.panels_[j].classList.remove(this.CssClasses_.ACTIVE_CLASS);
	    }
	};
	/**
	   * Initialize element.
	   */
	MaterialTabs.prototype.init = function () {
	    if (this.element_) {
	        this.initTabs_();
	    }
	};
	/**
	   * Constructor for an individual tab.
	   *
	   * @constructor
	   * @param {Element} tab The HTML element for the tab.
	   * @param {MaterialTabs} ctx The MaterialTabs object that owns the tab.
	   */
	function MaterialTab(tab, ctx) {
	    if (tab) {
	        if (ctx.element_.classList.contains(ctx.CssClasses_.MDL_JS_RIPPLE_EFFECT)) {
	            var rippleContainer = document.createElement('span');
	            rippleContainer.classList.add(ctx.CssClasses_.MDL_RIPPLE_CONTAINER);
	            rippleContainer.classList.add(ctx.CssClasses_.MDL_JS_RIPPLE_EFFECT);
	            var ripple = document.createElement('span');
	            ripple.classList.add(ctx.CssClasses_.MDL_RIPPLE);
	            rippleContainer.appendChild(ripple);
	            tab.appendChild(rippleContainer);
	        }
	        tab.addEventListener('click', function (e) {
	            e.preventDefault();
	            var href = tab.href.split('#')[1];
	            var panel = ctx.element_.querySelector('#' + href);
	            ctx.resetTabState_();
	            ctx.resetPanelState_();
	            tab.classList.add(ctx.CssClasses_.ACTIVE_CLASS);
	            panel.classList.add(ctx.CssClasses_.ACTIVE_CLASS);
	        });
	    }
	}
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialTabs,
	    classAsString: 'MaterialTabs',
	    cssClass: 'mdl-js-tabs'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Textfield MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialTextfield = function MaterialTextfield(element) {
	    this.element_ = element;
	    this.maxRows = this.Constant_.NO_MAX_ROWS;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialTextfield'] = MaterialTextfield;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialTextfield.prototype.Constant_ = {
	    NO_MAX_ROWS: -1,
	    MAX_ROWS_ATTRIBUTE: 'maxrows'
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTextfield.prototype.CssClasses_ = {
	    LABEL: 'mdl-textfield__label',
	    INPUT: 'mdl-textfield__input',
	    IS_DIRTY: 'is-dirty',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_INVALID: 'is-invalid',
	    IS_UPGRADED: 'is-upgraded',
	    HAS_PLACEHOLDER: 'has-placeholder'
	};
	/**
	   * Handle input being entered.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onKeyDown_ = function (event) {
	    var currentRowCount = event.target.value.split('\n').length;
	    if (event.keyCode === 13) {
	        if (currentRowCount >= this.maxRows) {
	            event.preventDefault();
	        }
	    }
	};
	/**
	   * Handle focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle reset event from out side.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onReset_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialTextfield.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkValidity();
	    this.checkDirty();
	    this.checkFocus();
	};
	// Public methods.
	/**
	   * Check the disabled state and update field accordingly.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.checkDisabled = function () {
	    if (this.input_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialTextfield.prototype['checkDisabled'] = MaterialTextfield.prototype.checkDisabled;
	/**
	  * Check the focus state and update field accordingly.
	  *
	  * @public
	  */
	MaterialTextfield.prototype.checkFocus = function () {
	    if (Boolean(this.element_.querySelector(':focus'))) {
	        this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	    }
	};
	MaterialTextfield.prototype['checkFocus'] = MaterialTextfield.prototype.checkFocus;
	/**
	   * Check the validity state and update field accordingly.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.checkValidity = function () {
	    if (this.input_.validity) {
	        if (this.input_.validity.valid) {
	            this.element_.classList.remove(this.CssClasses_.IS_INVALID);
	        } else {
	            this.element_.classList.add(this.CssClasses_.IS_INVALID);
	        }
	    }
	};
	MaterialTextfield.prototype['checkValidity'] = MaterialTextfield.prototype.checkValidity;
	/**
	   * Check the dirty state and update field accordingly.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.checkDirty = function () {
	    if (this.input_.value && this.input_.value.length > 0) {
	        this.element_.classList.add(this.CssClasses_.IS_DIRTY);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DIRTY);
	    }
	};
	MaterialTextfield.prototype['checkDirty'] = MaterialTextfield.prototype.checkDirty;
	/**
	   * Disable text field.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.disable = function () {
	    this.input_.disabled = true;
	    this.updateClasses_();
	};
	MaterialTextfield.prototype['disable'] = MaterialTextfield.prototype.disable;
	/**
	   * Enable text field.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.enable = function () {
	    this.input_.disabled = false;
	    this.updateClasses_();
	};
	MaterialTextfield.prototype['enable'] = MaterialTextfield.prototype.enable;
	/**
	   * Update text field value.
	   *
	   * @param {string} value The value to which to set the control (optional).
	   * @public
	   */
	MaterialTextfield.prototype.change = function (value) {
	    this.input_.value = value || '';
	    this.updateClasses_();
	};
	MaterialTextfield.prototype['change'] = MaterialTextfield.prototype.change;
	/**
	   * Initialize element.
	   */
	MaterialTextfield.prototype.init = function () {
	    if (this.element_) {
	        this.label_ = this.element_.querySelector('.' + this.CssClasses_.LABEL);
	        this.input_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        if (this.input_) {
	            if (this.input_.hasAttribute(this.Constant_.MAX_ROWS_ATTRIBUTE)) {
	                this.maxRows = parseInt(this.input_.getAttribute(this.Constant_.MAX_ROWS_ATTRIBUTE), 10);
	                if (isNaN(this.maxRows)) {
	                    this.maxRows = this.Constant_.NO_MAX_ROWS;
	                }
	            }
	            if (this.input_.hasAttribute('placeholder')) {
	                this.element_.classList.add(this.CssClasses_.HAS_PLACEHOLDER);
	            }
	            this.boundUpdateClassesHandler = this.updateClasses_.bind(this);
	            this.boundFocusHandler = this.onFocus_.bind(this);
	            this.boundBlurHandler = this.onBlur_.bind(this);
	            this.boundResetHandler = this.onReset_.bind(this);
	            this.input_.addEventListener('input', this.boundUpdateClassesHandler);
	            this.input_.addEventListener('focus', this.boundFocusHandler);
	            this.input_.addEventListener('blur', this.boundBlurHandler);
	            this.input_.addEventListener('reset', this.boundResetHandler);
	            if (this.maxRows !== this.Constant_.NO_MAX_ROWS) {
	                // TODO: This should handle pasting multi line text.
	                // Currently doesn't.
	                this.boundKeyDownHandler = this.onKeyDown_.bind(this);
	                this.input_.addEventListener('keydown', this.boundKeyDownHandler);
	            }
	            var invalid = this.element_.classList.contains(this.CssClasses_.IS_INVALID);
	            this.updateClasses_();
	            this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	            if (invalid) {
	                this.element_.classList.add(this.CssClasses_.IS_INVALID);
	            }
	            if (this.input_.hasAttribute('autofocus')) {
	                this.element_.focus();
	                this.checkFocus();
	            }
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialTextfield,
	    classAsString: 'MaterialTextfield',
	    cssClass: 'mdl-js-textfield',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Tooltip MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialTooltip = function MaterialTooltip(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialTooltip'] = MaterialTooltip;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialTooltip.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTooltip.prototype.CssClasses_ = {
	    IS_ACTIVE: 'is-active',
	    BOTTOM: 'mdl-tooltip--bottom',
	    LEFT: 'mdl-tooltip--left',
	    RIGHT: 'mdl-tooltip--right',
	    TOP: 'mdl-tooltip--top'
	};
	/**
	   * Handle mouseenter for tooltip.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTooltip.prototype.handleMouseEnter_ = function (event) {
	    var props = event.target.getBoundingClientRect();
	    var left = props.left + props.width / 2;
	    var top = props.top + props.height / 2;
	    var marginLeft = -1 * (this.element_.offsetWidth / 2);
	    var marginTop = -1 * (this.element_.offsetHeight / 2);
	    if (this.element_.classList.contains(this.CssClasses_.LEFT) || this.element_.classList.contains(this.CssClasses_.RIGHT)) {
	        left = props.width / 2;
	        if (top + marginTop < 0) {
	            this.element_.style.top = 0;
	            this.element_.style.marginTop = 0;
	        } else {
	            this.element_.style.top = top + 'px';
	            this.element_.style.marginTop = marginTop + 'px';
	        }
	    } else {
	        if (left + marginLeft < 0) {
	            this.element_.style.left = 0;
	            this.element_.style.marginLeft = 0;
	        } else {
	            this.element_.style.left = left + 'px';
	            this.element_.style.marginLeft = marginLeft + 'px';
	        }
	    }
	    if (this.element_.classList.contains(this.CssClasses_.TOP)) {
	        this.element_.style.top = props.top - this.element_.offsetHeight - 10 + 'px';
	    } else if (this.element_.classList.contains(this.CssClasses_.RIGHT)) {
	        this.element_.style.left = props.left + props.width + 10 + 'px';
	    } else if (this.element_.classList.contains(this.CssClasses_.LEFT)) {
	        this.element_.style.left = props.left - this.element_.offsetWidth - 10 + 'px';
	    } else {
	        this.element_.style.top = props.top + props.height + 10 + 'px';
	    }
	    this.element_.classList.add(this.CssClasses_.IS_ACTIVE);
	};
	/**
	   * Handle mouseleave for tooltip.
	   *
	   * @private
	   */
	MaterialTooltip.prototype.handleMouseLeave_ = function () {
	    this.element_.classList.remove(this.CssClasses_.IS_ACTIVE);
	};
	/**
	   * Initialize element.
	   */
	MaterialTooltip.prototype.init = function () {
	    if (this.element_) {
	        var forElId = this.element_.getAttribute('for');
	        if (forElId) {
	            this.forElement_ = document.getElementById(forElId);
	        }
	        if (this.forElement_) {
	            // It's left here because it prevents accidental text selection on Android
	            if (!this.forElement_.hasAttribute('tabindex')) {
	                this.forElement_.setAttribute('tabindex', '0');
	            }
	            this.boundMouseEnterHandler = this.handleMouseEnter_.bind(this);
	            this.boundMouseLeaveHandler = this.handleMouseLeave_.bind(this);
	            this.forElement_.addEventListener('mouseenter', this.boundMouseEnterHandler, false);
	            this.forElement_.addEventListener('touchend', this.boundMouseEnterHandler, false);
	            this.forElement_.addEventListener('mouseleave', this.boundMouseLeaveHandler, false);
	            window.addEventListener('touchstart', this.boundMouseLeaveHandler);
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialTooltip,
	    classAsString: 'MaterialTooltip',
	    cssClass: 'mdl-tooltip'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Layout MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialLayout = function MaterialLayout(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialLayout'] = MaterialLayout;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialLayout.prototype.Constant_ = {
	    MAX_WIDTH: '(max-width: 1024px)',
	    TAB_SCROLL_PIXELS: 100,
	    RESIZE_TIMEOUT: 100,
	    MENU_ICON: '&#xE5D2;',
	    CHEVRON_LEFT: 'chevron_left',
	    CHEVRON_RIGHT: 'chevron_right'
	};
	/**
	   * Keycodes, for code readability.
	   *
	   * @enum {number}
	   * @private
	   */
	MaterialLayout.prototype.Keycodes_ = {
	    ENTER: 13,
	    ESCAPE: 27,
	    SPACE: 32
	};
	/**
	   * Modes.
	   *
	   * @enum {number}
	   * @private
	   */
	MaterialLayout.prototype.Mode_ = {
	    STANDARD: 0,
	    SEAMED: 1,
	    WATERFALL: 2,
	    SCROLL: 3
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialLayout.prototype.CssClasses_ = {
	    CONTAINER: 'mdl-layout__container',
	    HEADER: 'mdl-layout__header',
	    DRAWER: 'mdl-layout__drawer',
	    CONTENT: 'mdl-layout__content',
	    DRAWER_BTN: 'mdl-layout__drawer-button',
	    ICON: 'material-icons',
	    JS_RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_CONTAINER: 'mdl-layout__tab-ripple-container',
	    RIPPLE: 'mdl-ripple',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    HEADER_SEAMED: 'mdl-layout__header--seamed',
	    HEADER_WATERFALL: 'mdl-layout__header--waterfall',
	    HEADER_SCROLL: 'mdl-layout__header--scroll',
	    FIXED_HEADER: 'mdl-layout--fixed-header',
	    OBFUSCATOR: 'mdl-layout__obfuscator',
	    TAB_BAR: 'mdl-layout__tab-bar',
	    TAB_CONTAINER: 'mdl-layout__tab-bar-container',
	    TAB: 'mdl-layout__tab',
	    TAB_BAR_BUTTON: 'mdl-layout__tab-bar-button',
	    TAB_BAR_LEFT_BUTTON: 'mdl-layout__tab-bar-left-button',
	    TAB_BAR_RIGHT_BUTTON: 'mdl-layout__tab-bar-right-button',
	    PANEL: 'mdl-layout__tab-panel',
	    HAS_DRAWER: 'has-drawer',
	    HAS_TABS: 'has-tabs',
	    HAS_SCROLLING_HEADER: 'has-scrolling-header',
	    CASTING_SHADOW: 'is-casting-shadow',
	    IS_COMPACT: 'is-compact',
	    IS_SMALL_SCREEN: 'is-small-screen',
	    IS_DRAWER_OPEN: 'is-visible',
	    IS_ACTIVE: 'is-active',
	    IS_UPGRADED: 'is-upgraded',
	    IS_ANIMATING: 'is-animating',
	    ON_LARGE_SCREEN: 'mdl-layout--large-screen-only',
	    ON_SMALL_SCREEN: 'mdl-layout--small-screen-only'
	};
	/**
	   * Handles scrolling on the content.
	   *
	   * @private
	   */
	MaterialLayout.prototype.contentScrollHandler_ = function () {
	    if (this.header_.classList.contains(this.CssClasses_.IS_ANIMATING)) {
	        return;
	    }
	    var headerVisible = !this.element_.classList.contains(this.CssClasses_.IS_SMALL_SCREEN) || this.element_.classList.contains(this.CssClasses_.FIXED_HEADER);
	    if (this.content_.scrollTop > 0 && !this.header_.classList.contains(this.CssClasses_.IS_COMPACT)) {
	        this.header_.classList.add(this.CssClasses_.CASTING_SHADOW);
	        this.header_.classList.add(this.CssClasses_.IS_COMPACT);
	        if (headerVisible) {
	            this.header_.classList.add(this.CssClasses_.IS_ANIMATING);
	        }
	    } else if (this.content_.scrollTop <= 0 && this.header_.classList.contains(this.CssClasses_.IS_COMPACT)) {
	        this.header_.classList.remove(this.CssClasses_.CASTING_SHADOW);
	        this.header_.classList.remove(this.CssClasses_.IS_COMPACT);
	        if (headerVisible) {
	            this.header_.classList.add(this.CssClasses_.IS_ANIMATING);
	        }
	    }
	};
	/**
	   * Handles a keyboard event on the drawer.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialLayout.prototype.keyboardEventHandler_ = function (evt) {
	    // Only react when the drawer is open.
	    if (evt.keyCode === this.Keycodes_.ESCAPE && this.drawer_.classList.contains(this.CssClasses_.IS_DRAWER_OPEN)) {
	        this.toggleDrawer();
	    }
	};
	/**
	   * Handles changes in screen size.
	   *
	   * @private
	   */
	MaterialLayout.prototype.screenSizeHandler_ = function () {
	    if (this.screenSizeMediaQuery_.matches) {
	        this.element_.classList.add(this.CssClasses_.IS_SMALL_SCREEN);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_SMALL_SCREEN);
	        // Collapse drawer (if any) when moving to a large screen size.
	        if (this.drawer_) {
	            this.drawer_.classList.remove(this.CssClasses_.IS_DRAWER_OPEN);
	            this.obfuscator_.classList.remove(this.CssClasses_.IS_DRAWER_OPEN);
	        }
	    }
	};
	/**
	   * Handles events of drawer button.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialLayout.prototype.drawerToggleHandler_ = function (evt) {
	    if (evt && evt.type === 'keydown') {
	        if (evt.keyCode === this.Keycodes_.SPACE || evt.keyCode === this.Keycodes_.ENTER) {
	            // prevent scrolling in drawer nav
	            evt.preventDefault();
	        } else {
	            // prevent other keys
	            return;
	        }
	    }
	    this.toggleDrawer();
	};
	/**
	   * Handles (un)setting the `is-animating` class
	   *
	   * @private
	   */
	MaterialLayout.prototype.headerTransitionEndHandler_ = function () {
	    this.header_.classList.remove(this.CssClasses_.IS_ANIMATING);
	};
	/**
	   * Handles expanding the header on click
	   *
	   * @private
	   */
	MaterialLayout.prototype.headerClickHandler_ = function () {
	    if (this.header_.classList.contains(this.CssClasses_.IS_COMPACT)) {
	        this.header_.classList.remove(this.CssClasses_.IS_COMPACT);
	        this.header_.classList.add(this.CssClasses_.IS_ANIMATING);
	    }
	};
	/**
	   * Reset tab state, dropping active classes
	   *
	   * @private
	   */
	MaterialLayout.prototype.resetTabState_ = function (tabBar) {
	    for (var k = 0; k < tabBar.length; k++) {
	        tabBar[k].classList.remove(this.CssClasses_.IS_ACTIVE);
	    }
	};
	/**
	   * Reset panel state, droping active classes
	   *
	   * @private
	   */
	MaterialLayout.prototype.resetPanelState_ = function (panels) {
	    for (var j = 0; j < panels.length; j++) {
	        panels[j].classList.remove(this.CssClasses_.IS_ACTIVE);
	    }
	};
	/**
	  * Toggle drawer state
	  *
	  * @public
	  */
	MaterialLayout.prototype.toggleDrawer = function () {
	    var drawerButton = this.element_.querySelector('.' + this.CssClasses_.DRAWER_BTN);
	    this.drawer_.classList.toggle(this.CssClasses_.IS_DRAWER_OPEN);
	    this.obfuscator_.classList.toggle(this.CssClasses_.IS_DRAWER_OPEN);
	    // Set accessibility properties.
	    if (this.drawer_.classList.contains(this.CssClasses_.IS_DRAWER_OPEN)) {
	        this.drawer_.setAttribute('aria-hidden', 'false');
	        drawerButton.setAttribute('aria-expanded', 'true');
	    } else {
	        this.drawer_.setAttribute('aria-hidden', 'true');
	        drawerButton.setAttribute('aria-expanded', 'false');
	    }
	};
	MaterialLayout.prototype['toggleDrawer'] = MaterialLayout.prototype.toggleDrawer;
	/**
	   * Initialize element.
	   */
	MaterialLayout.prototype.init = function () {
	    if (this.element_) {
	        var container = document.createElement('div');
	        container.classList.add(this.CssClasses_.CONTAINER);
	        var focusedElement = this.element_.querySelector(':focus');
	        this.element_.parentElement.insertBefore(container, this.element_);
	        this.element_.parentElement.removeChild(this.element_);
	        container.appendChild(this.element_);
	        if (focusedElement) {
	            focusedElement.focus();
	        }
	        var directChildren = this.element_.childNodes;
	        var numChildren = directChildren.length;
	        for (var c = 0; c < numChildren; c++) {
	            var child = directChildren[c];
	            if (child.classList && child.classList.contains(this.CssClasses_.HEADER)) {
	                this.header_ = child;
	            }
	            if (child.classList && child.classList.contains(this.CssClasses_.DRAWER)) {
	                this.drawer_ = child;
	            }
	            if (child.classList && child.classList.contains(this.CssClasses_.CONTENT)) {
	                this.content_ = child;
	            }
	        }
	        window.addEventListener('pageshow', function (e) {
	            if (e.persisted) {
	                // when page is loaded from back/forward cache
	                // trigger repaint to let layout scroll in safari
	                this.element_.style.overflowY = 'hidden';
	                requestAnimationFrame(function () {
	                    this.element_.style.overflowY = '';
	                }.bind(this));
	            }
	        }.bind(this), false);
	        if (this.header_) {
	            this.tabBar_ = this.header_.querySelector('.' + this.CssClasses_.TAB_BAR);
	        }
	        var mode = this.Mode_.STANDARD;
	        if (this.header_) {
	            if (this.header_.classList.contains(this.CssClasses_.HEADER_SEAMED)) {
	                mode = this.Mode_.SEAMED;
	            } else if (this.header_.classList.contains(this.CssClasses_.HEADER_WATERFALL)) {
	                mode = this.Mode_.WATERFALL;
	                this.header_.addEventListener('transitionend', this.headerTransitionEndHandler_.bind(this));
	                this.header_.addEventListener('click', this.headerClickHandler_.bind(this));
	            } else if (this.header_.classList.contains(this.CssClasses_.HEADER_SCROLL)) {
	                mode = this.Mode_.SCROLL;
	                container.classList.add(this.CssClasses_.HAS_SCROLLING_HEADER);
	            }
	            if (mode === this.Mode_.STANDARD) {
	                this.header_.classList.add(this.CssClasses_.CASTING_SHADOW);
	                if (this.tabBar_) {
	                    this.tabBar_.classList.add(this.CssClasses_.CASTING_SHADOW);
	                }
	            } else if (mode === this.Mode_.SEAMED || mode === this.Mode_.SCROLL) {
	                this.header_.classList.remove(this.CssClasses_.CASTING_SHADOW);
	                if (this.tabBar_) {
	                    this.tabBar_.classList.remove(this.CssClasses_.CASTING_SHADOW);
	                }
	            } else if (mode === this.Mode_.WATERFALL) {
	                // Add and remove shadows depending on scroll position.
	                // Also add/remove auxiliary class for styling of the compact version of
	                // the header.
	                this.content_.addEventListener('scroll', this.contentScrollHandler_.bind(this));
	                this.contentScrollHandler_();
	            }
	        }
	        // Add drawer toggling button to our layout, if we have an openable drawer.
	        if (this.drawer_) {
	            var drawerButton = this.element_.querySelector('.' + this.CssClasses_.DRAWER_BTN);
	            if (!drawerButton) {
	                drawerButton = document.createElement('div');
	                drawerButton.setAttribute('aria-expanded', 'false');
	                drawerButton.setAttribute('role', 'button');
	                drawerButton.setAttribute('tabindex', '0');
	                drawerButton.classList.add(this.CssClasses_.DRAWER_BTN);
	                var drawerButtonIcon = document.createElement('i');
	                drawerButtonIcon.classList.add(this.CssClasses_.ICON);
	                drawerButtonIcon.innerHTML = this.Constant_.MENU_ICON;
	                drawerButton.appendChild(drawerButtonIcon);
	            }
	            if (this.drawer_.classList.contains(this.CssClasses_.ON_LARGE_SCREEN)) {
	                //If drawer has ON_LARGE_SCREEN class then add it to the drawer toggle button as well.
	                drawerButton.classList.add(this.CssClasses_.ON_LARGE_SCREEN);
	            } else if (this.drawer_.classList.contains(this.CssClasses_.ON_SMALL_SCREEN)) {
	                //If drawer has ON_SMALL_SCREEN class then add it to the drawer toggle button as well.
	                drawerButton.classList.add(this.CssClasses_.ON_SMALL_SCREEN);
	            }
	            drawerButton.addEventListener('click', this.drawerToggleHandler_.bind(this));
	            drawerButton.addEventListener('keydown', this.drawerToggleHandler_.bind(this));
	            // Add a class if the layout has a drawer, for altering the left padding.
	            // Adds the HAS_DRAWER to the elements since this.header_ may or may
	            // not be present.
	            this.element_.classList.add(this.CssClasses_.HAS_DRAWER);
	            // If we have a fixed header, add the button to the header rather than
	            // the layout.
	            if (this.element_.classList.contains(this.CssClasses_.FIXED_HEADER)) {
	                this.header_.insertBefore(drawerButton, this.header_.firstChild);
	            } else {
	                this.element_.insertBefore(drawerButton, this.content_);
	            }
	            var obfuscator = document.createElement('div');
	            obfuscator.classList.add(this.CssClasses_.OBFUSCATOR);
	            this.element_.appendChild(obfuscator);
	            obfuscator.addEventListener('click', this.drawerToggleHandler_.bind(this));
	            this.obfuscator_ = obfuscator;
	            this.drawer_.addEventListener('keydown', this.keyboardEventHandler_.bind(this));
	            this.drawer_.setAttribute('aria-hidden', 'true');
	        }
	        // Keep an eye on screen size, and add/remove auxiliary class for styling
	        // of small screens.
	        this.screenSizeMediaQuery_ = window.matchMedia(this.Constant_.MAX_WIDTH);
	        this.screenSizeMediaQuery_.addListener(this.screenSizeHandler_.bind(this));
	        this.screenSizeHandler_();
	        // Initialize tabs, if any.
	        if (this.header_ && this.tabBar_) {
	            this.element_.classList.add(this.CssClasses_.HAS_TABS);
	            var tabContainer = document.createElement('div');
	            tabContainer.classList.add(this.CssClasses_.TAB_CONTAINER);
	            this.header_.insertBefore(tabContainer, this.tabBar_);
	            this.header_.removeChild(this.tabBar_);
	            var leftButton = document.createElement('div');
	            leftButton.classList.add(this.CssClasses_.TAB_BAR_BUTTON);
	            leftButton.classList.add(this.CssClasses_.TAB_BAR_LEFT_BUTTON);
	            var leftButtonIcon = document.createElement('i');
	            leftButtonIcon.classList.add(this.CssClasses_.ICON);
	            leftButtonIcon.textContent = this.Constant_.CHEVRON_LEFT;
	            leftButton.appendChild(leftButtonIcon);
	            leftButton.addEventListener('click', function () {
	                this.tabBar_.scrollLeft -= this.Constant_.TAB_SCROLL_PIXELS;
	            }.bind(this));
	            var rightButton = document.createElement('div');
	            rightButton.classList.add(this.CssClasses_.TAB_BAR_BUTTON);
	            rightButton.classList.add(this.CssClasses_.TAB_BAR_RIGHT_BUTTON);
	            var rightButtonIcon = document.createElement('i');
	            rightButtonIcon.classList.add(this.CssClasses_.ICON);
	            rightButtonIcon.textContent = this.Constant_.CHEVRON_RIGHT;
	            rightButton.appendChild(rightButtonIcon);
	            rightButton.addEventListener('click', function () {
	                this.tabBar_.scrollLeft += this.Constant_.TAB_SCROLL_PIXELS;
	            }.bind(this));
	            tabContainer.appendChild(leftButton);
	            tabContainer.appendChild(this.tabBar_);
	            tabContainer.appendChild(rightButton);
	            // Add and remove tab buttons depending on scroll position and total
	            // window size.
	            var tabUpdateHandler = function () {
	                if (this.tabBar_.scrollLeft > 0) {
	                    leftButton.classList.add(this.CssClasses_.IS_ACTIVE);
	                } else {
	                    leftButton.classList.remove(this.CssClasses_.IS_ACTIVE);
	                }
	                if (this.tabBar_.scrollLeft < this.tabBar_.scrollWidth - this.tabBar_.offsetWidth) {
	                    rightButton.classList.add(this.CssClasses_.IS_ACTIVE);
	                } else {
	                    rightButton.classList.remove(this.CssClasses_.IS_ACTIVE);
	                }
	            }.bind(this);
	            this.tabBar_.addEventListener('scroll', tabUpdateHandler);
	            tabUpdateHandler();
	            // Update tabs when the window resizes.
	            var windowResizeHandler = function () {
	                // Use timeouts to make sure it doesn't happen too often.
	                if (this.resizeTimeoutId_) {
	                    clearTimeout(this.resizeTimeoutId_);
	                }
	                this.resizeTimeoutId_ = setTimeout(function () {
	                    tabUpdateHandler();
	                    this.resizeTimeoutId_ = null;
	                }.bind(this), this.Constant_.RESIZE_TIMEOUT);
	            }.bind(this);
	            window.addEventListener('resize', windowResizeHandler);
	            if (this.tabBar_.classList.contains(this.CssClasses_.JS_RIPPLE_EFFECT)) {
	                this.tabBar_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            }
	            // Select element tabs, document panels
	            var tabs = this.tabBar_.querySelectorAll('.' + this.CssClasses_.TAB);
	            var panels = this.content_.querySelectorAll('.' + this.CssClasses_.PANEL);
	            // Create new tabs for each tab element
	            for (var i = 0; i < tabs.length; i++) {
	                new MaterialLayoutTab(tabs[i], tabs, panels, this);
	            }
	        }
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	/**
	   * Constructor for an individual tab.
	   *
	   * @constructor
	   * @param {HTMLElement} tab The HTML element for the tab.
	   * @param {!Array<HTMLElement>} tabs Array with HTML elements for all tabs.
	   * @param {!Array<HTMLElement>} panels Array with HTML elements for all panels.
	   * @param {MaterialLayout} layout The MaterialLayout object that owns the tab.
	   */
	function MaterialLayoutTab(tab, tabs, panels, layout) {
	    /**
	     * Auxiliary method to programmatically select a tab in the UI.
	     */
	    function selectTab() {
	        var href = tab.href.split('#')[1];
	        var panel = layout.content_.querySelector('#' + href);
	        layout.resetTabState_(tabs);
	        layout.resetPanelState_(panels);
	        tab.classList.add(layout.CssClasses_.IS_ACTIVE);
	        panel.classList.add(layout.CssClasses_.IS_ACTIVE);
	    }
	    if (layout.tabBar_.classList.contains(layout.CssClasses_.JS_RIPPLE_EFFECT)) {
	        var rippleContainer = document.createElement('span');
	        rippleContainer.classList.add(layout.CssClasses_.RIPPLE_CONTAINER);
	        rippleContainer.classList.add(layout.CssClasses_.JS_RIPPLE_EFFECT);
	        var ripple = document.createElement('span');
	        ripple.classList.add(layout.CssClasses_.RIPPLE);
	        rippleContainer.appendChild(ripple);
	        tab.appendChild(rippleContainer);
	    }
	    tab.addEventListener('click', function (e) {
	        if (tab.getAttribute('href').charAt(0) === '#') {
	            e.preventDefault();
	            selectTab();
	        }
	    });
	    tab.show = selectTab;
	}
	window['MaterialLayoutTab'] = MaterialLayoutTab;
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialLayout,
	    classAsString: 'MaterialLayout',
	    cssClass: 'mdl-js-layout'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Data Table Card MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {Element} element The element that will be upgraded.
	   */
	var MaterialDataTable = function MaterialDataTable(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialDataTable'] = MaterialDataTable;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialDataTable.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialDataTable.prototype.CssClasses_ = {
	    DATA_TABLE: 'mdl-data-table',
	    SELECTABLE: 'mdl-data-table--selectable',
	    SELECT_ELEMENT: 'mdl-data-table__select',
	    IS_SELECTED: 'is-selected',
	    IS_UPGRADED: 'is-upgraded'
	};
	/**
	   * Generates and returns a function that toggles the selection state of a
	   * single row (or multiple rows).
	   *
	   * @param {Element} checkbox Checkbox that toggles the selection state.
	   * @param {Element} row Row to toggle when checkbox changes.
	   * @param {(Array<Object>|NodeList)=} opt_rows Rows to toggle when checkbox changes.
	   * @private
	   */
	MaterialDataTable.prototype.selectRow_ = function (checkbox, row, opt_rows) {
	    if (row) {
	        return function () {
	            if (checkbox.checked) {
	                row.classList.add(this.CssClasses_.IS_SELECTED);
	            } else {
	                row.classList.remove(this.CssClasses_.IS_SELECTED);
	            }
	        }.bind(this);
	    }
	    if (opt_rows) {
	        return function () {
	            var i;
	            var el;
	            if (checkbox.checked) {
	                for (i = 0; i < opt_rows.length; i++) {
	                    el = opt_rows[i].querySelector('td').querySelector('.mdl-checkbox');
	                    el['MaterialCheckbox'].check();
	                    opt_rows[i].classList.add(this.CssClasses_.IS_SELECTED);
	                }
	            } else {
	                for (i = 0; i < opt_rows.length; i++) {
	                    el = opt_rows[i].querySelector('td').querySelector('.mdl-checkbox');
	                    el['MaterialCheckbox'].uncheck();
	                    opt_rows[i].classList.remove(this.CssClasses_.IS_SELECTED);
	                }
	            }
	        }.bind(this);
	    }
	};
	/**
	   * Creates a checkbox for a single or or multiple rows and hooks up the
	   * event handling.
	   *
	   * @param {Element} row Row to toggle when checkbox changes.
	   * @param {(Array<Object>|NodeList)=} opt_rows Rows to toggle when checkbox changes.
	   * @private
	   */
	MaterialDataTable.prototype.createCheckbox_ = function (row, opt_rows) {
	    var label = document.createElement('label');
	    var labelClasses = [
	        'mdl-checkbox',
	        'mdl-js-checkbox',
	        'mdl-js-ripple-effect',
	        this.CssClasses_.SELECT_ELEMENT
	    ];
	    label.className = labelClasses.join(' ');
	    var checkbox = document.createElement('input');
	    checkbox.type = 'checkbox';
	    checkbox.classList.add('mdl-checkbox__input');
	    if (row) {
	        checkbox.checked = row.classList.contains(this.CssClasses_.IS_SELECTED);
	        checkbox.addEventListener('change', this.selectRow_(checkbox, row));
	    } else if (opt_rows) {
	        checkbox.addEventListener('change', this.selectRow_(checkbox, null, opt_rows));
	    }
	    label.appendChild(checkbox);
	    componentHandler.upgradeElement(label, 'MaterialCheckbox');
	    return label;
	};
	/**
	   * Initialize element.
	   */
	MaterialDataTable.prototype.init = function () {
	    if (this.element_) {
	        var firstHeader = this.element_.querySelector('th');
	        var bodyRows = Array.prototype.slice.call(this.element_.querySelectorAll('tbody tr'));
	        var footRows = Array.prototype.slice.call(this.element_.querySelectorAll('tfoot tr'));
	        var rows = bodyRows.concat(footRows);
	        if (this.element_.classList.contains(this.CssClasses_.SELECTABLE)) {
	            var th = document.createElement('th');
	            var headerCheckbox = this.createCheckbox_(null, rows);
	            th.appendChild(headerCheckbox);
	            firstHeader.parentElement.insertBefore(th, firstHeader);
	            for (var i = 0; i < rows.length; i++) {
	                var firstCell = rows[i].querySelector('td');
	                if (firstCell) {
	                    var td = document.createElement('td');
	                    if (rows[i].parentNode.nodeName.toUpperCase() === 'TBODY') {
	                        var rowCheckbox = this.createCheckbox_(rows[i]);
	                        td.appendChild(rowCheckbox);
	                    }
	                    rows[i].insertBefore(td, firstCell);
	                }
	            }
	            this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialDataTable,
	    classAsString: 'MaterialDataTable',
	    cssClass: 'mdl-js-data-table'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Ripple MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialRipple = function MaterialRipple(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialRipple'] = MaterialRipple;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialRipple.prototype.Constant_ = {
	    INITIAL_SCALE: 'scale(0.0001, 0.0001)',
	    INITIAL_SIZE: '1px',
	    INITIAL_OPACITY: '0.4',
	    FINAL_OPACITY: '0',
	    FINAL_SCALE: ''
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialRipple.prototype.CssClasses_ = {
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE: 'mdl-ripple',
	    IS_ANIMATING: 'is-animating',
	    IS_VISIBLE: 'is-visible'
	};
	/**
	   * Handle mouse / finger down on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRipple.prototype.downHandler_ = function (event) {
	    if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
	        var rect = this.element_.getBoundingClientRect();
	        this.boundHeight = rect.height;
	        this.boundWidth = rect.width;
	        this.rippleSize_ = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
	        this.rippleElement_.style.width = this.rippleSize_ + 'px';
	        this.rippleElement_.style.height = this.rippleSize_ + 'px';
	    }
	    this.rippleElement_.classList.add(this.CssClasses_.IS_VISIBLE);
	    if (event.type === 'mousedown' && this.ignoringMouseDown_) {
	        this.ignoringMouseDown_ = false;
	    } else {
	        if (event.type === 'touchstart') {
	            this.ignoringMouseDown_ = true;
	        }
	        var frameCount = this.getFrameCount();
	        if (frameCount > 0) {
	            return;
	        }
	        this.setFrameCount(1);
	        var bound = event.currentTarget.getBoundingClientRect();
	        var x;
	        var y;
	        // Check if we are handling a keyboard click.
	        if (event.clientX === 0 && event.clientY === 0) {
	            x = Math.round(bound.width / 2);
	            y = Math.round(bound.height / 2);
	        } else {
	            var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
	            var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
	            x = Math.round(clientX - bound.left);
	            y = Math.round(clientY - bound.top);
	        }
	        this.setRippleXY(x, y);
	        this.setRippleStyles(true);
	        window.requestAnimationFrame(this.animFrameHandler.bind(this));
	    }
	};
	/**
	   * Handle mouse / finger up on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRipple.prototype.upHandler_ = function (event) {
	    // Don't fire for the artificial "mouseup" generated by a double-click.
	    if (event && event.detail !== 2) {
	        // Allow a repaint to occur before removing this class, so the animation
	        // shows for tap events, which seem to trigger a mouseup too soon after
	        // mousedown.
	        window.setTimeout(function () {
	            this.rippleElement_.classList.remove(this.CssClasses_.IS_VISIBLE);
	        }.bind(this), 0);
	    }
	};
	/**
	   * Initialize element.
	   */
	MaterialRipple.prototype.init = function () {
	    if (this.element_) {
	        var recentering = this.element_.classList.contains(this.CssClasses_.RIPPLE_CENTER);
	        if (!this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT_IGNORE_EVENTS)) {
	            this.rippleElement_ = this.element_.querySelector('.' + this.CssClasses_.RIPPLE);
	            this.frameCount_ = 0;
	            this.rippleSize_ = 0;
	            this.x_ = 0;
	            this.y_ = 0;
	            // Touch start produces a compat mouse down event, which would cause a
	            // second ripples. To avoid that, we use this property to ignore the first
	            // mouse down after a touch start.
	            this.ignoringMouseDown_ = false;
	            this.boundDownHandler = this.downHandler_.bind(this);
	            this.element_.addEventListener('mousedown', this.boundDownHandler);
	            this.element_.addEventListener('touchstart', this.boundDownHandler);
	            this.boundUpHandler = this.upHandler_.bind(this);
	            this.element_.addEventListener('mouseup', this.boundUpHandler);
	            this.element_.addEventListener('mouseleave', this.boundUpHandler);
	            this.element_.addEventListener('touchend', this.boundUpHandler);
	            this.element_.addEventListener('blur', this.boundUpHandler);
	            /**
	         * Getter for frameCount_.
	         * @return {number} the frame count.
	         */
	            this.getFrameCount = function () {
	                return this.frameCount_;
	            };
	            /**
	         * Setter for frameCount_.
	         * @param {number} fC the frame count.
	         */
	            this.setFrameCount = function (fC) {
	                this.frameCount_ = fC;
	            };
	            /**
	         * Getter for rippleElement_.
	         * @return {Element} the ripple element.
	         */
	            this.getRippleElement = function () {
	                return this.rippleElement_;
	            };
	            /**
	         * Sets the ripple X and Y coordinates.
	         * @param  {number} newX the new X coordinate
	         * @param  {number} newY the new Y coordinate
	         */
	            this.setRippleXY = function (newX, newY) {
	                this.x_ = newX;
	                this.y_ = newY;
	            };
	            /**
	         * Sets the ripple styles.
	         * @param  {boolean} start whether or not this is the start frame.
	         */
	            this.setRippleStyles = function (start) {
	                if (this.rippleElement_ !== null) {
	                    var transformString;
	                    var scale;
	                    var size;
	                    var offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';
	                    if (start) {
	                        scale = this.Constant_.INITIAL_SCALE;
	                        size = this.Constant_.INITIAL_SIZE;
	                    } else {
	                        scale = this.Constant_.FINAL_SCALE;
	                        size = this.rippleSize_ + 'px';
	                        if (recentering) {
	                            offset = 'translate(' + this.boundWidth / 2 + 'px, ' + this.boundHeight / 2 + 'px)';
	                        }
	                    }
	                    transformString = 'translate(-50%, -50%) ' + offset + scale;
	                    this.rippleElement_.style.webkitTransform = transformString;
	                    this.rippleElement_.style.msTransform = transformString;
	                    this.rippleElement_.style.transform = transformString;
	                    if (start) {
	                        this.rippleElement_.classList.remove(this.CssClasses_.IS_ANIMATING);
	                    } else {
	                        this.rippleElement_.classList.add(this.CssClasses_.IS_ANIMATING);
	                    }
	                }
	            };
	            /**
	         * Handles an animation frame.
	         */
	            this.animFrameHandler = function () {
	                if (this.frameCount_-- > 0) {
	                    window.requestAnimationFrame(this.animFrameHandler.bind(this));
	                } else {
	                    this.setRippleStyles(false);
	                }
	            };
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialRipple,
	    classAsString: 'MaterialRipple',
	    cssClass: 'mdl-js-ripple-effect',
	    widget: false
	});
	}());


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	
	var exportLibs = function(exports /*libs to include */) {
		var feature, i, len, libfeatures, libname, obj;
		
		for(i = 1, len = arguments.length; i < len; i++) {
			libname = arguments[i];
			libfeatures = __webpack_require__(263)("./" + libname + '.js');
			obj = exports;
			if (libfeatures.__namespace__ && libfeatures.__namespace__ != "") {
				if (!obj.hasOwnProperty(libfeatures.__namespace__)) {
					obj[libfeatures.__namespace__] = {};
				}
				obj = obj[libfeatures.__namespace__];
			}
			for(feature in libfeatures) {
				if (feature == '__namespace__') {
					continue;
				}
				if (obj.hasOwnProperty(feature)) {
					throw new Error('Feature exists: ' + feature);
				}
				obj[feature] = libfeatures[feature];
			}
		}
		return exports;
	};
	
	exportLibs(module.exports, 'distance', 'formatter', 'gpx-parser', 'tcx-parser', 'time', 'calc', 'creator', 'image', 'geohash');

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./calc.js": 264,
		"./constants.js": 267,
		"./creator.js": 269,
		"./distance.js": 268,
		"./exiftool.js": 324,
		"./formatter.js": 328,
		"./geohash.js": 329,
		"./gpx-parser.js": 271,
		"./image.js": 330,
		"./speed.js": 266,
		"./tcx-parser.js": 331,
		"./time.js": 265
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 263;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var time = __webpack_require__(265);
	var speed = __webpack_require__(266);
	var distance = __webpack_require__(268);
	
	var Trackpoint = function() {
		this.lat = null;
		this.lng = null;
		this.ele = null;
		this.time = null;
		this.speed = undefined;
		this.distance = undefined;
	};
	
	Trackpoint.copy = function(tp) {
		var ctp = new Trackpoint();
		ctp.lat = tp.lat;
		ctp.lng = tp.lng;
		ctp.time = tp.time;
		ctp.speed = tp.speed;
		ctp.distance = tp.distance;
		if(tp.altitude) {
			/* TODO this is not true */
			ctp.ele = tp.altitude;
		} else if(tp.ele) {
			ctp.ele = tp.ele;
		}
	
		return ctp;
	};
	var TrackingResult = function() {
		this.points = [];
		this.averageSpeed = undefined;
		this.fastestSpeed = undefined;
		this.slowestSpeed = undefined;
		/* Pace can be converted from speed */
		this.totalDistance = 0;
		this.totalTime = 0;
	};
	/**
	 * Calculate speed and distance
	 * 
	 * First point assumed same speed as the second point
	 *
	 * TODO: calculate based on more than 2 points for better values
	 *
	 */
	var calculateFromGPX = function(points, callback, fromIndex, toIndex) {
		var i, len, index, currentDistance, currentSpeed, fastestSpeed = 0, slowestSpeed = 100000000;
		var result;
		len = points.length - 1;
		i = 0;
		if(fromIndex && fromIndex > 0 && fromIndex < len) {
			i = fromIndex;
		}
		if(toIndex && toIndex < len) {
			len = toIndex;
		}
		if(points.length < 2 || len - i < 2) {
			return callback(new Error('Result can not be calculated properly with data points less than 2'), null);
		}
	
		try {
			result = new TrackingResult();
			index = 0;
			result.points[index] = Trackpoint.copy(points[i]);
			result.points[index].distance = 0;
			for(; i < len; i++, index++) {
				result.points[index + 1] = Trackpoint.copy(points[i + 1]);
				currentDistance = distance.getDistance(result.points[index].lng, result.points[index].lat, result.points[index + 1].lng, result.points[index + 1].lat);
				currentSpeed = speed.calculateSpeed(currentDistance, result.points[index].time, result.points[index + 1].time);
				result.totalDistance += currentDistance;
				result.points[index + 1].distance = result.points[index].distance + currentDistance;
				result.points[index + 1].speed = currentSpeed;
				if(currentSpeed > fastestSpeed) {
					fastestSpeed = currentSpeed;
				}
				if(currentSpeed < slowestSpeed) {
					slowestSpeed = currentSpeed;
				}
			}
			result.points[0].speed = result.points[1].speed;
			result.averageSpeed = speed.calculateSpeed(result.totalDistance, result.points[0].time, result.points[index].time);
			result.fastestSpeed = fastestSpeed;
			result.slowestSpeed = slowestSpeed;
			result.totalTime = time.getDiffInSecs(result.points[0].time, result.points[index].time);
			callback(null, result);
		} catch(e) {
			callback(e, null);
		}
	};
	
	/**
	 * Calculate speed and distance
	 * 
	 * Same way as GPX
	 *
	 */
	var calculateFromTCX = function(points, callback, fromIndex, toIndex) {
		var newPoints = [], i, len;
		try {
			for (i = 0, len = points.length; i < len; i++) {
				if (!points[i].lat || !points[i].lng) {
					continue;
				}
				newPoints.push(points[i]);
			}
			calculateFromGPX(newPoints, callback, fromIndex, toIndex);
		} catch(e) {
			callback(e, null);
		}
	};
	
	
	module.exports = {
		calculateFromGPX : calculateFromGPX,
		calculateFromTCX : calculateFromTCX
	};


/***/ },
/* 265 */
/***/ function(module, exports) {

	var getDiffInSecs = function(d1, d2) {
		return Math.round((d2.getTime() - d1.getTime())/1000);
	};
	
	var RelativeTime = function(secs) {
		this.hours = Math.floor(secs / 3600);
		this.minutes = Math.floor((secs % 3600) / 60);
		this.seconds = Math.round(secs % 60);
	};
	
	RelativeTime.prototype.toString = function() {
		var str = '';
		if(this.hours) {
			str += this.padDigitsString(this.hours) + ':';
		}
		str += this.padDigitsString(this.minutes) + ':';
		str += this.padDigitsString(this.seconds);
		return str;
	};
	
	RelativeTime.prototype.padDigitsString = function(digits) {
		if(digits < 10) {
			return '0' + digits;
		}
		return String(digits);
	};
	
	module.exports = {
		getDiffInSecs: getDiffInSecs,
		RelativeTime: RelativeTime
	};


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(267);
	var time = __webpack_require__(265);
	
	/**
	 *
	 *
	 * @param distance Float meters
	 * @param time1 Date
	 * @param time2 Date
	 *
	 * @return float speed in meter per second
	 */
	var calculateSpeed = function(distance, time1, time2) {
		if( typeof distance == 'undefined' || distance < 0) {
			return undefined;
		}
		if(!time1 || !time2 || time2 <= time1) {
			return undefined;
		}
		return (1000 * distance) / (time2.getTime() - time1.getTime());
	};
	var convertTypes = {
		MPSec2KmPH : 'MPSec2KmPH',
		KmPH2MPSec : 'KmPH2MPSec',
		MPSec2MPH : 'MPSec2MPH',
		MPH2MPSec : 'MPH2MPSec'
	};
	
	/* Those may make the tests fail if they are run in diff precision :-D */
	var convertFactors = {
		MPSec2KmPH : 3.6,
		KmPH2MPSec : 1 / 3.6,
		MPSec2MPH : 3600 / constants.MILE_IN_METERS,
		MPH2MPSec : constants.MILE_IN_METERS / 3600
	};
	
	var convertSpeed = function(speed, fromto) {
		var scaleFactor;
	
		if(convertFactors.hasOwnProperty(fromto)) {
			scaleFactor = convertFactors[fromto];
		} else {
			throw new Error('Not supported conversion: ' + fromto);
		}
	
		return speed * scaleFactor;
	};
	var calculatePaceTypes = {
		PER_KM : 'PER_KM',
		PER_MILE : 'PER_MILE'
	};
	
	var PaceResult = function(hours, minutes, seconds, type) {
		this.hours = hours;
		this.minutes = minutes;
		this.seconds = seconds;
		this.type = type;
	};
	
	PaceResult.prototype.padDigitsString = function(digits) {
		if(digits < 10) {
			return '0' + digits;
		}
		return String(digits);
	};
	
	PaceResult.prototype.toString = function() {
		var str = '';
		if(this.hours) {
			str += this.padDigitsString(this.hours) + ':';
		}
		str += this.padDigitsString(this.minutes) + ':';
		str += this.padDigitsString(this.seconds);
		switch(this.type) {
			case calculatePaceTypes.PER_KM:
				str += ' / km';
				break;
			case calculatePaceTypes.PER_MILE:
				str += ' / mile';
				break;
		}
		return str;
	};
	
	/**
	 *
	 * @param speed m/s
	 * @param type /km or /mile
	 */
	var calculatePace = function(speed, type) {
		var result = new PaceResult(), secs, dd;
		result.type = type;
	
		if(speed > 0) {
			switch(type) {
				case calculatePaceTypes.PER_KM:
					secs = 1000 / speed;
					break;
				case calculatePaceTypes.PER_MILE:
					secs = constants.MILE_IN_METERS / speed;
	
					break;
				default:
					throw new Error('Not supported type: ' + type);
			}
			dd = new time.RelativeTime(secs);
			result.hours = dd.hours;
			result.minutes = dd.minutes;
			result.seconds = dd.seconds;
		}
		return result;
	};
	
	module.exports = {
		calculateSpeed : calculateSpeed,
		calculatePace : calculatePace,
		calculatePaceTypes : calculatePaceTypes,
		convertSpeed : convertSpeed,
		convertTypes : convertTypes
	};


/***/ },
/* 267 */
/***/ function(module, exports) {

	module.exports = {
		MILE_IN_METERS: 1609.344
	};


/***/ },
/* 268 */
/***/ function(module, exports) {

	var EARTH_RADIUS = 6371000;
	var MIN_LNG = - Math.PI, MAX_LNG = Math.PI, MIN_LAT = - Math.PI / 2, MAX_LAT = Math.PI / 2;
	
	var toRad = function(decDegrees) {
		return decDegrees * Math.PI / 180;
	};
	var toDegrees = function(radians) {
		return (180 * radians) / Math.PI
	};
	
	var getDistance = function(lng1, lat1, lng2, lat2) {
		var a, c, dLat = toRad(lat2 - lat1), dLng = toRad(lng2 - lng1);
		a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLng / 2) * Math.sin(dLng / 2) * Math.cos(toRad(lat1)) * Math.cos(toRad(lat2));
		c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return c * EARTH_RADIUS;
	};
	var getTotalDistance = function(points) {
		var i, len, total = 0;
		for( i = 0, len = points.length - 1; i < len; i++) {
			total += getDistance(points[i].lng, points[i].lat, points[i + 1].lng, points[i + 1].lat);
		}
	
		return total;
	};
	/**
	 * http://JanMatuschek.de/LatitudeLongitudeBoundingCoordinates
	 */
	var getBoundingBox = function(lat, lng, distance) {
		var minLat, maxLat, minLng, maxLng;
		var deltaLng;
		var radDist = distance / EARTH_RADIUS;
		var radLat = toRad(lat), radLng = toRad(lng);
		
		minLat = radLat - radDist;
		maxLat = radLat + radDist;
	
		if(minLat > MIN_LAT && maxLat < MAX_LAT) {
			deltaLng = Math.asin(Math.sin(radDist) / Math.cos(radLat));
			minLng = radLng - deltaLng;
			if(minLng < MIN_LNG) {
				minLng += 2 * Math.PI;
			}
			maxLng = radLng + deltaLng;
			if(maxLng > MAX_LNG) {
				maxLng -= 2 * Math.PI;
			}
		} else {
			minLat = Math.max(minLat, MIN_LAT);
			maxLat = Math.min(maxLat, MAX_LAT);
			minLng = MIN_LNG;
			maxLng = MAX_LNG;
		}
		return [
			{lat: toDegrees(minLat), lng: toDegrees(minLng)}, // Southwest
			{lat: toDegrees(maxLat), lng: toDegrees(maxLng)} // Northeast
		];
	};
	
	var getMidPoint = function(points) {
		var len = points.length, x = 0, y = 0, z = 0;
		var i, lat, lng;
		if (len < 1) {
			throw new Error('Points must not be empty');
		} else if (len == 1) {
			return points[0];
		}
		
		for (i = 0; i < len; i++) {
			lat = toRad(points[i].lat);
			lng = toRad(points[i].lng);
			x += Math.cos(lat) * Math.cos(lng);
			y += Math.cos(lat) * Math.sin(lng);
			z += Math.sin(lat);
		}
		x = x / len;
		y = y / len;
		z = z / len;
		lng = Math.atan2(y, x);
		lat = Math.atan2(z, Math.sqrt(x * x + y * y));
		
		return {lat: toDegrees(lat), lng: toDegrees(lng) };
	};
	
	module.exports = {
		getDistance : getDistance,
		getTotalDistance : getTotalDistance,
		getBoundingBox : getBoundingBox,
		getMidPoint : getMidPoint
	};


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	var data2xml = __webpack_require__(270);
	var data2xmlConvert = data2xml();
	var gpx = __webpack_require__(271);
	
	var toGPX = function(trackingResult, callback, name) {
		var i, len, trkpts = [], started;
		var name = name || 'Untitled';
		len = trackingResult.points.length
	
		if(len > 0) {
			started = trackingResult.points[0].time.toISOString();
		} else {
			started = new Date().toISOString()
		}
	
		for( i = 0; i < len; i++) {
			trkpts.push({
				ele : trackingResult.points[i].ele,
				time : trackingResult.points[i].time.toISOString(),
				_attr : {
					lat : trackingResult.points[i].lat,
					lon : trackingResult.points[i].lng
				}
			});
		}
	
		var obj = {
			trk : {
				name : name,
				time : started,
				trkseg : {
					trkpt : trkpts
				}
			},
			_attr : {
				'version' : '1.1',
				'creator' : 'gps-util - https://github.com/vanng822/gps-util',
				'xmlns:xsi' : 'http://www.w3.org/2001/XMLSchema-instance',
				'xmlns' : 'http://www.topografix.com/GPX/1/1',
				'xsi:schemaLocation' : 'http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd',
				'xmlns:gpxtpx' : 'http://www.garmin.com/xmlschemas/TrackPointExtension/v1'
			}
		};
		try {
			result = data2xmlConvert('gpx', obj);
		} catch(e) {
			return callback(e, null);
		}
		callback(null, result);
	};
	var toTCX = function(trackingResult, callback, name) {
		var name = name || 'Untitled';
		throw new Error('Implement!');
	};
	
	var generateKml = function(coordinates, altitudeMode, lookAt) {
		var obj = {
			'Document' : {
				Style : {
					'LineStyle' : {
						'color' : 'C81400FF',
						'width' : 4
					},
					_attr : {
						'id' : 'red'
					}
				},
				'Folder' : {
					'Placemark' : {
						'styleUrl' : '#red',
						'LineString' : {
							'altitudeMode' : altitudeMode,
							'coordinates' : coordinates.join("\n")
						}
					}
				},
				'LookAt' : lookAt
			},
			_attr : {
				'xmlns' : 'http://www.opengis.net/kml/2.2',
				'xmlns:gx' : 'http://www.google.com/kml/ext/2.2',
				'xmlns:kml' : 'http://www.opengis.net/kml/2.2',
				'xmlns:atom' : 'http://www.w3.org/2005/Atom'
			}
		}
		return data2xmlConvert('kml', obj);
	};
	
	var toKml = function(points, callback) {
		var altitudeMode = 'clampToGround';
		var coordinates = [];
		var i, len, lookAt = {};
		len = points.length
		for( i = 0; i < len; i++) {
			coordinates.push(points[i].lng +',' + points[i].lat + ','+ points[i].ele);
		}
		if(len) {
			lookAt.longitude = points[0].lng;
			lookAt.latitude = points[0].lat;
			lookAt.altitude = 0;
			lookAt.heading = 0;
		}
		
	
		try {
			result = generateKml(coordinates, altitudeMode, lookAt);
		} catch(e) {
			return callback(e, null);
		}
		callback(null, result);
	};
	
	
	module.exports = {
		toGPX : toGPX,
		toKml : toKml
	};


/***/ },
/* 270 */
/***/ function(module, exports) {

	// --------------------------------------------------------------------------------------------------------------------
	//
	// data2xml.js - A data to XML converter with a nice interface (for NodeJS).
	//
	// Copyright (c) 2011 Andrew Chilton - http://chilts.org/
	// Written by Andrew Chilton <andychilton@gmail.com>
	//
	// License: http://opensource.org/licenses/MIT
	//
	// --------------------------------------------------------------------------------------------------------------------
	
	var valid = {
	    'omit'   : true, // no element is output       : ''
	    'empty'  : true, // an empty element is output : '<element></element>'
	    'closed' : true  // a closed element is output : '<element/>'
	};
	
	var defaults = {
	    'attrProp'  : '_attr',
	    'valProp'   : '_value',
	    'undefined' : 'omit',
	    'null'      : 'omit',
	    'xmlDecl'   : true
	};
	
	var xmlHeader = '<?xml version="1.0" encoding="utf-8"?>\n';
	
	module.exports = function(opts) {
	    opts = opts || {};
	
	    opts.attrProp = opts.attrProp || defaults.attrProp;
	    opts.valProp  = opts.valProp  || defaults.valProp;
	
	    if (typeof opts.xmlDecl === 'undefined') {
	        opts.xmlDecl = defaults.xmlDecl;
	    }
	
	    if ( opts['undefined'] && valid[opts['undefined']] ) {
	        // nothing, this is fine
	    }
	    else {
	        opts['undefined'] = defaults['undefined'];
	    }
	    if ( opts['null'] && valid[opts['null']] ) {
	        // nothing, this is fine
	    }
	    else {
	        opts['null'] = defaults['null'];
	    }
	
	    return function(name, data) {
	        var xml = opts.xmlDecl ? xmlHeader : '';
	        xml += makeElement(name, data, opts);
	        return xml;
	    };
	};
	
	function entitify(str) {
	    str = '' + str;
	    str = str
	        .replace(/&/g, '&amp;')
	        .replace(/</g,'&lt;')
	        .replace(/>/g,'&gt;')
	        .replace(/'/g, '&apos;')
	        .replace(/"/g, '&quot;');
	    return str;
	}
	
	function makeStartTag(name, attr) {
	    attr = attr || {};
	    var tag = '<' + name;
	    for(var a in attr) {
	        tag += ' ' + a + '="' + entitify(attr[a]) + '"';
	    }
	    tag += '>';
	    return tag;
	}
	
	function makeEndTag(name) {
	    return '</' + name + '>';
	}
	
	function makeElement(name, data, opts) {
	    var element = '';
	    if ( Array.isArray(data) ) {
	        data.forEach(function(v) {
	            element += makeElement(name, v, opts);
	        });
	        return element;
	    }
	    else if ( typeof data === 'undefined' ) {
	        if ( opts['undefined'] === 'omit' ) {
	            return '';
	        }
	        if ( opts['undefined'] === 'empty' ) {
	            return makeStartTag(name) + makeEndTag(name);
	        }
	        else if ( opts['undefined'] === 'closed' ) {
	            return '<' + name + '/>';
	        }
	    }
	    else if ( data === null ) {
	        if ( opts['null'] === 'omit' ) {
	            return '';
	        }
	        if ( opts['null'] === 'empty' ) {
	            return makeStartTag(name) + makeEndTag(name);
	        }
	        else if ( opts['null'] === 'closed' ) {
	            return '<' + name + '/>';
	        }
	    }
	    else if ( typeof data === 'object' ) {
	        element += makeStartTag(name, data[opts.attrProp]);
	        if ( data[opts.valProp] ) {
	            element += entitify(data[opts.valProp]);
	        }
	        for (var el in data) {
	            if ( el === opts.attrProp || el === opts.valProp ) {
	                continue;
	            }
	            element += makeElement(el, data[el], opts);
	        }
	        element += makeEndTag(name);
	        return element;
	    }
	    else {
	        // a piece of data on it's own can't have attributes
	        return makeStartTag(name) + entitify(data) + makeEndTag(name);
	    }
	    throw 'Unknown data ' + data;
	}
	
	// --------------------------------------------------------------------------------------------------------------------
	
	module.exports.makeStartTag = makeStartTag;
	module.exports.makeEndTag   = makeEndTag;
	module.exports.makeElement  = makeElement;
	module.exports.entitify     = entitify;
	
	// --------------------------------------------------------------------------------------------------------------------


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xml2js = __webpack_require__(272), parser = new xml2js.Parser();
	
	var http = __webpack_require__(313);
	var https = __webpack_require__(323);
	
	var ATTRIBUTE_NAME = '$';
	
	var Trackpoint = function() {
		this.lat = null;
		this.lng = null;
		this.ele = null;
		this.time = null;
		this.speed = undefined;
		this.distance = undefined;
	};
	var getTrk = function(trks) {
		var returnTrks = [], trkpts, trkpt, trk;
		var i, len, j, jlen;
		if(!( trks instanceof Array)) {
			trks = [trks];
		}
		for( i = 0, len = trks.length; i < len; i++) {
			trkpts = trks[i].trkseg[0].trkpt;
			for( j = 0, jlen = trkpts.length; j < jlen; j++) {
				trkpt = trkpts[j];
				if(trkpt.hasOwnProperty(ATTRIBUTE_NAME) && trkpt[ATTRIBUTE_NAME].hasOwnProperty('lat') && trkpt.hasOwnProperty('time')) {
					trk = new Trackpoint();
					trk.lat = parseFloat(trkpt[ATTRIBUTE_NAME].lat);
					trk.lng = parseFloat(trkpt[ATTRIBUTE_NAME].lon);
					trk.time = new Date(trkpt.time);
	
					if(trkpt.hasOwnProperty('ele')) {
						trk.ele = parseFloat(trkpt.ele);
					}
	
					returnTrks.push(trk);
				}
			}
		}
	
		return returnTrks;
	};
	var gpxParse = function(data, callback) {
		parser.parseString(data, function(err, result) {
			if(err) {
				return callback(err, null);
			}
			if(result.gpx && result.gpx.trk) {
				return callback(null, getTrk(result.gpx.trk));
			} else {
				return callback(new Error('Unexpected data'), null);
			}
		});
	};
	var gpxParseFile = function(filename, callback) {
	    fs.readFile(filename, function(err, result) {
			if(err) {
				return callback(err, null);
			}
			return gpxParse(result, callback);
		});
	};
	var gpxParseURL = function(url, callback, secure) {
		var h = secure? https : http;
		h.get(url, function(res) {
			var data = '';
			res.on('data', function(chunk) {
				data += chunk;
			});
			res.on('end', function() {
				if(res.statusCode == 200) {
					return gpxParse(new Buffer(data), callback);
				} else {
					return callback(new Error('Got unexpected response code'), null);
				}
			});
		}).on('error', function(err) {
			return callback(err, null);
		});
	};
	
	module.exports = {
		gpxParse : gpxParse,
		gpxParseFile : gpxParseFile,
		gpxParseURL : gpxParseURL
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144).Buffer))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.6.3
	(function() {
	  var bom, builder, events, isEmpty, sax,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  sax = __webpack_require__(273);
	
	  events = __webpack_require__(275);
	
	  builder = __webpack_require__(290);
	
	  bom = __webpack_require__(312);
	
	  isEmpty = function(thing) {
	    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
	  };
	
	  exports.defaults = {
	    "0.1": {
	      explicitCharkey: false,
	      trim: true,
	      normalize: true,
	      normalizeTags: false,
	      attrkey: "@",
	      charkey: "#",
	      explicitArray: false,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: false,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      childkey: '@@',
	      charsAsChildren: false,
	      async: false,
	      strict: true
	    },
	    "0.2": {
	      explicitCharkey: false,
	      trim: false,
	      normalize: false,
	      normalizeTags: false,
	      attrkey: "$",
	      charkey: "_",
	      explicitArray: true,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: true,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      childkey: '$$',
	      charsAsChildren: false,
	      async: false,
	      strict: true,
	      rootName: 'root',
	      xmldec: {
	        'version': '1.0',
	        'encoding': 'UTF-8',
	        'standalone': true
	      },
	      doctype: null,
	      renderOpts: {
	        'pretty': true,
	        'indent': '  ',
	        'newline': '\n'
	      }
	    }
	  };
	
	  exports.ValidationError = (function(_super) {
	    __extends(ValidationError, _super);
	
	    function ValidationError(message) {
	      this.message = message;
	    }
	
	    return ValidationError;
	
	  })(Error);
	
	  exports.Builder = (function() {
	    function Builder(opts) {
	      var key, value, _ref;
	      this.options = {};
	      _ref = exports.defaults["0.2"];
	      for (key in _ref) {
	        if (!__hasProp.call(_ref, key)) continue;
	        value = _ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!__hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	    }
	
	    Builder.prototype.buildObject = function(rootObj) {
	      var attrkey, charkey, render, rootElement, rootName;
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
	        rootName = Object.keys(rootObj)[0];
	        rootObj = rootObj[rootName];
	      } else {
	        rootName = this.options.rootName;
	      }
	      render = function(element, obj) {
	        var attr, child, entry, index, key, value, _ref, _ref1;
	        if (typeof obj !== 'object') {
	          element.txt(obj);
	        } else {
	          for (key in obj) {
	            if (!__hasProp.call(obj, key)) continue;
	            child = obj[key];
	            if (key === attrkey) {
	              if (typeof child === "object") {
	                for (attr in child) {
	                  value = child[attr];
	                  element = element.att(attr, value);
	                }
	              }
	            } else if (key === charkey) {
	              element = element.txt(child);
	            } else if (typeof child === 'object' && ((child != null ? child.constructor : void 0) != null) && ((child != null ? (_ref = child.constructor) != null ? _ref.name : void 0 : void 0) != null) && (child != null ? (_ref1 = child.constructor) != null ? _ref1.name : void 0 : void 0) === 'Array') {
	              for (index in child) {
	                if (!__hasProp.call(child, index)) continue;
	                entry = child[index];
	                if (typeof entry === 'string') {
	                  element = element.ele(key, entry).up();
	                } else {
	                  element = arguments.callee(element.ele(key), entry).up();
	                }
	              }
	            } else if (typeof child === "object") {
	              element = arguments.callee(element.ele(key), child).up();
	            } else {
	              element = element.ele(key, child.toString()).up();
	            }
	          }
	        }
	        return element;
	      };
	      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype);
	      return render(rootElement, rootObj).end(this.options.renderOpts);
	    };
	
	    return Builder;
	
	  })();
	
	  exports.Parser = (function(_super) {
	    __extends(Parser, _super);
	
	    function Parser(opts) {
	      this.parseString = __bind(this.parseString, this);
	      this.reset = __bind(this.reset, this);
	      this.assignOrPush = __bind(this.assignOrPush, this);
	      var key, value, _ref;
	      if (!(this instanceof exports.Parser)) {
	        return new exports.Parser(opts);
	      }
	      this.options = {};
	      _ref = exports.defaults["0.2"];
	      for (key in _ref) {
	        if (!__hasProp.call(_ref, key)) continue;
	        value = _ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!__hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	      if (this.options.xmlns) {
	        this.options.xmlnskey = this.options.attrkey + "ns";
	      }
	      this.reset();
	    }
	
	    Parser.prototype.assignOrPush = function(obj, key, newValue) {
	      if (!(key in obj)) {
	        if (!this.options.explicitArray) {
	          return obj[key] = newValue;
	        } else {
	          return obj[key] = [newValue];
	        }
	      } else {
	        if (!(obj[key] instanceof Array)) {
	          obj[key] = [obj[key]];
	        }
	        return obj[key].push(newValue);
	      }
	    };
	
	    Parser.prototype.reset = function() {
	      var attrkey, charkey, err, ontext, stack,
	        _this = this;
	      this.removeAllListeners();
	      this.saxParser = sax.parser(this.options.strict, {
	        trim: false,
	        normalize: false,
	        xmlns: this.options.xmlns
	      });
	      err = false;
	      this.saxParser.onerror = function(error) {
	        if (!err) {
	          err = true;
	          return _this.emit("error", error);
	        }
	      };
	      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
	      this.resultObject = null;
	      stack = [];
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      this.saxParser.onopentag = function(node) {
	        var key, newValue, obj, _ref;
	        obj = {};
	        obj[charkey] = "";
	        if (!_this.options.ignoreAttrs) {
	          _ref = node.attributes;
	          for (key in _ref) {
	            if (!__hasProp.call(_ref, key)) continue;
	            if (!(attrkey in obj) && !_this.options.mergeAttrs) {
	              obj[attrkey] = {};
	            }
	            newValue = node.attributes[key];
	            if (_this.options.mergeAttrs) {
	              _this.assignOrPush(obj, key, newValue);
	            } else {
	              obj[attrkey][key] = newValue;
	            }
	          }
	        }
	        obj["#name"] = _this.options.normalizeTags ? node.name.toLowerCase() : node.name;
	        if (_this.options.xmlns) {
	          obj[_this.options.xmlnskey] = {
	            uri: node.uri,
	            local: node.local
	          };
	        }
	        return stack.push(obj);
	      };
	      this.saxParser.onclosetag = function() {
	        var cdata, emptyStr, node, nodeName, obj, old, s, xpath;
	        obj = stack.pop();
	        nodeName = obj["#name"];
	        delete obj["#name"];
	        cdata = obj.cdata;
	        delete obj.cdata;
	        s = stack[stack.length - 1];
	        if (obj[charkey].match(/^\s*$/) && !cdata) {
	          emptyStr = obj[charkey];
	          delete obj[charkey];
	        } else {
	          if (_this.options.trim) {
	            obj[charkey] = obj[charkey].trim();
	          }
	          if (_this.options.normalize) {
	            obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
	          }
	          if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	            obj = obj[charkey];
	          }
	        }
	        if (isEmpty(obj)) {
	          obj = _this.options.emptyTag !== void 0 ? _this.options.emptyTag : emptyStr;
	        }
	        if (_this.options.validator != null) {
	          xpath = "/" + ((function() {
	            var _i, _len, _results;
	            _results = [];
	            for (_i = 0, _len = stack.length; _i < _len; _i++) {
	              node = stack[_i];
	              _results.push(node["#name"]);
	            }
	            return _results;
	          })()).concat(nodeName).join("/");
	          try {
	            obj = _this.options.validator(xpath, s && s[nodeName], obj);
	          } catch (_error) {
	            err = _error;
	            _this.emit("error", err);
	          }
	        }
	        if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
	          node = {};
	          if (_this.options.attrkey in obj) {
	            node[_this.options.attrkey] = obj[_this.options.attrkey];
	            delete obj[_this.options.attrkey];
	          }
	          if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
	            node[_this.options.charkey] = obj[_this.options.charkey];
	            delete obj[_this.options.charkey];
	          }
	          if (Object.getOwnPropertyNames(obj).length > 0) {
	            node[_this.options.childkey] = obj;
	          }
	          obj = node;
	        }
	        if (stack.length > 0) {
	          return _this.assignOrPush(s, nodeName, obj);
	        } else {
	          if (_this.options.explicitRoot) {
	            old = obj;
	            obj = {};
	            obj[nodeName] = old;
	          }
	          _this.resultObject = obj;
	          return _this.emit("end", _this.resultObject);
	        }
	      };
	      ontext = function(text) {
	        var s;
	        s = stack[stack.length - 1];
	        if (s) {
	          s[charkey] += text;
	          return s;
	        }
	      };
	      this.saxParser.ontext = ontext;
	      return this.saxParser.oncdata = function(text) {
	        var s;
	        s = ontext(text);
	        if (s) {
	          return s.cdata = true;
	        }
	      };
	    };
	
	    Parser.prototype.parseString = function(str, cb) {
	      if ((cb != null) && typeof cb === "function") {
	        this.on("end", function(result) {
	          this.reset();
	          if (this.options.async) {
	            return process.nextTick(function() {
	              return cb(null, result);
	            });
	          } else {
	            return cb(null, result);
	          }
	        });
	        this.on("error", function(err) {
	          this.reset();
	          if (this.options.async) {
	            return process.nextTick(function() {
	              return cb(err);
	            });
	          } else {
	            return cb(err);
	          }
	        });
	      }
	      if (str.toString().trim() === '') {
	        this.emit("end", null);
	        return true;
	      }
	      return this.saxParser.write(bom.stripBOM(str.toString()));
	    };
	
	    return Parser;
	
	  })(events.EventEmitter);
	
	  exports.parseString = function(str, a, b) {
	    var cb, options, parser;
	    if (b != null) {
	      if (typeof b === 'function') {
	        cb = b;
	      }
	      if (typeof a === 'object') {
	        options = a;
	      }
	    } else {
	      if (typeof a === 'function') {
	        cb = a;
	      }
	      options = {};
	    }
	    parser = new exports.Parser(options);
	    return parser.parseString(str, cb);
	  };
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// wrapper for non-node envs
	;(function (sax) {
	
	sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
	sax.SAXParser = SAXParser
	sax.SAXStream = SAXStream
	sax.createStream = createStream
	
	// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
	// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
	// since that's the earliest that a buffer overrun could occur.  This way, checks are
	// as rare as required, but as often as necessary to ensure never crossing this bound.
	// Furthermore, buffers are only tested at most once per write(), so passing a very
	// large string into write() might have undesirable effects, but this is manageable by
	// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
	// edge case, result in creating at most one complete copy of the string passed in.
	// Set to Infinity to have unlimited buffers.
	sax.MAX_BUFFER_LENGTH = 64 * 1024
	
	var buffers = [
	  "comment", "sgmlDecl", "textNode", "tagName", "doctype",
	  "procInstName", "procInstBody", "entity", "attribName",
	  "attribValue", "cdata", "script"
	]
	
	sax.EVENTS = // for discoverability.
	  [ "text"
	  , "processinginstruction"
	  , "sgmldeclaration"
	  , "doctype"
	  , "comment"
	  , "attribute"
	  , "opentag"
	  , "closetag"
	  , "opencdata"
	  , "cdata"
	  , "closecdata"
	  , "error"
	  , "end"
	  , "ready"
	  , "script"
	  , "opennamespace"
	  , "closenamespace"
	  ]
	
	function SAXParser (strict, opt) {
	  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)
	
	  var parser = this
	  clearBuffers(parser)
	  parser.q = parser.c = ""
	  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
	  parser.opt = opt || {}
	  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
	  parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
	  parser.tags = []
	  parser.closed = parser.closedRoot = parser.sawRoot = false
	  parser.tag = parser.error = null
	  parser.strict = !!strict
	  parser.noscript = !!(strict || parser.opt.noscript)
	  parser.state = S.BEGIN
	  parser.ENTITIES = Object.create(sax.ENTITIES)
	  parser.attribList = []
	
	  // namespaces form a prototype chain.
	  // it always points at the current tag,
	  // which protos to its parent tag.
	  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)
	
	  // mostly just for error reporting
	  parser.trackPosition = parser.opt.position !== false
	  if (parser.trackPosition) {
	    parser.position = parser.line = parser.column = 0
	  }
	  emit(parser, "onready")
	}
	
	if (!Object.create) Object.create = function (o) {
	  function f () { this.__proto__ = o }
	  f.prototype = o
	  return new f
	}
	
	if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
	  return o.__proto__
	}
	
	if (!Object.keys) Object.keys = function (o) {
	  var a = []
	  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
	  return a
	}
	
	function checkBufferLength (parser) {
	  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
	    , maxActual = 0
	  for (var i = 0, l = buffers.length; i < l; i ++) {
	    var len = parser[buffers[i]].length
	    if (len > maxAllowed) {
	      // Text/cdata nodes can get big, and since they're buffered,
	      // we can get here under normal conditions.
	      // Avoid issues by emitting the text node now,
	      // so at least it won't get any bigger.
	      switch (buffers[i]) {
	        case "textNode":
	          closeText(parser)
	        break
	
	        case "cdata":
	          emitNode(parser, "oncdata", parser.cdata)
	          parser.cdata = ""
	        break
	
	        case "script":
	          emitNode(parser, "onscript", parser.script)
	          parser.script = ""
	        break
	
	        default:
	          error(parser, "Max buffer length exceeded: "+buffers[i])
	      }
	    }
	    maxActual = Math.max(maxActual, len)
	  }
	  // schedule the next check for the earliest possible buffer overrun.
	  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
	                             + parser.position
	}
	
	function clearBuffers (parser) {
	  for (var i = 0, l = buffers.length; i < l; i ++) {
	    parser[buffers[i]] = ""
	  }
	}
	
	function flushBuffers (parser) {
	  closeText(parser)
	  if (parser.cdata !== "") {
	    emitNode(parser, "oncdata", parser.cdata)
	    parser.cdata = ""
	  }
	  if (parser.script !== "") {
	    emitNode(parser, "onscript", parser.script)
	    parser.script = ""
	  }
	}
	
	SAXParser.prototype =
	  { end: function () { end(this) }
	  , write: write
	  , resume: function () { this.error = null; return this }
	  , close: function () { return this.write(null) }
	  , flush: function () { flushBuffers(this) }
	  }
	
	try {
	  var Stream = __webpack_require__(274).Stream
	} catch (ex) {
	  var Stream = function () {}
	}
	
	
	var streamWraps = sax.EVENTS.filter(function (ev) {
	  return ev !== "error" && ev !== "end"
	})
	
	function createStream (strict, opt) {
	  return new SAXStream(strict, opt)
	}
	
	function SAXStream (strict, opt) {
	  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)
	
	  Stream.apply(this)
	
	  this._parser = new SAXParser(strict, opt)
	  this.writable = true
	  this.readable = true
	
	
	  var me = this
	
	  this._parser.onend = function () {
	    me.emit("end")
	  }
	
	  this._parser.onerror = function (er) {
	    me.emit("error", er)
	
	    // if didn't throw, then means error was handled.
	    // go ahead and clear error, so we can write again.
	    me._parser.error = null
	  }
	
	  this._decoder = null;
	
	  streamWraps.forEach(function (ev) {
	    Object.defineProperty(me, "on" + ev, {
	      get: function () { return me._parser["on" + ev] },
	      set: function (h) {
	        if (!h) {
	          me.removeAllListeners(ev)
	          return me._parser["on"+ev] = h
	        }
	        me.on(ev, h)
	      },
	      enumerable: true,
	      configurable: false
	    })
	  })
	}
	
	SAXStream.prototype = Object.create(Stream.prototype,
	  { constructor: { value: SAXStream } })
	
	SAXStream.prototype.write = function (data) {
	  if (typeof Buffer === 'function' &&
	      typeof Buffer.isBuffer === 'function' &&
	      Buffer.isBuffer(data)) {
	    if (!this._decoder) {
	      var SD = __webpack_require__(283).StringDecoder
	      this._decoder = new SD('utf8')
	    }
	    data = this._decoder.write(data);
	  }
	
	  this._parser.write(data.toString())
	  this.emit("data", data)
	  return true
	}
	
	SAXStream.prototype.end = function (chunk) {
	  if (chunk && chunk.length) this.write(chunk)
	  this._parser.end()
	  return true
	}
	
	SAXStream.prototype.on = function (ev, handler) {
	  var me = this
	  if (!me._parser["on"+ev] && streamWraps.indexOf(ev) !== -1) {
	    me._parser["on"+ev] = function () {
	      var args = arguments.length === 1 ? [arguments[0]]
	               : Array.apply(null, arguments)
	      args.splice(0, 0, ev)
	      me.emit.apply(me, args)
	    }
	  }
	
	  return Stream.prototype.on.call(me, ev, handler)
	}
	
	
	
	// character classes and tokens
	var whitespace = "\r\n\t "
	  // this really needs to be replaced with character classes.
	  // XML allows all manner of ridiculous numbers and digits.
	  , number = "0124356789"
	  , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	  // (Letter | "_" | ":")
	  , quote = "'\""
	  , entity = number+letter+"#"
	  , attribEnd = whitespace + ">"
	  , CDATA = "[CDATA["
	  , DOCTYPE = "DOCTYPE"
	  , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
	  , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
	  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }
	
	// turn all the string character sets into character class objects.
	whitespace = charClass(whitespace)
	number = charClass(number)
	letter = charClass(letter)
	
	// http://www.w3.org/TR/REC-xml/#NT-NameStartChar
	// This implementation works on strings, a single character at a time
	// as such, it cannot ever support astral-plane characters (10000-EFFFF)
	// without a significant breaking change to either this  parser, or the
	// JavaScript language.  Implementation of an emoji-capable xml parser
	// is left as an exercise for the reader.
	var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
	
	var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/
	
	quote = charClass(quote)
	entity = charClass(entity)
	attribEnd = charClass(attribEnd)
	
	function charClass (str) {
	  return str.split("").reduce(function (s, c) {
	    s[c] = true
	    return s
	  }, {})
	}
	
	function isRegExp (c) {
	  return Object.prototype.toString.call(c) === '[object RegExp]'
	}
	
	function is (charclass, c) {
	  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
	}
	
	function not (charclass, c) {
	  return !is(charclass, c)
	}
	
	var S = 0
	sax.STATE =
	{ BEGIN                     : S++
	, TEXT                      : S++ // general stuff
	, TEXT_ENTITY               : S++ // &amp and such.
	, OPEN_WAKA                 : S++ // <
	, SGML_DECL                 : S++ // <!BLARG
	, SGML_DECL_QUOTED          : S++ // <!BLARG foo "bar
	, DOCTYPE                   : S++ // <!DOCTYPE
	, DOCTYPE_QUOTED            : S++ // <!DOCTYPE "//blah
	, DOCTYPE_DTD               : S++ // <!DOCTYPE "//blah" [ ...
	, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE "//blah" [ "foo
	, COMMENT_STARTING          : S++ // <!-
	, COMMENT                   : S++ // <!--
	, COMMENT_ENDING            : S++ // <!-- blah -
	, COMMENT_ENDED             : S++ // <!-- blah --
	, CDATA                     : S++ // <![CDATA[ something
	, CDATA_ENDING              : S++ // ]
	, CDATA_ENDING_2            : S++ // ]]
	, PROC_INST                 : S++ // <?hi
	, PROC_INST_BODY            : S++ // <?hi there
	, PROC_INST_ENDING          : S++ // <?hi "there" ?
	, OPEN_TAG                  : S++ // <strong
	, OPEN_TAG_SLASH            : S++ // <strong /
	, ATTRIB                    : S++ // <a
	, ATTRIB_NAME               : S++ // <a foo
	, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _
	, ATTRIB_VALUE              : S++ // <a foo=
	, ATTRIB_VALUE_QUOTED       : S++ // <a foo="bar
	, ATTRIB_VALUE_CLOSED       : S++ // <a foo="bar"
	, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar
	, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar="&quot;"
	, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;
	, CLOSE_TAG                 : S++ // </a
	, CLOSE_TAG_SAW_WHITE       : S++ // </a   >
	, SCRIPT                    : S++ // <script> ...
	, SCRIPT_ENDING             : S++ // <script> ... <
	}
	
	sax.ENTITIES =
	{ "amp" : "&"
	, "gt" : ">"
	, "lt" : "<"
	, "quot" : "\""
	, "apos" : "'"
	, "AElig" : 198
	, "Aacute" : 193
	, "Acirc" : 194
	, "Agrave" : 192
	, "Aring" : 197
	, "Atilde" : 195
	, "Auml" : 196
	, "Ccedil" : 199
	, "ETH" : 208
	, "Eacute" : 201
	, "Ecirc" : 202
	, "Egrave" : 200
	, "Euml" : 203
	, "Iacute" : 205
	, "Icirc" : 206
	, "Igrave" : 204
	, "Iuml" : 207
	, "Ntilde" : 209
	, "Oacute" : 211
	, "Ocirc" : 212
	, "Ograve" : 210
	, "Oslash" : 216
	, "Otilde" : 213
	, "Ouml" : 214
	, "THORN" : 222
	, "Uacute" : 218
	, "Ucirc" : 219
	, "Ugrave" : 217
	, "Uuml" : 220
	, "Yacute" : 221
	, "aacute" : 225
	, "acirc" : 226
	, "aelig" : 230
	, "agrave" : 224
	, "aring" : 229
	, "atilde" : 227
	, "auml" : 228
	, "ccedil" : 231
	, "eacute" : 233
	, "ecirc" : 234
	, "egrave" : 232
	, "eth" : 240
	, "euml" : 235
	, "iacute" : 237
	, "icirc" : 238
	, "igrave" : 236
	, "iuml" : 239
	, "ntilde" : 241
	, "oacute" : 243
	, "ocirc" : 244
	, "ograve" : 242
	, "oslash" : 248
	, "otilde" : 245
	, "ouml" : 246
	, "szlig" : 223
	, "thorn" : 254
	, "uacute" : 250
	, "ucirc" : 251
	, "ugrave" : 249
	, "uuml" : 252
	, "yacute" : 253
	, "yuml" : 255
	, "copy" : 169
	, "reg" : 174
	, "nbsp" : 160
	, "iexcl" : 161
	, "cent" : 162
	, "pound" : 163
	, "curren" : 164
	, "yen" : 165
	, "brvbar" : 166
	, "sect" : 167
	, "uml" : 168
	, "ordf" : 170
	, "laquo" : 171
	, "not" : 172
	, "shy" : 173
	, "macr" : 175
	, "deg" : 176
	, "plusmn" : 177
	, "sup1" : 185
	, "sup2" : 178
	, "sup3" : 179
	, "acute" : 180
	, "micro" : 181
	, "para" : 182
	, "middot" : 183
	, "cedil" : 184
	, "ordm" : 186
	, "raquo" : 187
	, "frac14" : 188
	, "frac12" : 189
	, "frac34" : 190
	, "iquest" : 191
	, "times" : 215
	, "divide" : 247
	, "OElig" : 338
	, "oelig" : 339
	, "Scaron" : 352
	, "scaron" : 353
	, "Yuml" : 376
	, "fnof" : 402
	, "circ" : 710
	, "tilde" : 732
	, "Alpha" : 913
	, "Beta" : 914
	, "Gamma" : 915
	, "Delta" : 916
	, "Epsilon" : 917
	, "Zeta" : 918
	, "Eta" : 919
	, "Theta" : 920
	, "Iota" : 921
	, "Kappa" : 922
	, "Lambda" : 923
	, "Mu" : 924
	, "Nu" : 925
	, "Xi" : 926
	, "Omicron" : 927
	, "Pi" : 928
	, "Rho" : 929
	, "Sigma" : 931
	, "Tau" : 932
	, "Upsilon" : 933
	, "Phi" : 934
	, "Chi" : 935
	, "Psi" : 936
	, "Omega" : 937
	, "alpha" : 945
	, "beta" : 946
	, "gamma" : 947
	, "delta" : 948
	, "epsilon" : 949
	, "zeta" : 950
	, "eta" : 951
	, "theta" : 952
	, "iota" : 953
	, "kappa" : 954
	, "lambda" : 955
	, "mu" : 956
	, "nu" : 957
	, "xi" : 958
	, "omicron" : 959
	, "pi" : 960
	, "rho" : 961
	, "sigmaf" : 962
	, "sigma" : 963
	, "tau" : 964
	, "upsilon" : 965
	, "phi" : 966
	, "chi" : 967
	, "psi" : 968
	, "omega" : 969
	, "thetasym" : 977
	, "upsih" : 978
	, "piv" : 982
	, "ensp" : 8194
	, "emsp" : 8195
	, "thinsp" : 8201
	, "zwnj" : 8204
	, "zwj" : 8205
	, "lrm" : 8206
	, "rlm" : 8207
	, "ndash" : 8211
	, "mdash" : 8212
	, "lsquo" : 8216
	, "rsquo" : 8217
	, "sbquo" : 8218
	, "ldquo" : 8220
	, "rdquo" : 8221
	, "bdquo" : 8222
	, "dagger" : 8224
	, "Dagger" : 8225
	, "bull" : 8226
	, "hellip" : 8230
	, "permil" : 8240
	, "prime" : 8242
	, "Prime" : 8243
	, "lsaquo" : 8249
	, "rsaquo" : 8250
	, "oline" : 8254
	, "frasl" : 8260
	, "euro" : 8364
	, "image" : 8465
	, "weierp" : 8472
	, "real" : 8476
	, "trade" : 8482
	, "alefsym" : 8501
	, "larr" : 8592
	, "uarr" : 8593
	, "rarr" : 8594
	, "darr" : 8595
	, "harr" : 8596
	, "crarr" : 8629
	, "lArr" : 8656
	, "uArr" : 8657
	, "rArr" : 8658
	, "dArr" : 8659
	, "hArr" : 8660
	, "forall" : 8704
	, "part" : 8706
	, "exist" : 8707
	, "empty" : 8709
	, "nabla" : 8711
	, "isin" : 8712
	, "notin" : 8713
	, "ni" : 8715
	, "prod" : 8719
	, "sum" : 8721
	, "minus" : 8722
	, "lowast" : 8727
	, "radic" : 8730
	, "prop" : 8733
	, "infin" : 8734
	, "ang" : 8736
	, "and" : 8743
	, "or" : 8744
	, "cap" : 8745
	, "cup" : 8746
	, "int" : 8747
	, "there4" : 8756
	, "sim" : 8764
	, "cong" : 8773
	, "asymp" : 8776
	, "ne" : 8800
	, "equiv" : 8801
	, "le" : 8804
	, "ge" : 8805
	, "sub" : 8834
	, "sup" : 8835
	, "nsub" : 8836
	, "sube" : 8838
	, "supe" : 8839
	, "oplus" : 8853
	, "otimes" : 8855
	, "perp" : 8869
	, "sdot" : 8901
	, "lceil" : 8968
	, "rceil" : 8969
	, "lfloor" : 8970
	, "rfloor" : 8971
	, "lang" : 9001
	, "rang" : 9002
	, "loz" : 9674
	, "spades" : 9824
	, "clubs" : 9827
	, "hearts" : 9829
	, "diams" : 9830
	}
	
	Object.keys(sax.ENTITIES).forEach(function (key) {
	    var e = sax.ENTITIES[key]
	    var s = typeof e === 'number' ? String.fromCharCode(e) : e
	    sax.ENTITIES[key] = s
	})
	
	for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S
	
	// shorthand
	S = sax.STATE
	
	function emit (parser, event, data) {
	  parser[event] && parser[event](data)
	}
	
	function emitNode (parser, nodeType, data) {
	  if (parser.textNode) closeText(parser)
	  emit(parser, nodeType, data)
	}
	
	function closeText (parser) {
	  parser.textNode = textopts(parser.opt, parser.textNode)
	  if (parser.textNode) emit(parser, "ontext", parser.textNode)
	  parser.textNode = ""
	}
	
	function textopts (opt, text) {
	  if (opt.trim) text = text.trim()
	  if (opt.normalize) text = text.replace(/\s+/g, " ")
	  return text
	}
	
	function error (parser, er) {
	  closeText(parser)
	  if (parser.trackPosition) {
	    er += "\nLine: "+parser.line+
	          "\nColumn: "+parser.column+
	          "\nChar: "+parser.c
	  }
	  er = new Error(er)
	  parser.error = er
	  emit(parser, "onerror", er)
	  return parser
	}
	
	function end (parser) {
	  if (!parser.closedRoot) strictFail(parser, "Unclosed root tag")
	  if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, "Unexpected end")
	  closeText(parser)
	  parser.c = ""
	  parser.closed = true
	  emit(parser, "onend")
	  SAXParser.call(parser, parser.strict, parser.opt)
	  return parser
	}
	
	function strictFail (parser, message) {
	  if (typeof parser !== 'object' || !(parser instanceof SAXParser))
	    throw new Error('bad call to strictFail');
	  if (parser.strict) error(parser, message)
	}
	
	function newTag (parser) {
	  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
	  var parent = parser.tags[parser.tags.length - 1] || parser
	    , tag = parser.tag = { name : parser.tagName, attributes : {} }
	
	  // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
	  if (parser.opt.xmlns) tag.ns = parent.ns
	  parser.attribList.length = 0
	}
	
	function qname (name, attribute) {
	  var i = name.indexOf(":")
	    , qualName = i < 0 ? [ "", name ] : name.split(":")
	    , prefix = qualName[0]
	    , local = qualName[1]
	
	  // <x "xmlns"="http://foo">
	  if (attribute && name === "xmlns") {
	    prefix = "xmlns"
	    local = ""
	  }
	
	  return { prefix: prefix, local: local }
	}
	
	function attrib (parser) {
	  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()
	
	  if (parser.attribList.indexOf(parser.attribName) !== -1 ||
	      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
	    return parser.attribName = parser.attribValue = ""
	  }
	
	  if (parser.opt.xmlns) {
	    var qn = qname(parser.attribName, true)
	      , prefix = qn.prefix
	      , local = qn.local
	
	    if (prefix === "xmlns") {
	      // namespace binding attribute; push the binding into scope
	      if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
	        strictFail( parser
	                  , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
	                  + "Actual: " + parser.attribValue )
	      } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
	        strictFail( parser
	                  , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
	                  + "Actual: " + parser.attribValue )
	      } else {
	        var tag = parser.tag
	          , parent = parser.tags[parser.tags.length - 1] || parser
	        if (tag.ns === parent.ns) {
	          tag.ns = Object.create(parent.ns)
	        }
	        tag.ns[local] = parser.attribValue
	      }
	    }
	
	    // defer onattribute events until all attributes have been seen
	    // so any new bindings can take effect; preserve attribute order
	    // so deferred events can be emitted in document order
	    parser.attribList.push([parser.attribName, parser.attribValue])
	  } else {
	    // in non-xmlns mode, we can emit the event right away
	    parser.tag.attributes[parser.attribName] = parser.attribValue
	    emitNode( parser
	            , "onattribute"
	            , { name: parser.attribName
	              , value: parser.attribValue } )
	  }
	
	  parser.attribName = parser.attribValue = ""
	}
	
	function openTag (parser, selfClosing) {
	  if (parser.opt.xmlns) {
	    // emit namespace binding events
	    var tag = parser.tag
	
	    // add namespace info to tag
	    var qn = qname(parser.tagName)
	    tag.prefix = qn.prefix
	    tag.local = qn.local
	    tag.uri = tag.ns[qn.prefix] || ""
	
	    if (tag.prefix && !tag.uri) {
	      strictFail(parser, "Unbound namespace prefix: "
	                       + JSON.stringify(parser.tagName))
	      tag.uri = qn.prefix
	    }
	
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    if (tag.ns && parent.ns !== tag.ns) {
	      Object.keys(tag.ns).forEach(function (p) {
	        emitNode( parser
	                , "onopennamespace"
	                , { prefix: p , uri: tag.ns[p] } )
	      })
	    }
	
	    // handle deferred onattribute events
	    // Note: do not apply default ns to attributes:
	    //   http://www.w3.org/TR/REC-xml-names/#defaulting
	    for (var i = 0, l = parser.attribList.length; i < l; i ++) {
	      var nv = parser.attribList[i]
	      var name = nv[0]
	        , value = nv[1]
	        , qualName = qname(name, true)
	        , prefix = qualName.prefix
	        , local = qualName.local
	        , uri = prefix == "" ? "" : (tag.ns[prefix] || "")
	        , a = { name: name
	              , value: value
	              , prefix: prefix
	              , local: local
	              , uri: uri
	              }
	
	      // if there's any attributes with an undefined namespace,
	      // then fail on them now.
	      if (prefix && prefix != "xmlns" && !uri) {
	        strictFail(parser, "Unbound namespace prefix: "
	                         + JSON.stringify(prefix))
	        a.uri = prefix
	      }
	      parser.tag.attributes[name] = a
	      emitNode(parser, "onattribute", a)
	    }
	    parser.attribList.length = 0
	  }
	
	  parser.tag.isSelfClosing = !!selfClosing
	
	  // process the tag
	  parser.sawRoot = true
	  parser.tags.push(parser.tag)
	  emitNode(parser, "onopentag", parser.tag)
	  if (!selfClosing) {
	    // special case for <script> in non-strict mode.
	    if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
	      parser.state = S.SCRIPT
	    } else {
	      parser.state = S.TEXT
	    }
	    parser.tag = null
	    parser.tagName = ""
	  }
	  parser.attribName = parser.attribValue = ""
	  parser.attribList.length = 0
	}
	
	function closeTag (parser) {
	  if (!parser.tagName) {
	    strictFail(parser, "Weird empty close tag.")
	    parser.textNode += "</>"
	    parser.state = S.TEXT
	    return
	  }
	
	  if (parser.script) {
	    if (parser.tagName !== "script") {
	      parser.script += "</" + parser.tagName + ">"
	      parser.tagName = ""
	      parser.state = S.SCRIPT
	      return
	    }
	    emitNode(parser, "onscript", parser.script)
	    parser.script = ""
	  }
	
	  // first make sure that the closing tag actually exists.
	  // <a><b></c></b></a> will close everything, otherwise.
	  var t = parser.tags.length
	  var tagName = parser.tagName
	  if (!parser.strict) tagName = tagName[parser.looseCase]()
	  var closeTo = tagName
	  while (t --) {
	    var close = parser.tags[t]
	    if (close.name !== closeTo) {
	      // fail the first time in strict mode
	      strictFail(parser, "Unexpected close tag")
	    } else break
	  }
	
	  // didn't find it.  we already failed for strict, so just abort.
	  if (t < 0) {
	    strictFail(parser, "Unmatched closing tag: "+parser.tagName)
	    parser.textNode += "</" + parser.tagName + ">"
	    parser.state = S.TEXT
	    return
	  }
	  parser.tagName = tagName
	  var s = parser.tags.length
	  while (s --> t) {
	    var tag = parser.tag = parser.tags.pop()
	    parser.tagName = parser.tag.name
	    emitNode(parser, "onclosetag", parser.tagName)
	
	    var x = {}
	    for (var i in tag.ns) x[i] = tag.ns[i]
	
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    if (parser.opt.xmlns && tag.ns !== parent.ns) {
	      // remove namespace bindings introduced by tag
	      Object.keys(tag.ns).forEach(function (p) {
	        var n = tag.ns[p]
	        emitNode(parser, "onclosenamespace", { prefix: p, uri: n })
	      })
	    }
	  }
	  if (t === 0) parser.closedRoot = true
	  parser.tagName = parser.attribValue = parser.attribName = ""
	  parser.attribList.length = 0
	  parser.state = S.TEXT
	}
	
	function parseEntity (parser) {
	  var entity = parser.entity
	    , entityLC = entity.toLowerCase()
	    , num
	    , numStr = ""
	  if (parser.ENTITIES[entity])
	    return parser.ENTITIES[entity]
	  if (parser.ENTITIES[entityLC])
	    return parser.ENTITIES[entityLC]
	  entity = entityLC
	  if (entity.charAt(0) === "#") {
	    if (entity.charAt(1) === "x") {
	      entity = entity.slice(2)
	      num = parseInt(entity, 16)
	      numStr = num.toString(16)
	    } else {
	      entity = entity.slice(1)
	      num = parseInt(entity, 10)
	      numStr = num.toString(10)
	    }
	  }
	  entity = entity.replace(/^0+/, "")
	  if (numStr.toLowerCase() !== entity) {
	    strictFail(parser, "Invalid character entity")
	    return "&"+parser.entity + ";"
	  }
	  return String.fromCharCode(num)
	}
	
	function write (chunk) {
	  var parser = this
	  if (this.error) throw this.error
	  if (parser.closed) return error(parser,
	    "Cannot write after close. Assign an onready handler.")
	  if (chunk === null) return end(parser)
	  var i = 0, c = ""
	  while (parser.c = c = chunk.charAt(i++)) {
	    if (parser.trackPosition) {
	      parser.position ++
	      if (c === "\n") {
	        parser.line ++
	        parser.column = 0
	      } else parser.column ++
	    }
	    switch (parser.state) {
	
	      case S.BEGIN:
	        if (c === "<") {
	          parser.state = S.OPEN_WAKA
	          parser.startTagPosition = parser.position
	        } else if (not(whitespace,c)) {
	          // have to process this as a text node.
	          // weird, but happens.
	          strictFail(parser, "Non-whitespace before first tag.")
	          parser.textNode = c
	          parser.state = S.TEXT
	        }
	      continue
	
	      case S.TEXT:
	        if (parser.sawRoot && !parser.closedRoot) {
	          var starti = i-1
	          while (c && c!=="<" && c!=="&") {
	            c = chunk.charAt(i++)
	            if (c && parser.trackPosition) {
	              parser.position ++
	              if (c === "\n") {
	                parser.line ++
	                parser.column = 0
	              } else parser.column ++
	            }
	          }
	          parser.textNode += chunk.substring(starti, i-1)
	        }
	        if (c === "<") {
	          parser.state = S.OPEN_WAKA
	          parser.startTagPosition = parser.position
	        } else {
	          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
	            strictFail(parser, "Text data outside of root node.")
	          if (c === "&") parser.state = S.TEXT_ENTITY
	          else parser.textNode += c
	        }
	      continue
	
	      case S.SCRIPT:
	        // only non-strict
	        if (c === "<") {
	          parser.state = S.SCRIPT_ENDING
	        } else parser.script += c
	      continue
	
	      case S.SCRIPT_ENDING:
	        if (c === "/") {
	          parser.state = S.CLOSE_TAG
	        } else {
	          parser.script += "<" + c
	          parser.state = S.SCRIPT
	        }
	      continue
	
	      case S.OPEN_WAKA:
	        // either a /, ?, !, or text is coming next.
	        if (c === "!") {
	          parser.state = S.SGML_DECL
	          parser.sgmlDecl = ""
	        } else if (is(whitespace, c)) {
	          // wait for it...
	        } else if (is(nameStart,c)) {
	          parser.state = S.OPEN_TAG
	          parser.tagName = c
	        } else if (c === "/") {
	          parser.state = S.CLOSE_TAG
	          parser.tagName = ""
	        } else if (c === "?") {
	          parser.state = S.PROC_INST
	          parser.procInstName = parser.procInstBody = ""
	        } else {
	          strictFail(parser, "Unencoded <")
	          // if there was some whitespace, then add that in.
	          if (parser.startTagPosition + 1 < parser.position) {
	            var pad = parser.position - parser.startTagPosition
	            c = new Array(pad).join(" ") + c
	          }
	          parser.textNode += "<" + c
	          parser.state = S.TEXT
	        }
	      continue
	
	      case S.SGML_DECL:
	        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {
	          emitNode(parser, "onopencdata")
	          parser.state = S.CDATA
	          parser.sgmlDecl = ""
	          parser.cdata = ""
	        } else if (parser.sgmlDecl+c === "--") {
	          parser.state = S.COMMENT
	          parser.comment = ""
	          parser.sgmlDecl = ""
	        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {
	          parser.state = S.DOCTYPE
	          if (parser.doctype || parser.sawRoot) strictFail(parser,
	            "Inappropriately located doctype declaration")
	          parser.doctype = ""
	          parser.sgmlDecl = ""
	        } else if (c === ">") {
	          emitNode(parser, "onsgmldeclaration", parser.sgmlDecl)
	          parser.sgmlDecl = ""
	          parser.state = S.TEXT
	        } else if (is(quote, c)) {
	          parser.state = S.SGML_DECL_QUOTED
	          parser.sgmlDecl += c
	        } else parser.sgmlDecl += c
	      continue
	
	      case S.SGML_DECL_QUOTED:
	        if (c === parser.q) {
	          parser.state = S.SGML_DECL
	          parser.q = ""
	        }
	        parser.sgmlDecl += c
	      continue
	
	      case S.DOCTYPE:
	        if (c === ">") {
	          parser.state = S.TEXT
	          emitNode(parser, "ondoctype", parser.doctype)
	          parser.doctype = true // just remember that we saw it.
	        } else {
	          parser.doctype += c
	          if (c === "[") parser.state = S.DOCTYPE_DTD
	          else if (is(quote, c)) {
	            parser.state = S.DOCTYPE_QUOTED
	            parser.q = c
	          }
	        }
	      continue
	
	      case S.DOCTYPE_QUOTED:
	        parser.doctype += c
	        if (c === parser.q) {
	          parser.q = ""
	          parser.state = S.DOCTYPE
	        }
	      continue
	
	      case S.DOCTYPE_DTD:
	        parser.doctype += c
	        if (c === "]") parser.state = S.DOCTYPE
	        else if (is(quote,c)) {
	          parser.state = S.DOCTYPE_DTD_QUOTED
	          parser.q = c
	        }
	      continue
	
	      case S.DOCTYPE_DTD_QUOTED:
	        parser.doctype += c
	        if (c === parser.q) {
	          parser.state = S.DOCTYPE_DTD
	          parser.q = ""
	        }
	      continue
	
	      case S.COMMENT:
	        if (c === "-") parser.state = S.COMMENT_ENDING
	        else parser.comment += c
	      continue
	
	      case S.COMMENT_ENDING:
	        if (c === "-") {
	          parser.state = S.COMMENT_ENDED
	          parser.comment = textopts(parser.opt, parser.comment)
	          if (parser.comment) emitNode(parser, "oncomment", parser.comment)
	          parser.comment = ""
	        } else {
	          parser.comment += "-" + c
	          parser.state = S.COMMENT
	        }
	      continue
	
	      case S.COMMENT_ENDED:
	        if (c !== ">") {
	          strictFail(parser, "Malformed comment")
	          // allow <!-- blah -- bloo --> in non-strict mode,
	          // which is a comment of " blah -- bloo "
	          parser.comment += "--" + c
	          parser.state = S.COMMENT
	        } else parser.state = S.TEXT
	      continue
	
	      case S.CDATA:
	        if (c === "]") parser.state = S.CDATA_ENDING
	        else parser.cdata += c
	      continue
	
	      case S.CDATA_ENDING:
	        if (c === "]") parser.state = S.CDATA_ENDING_2
	        else {
	          parser.cdata += "]" + c
	          parser.state = S.CDATA
	        }
	      continue
	
	      case S.CDATA_ENDING_2:
	        if (c === ">") {
	          if (parser.cdata) emitNode(parser, "oncdata", parser.cdata)
	          emitNode(parser, "onclosecdata")
	          parser.cdata = ""
	          parser.state = S.TEXT
	        } else if (c === "]") {
	          parser.cdata += "]"
	        } else {
	          parser.cdata += "]]" + c
	          parser.state = S.CDATA
	        }
	      continue
	
	      case S.PROC_INST:
	        if (c === "?") parser.state = S.PROC_INST_ENDING
	        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
	        else parser.procInstName += c
	      continue
	
	      case S.PROC_INST_BODY:
	        if (!parser.procInstBody && is(whitespace, c)) continue
	        else if (c === "?") parser.state = S.PROC_INST_ENDING
	        else parser.procInstBody += c
	      continue
	
	      case S.PROC_INST_ENDING:
	        if (c === ">") {
	          emitNode(parser, "onprocessinginstruction", {
	            name : parser.procInstName,
	            body : parser.procInstBody
	          })
	          parser.procInstName = parser.procInstBody = ""
	          parser.state = S.TEXT
	        } else {
	          parser.procInstBody += "?" + c
	          parser.state = S.PROC_INST_BODY
	        }
	      continue
	
	      case S.OPEN_TAG:
	        if (is(nameBody, c)) parser.tagName += c
	        else {
	          newTag(parser)
	          if (c === ">") openTag(parser)
	          else if (c === "/") parser.state = S.OPEN_TAG_SLASH
	          else {
	            if (not(whitespace, c)) strictFail(
	              parser, "Invalid character in tag name")
	            parser.state = S.ATTRIB
	          }
	        }
	      continue
	
	      case S.OPEN_TAG_SLASH:
	        if (c === ">") {
	          openTag(parser, true)
	          closeTag(parser)
	        } else {
	          strictFail(parser, "Forward-slash in opening tag not followed by >")
	          parser.state = S.ATTRIB
	        }
	      continue
	
	      case S.ATTRIB:
	        // haven't read the attribute name yet.
	        if (is(whitespace, c)) continue
	        else if (c === ">") openTag(parser)
	        else if (c === "/") parser.state = S.OPEN_TAG_SLASH
	        else if (is(nameStart, c)) {
	          parser.attribName = c
	          parser.attribValue = ""
	          parser.state = S.ATTRIB_NAME
	        } else strictFail(parser, "Invalid attribute name")
	      continue
	
	      case S.ATTRIB_NAME:
	        if (c === "=") parser.state = S.ATTRIB_VALUE
	        else if (c === ">") {
	          strictFail(parser, "Attribute without value")
	          parser.attribValue = parser.attribName
	          attrib(parser)
	          openTag(parser)
	        }
	        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
	        else if (is(nameBody, c)) parser.attribName += c
	        else strictFail(parser, "Invalid attribute name")
	      continue
	
	      case S.ATTRIB_NAME_SAW_WHITE:
	        if (c === "=") parser.state = S.ATTRIB_VALUE
	        else if (is(whitespace, c)) continue
	        else {
	          strictFail(parser, "Attribute without value")
	          parser.tag.attributes[parser.attribName] = ""
	          parser.attribValue = ""
	          emitNode(parser, "onattribute",
	                   { name : parser.attribName, value : "" })
	          parser.attribName = ""
	          if (c === ">") openTag(parser)
	          else if (is(nameStart, c)) {
	            parser.attribName = c
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, "Invalid attribute name")
	            parser.state = S.ATTRIB
	          }
	        }
	      continue
	
	      case S.ATTRIB_VALUE:
	        if (is(whitespace, c)) continue
	        else if (is(quote, c)) {
	          parser.q = c
	          parser.state = S.ATTRIB_VALUE_QUOTED
	        } else {
	          strictFail(parser, "Unquoted attribute value")
	          parser.state = S.ATTRIB_VALUE_UNQUOTED
	          parser.attribValue = c
	        }
	      continue
	
	      case S.ATTRIB_VALUE_QUOTED:
	        if (c !== parser.q) {
	          if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q
	          else parser.attribValue += c
	          continue
	        }
	        attrib(parser)
	        parser.q = ""
	        parser.state = S.ATTRIB_VALUE_CLOSED
	      continue
	
	      case S.ATTRIB_VALUE_CLOSED:
	        if (is(whitespace, c)) {
	          parser.state = S.ATTRIB
	        } else if (c === ">") openTag(parser)
	        else if (c === "/") parser.state = S.OPEN_TAG_SLASH
	        else if (is(nameStart, c)) {
	          strictFail(parser, "No whitespace between attributes")
	          parser.attribName = c
	          parser.attribValue = ""
	          parser.state = S.ATTRIB_NAME
	        } else strictFail(parser, "Invalid attribute name")
	      continue
	
	      case S.ATTRIB_VALUE_UNQUOTED:
	        if (not(attribEnd,c)) {
	          if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U
	          else parser.attribValue += c
	          continue
	        }
	        attrib(parser)
	        if (c === ">") openTag(parser)
	        else parser.state = S.ATTRIB
	      continue
	
	      case S.CLOSE_TAG:
	        if (!parser.tagName) {
	          if (is(whitespace, c)) continue
	          else if (not(nameStart, c)) {
	            if (parser.script) {
	              parser.script += "</" + c
	              parser.state = S.SCRIPT
	            } else {
	              strictFail(parser, "Invalid tagname in closing tag.")
	            }
	          } else parser.tagName = c
	        }
	        else if (c === ">") closeTag(parser)
	        else if (is(nameBody, c)) parser.tagName += c
	        else if (parser.script) {
	          parser.script += "</" + parser.tagName
	          parser.tagName = ""
	          parser.state = S.SCRIPT
	        } else {
	          if (not(whitespace, c)) strictFail(parser,
	            "Invalid tagname in closing tag")
	          parser.state = S.CLOSE_TAG_SAW_WHITE
	        }
	      continue
	
	      case S.CLOSE_TAG_SAW_WHITE:
	        if (is(whitespace, c)) continue
	        if (c === ">") closeTag(parser)
	        else strictFail(parser, "Invalid characters in closing tag")
	      continue
	
	      case S.TEXT_ENTITY:
	      case S.ATTRIB_VALUE_ENTITY_Q:
	      case S.ATTRIB_VALUE_ENTITY_U:
	        switch(parser.state) {
	          case S.TEXT_ENTITY:
	            var returnState = S.TEXT, buffer = "textNode"
	          break
	
	          case S.ATTRIB_VALUE_ENTITY_Q:
	            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
	          break
	
	          case S.ATTRIB_VALUE_ENTITY_U:
	            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
	          break
	        }
	        if (c === ";") {
	          parser[buffer] += parseEntity(parser)
	          parser.entity = ""
	          parser.state = returnState
	        }
	        else if (is(entity, c)) parser.entity += c
	        else {
	          strictFail(parser, "Invalid character entity")
	          parser[buffer] += "&" + parser.entity + c
	          parser.entity = ""
	          parser.state = returnState
	        }
	      continue
	
	      default:
	        throw new Error(parser, "Unknown state: " + parser.state)
	    }
	  } // while
	  // cdata blocks can get very big under normal conditions. emit and move on.
	  // if (parser.state === S.CDATA && parser.cdata) {
	  //   emitNode(parser, "oncdata", parser.cdata)
	  //   parser.cdata = ""
	  // }
	  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)
	  return parser
	}
	
	})( false ? sax = {} : exports)
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144).Buffer))

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(275).EventEmitter;
	var inherits = __webpack_require__(107);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(276);
	Stream.Writable = __webpack_require__(286);
	Stream.Duplex = __webpack_require__(287);
	Stream.Transform = __webpack_require__(288);
	Stream.PassThrough = __webpack_require__(289);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(277);
	exports.Stream = __webpack_require__(274);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(282);
	exports.Duplex = __webpack_require__(281);
	exports.Transform = __webpack_require__(284);
	exports.PassThrough = __webpack_require__(285);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(274);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(278);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(144).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(275).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(274);
	
	/*<replacement>*/
	var util = __webpack_require__(279);
	util.inherits = __webpack_require__(107);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(280);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(281);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(283).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(281);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(283).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 278 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144).Buffer))

/***/ },
/* 280 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(279);
	util.inherits = __webpack_require__(107);
	/*</replacement>*/
	
	var Readable = __webpack_require__(277);
	var Writable = __webpack_require__(282);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(144).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(279);
	util.inherits = __webpack_require__(107);
	/*</replacement>*/
	
	var Stream = __webpack_require__(274);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(281);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(281);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(144).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(281);
	
	/*<replacement>*/
	var util = __webpack_require__(279);
	util.inherits = __webpack_require__(107);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(284);
	
	/*<replacement>*/
	var util = __webpack_require__(279);
	util.inherits = __webpack_require__(107);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(282)


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281)


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(284)


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(285)


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
	
	  ref = __webpack_require__(291), assign = ref.assign, isFunction = ref.isFunction;
	
	  XMLDocument = __webpack_require__(292);
	
	  XMLDocumentCB = __webpack_require__(310);
	
	  XMLStringWriter = __webpack_require__(308);
	
	  XMLStreamWriter = __webpack_require__(311);
	
	  module.exports.create = function(name, xmldec, doctype, options) {
	    var doc, root;
	    if (name == null) {
	      throw new Error("Root element needs a name");
	    }
	    options = assign({}, xmldec, doctype, options);
	    doc = new XMLDocument(options);
	    root = doc.element(name);
	    if (!options.headless) {
	      doc.declaration(options);
	      if ((options.pubID != null) || (options.sysID != null)) {
	        doc.doctype(options);
	      }
	    }
	    return root;
	  };
	
	  module.exports.begin = function(options, onData, onEnd) {
	    var ref1;
	    if (isFunction(options)) {
	      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
	      options = {};
	    }
	    if (onData) {
	      return new XMLDocumentCB(options, onData, onEnd);
	    } else {
	      return new XMLDocument(options);
	    }
	  };
	
	  module.exports.stringWriter = function(options) {
	    return new XMLStringWriter(options);
	  };
	
	  module.exports.streamWriter = function(stream, options) {
	    return new XMLStreamWriter(stream, options);
	  };
	
	}).call(this);


/***/ },
/* 291 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var assign, camelCase, capitalize, isArray, isEmpty, isFunction, isObject, isPlainObject, kebabCase, snakeCase, titleCase, words,
	    slice = [].slice,
	    hasProp = {}.hasOwnProperty;
	
	  assign = function() {
	    var i, key, len, source, sources, target;
	    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (isFunction(Object.assign)) {
	      Object.assign.apply(null, arguments);
	    } else {
	      for (i = 0, len = sources.length; i < len; i++) {
	        source = sources[i];
	        if (source != null) {
	          for (key in source) {
	            if (!hasProp.call(source, key)) continue;
	            target[key] = source[key];
	          }
	        }
	      }
	    }
	    return target;
	  };
	
	  isFunction = function(val) {
	    return !!val && Object.prototype.toString.call(val) === '[object Function]';
	  };
	
	  isObject = function(val) {
	    var ref;
	    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
	  };
	
	  isArray = function(val) {
	    if (isFunction(Array.isArray)) {
	      return Array.isArray(val);
	    } else {
	      return Object.prototype.toString.call(val) === '[object Array]';
	    }
	  };
	
	  isEmpty = function(val) {
	    var key;
	    if (isArray(val)) {
	      return !val.length;
	    } else {
	      for (key in val) {
	        if (!hasProp.call(val, key)) continue;
	        return false;
	      }
	      return true;
	    }
	  };
	
	  isPlainObject = function(val) {
	    var ctor, proto;
	    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
	  };
	
	  words = function(val) {
	    return (val.split(/[-_\s]+|(?=[A-Z][a-z])/) || []).filter(function(n) {
	      return !!n;
	    });
	  };
	
	  camelCase = function(val) {
	    var i, index, len, r, ref, word;
	    r = '';
	    ref = words(val);
	    for (index = i = 0, len = ref.length; i < len; index = ++i) {
	      word = ref[index];
	      r += index ? capitalize(word.toLowerCase()) : word.toLowerCase();
	    }
	    return r;
	  };
	
	  titleCase = function(val) {
	    var i, index, len, r, ref, word;
	    r = '';
	    ref = words(val);
	    for (index = i = 0, len = ref.length; i < len; index = ++i) {
	      word = ref[index];
	      r += capitalize(word.toLowerCase());
	    }
	    return r;
	  };
	
	  kebabCase = function(val) {
	    var i, index, len, r, ref, word;
	    r = '';
	    ref = words(val);
	    for (index = i = 0, len = ref.length; i < len; index = ++i) {
	      word = ref[index];
	      r += (index ? '-' : '') + word.toLowerCase();
	    }
	    return r;
	  };
	
	  snakeCase = function(val) {
	    var i, index, len, r, ref, word;
	    r = '';
	    ref = words(val);
	    for (index = i = 0, len = ref.length; i < len; index = ++i) {
	      word = ref[index];
	      r += (index ? '_' : '') + word.toLowerCase();
	    }
	    return r;
	  };
	
	  capitalize = function(val) {
	    return val.charAt(0).toUpperCase() + val.slice(1);
	  };
	
	  module.exports.assign = assign;
	
	  module.exports.isFunction = isFunction;
	
	  module.exports.isObject = isObject;
	
	  module.exports.isArray = isArray;
	
	  module.exports.isEmpty = isEmpty;
	
	  module.exports.isPlainObject = isPlainObject;
	
	  module.exports.camelCase = camelCase;
	
	  module.exports.titleCase = titleCase;
	
	  module.exports.kebabCase = kebabCase;
	
	  module.exports.snakeCase = snakeCase;
	
	  module.exports.capitalize = capitalize;
	
	  module.exports.words = words;
	
	}).call(this);


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  isPlainObject = __webpack_require__(291).isPlainObject;
	
	  XMLNode = __webpack_require__(293);
	
	  XMLStringifier = __webpack_require__(307);
	
	  XMLStringWriter = __webpack_require__(308);
	
	  module.exports = XMLDocument = (function(superClass) {
	    extend(XMLDocument, superClass);
	
	    function XMLDocument(options) {
	      XMLDocument.__super__.constructor.call(this, null);
	      options || (options = {});
	      if (!options.writer) {
	        options.writer = new XMLStringWriter();
	      }
	      this.options = options;
	      this.stringify = new XMLStringifier(options);
	      this.isDocument = true;
	    }
	
	    XMLDocument.prototype.end = function(writer) {
	      var writerOptions;
	      if (!writer) {
	        writer = this.options.writer;
	      } else if (isPlainObject(writer)) {
	        writerOptions = writer;
	        writer = this.options.writer.set(writerOptions);
	      }
	      return writer.document(this);
	    };
	
	    XMLDocument.prototype.toString = function(options) {
	      return this.options.writer.set(options).document(this);
	    };
	
	    return XMLDocument;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,
	    hasProp = {}.hasOwnProperty;
	
	  ref = __webpack_require__(291), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;
	
	  XMLElement = null;
	
	  XMLCData = null;
	
	  XMLComment = null;
	
	  XMLDeclaration = null;
	
	  XMLDocType = null;
	
	  XMLRaw = null;
	
	  XMLText = null;
	
	  XMLProcessingInstruction = null;
	
	  module.exports = XMLNode = (function() {
	    function XMLNode(parent) {
	      this.parent = parent;
	      if (this.parent) {
	        this.options = this.parent.options;
	        this.stringify = this.parent.stringify;
	      }
	      this.children = [];
	      if (!XMLElement) {
	        XMLElement = __webpack_require__(294);
	        XMLCData = __webpack_require__(296);
	        XMLComment = __webpack_require__(297);
	        XMLDeclaration = __webpack_require__(298);
	        XMLDocType = __webpack_require__(299);
	        XMLRaw = __webpack_require__(304);
	        XMLText = __webpack_require__(305);
	        XMLProcessingInstruction = __webpack_require__(306);
	      }
	    }
	
	    XMLNode.prototype.element = function(name, attributes, text) {
	      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
	      lastChild = null;
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
	      }
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (Array.isArray(name)) {
	        for (j = 0, len = name.length; j < len; j++) {
	          item = name[j];
	          lastChild = this.element(item);
	        }
	      } else if (isFunction(name)) {
	        lastChild = this.element(name.apply());
	      } else if (isObject(name)) {
	        for (key in name) {
	          if (!hasProp.call(name, key)) continue;
	          val = name[key];
	          if (isFunction(val)) {
	            val = val.apply();
	          }
	          if ((isObject(val)) && (isEmpty(val))) {
	            val = null;
	          }
	          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
	            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
	          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
	            for (k = 0, len1 = val.length; k < len1; k++) {
	              item = val[k];
	              childNode = {};
	              childNode[key] = item;
	              lastChild = this.element(childNode);
	            }
	          } else if (isObject(val)) {
	            lastChild = this.element(key);
	            lastChild.element(val);
	          } else {
	            lastChild = this.element(key, val);
	          }
	        }
	      } else {
	        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
	          lastChild = this.text(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
	          lastChild = this.cdata(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
	          lastChild = this.comment(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
	          lastChild = this.raw(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
	          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
	        } else {
	          lastChild = this.node(name, attributes, text);
	        }
	      }
	      if (lastChild == null) {
	        throw new Error("Could not create any elements with: " + name);
	      }
	      return lastChild;
	    };
	
	    XMLNode.prototype.insertBefore = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };
	
	    XMLNode.prototype.insertAfter = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };
	
	    XMLNode.prototype.remove = function() {
	      var i, ref1;
	      if (this.isRoot) {
	        throw new Error("Cannot remove the root element");
	      }
	      i = this.parent.children.indexOf(this);
	      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
	      return this.parent;
	    };
	
	    XMLNode.prototype.node = function(name, attributes, text) {
	      var child, ref1;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      attributes || (attributes = {});
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
	      }
	      child = new XMLElement(this, name, attributes);
	      if (text != null) {
	        child.text(text);
	      }
	      this.children.push(child);
	      return child;
	    };
	
	    XMLNode.prototype.text = function(value) {
	      var child;
	      child = new XMLText(this, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLNode.prototype.cdata = function(value) {
	      var child;
	      child = new XMLCData(this, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLNode.prototype.comment = function(value) {
	      var child;
	      child = new XMLComment(this, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLNode.prototype.commentBefore = function(value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.comment(value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };
	
	    XMLNode.prototype.commentAfter = function(value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.comment(value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };
	
	    XMLNode.prototype.raw = function(value) {
	      var child;
	      child = new XMLRaw(this, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLNode.prototype.instruction = function(target, value) {
	      var insTarget, insValue, instruction, j, len;
	      if (target != null) {
	        target = target.valueOf();
	      }
	      if (value != null) {
	        value = value.valueOf();
	      }
	      if (Array.isArray(target)) {
	        for (j = 0, len = target.length; j < len; j++) {
	          insTarget = target[j];
	          this.instruction(insTarget);
	        }
	      } else if (isObject(target)) {
	        for (insTarget in target) {
	          if (!hasProp.call(target, insTarget)) continue;
	          insValue = target[insTarget];
	          this.instruction(insTarget, insValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        instruction = new XMLProcessingInstruction(this, target, value);
	        this.children.push(instruction);
	      }
	      return this;
	    };
	
	    XMLNode.prototype.instructionBefore = function(target, value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.instruction(target, value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };
	
	    XMLNode.prototype.instructionAfter = function(target, value) {
	      var child, i, removed;
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.instruction(target, value);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return this;
	    };
	
	    XMLNode.prototype.declaration = function(version, encoding, standalone) {
	      var doc, xmldec;
	      doc = this.document();
	      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
	      if (doc.children[0] instanceof XMLDeclaration) {
	        doc.children[0] = xmldec;
	      } else {
	        doc.children.unshift(xmldec);
	      }
	      return doc.root() || doc;
	    };
	
	    XMLNode.prototype.doctype = function(pubID, sysID) {
	      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
	      doc = this.document();
	      doctype = new XMLDocType(doc, pubID, sysID);
	      ref1 = doc.children;
	      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
	        child = ref1[i];
	        if (child instanceof XMLDocType) {
	          doc.children[i] = doctype;
	          return doctype;
	        }
	      }
	      ref2 = doc.children;
	      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
	        child = ref2[i];
	        if (child.isRoot) {
	          doc.children.splice(i, 0, doctype);
	          return doctype;
	        }
	      }
	      doc.children.push(doctype);
	      return doctype;
	    };
	
	    XMLNode.prototype.up = function() {
	      if (this.isRoot) {
	        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
	      }
	      return this.parent;
	    };
	
	    XMLNode.prototype.root = function() {
	      var node;
	      node = this;
	      while (node) {
	        if (node.isDocument) {
	          return node.rootObject;
	        } else if (node.isRoot) {
	          return node;
	        } else {
	          node = node.parent;
	        }
	      }
	    };
	
	    XMLNode.prototype.document = function() {
	      var node;
	      node = this;
	      while (node) {
	        if (node.isDocument) {
	          return node;
	        } else {
	          node = node.parent;
	        }
	      }
	    };
	
	    XMLNode.prototype.end = function(options) {
	      return this.document().end(options);
	    };
	
	    XMLNode.prototype.prev = function() {
	      var i;
	      i = this.parent.children.indexOf(this);
	      if (i < 1) {
	        throw new Error("Already at the first node");
	      }
	      return this.parent.children[i - 1];
	    };
	
	    XMLNode.prototype.next = function() {
	      var i;
	      i = this.parent.children.indexOf(this);
	      if (i === -1 || i === this.parent.children.length - 1) {
	        throw new Error("Already at the last node");
	      }
	      return this.parent.children[i + 1];
	    };
	
	    XMLNode.prototype.importDocument = function(doc) {
	      var clonedRoot;
	      clonedRoot = doc.root().clone();
	      clonedRoot.parent = this;
	      clonedRoot.isRoot = false;
	      this.children.push(clonedRoot);
	      return this;
	    };
	
	    XMLNode.prototype.ele = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };
	
	    XMLNode.prototype.nod = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };
	
	    XMLNode.prototype.txt = function(value) {
	      return this.text(value);
	    };
	
	    XMLNode.prototype.dat = function(value) {
	      return this.cdata(value);
	    };
	
	    XMLNode.prototype.com = function(value) {
	      return this.comment(value);
	    };
	
	    XMLNode.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };
	
	    XMLNode.prototype.doc = function() {
	      return this.document();
	    };
	
	    XMLNode.prototype.dec = function(version, encoding, standalone) {
	      return this.declaration(version, encoding, standalone);
	    };
	
	    XMLNode.prototype.dtd = function(pubID, sysID) {
	      return this.doctype(pubID, sysID);
	    };
	
	    XMLNode.prototype.e = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };
	
	    XMLNode.prototype.n = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };
	
	    XMLNode.prototype.t = function(value) {
	      return this.text(value);
	    };
	
	    XMLNode.prototype.d = function(value) {
	      return this.cdata(value);
	    };
	
	    XMLNode.prototype.c = function(value) {
	      return this.comment(value);
	    };
	
	    XMLNode.prototype.r = function(value) {
	      return this.raw(value);
	    };
	
	    XMLNode.prototype.i = function(target, value) {
	      return this.instruction(target, value);
	    };
	
	    XMLNode.prototype.u = function() {
	      return this.up();
	    };
	
	    XMLNode.prototype.importXMLBuilder = function(doc) {
	      return this.importDocument(doc);
	    };
	
	    return XMLNode;
	
	  })();
	
	}).call(this);


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  ref = __webpack_require__(291), isObject = ref.isObject, isFunction = ref.isFunction;
	
	  XMLNode = __webpack_require__(293);
	
	  XMLAttribute = __webpack_require__(295);
	
	  module.exports = XMLElement = (function(superClass) {
	    extend(XMLElement, superClass);
	
	    function XMLElement(parent, name, attributes) {
	      XMLElement.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing element name");
	      }
	      this.name = this.stringify.eleName(name);
	      this.attributes = {};
	      if (attributes != null) {
	        this.attribute(attributes);
	      }
	      if (parent.isDocument) {
	        this.isRoot = true;
	        this.documentObject = parent;
	        parent.rootObject = this;
	      }
	    }
	
	    XMLElement.prototype.clone = function() {
	      var att, attName, clonedSelf, ref1;
	      clonedSelf = Object.create(this);
	      if (clonedSelf.isRoot) {
	        clonedSelf.documentObject = null;
	      }
	      clonedSelf.attributes = {};
	      ref1 = this.attributes;
	      for (attName in ref1) {
	        if (!hasProp.call(ref1, attName)) continue;
	        att = ref1[attName];
	        clonedSelf.attributes[attName] = att.clone();
	      }
	      clonedSelf.children = [];
	      this.children.forEach(function(child) {
	        var clonedChild;
	        clonedChild = child.clone();
	        clonedChild.parent = clonedSelf;
	        return clonedSelf.children.push(clonedChild);
	      });
	      return clonedSelf;
	    };
	
	    XMLElement.prototype.attribute = function(name, value) {
	      var attName, attValue;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (isObject(name)) {
	        for (attName in name) {
	          if (!hasProp.call(name, attName)) continue;
	          attValue = name[attName];
	          this.attribute(attName, attValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        if (!this.options.skipNullAttributes || (value != null)) {
	          this.attributes[name] = new XMLAttribute(this, name, value);
	        }
	      }
	      return this;
	    };
	
	    XMLElement.prototype.removeAttribute = function(name) {
	      var attName, i, len;
	      if (name == null) {
	        throw new Error("Missing attribute name");
	      }
	      name = name.valueOf();
	      if (Array.isArray(name)) {
	        for (i = 0, len = name.length; i < len; i++) {
	          attName = name[i];
	          delete this.attributes[attName];
	        }
	      } else {
	        delete this.attributes[name];
	      }
	      return this;
	    };
	
	    XMLElement.prototype.toString = function(options) {
	      return this.options.writer.set(options).element(this);
	    };
	
	    XMLElement.prototype.att = function(name, value) {
	      return this.attribute(name, value);
	    };
	
	    XMLElement.prototype.a = function(name, value) {
	      return this.attribute(name, value);
	    };
	
	    return XMLElement;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 295 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLAttribute;
	
	  module.exports = XMLAttribute = (function() {
	    function XMLAttribute(parent, name, value) {
	      this.options = parent.options;
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing attribute name of element " + parent.name);
	      }
	      if (value == null) {
	        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
	      }
	      this.name = this.stringify.attName(name);
	      this.value = this.stringify.attValue(value);
	    }
	
	    XMLAttribute.prototype.clone = function() {
	      return Object.create(this);
	    };
	
	    XMLAttribute.prototype.toString = function(options) {
	      return this.options.writer.set(options).attribute(this);
	    };
	
	    return XMLAttribute;
	
	  })();
	
	}).call(this);


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLCData, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLCData = (function(superClass) {
	    extend(XMLCData, superClass);
	
	    function XMLCData(parent, text) {
	      XMLCData.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing CDATA text");
	      }
	      this.text = this.stringify.cdata(text);
	    }
	
	    XMLCData.prototype.clone = function() {
	      return Object.create(this);
	    };
	
	    XMLCData.prototype.toString = function(options) {
	      return this.options.writer.set(options).cdata(this);
	    };
	
	    return XMLCData;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLComment, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLComment = (function(superClass) {
	    extend(XMLComment, superClass);
	
	    function XMLComment(parent, text) {
	      XMLComment.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing comment text");
	      }
	      this.text = this.stringify.comment(text);
	    }
	
	    XMLComment.prototype.clone = function() {
	      return Object.create(this);
	    };
	
	    XMLComment.prototype.toString = function(options) {
	      return this.options.writer.set(options).comment(this);
	    };
	
	    return XMLComment;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDeclaration, XMLNode, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  isObject = __webpack_require__(291).isObject;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLDeclaration = (function(superClass) {
	    extend(XMLDeclaration, superClass);
	
	    function XMLDeclaration(parent, version, encoding, standalone) {
	      var ref;
	      XMLDeclaration.__super__.constructor.call(this, parent);
	      if (isObject(version)) {
	        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
	      }
	      if (!version) {
	        version = '1.0';
	      }
	      this.version = this.stringify.xmlVersion(version);
	      if (encoding != null) {
	        this.encoding = this.stringify.xmlEncoding(encoding);
	      }
	      if (standalone != null) {
	        this.standalone = this.stringify.xmlStandalone(standalone);
	      }
	    }
	
	    XMLDeclaration.prototype.toString = function(options) {
	      return this.options.writer.set(options).declaration(this);
	    };
	
	    return XMLDeclaration;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  isObject = __webpack_require__(291).isObject;
	
	  XMLNode = __webpack_require__(293);
	
	  XMLDTDAttList = __webpack_require__(300);
	
	  XMLDTDEntity = __webpack_require__(301);
	
	  XMLDTDElement = __webpack_require__(302);
	
	  XMLDTDNotation = __webpack_require__(303);
	
	  module.exports = XMLDocType = (function(superClass) {
	    extend(XMLDocType, superClass);
	
	    function XMLDocType(parent, pubID, sysID) {
	      var ref, ref1;
	      XMLDocType.__super__.constructor.call(this, parent);
	      this.documentObject = parent;
	      if (isObject(pubID)) {
	        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
	      }
	      if (sysID == null) {
	        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
	      }
	      if (pubID != null) {
	        this.pubID = this.stringify.dtdPubID(pubID);
	      }
	      if (sysID != null) {
	        this.sysID = this.stringify.dtdSysID(sysID);
	      }
	    }
	
	    XMLDocType.prototype.element = function(name, value) {
	      var child;
	      child = new XMLDTDElement(this, name, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      var child;
	      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLDocType.prototype.entity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, false, name, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLDocType.prototype.pEntity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, true, name, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLDocType.prototype.notation = function(name, value) {
	      var child;
	      child = new XMLDTDNotation(this, name, value);
	      this.children.push(child);
	      return this;
	    };
	
	    XMLDocType.prototype.toString = function(options) {
	      return this.options.writer.set(options).docType(this);
	    };
	
	    XMLDocType.prototype.ele = function(name, value) {
	      return this.element(name, value);
	    };
	
	    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
	    };
	
	    XMLDocType.prototype.ent = function(name, value) {
	      return this.entity(name, value);
	    };
	
	    XMLDocType.prototype.pent = function(name, value) {
	      return this.pEntity(name, value);
	    };
	
	    XMLDocType.prototype.not = function(name, value) {
	      return this.notation(name, value);
	    };
	
	    XMLDocType.prototype.up = function() {
	      return this.root() || this.documentObject;
	    };
	
	    return XMLDocType;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDTDAttList, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLDTDAttList = (function(superClass) {
	    extend(XMLDTDAttList, superClass);
	
	    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      XMLDTDAttList.__super__.constructor.call(this, parent);
	      if (elementName == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (attributeName == null) {
	        throw new Error("Missing DTD attribute name");
	      }
	      if (!attributeType) {
	        throw new Error("Missing DTD attribute type");
	      }
	      if (!defaultValueType) {
	        throw new Error("Missing DTD attribute default");
	      }
	      if (defaultValueType.indexOf('#') !== 0) {
	        defaultValueType = '#' + defaultValueType;
	      }
	      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
	        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
	      }
	      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
	        throw new Error("Default value only applies to #FIXED or #DEFAULT");
	      }
	      this.elementName = this.stringify.eleName(elementName);
	      this.attributeName = this.stringify.attName(attributeName);
	      this.attributeType = this.stringify.dtdAttType(attributeType);
	      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
	      this.defaultValueType = defaultValueType;
	    }
	
	    XMLDTDAttList.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdAttList(this);
	    };
	
	    return XMLDTDAttList;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDTDEntity, XMLNode, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  isObject = __webpack_require__(291).isObject;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLDTDEntity = (function(superClass) {
	    extend(XMLDTDEntity, superClass);
	
	    function XMLDTDEntity(parent, pe, name, value) {
	      XMLDTDEntity.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing entity name");
	      }
	      if (value == null) {
	        throw new Error("Missing entity value");
	      }
	      this.pe = !!pe;
	      this.name = this.stringify.eleName(name);
	      if (!isObject(value)) {
	        this.value = this.stringify.dtdEntityValue(value);
	      } else {
	        if (!value.pubID && !value.sysID) {
	          throw new Error("Public and/or system identifiers are required for an external entity");
	        }
	        if (value.pubID && !value.sysID) {
	          throw new Error("System identifier is required for a public external entity");
	        }
	        if (value.pubID != null) {
	          this.pubID = this.stringify.dtdPubID(value.pubID);
	        }
	        if (value.sysID != null) {
	          this.sysID = this.stringify.dtdSysID(value.sysID);
	        }
	        if (value.nData != null) {
	          this.nData = this.stringify.dtdNData(value.nData);
	        }
	        if (this.pe && this.nData) {
	          throw new Error("Notation declaration is not allowed in a parameter entity");
	        }
	      }
	    }
	
	    XMLDTDEntity.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdEntity(this);
	    };
	
	    return XMLDTDEntity;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDTDElement, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLDTDElement = (function(superClass) {
	    extend(XMLDTDElement, superClass);
	
	    function XMLDTDElement(parent, name, value) {
	      XMLDTDElement.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (!value) {
	        value = '(#PCDATA)';
	      }
	      if (Array.isArray(value)) {
	        value = '(' + value.join(',') + ')';
	      }
	      this.name = this.stringify.eleName(name);
	      this.value = this.stringify.dtdElementValue(value);
	    }
	
	    XMLDTDElement.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdElement(this);
	    };
	
	    return XMLDTDElement;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLDTDNotation, XMLNode,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLDTDNotation = (function(superClass) {
	    extend(XMLDTDNotation, superClass);
	
	    function XMLDTDNotation(parent, name, value) {
	      XMLDTDNotation.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing notation name");
	      }
	      if (!value.pubID && !value.sysID) {
	        throw new Error("Public or system identifiers are required for an external entity");
	      }
	      this.name = this.stringify.eleName(name);
	      if (value.pubID != null) {
	        this.pubID = this.stringify.dtdPubID(value.pubID);
	      }
	      if (value.sysID != null) {
	        this.sysID = this.stringify.dtdSysID(value.sysID);
	      }
	    }
	
	    XMLDTDNotation.prototype.toString = function(options) {
	      return this.options.writer.set(options).dtdNotation(this);
	    };
	
	    return XMLDTDNotation;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLNode, XMLRaw,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLRaw = (function(superClass) {
	    extend(XMLRaw, superClass);
	
	    function XMLRaw(parent, text) {
	      XMLRaw.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing raw text");
	      }
	      this.value = this.stringify.raw(text);
	    }
	
	    XMLRaw.prototype.clone = function() {
	      return Object.create(this);
	    };
	
	    XMLRaw.prototype.toString = function(options) {
	      return this.options.writer.set(options).raw(this);
	    };
	
	    return XMLRaw;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLNode, XMLText,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLText = (function(superClass) {
	    extend(XMLText, superClass);
	
	    function XMLText(parent, text) {
	      XMLText.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing element text");
	      }
	      this.value = this.stringify.eleText(text);
	    }
	
	    XMLText.prototype.clone = function() {
	      return Object.create(this);
	    };
	
	    XMLText.prototype.toString = function(options) {
	      return this.options.writer.set(options).text(this);
	    };
	
	    return XMLText;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLNode, XMLProcessingInstruction,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLNode = __webpack_require__(293);
	
	  module.exports = XMLProcessingInstruction = (function(superClass) {
	    extend(XMLProcessingInstruction, superClass);
	
	    function XMLProcessingInstruction(parent, target, value) {
	      XMLProcessingInstruction.__super__.constructor.call(this, parent);
	      if (target == null) {
	        throw new Error("Missing instruction target");
	      }
	      this.target = this.stringify.insTarget(target);
	      if (value) {
	        this.value = this.stringify.insValue(value);
	      }
	    }
	
	    XMLProcessingInstruction.prototype.clone = function() {
	      return Object.create(this);
	    };
	
	    XMLProcessingInstruction.prototype.toString = function(options) {
	      return this.options.writer.set(options).processingInstruction(this);
	    };
	
	    return XMLProcessingInstruction;
	
	  })(XMLNode);
	
	}).call(this);


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLStringifier, camelCase, kebabCase, ref, snakeCase, titleCase,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    hasProp = {}.hasOwnProperty;
	
	  ref = __webpack_require__(291), camelCase = ref.camelCase, titleCase = ref.titleCase, kebabCase = ref.kebabCase, snakeCase = ref.snakeCase;
	
	  module.exports = XMLStringifier = (function() {
	    function XMLStringifier(options) {
	      this.assertLegalChar = bind(this.assertLegalChar, this);
	      var key, ref1, value;
	      options || (options = {});
	      this.allowSurrogateChars = options.allowSurrogateChars;
	      this.noDoubleEncoding = options.noDoubleEncoding;
	      this.textCase = options.textCase;
	      ref1 = options.stringify || {};
	      for (key in ref1) {
	        if (!hasProp.call(ref1, key)) continue;
	        value = ref1[key];
	        this[key] = value;
	      }
	    }
	
	    XMLStringifier.prototype.eleName = function(val) {
	      val = '' + val || '';
	      val = this.applyCase(val);
	      return this.assertLegalChar(val);
	    };
	
	    XMLStringifier.prototype.eleText = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(this.elEscape(val));
	    };
	
	    XMLStringifier.prototype.cdata = function(val) {
	      val = '' + val || '';
	      val = val.replace(']]>', ']]]]><![CDATA[>');
	      return this.assertLegalChar(val);
	    };
	
	    XMLStringifier.prototype.comment = function(val) {
	      val = '' + val || '';
	      if (val.match(/--/)) {
	        throw new Error("Comment text cannot contain double-hypen: " + val);
	      }
	      return this.assertLegalChar(val);
	    };
	
	    XMLStringifier.prototype.raw = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.attName = function(val) {
	      val = '' + val || '';
	      return val = this.applyCase(val);
	    };
	
	    XMLStringifier.prototype.attValue = function(val) {
	      val = '' + val || '';
	      return this.attEscape(val);
	    };
	
	    XMLStringifier.prototype.insTarget = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.insValue = function(val) {
	      val = '' + val || '';
	      if (val.match(/\?>/)) {
	        throw new Error("Invalid processing instruction value: " + val);
	      }
	      return val;
	    };
	
	    XMLStringifier.prototype.xmlVersion = function(val) {
	      val = '' + val || '';
	      if (!val.match(/1\.[0-9]+/)) {
	        throw new Error("Invalid version number: " + val);
	      }
	      return val;
	    };
	
	    XMLStringifier.prototype.xmlEncoding = function(val) {
	      val = '' + val || '';
	      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-]|-)*$/)) {
	        throw new Error("Invalid encoding: " + val);
	      }
	      return val;
	    };
	
	    XMLStringifier.prototype.xmlStandalone = function(val) {
	      if (val) {
	        return "yes";
	      } else {
	        return "no";
	      }
	    };
	
	    XMLStringifier.prototype.dtdPubID = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.dtdSysID = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.dtdElementValue = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.dtdAttType = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.dtdAttDefault = function(val) {
	      if (val != null) {
	        return '' + val || '';
	      } else {
	        return val;
	      }
	    };
	
	    XMLStringifier.prototype.dtdEntityValue = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.dtdNData = function(val) {
	      return '' + val || '';
	    };
	
	    XMLStringifier.prototype.convertAttKey = '@';
	
	    XMLStringifier.prototype.convertPIKey = '?';
	
	    XMLStringifier.prototype.convertTextKey = '#text';
	
	    XMLStringifier.prototype.convertCDataKey = '#cdata';
	
	    XMLStringifier.prototype.convertCommentKey = '#comment';
	
	    XMLStringifier.prototype.convertRawKey = '#raw';
	
	    XMLStringifier.prototype.assertLegalChar = function(str) {
	      var chars, chr;
	      if (this.allowSurrogateChars) {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
	      } else {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
	      }
	      chr = str.match(chars);
	      if (chr) {
	        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
	      }
	      return str;
	    };
	
	    XMLStringifier.prototype.applyCase = function(str) {
	      switch (this.textCase) {
	        case "camel":
	          return camelCase(str);
	        case "title":
	          return titleCase(str);
	        case "kebab":
	        case "lower":
	          return kebabCase(str);
	        case "snake":
	          return snakeCase(str);
	        case "upper":
	          return kebabCase(str).toUpperCase();
	        default:
	          return str;
	      }
	    };
	
	    XMLStringifier.prototype.elEscape = function(str) {
	      var ampregex;
	      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
	      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
	    };
	
	    XMLStringifier.prototype.attEscape = function(str) {
	      var ampregex;
	      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
	      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
	    };
	
	    return XMLStringifier;
	
	  })();
	
	}).call(this);


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLDeclaration = __webpack_require__(298);
	
	  XMLDocType = __webpack_require__(299);
	
	  XMLCData = __webpack_require__(296);
	
	  XMLComment = __webpack_require__(297);
	
	  XMLElement = __webpack_require__(294);
	
	  XMLRaw = __webpack_require__(304);
	
	  XMLText = __webpack_require__(305);
	
	  XMLProcessingInstruction = __webpack_require__(306);
	
	  XMLDTDAttList = __webpack_require__(300);
	
	  XMLDTDElement = __webpack_require__(302);
	
	  XMLDTDEntity = __webpack_require__(301);
	
	  XMLDTDNotation = __webpack_require__(303);
	
	  XMLWriterBase = __webpack_require__(309);
	
	  module.exports = XMLStringWriter = (function(superClass) {
	    extend(XMLStringWriter, superClass);
	
	    function XMLStringWriter(options) {
	      XMLStringWriter.__super__.constructor.call(this, options);
	    }
	
	    XMLStringWriter.prototype.document = function(doc) {
	      var child, i, len, r, ref;
	      r = '';
	      ref = doc.children;
	      for (i = 0, len = ref.length; i < len; i++) {
	        child = ref[i];
	        r += (function() {
	          switch (false) {
	            case !(child instanceof XMLDeclaration):
	              return this.declaration(child);
	            case !(child instanceof XMLDocType):
	              return this.docType(child);
	            case !(child instanceof XMLComment):
	              return this.comment(child);
	            case !(child instanceof XMLProcessingInstruction):
	              return this.processingInstruction(child);
	            default:
	              return this.element(child, 0);
	          }
	        }).call(this);
	      }
	      if (this.pretty && r.slice(-this.newline.length) === this.newline) {
	        r = r.slice(0, -this.newline.length);
	      }
	      return r;
	    };
	
	    XMLStringWriter.prototype.attribute = function(att) {
	      return ' ' + att.name + '="' + att.value + '"';
	    };
	
	    XMLStringWriter.prototype.cdata = function(node, level) {
	      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
	    };
	
	    XMLStringWriter.prototype.comment = function(node, level) {
	      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
	    };
	
	    XMLStringWriter.prototype.declaration = function(node, level) {
	      var r;
	      r = this.space(level);
	      r += '<?xml version="' + node.version + '"';
	      if (node.encoding != null) {
	        r += ' encoding="' + node.encoding + '"';
	      }
	      if (node.standalone != null) {
	        r += ' standalone="' + node.standalone + '"';
	      }
	      r += '?>';
	      r += this.newline;
	      return r;
	    };
	
	    XMLStringWriter.prototype.docType = function(node, level) {
	      var child, i, len, r, ref;
	      level || (level = 0);
	      r = this.space(level);
	      r += '<!DOCTYPE ' + node.root().name;
	      if (node.pubID && node.sysID) {
	        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	      } else if (node.sysID) {
	        r += ' SYSTEM "' + node.sysID + '"';
	      }
	      if (node.children.length > 0) {
	        r += ' [';
	        r += this.newline;
	        ref = node.children;
	        for (i = 0, len = ref.length; i < len; i++) {
	          child = ref[i];
	          r += (function() {
	            switch (false) {
	              case !(child instanceof XMLDTDAttList):
	                return this.dtdAttList(child, level + 1);
	              case !(child instanceof XMLDTDElement):
	                return this.dtdElement(child, level + 1);
	              case !(child instanceof XMLDTDEntity):
	                return this.dtdEntity(child, level + 1);
	              case !(child instanceof XMLDTDNotation):
	                return this.dtdNotation(child, level + 1);
	              case !(child instanceof XMLCData):
	                return this.cdata(child, level + 1);
	              case !(child instanceof XMLComment):
	                return this.comment(child, level + 1);
	              case !(child instanceof XMLProcessingInstruction):
	                return this.processingInstruction(child, level + 1);
	              default:
	                throw new Error("Unknown DTD node type: " + child.constructor.name);
	            }
	          }).call(this);
	        }
	        r += ']';
	      }
	      r += '>';
	      r += this.newline;
	      return r;
	    };
	
	    XMLStringWriter.prototype.element = function(node, level) {
	      var att, child, i, len, name, r, ref, ref1, space;
	      level || (level = 0);
	      space = this.space(level);
	      r = '';
	      r += space + '<' + node.name;
	      ref = node.attributes;
	      for (name in ref) {
	        if (!hasProp.call(ref, name)) continue;
	        att = ref[name];
	        r += this.attribute(att);
	      }
	      if (node.children.length === 0 || node.children.every(function(e) {
	        return e.value === '';
	      })) {
	        if (this.allowEmpty) {
	          r += '></' + node.name + '>' + this.newline;
	        } else {
	          r += '/>' + this.newline;
	        }
	      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
	        r += '>';
	        r += node.children[0].value;
	        r += '</' + node.name + '>' + this.newline;
	      } else {
	        r += '>' + this.newline;
	        ref1 = node.children;
	        for (i = 0, len = ref1.length; i < len; i++) {
	          child = ref1[i];
	          r += (function() {
	            switch (false) {
	              case !(child instanceof XMLCData):
	                return this.cdata(child, level + 1);
	              case !(child instanceof XMLComment):
	                return this.comment(child, level + 1);
	              case !(child instanceof XMLElement):
	                return this.element(child, level + 1);
	              case !(child instanceof XMLRaw):
	                return this.raw(child, level + 1);
	              case !(child instanceof XMLText):
	                return this.text(child, level + 1);
	              case !(child instanceof XMLProcessingInstruction):
	                return this.processingInstruction(child, level + 1);
	              default:
	                throw new Error("Unknown XML node type: " + child.constructor.name);
	            }
	          }).call(this);
	        }
	        r += space + '</' + node.name + '>' + this.newline;
	      }
	      return r;
	    };
	
	    XMLStringWriter.prototype.processingInstruction = function(node, level) {
	      var r;
	      r = this.space(level) + '<?' + node.target;
	      if (node.value) {
	        r += ' ' + node.value;
	      }
	      r += '?>' + this.newline;
	      return r;
	    };
	
	    XMLStringWriter.prototype.raw = function(node, level) {
	      return this.space(level) + node.value + this.newline;
	    };
	
	    XMLStringWriter.prototype.text = function(node, level) {
	      return this.space(level) + node.value + this.newline;
	    };
	
	    XMLStringWriter.prototype.dtdAttList = function(node, level) {
	      var r;
	      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
	      if (node.defaultValueType !== '#DEFAULT') {
	        r += ' ' + node.defaultValueType;
	      }
	      if (node.defaultValue) {
	        r += ' "' + node.defaultValue + '"';
	      }
	      r += '>' + this.newline;
	      return r;
	    };
	
	    XMLStringWriter.prototype.dtdElement = function(node, level) {
	      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + '>' + this.newline;
	    };
	
	    XMLStringWriter.prototype.dtdEntity = function(node, level) {
	      var r;
	      r = this.space(level) + '<!ENTITY';
	      if (node.pe) {
	        r += ' %';
	      }
	      r += ' ' + node.name;
	      if (node.value) {
	        r += ' "' + node.value + '"';
	      } else {
	        if (node.pubID && node.sysID) {
	          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	        } else if (node.sysID) {
	          r += ' SYSTEM "' + node.sysID + '"';
	        }
	        if (node.nData) {
	          r += ' NDATA ' + node.nData;
	        }
	      }
	      r += '>' + this.newline;
	      return r;
	    };
	
	    XMLStringWriter.prototype.dtdNotation = function(node, level) {
	      var r;
	      r = this.space(level) + '<!NOTATION ' + node.name;
	      if (node.pubID && node.sysID) {
	        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	      } else if (node.pubID) {
	        r += ' PUBLIC "' + node.pubID + '"';
	      } else if (node.sysID) {
	        r += ' SYSTEM "' + node.sysID + '"';
	      }
	      r += '>' + this.newline;
	      return r;
	    };
	
	    XMLStringWriter.prototype.openNode = function(node, level) {
	      var att, name, r, ref;
	      level || (level = 0);
	      if (node instanceof XMLElement) {
	        r = this.space(level) + '<' + node.name;
	        ref = node.attributes;
	        for (name in ref) {
	          if (!hasProp.call(ref, name)) continue;
	          att = ref[name];
	          r += this.attribute(att);
	        }
	        r += (node.children ? '>' : '/>') + this.newline;
	        return r;
	      } else {
	        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
	        if (node.pubID && node.sysID) {
	          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
	        } else if (node.sysID) {
	          r += ' SYSTEM "' + node.sysID + '"';
	        }
	        r += (node.children ? ' [' : '>') + this.newline;
	        return r;
	      }
	    };
	
	    XMLStringWriter.prototype.closeNode = function(node, level) {
	      level || (level = 0);
	      switch (false) {
	        case !(node instanceof XMLElement):
	          return this.space(level) + '</' + node.name + '>' + this.newline;
	        case !(node instanceof XMLDocType):
	          return this.space(level) + ']>' + this.newline;
	      }
	    };
	
	    return XMLStringWriter;
	
	  })(XMLWriterBase);
	
	}).call(this);


/***/ },
/* 309 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLWriterBase,
	    hasProp = {}.hasOwnProperty;
	
	  module.exports = XMLWriterBase = (function() {
	    function XMLWriterBase(options) {
	      var key, ref, ref1, ref2, ref3, ref4, value;
	      options || (options = {});
	      this.pretty = options.pretty || false;
	      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
	      if (this.pretty) {
	        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
	        this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
	        this.offset = (ref3 = options.offset) != null ? ref3 : 0;
	      } else {
	        this.indent = '';
	        this.newline = '';
	        this.offset = 0;
	      }
	      ref4 = options.writer || {};
	      for (key in ref4) {
	        if (!hasProp.call(ref4, key)) continue;
	        value = ref4[key];
	        this[key] = value;
	      }
	    }
	
	    XMLWriterBase.prototype.set = function(options) {
	      var key, ref, value;
	      options || (options = {});
	      if ("pretty" in options) {
	        this.pretty = options.pretty;
	      }
	      if ("allowEmpty" in options) {
	        this.allowEmpty = options.allowEmpty;
	      }
	      if (this.pretty) {
	        this.indent = "indent" in options ? options.indent : '  ';
	        this.newline = "newline" in options ? options.newline : '\n';
	        this.offset = "offset" in options ? options.offset : 0;
	      } else {
	        this.indent = '';
	        this.newline = '';
	        this.offset = 0;
	      }
	      ref = options.writer || {};
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this[key] = value;
	      }
	      return this;
	    };
	
	    XMLWriterBase.prototype.space = function(level) {
	      if (this.pretty) {
	        return new Array((level || 0) + this.offset + 1).join(this.indent);
	      } else {
	        return '';
	      }
	    };
	
	    return XMLWriterBase;
	
	  })();
	
	}).call(this);


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,
	    hasProp = {}.hasOwnProperty;
	
	  ref = __webpack_require__(291), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;
	
	  XMLElement = __webpack_require__(294);
	
	  XMLCData = __webpack_require__(296);
	
	  XMLComment = __webpack_require__(297);
	
	  XMLRaw = __webpack_require__(304);
	
	  XMLText = __webpack_require__(305);
	
	  XMLProcessingInstruction = __webpack_require__(306);
	
	  XMLDeclaration = __webpack_require__(298);
	
	  XMLDocType = __webpack_require__(299);
	
	  XMLDTDAttList = __webpack_require__(300);
	
	  XMLDTDEntity = __webpack_require__(301);
	
	  XMLDTDElement = __webpack_require__(302);
	
	  XMLDTDNotation = __webpack_require__(303);
	
	  XMLAttribute = __webpack_require__(295);
	
	  XMLStringifier = __webpack_require__(307);
	
	  XMLStringWriter = __webpack_require__(308);
	
	  module.exports = XMLDocumentCB = (function() {
	    function XMLDocumentCB(options, onData, onEnd) {
	      var writerOptions;
	      options || (options = {});
	      if (!options.writer) {
	        options.writer = new XMLStringWriter(options);
	      } else if (isPlainObject(options.writer)) {
	        writerOptions = options.writer;
	        options.writer = new XMLStringWriter(writerOptions);
	      }
	      this.options = options;
	      this.writer = options.writer;
	      this.stringify = new XMLStringifier(options);
	      this.onDataCallback = onData || function() {};
	      this.onEndCallback = onEnd || function() {};
	      this.currentNode = null;
	      this.currentLevel = -1;
	      this.openTags = {};
	      this.documentStarted = false;
	      this.documentCompleted = false;
	      this.root = null;
	    }
	
	    XMLDocumentCB.prototype.node = function(name, attributes, text) {
	      var ref1;
	      if (name == null) {
	        throw new Error("Missing node name");
	      }
	      if (this.root && this.currentLevel === -1) {
	        throw new Error("Document can only have one root node");
	      }
	      this.openCurrent();
	      name = name.valueOf();
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
	      }
	      this.currentNode = new XMLElement(this, name, attributes);
	      this.currentNode.children = false;
	      this.currentLevel++;
	      this.openTags[this.currentLevel] = this.currentNode;
	      if (text != null) {
	        this.text(text);
	      }
	      return this;
	    };
	
	    XMLDocumentCB.prototype.element = function(name, attributes, text) {
	      if (this.currentNode && this.currentNode instanceof XMLDocType) {
	        return this.dtdElement.apply(this, arguments);
	      } else {
	        return this.node(name, attributes, text);
	      }
	    };
	
	    XMLDocumentCB.prototype.attribute = function(name, value) {
	      var attName, attValue;
	      if (!this.currentNode || this.currentNode.children) {
	        throw new Error("att() can only be used immediately after an ele() call in callback mode");
	      }
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (isObject(name)) {
	        for (attName in name) {
	          if (!hasProp.call(name, attName)) continue;
	          attValue = name[attName];
	          this.attribute(attName, attValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        if (!this.options.skipNullAttributes || (value != null)) {
	          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
	        }
	      }
	      return this;
	    };
	
	    XMLDocumentCB.prototype.text = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLText(this, value);
	      this.onData(this.writer.text(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.cdata = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLCData(this, value);
	      this.onData(this.writer.cdata(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.comment = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLComment(this, value);
	      this.onData(this.writer.comment(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.raw = function(value) {
	      var node;
	      this.openCurrent();
	      node = new XMLRaw(this, value);
	      this.onData(this.writer.raw(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.instruction = function(target, value) {
	      var i, insTarget, insValue, len, node;
	      this.openCurrent();
	      if (target != null) {
	        target = target.valueOf();
	      }
	      if (value != null) {
	        value = value.valueOf();
	      }
	      if (Array.isArray(target)) {
	        for (i = 0, len = target.length; i < len; i++) {
	          insTarget = target[i];
	          this.instruction(insTarget);
	        }
	      } else if (isObject(target)) {
	        for (insTarget in target) {
	          if (!hasProp.call(target, insTarget)) continue;
	          insValue = target[insTarget];
	          this.instruction(insTarget, insValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        node = new XMLProcessingInstruction(this, target, value);
	        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
	      }
	      return this;
	    };
	
	    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
	      var node;
	      this.openCurrent();
	      if (this.documentStarted) {
	        throw new Error("declaration() must be the first node");
	      }
	      node = new XMLDeclaration(this, version, encoding, standalone);
	      this.onData(this.writer.declaration(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
	      this.openCurrent();
	      if (root == null) {
	        throw new Error("Missing root node name");
	      }
	      if (this.root) {
	        throw new Error("dtd() must come before the root node");
	      }
	      this.currentNode = new XMLDocType(this, pubID, sysID);
	      this.currentNode.rootNodeName = root;
	      this.currentNode.children = false;
	      this.currentLevel++;
	      this.openTags[this.currentLevel] = this.currentNode;
	      return this;
	    };
	
	    XMLDocumentCB.prototype.dtdElement = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDElement(this, name, value);
	      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
	      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.entity = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDEntity(this, false, name, value);
	      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.pEntity = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDEntity(this, true, name, value);
	      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.notation = function(name, value) {
	      var node;
	      this.openCurrent();
	      node = new XMLDTDNotation(this, name, value);
	      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
	      return this;
	    };
	
	    XMLDocumentCB.prototype.up = function() {
	      if (this.currentLevel < 0) {
	        throw new Error("The document node has no parent");
	      }
	      if (this.currentNode) {
	        if (this.currentNode.children) {
	          this.closeNode(this.currentNode);
	        } else {
	          this.openNode(this.currentNode);
	        }
	        this.currentNode = null;
	      } else {
	        this.closeNode(this.openTags[this.currentLevel]);
	      }
	      delete this.openTags[this.currentLevel];
	      this.currentLevel--;
	      return this;
	    };
	
	    XMLDocumentCB.prototype.end = function() {
	      while (this.currentLevel >= 0) {
	        this.up();
	      }
	      return this.onEnd();
	    };
	
	    XMLDocumentCB.prototype.openCurrent = function() {
	      if (this.currentNode) {
	        this.currentNode.children = true;
	        return this.openNode(this.currentNode);
	      }
	    };
	
	    XMLDocumentCB.prototype.openNode = function(node) {
	      if (!node.isOpen) {
	        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
	          this.root = node;
	        }
	        this.onData(this.writer.openNode(node, this.currentLevel));
	        return node.isOpen = true;
	      }
	    };
	
	    XMLDocumentCB.prototype.closeNode = function(node) {
	      if (!node.isClosed) {
	        this.onData(this.writer.closeNode(node, this.currentLevel));
	        return node.isClosed = true;
	      }
	    };
	
	    XMLDocumentCB.prototype.onData = function(chunk) {
	      this.documentStarted = true;
	      return this.onDataCallback(chunk);
	    };
	
	    XMLDocumentCB.prototype.onEnd = function() {
	      this.documentCompleted = true;
	      return this.onEndCallback();
	    };
	
	    XMLDocumentCB.prototype.ele = function() {
	      return this.element.apply(this, arguments);
	    };
	
	    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };
	
	    XMLDocumentCB.prototype.txt = function(value) {
	      return this.text(value);
	    };
	
	    XMLDocumentCB.prototype.dat = function(value) {
	      return this.cdata(value);
	    };
	
	    XMLDocumentCB.prototype.com = function(value) {
	      return this.comment(value);
	    };
	
	    XMLDocumentCB.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };
	
	    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
	      return this.declaration(version, encoding, standalone);
	    };
	
	    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
	      return this.doctype(root, pubID, sysID);
	    };
	
	    XMLDocumentCB.prototype.e = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };
	
	    XMLDocumentCB.prototype.n = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };
	
	    XMLDocumentCB.prototype.t = function(value) {
	      return this.text(value);
	    };
	
	    XMLDocumentCB.prototype.d = function(value) {
	      return this.cdata(value);
	    };
	
	    XMLDocumentCB.prototype.c = function(value) {
	      return this.comment(value);
	    };
	
	    XMLDocumentCB.prototype.r = function(value) {
	      return this.raw(value);
	    };
	
	    XMLDocumentCB.prototype.i = function(target, value) {
	      return this.instruction(target, value);
	    };
	
	    XMLDocumentCB.prototype.att = function() {
	      if (this.currentNode && this.currentNode instanceof XMLDocType) {
	        return this.attList.apply(this, arguments);
	      } else {
	        return this.attribute.apply(this, arguments);
	      }
	    };
	
	    XMLDocumentCB.prototype.a = function() {
	      if (this.currentNode && this.currentNode instanceof XMLDocType) {
	        return this.attList.apply(this, arguments);
	      } else {
	        return this.attribute.apply(this, arguments);
	      }
	    };
	
	    XMLDocumentCB.prototype.ent = function(name, value) {
	      return this.entity(name, value);
	    };
	
	    XMLDocumentCB.prototype.pent = function(name, value) {
	      return this.pEntity(name, value);
	    };
	
	    XMLDocumentCB.prototype.not = function(name, value) {
	      return this.notation(name, value);
	    };
	
	    return XMLDocumentCB;
	
	  })();
	
	}).call(this);


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  XMLDeclaration = __webpack_require__(298);
	
	  XMLDocType = __webpack_require__(299);
	
	  XMLCData = __webpack_require__(296);
	
	  XMLComment = __webpack_require__(297);
	
	  XMLElement = __webpack_require__(294);
	
	  XMLRaw = __webpack_require__(304);
	
	  XMLText = __webpack_require__(305);
	
	  XMLProcessingInstruction = __webpack_require__(306);
	
	  XMLDTDAttList = __webpack_require__(300);
	
	  XMLDTDElement = __webpack_require__(302);
	
	  XMLDTDEntity = __webpack_require__(301);
	
	  XMLDTDNotation = __webpack_require__(303);
	
	  XMLWriterBase = __webpack_require__(309);
	
	  module.exports = XMLStreamWriter = (function(superClass) {
	    extend(XMLStreamWriter, superClass);
	
	    function XMLStreamWriter(stream, options) {
	      this.stream = stream;
	      XMLStreamWriter.__super__.constructor.call(this, options);
	    }
	
	    XMLStreamWriter.prototype.document = function(doc) {
	      var child, i, j, len, len1, ref, ref1, results;
	      ref = doc.children;
	      for (i = 0, len = ref.length; i < len; i++) {
	        child = ref[i];
	        child.isLastRootNode = false;
	      }
	      doc.children[doc.children.length - 1].isLastRootNode = true;
	      ref1 = doc.children;
	      results = [];
	      for (j = 0, len1 = ref1.length; j < len1; j++) {
	        child = ref1[j];
	        switch (false) {
	          case !(child instanceof XMLDeclaration):
	            results.push(this.declaration(child));
	            break;
	          case !(child instanceof XMLDocType):
	            results.push(this.docType(child));
	            break;
	          case !(child instanceof XMLComment):
	            results.push(this.comment(child));
	            break;
	          case !(child instanceof XMLProcessingInstruction):
	            results.push(this.processingInstruction(child));
	            break;
	          default:
	            results.push(this.element(child));
	        }
	      }
	      return results;
	    };
	
	    XMLStreamWriter.prototype.attribute = function(att) {
	      return this.stream.write(' ' + att.name + '="' + att.value + '"');
	    };
	
	    XMLStreamWriter.prototype.cdata = function(node, level) {
	      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.comment = function(node, level) {
	      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.declaration = function(node, level) {
	      this.stream.write(this.space(level));
	      this.stream.write('<?xml version="' + node.version + '"');
	      if (node.encoding != null) {
	        this.stream.write(' encoding="' + node.encoding + '"');
	      }
	      if (node.standalone != null) {
	        this.stream.write(' standalone="' + node.standalone + '"');
	      }
	      this.stream.write('?>');
	      return this.stream.write(this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.docType = function(node, level) {
	      var child, i, len, ref;
	      level || (level = 0);
	      this.stream.write(this.space(level));
	      this.stream.write('<!DOCTYPE ' + node.root().name);
	      if (node.pubID && node.sysID) {
	        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
	      } else if (node.sysID) {
	        this.stream.write(' SYSTEM "' + node.sysID + '"');
	      }
	      if (node.children.length > 0) {
	        this.stream.write(' [');
	        this.stream.write(this.endline(node));
	        ref = node.children;
	        for (i = 0, len = ref.length; i < len; i++) {
	          child = ref[i];
	          switch (false) {
	            case !(child instanceof XMLDTDAttList):
	              this.dtdAttList(child, level + 1);
	              break;
	            case !(child instanceof XMLDTDElement):
	              this.dtdElement(child, level + 1);
	              break;
	            case !(child instanceof XMLDTDEntity):
	              this.dtdEntity(child, level + 1);
	              break;
	            case !(child instanceof XMLDTDNotation):
	              this.dtdNotation(child, level + 1);
	              break;
	            case !(child instanceof XMLCData):
	              this.cdata(child, level + 1);
	              break;
	            case !(child instanceof XMLComment):
	              this.comment(child, level + 1);
	              break;
	            case !(child instanceof XMLProcessingInstruction):
	              this.processingInstruction(child, level + 1);
	              break;
	            default:
	              throw new Error("Unknown DTD node type: " + child.constructor.name);
	          }
	        }
	        this.stream.write(']');
	      }
	      this.stream.write('>');
	      return this.stream.write(this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.element = function(node, level) {
	      var att, child, i, len, name, ref, ref1, space;
	      level || (level = 0);
	      space = this.space(level);
	      this.stream.write(space + '<' + node.name);
	      ref = node.attributes;
	      for (name in ref) {
	        if (!hasProp.call(ref, name)) continue;
	        att = ref[name];
	        this.attribute(att);
	      }
	      if (node.children.length === 0 || node.children.every(function(e) {
	        return e.value === '';
	      })) {
	        if (this.allowEmpty) {
	          this.stream.write('></' + node.name + '>');
	        } else {
	          this.stream.write('/>');
	        }
	      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
	        this.stream.write('>');
	        this.stream.write(node.children[0].value);
	        this.stream.write('</' + node.name + '>');
	      } else {
	        this.stream.write('>' + this.newline);
	        ref1 = node.children;
	        for (i = 0, len = ref1.length; i < len; i++) {
	          child = ref1[i];
	          switch (false) {
	            case !(child instanceof XMLCData):
	              this.cdata(child, level + 1);
	              break;
	            case !(child instanceof XMLComment):
	              this.comment(child, level + 1);
	              break;
	            case !(child instanceof XMLElement):
	              this.element(child, level + 1);
	              break;
	            case !(child instanceof XMLRaw):
	              this.raw(child, level + 1);
	              break;
	            case !(child instanceof XMLText):
	              this.text(child, level + 1);
	              break;
	            case !(child instanceof XMLProcessingInstruction):
	              this.processingInstruction(child, level + 1);
	              break;
	            default:
	              throw new Error("Unknown XML node type: " + child.constructor.name);
	          }
	        }
	        this.stream.write(space + '</' + node.name + '>');
	      }
	      return this.stream.write(this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.processingInstruction = function(node, level) {
	      this.stream.write(this.space(level) + '<?' + node.target);
	      if (node.value) {
	        this.stream.write(' ' + node.value);
	      }
	      return this.stream.write('?>' + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.raw = function(node, level) {
	      return this.stream.write(this.space(level) + node.value + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.text = function(node, level) {
	      return this.stream.write(this.space(level) + node.value + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.dtdAttList = function(node, level) {
	      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
	      if (node.defaultValueType !== '#DEFAULT') {
	        this.stream.write(' ' + node.defaultValueType);
	      }
	      if (node.defaultValue) {
	        this.stream.write(' "' + node.defaultValue + '"');
	      }
	      return this.stream.write('>' + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.dtdElement = function(node, level) {
	      return this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + '>' + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.dtdEntity = function(node, level) {
	      this.stream.write(this.space(level) + '<!ENTITY');
	      if (node.pe) {
	        this.stream.write(' %');
	      }
	      this.stream.write(' ' + node.name);
	      if (node.value) {
	        this.stream.write(' "' + node.value + '"');
	      } else {
	        if (node.pubID && node.sysID) {
	          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
	        } else if (node.sysID) {
	          this.stream.write(' SYSTEM "' + node.sysID + '"');
	        }
	        if (node.nData) {
	          this.stream.write(' NDATA ' + node.nData);
	        }
	      }
	      return this.stream.write('>' + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.dtdNotation = function(node, level) {
	      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
	      if (node.pubID && node.sysID) {
	        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
	      } else if (node.pubID) {
	        this.stream.write(' PUBLIC "' + node.pubID + '"');
	      } else if (node.sysID) {
	        this.stream.write(' SYSTEM "' + node.sysID + '"');
	      }
	      return this.stream.write('>' + this.endline(node));
	    };
	
	    XMLStreamWriter.prototype.endline = function(node) {
	      if (!node.isLastRootNode) {
	        return this.newline;
	      } else {
	        return '';
	      }
	    };
	
	    return XMLStreamWriter;
	
	  })(XMLWriterBase);
	
	}).call(this);


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.6.3
	(function() {
	  var xml2js;
	
	  xml2js = __webpack_require__(272);
	
	  exports.stripBOM = function(str) {
	    if (str[0] === '\uFEFF') {
	      return str.substring(1);
	    } else {
	      return str;
	    }
	  };
	
	}).call(this);


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var http = module.exports;
	var EventEmitter = __webpack_require__(275).EventEmitter;
	var Request = __webpack_require__(314);
	var url = __webpack_require__(317)
	
	http.request = function (params, cb) {
	    if (typeof params === 'string') {
	        params = url.parse(params)
	    }
	    if (!params) params = {};
	    if (!params.host && !params.port) {
	        params.port = parseInt(window.location.port, 10);
	    }
	    if (!params.host && params.hostname) {
	        params.host = params.hostname;
	    }
	
	    if (!params.protocol) {
	        if (params.scheme) {
	            params.protocol = params.scheme + ':';
	        } else {
	            params.protocol = window.location.protocol;
	        }
	    }
	
	    if (!params.host) {
	        params.host = window.location.hostname || window.location.host;
	    }
	    if (/:/.test(params.host)) {
	        if (!params.port) {
	            params.port = params.host.split(':')[1];
	        }
	        params.host = params.host.split(':')[0];
	    }
	    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
	    
	    var req = new Request(new xhrHttp, params);
	    if (cb) req.on('response', cb);
	    return req;
	};
	
	http.get = function (params, cb) {
	    params.method = 'GET';
	    var req = http.request(params, cb);
	    req.end();
	    return req;
	};
	
	http.Agent = function () {};
	http.Agent.defaultMaxSockets = 4;
	
	var xhrHttp = (function () {
	    if (typeof window === 'undefined') {
	        throw new Error('no window object present');
	    }
	    else if (window.XMLHttpRequest) {
	        return window.XMLHttpRequest;
	    }
	    else if (window.ActiveXObject) {
	        var axs = [
	            'Msxml2.XMLHTTP.6.0',
	            'Msxml2.XMLHTTP.3.0',
	            'Microsoft.XMLHTTP'
	        ];
	        for (var i = 0; i < axs.length; i++) {
	            try {
	                var ax = new(window.ActiveXObject)(axs[i]);
	                return function () {
	                    if (ax) {
	                        var ax_ = ax;
	                        ax = null;
	                        return ax_;
	                    }
	                    else {
	                        return new(window.ActiveXObject)(axs[i]);
	                    }
	                };
	            }
	            catch (e) {}
	        }
	        throw new Error('ajax not supported in this browser')
	    }
	    else {
	        throw new Error('ajax not supported in this browser');
	    }
	})();
	
	http.STATUS_CODES = {
	    100 : 'Continue',
	    101 : 'Switching Protocols',
	    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
	    200 : 'OK',
	    201 : 'Created',
	    202 : 'Accepted',
	    203 : 'Non-Authoritative Information',
	    204 : 'No Content',
	    205 : 'Reset Content',
	    206 : 'Partial Content',
	    207 : 'Multi-Status',               // RFC 4918
	    300 : 'Multiple Choices',
	    301 : 'Moved Permanently',
	    302 : 'Moved Temporarily',
	    303 : 'See Other',
	    304 : 'Not Modified',
	    305 : 'Use Proxy',
	    307 : 'Temporary Redirect',
	    400 : 'Bad Request',
	    401 : 'Unauthorized',
	    402 : 'Payment Required',
	    403 : 'Forbidden',
	    404 : 'Not Found',
	    405 : 'Method Not Allowed',
	    406 : 'Not Acceptable',
	    407 : 'Proxy Authentication Required',
	    408 : 'Request Time-out',
	    409 : 'Conflict',
	    410 : 'Gone',
	    411 : 'Length Required',
	    412 : 'Precondition Failed',
	    413 : 'Request Entity Too Large',
	    414 : 'Request-URI Too Large',
	    415 : 'Unsupported Media Type',
	    416 : 'Requested Range Not Satisfiable',
	    417 : 'Expectation Failed',
	    418 : 'I\'m a teapot',              // RFC 2324
	    422 : 'Unprocessable Entity',       // RFC 4918
	    423 : 'Locked',                     // RFC 4918
	    424 : 'Failed Dependency',          // RFC 4918
	    425 : 'Unordered Collection',       // RFC 4918
	    426 : 'Upgrade Required',           // RFC 2817
	    428 : 'Precondition Required',      // RFC 6585
	    429 : 'Too Many Requests',          // RFC 6585
	    431 : 'Request Header Fields Too Large',// RFC 6585
	    500 : 'Internal Server Error',
	    501 : 'Not Implemented',
	    502 : 'Bad Gateway',
	    503 : 'Service Unavailable',
	    504 : 'Gateway Time-out',
	    505 : 'HTTP Version Not Supported',
	    506 : 'Variant Also Negotiates',    // RFC 2295
	    507 : 'Insufficient Storage',       // RFC 4918
	    509 : 'Bandwidth Limit Exceeded',
	    510 : 'Not Extended',               // RFC 2774
	    511 : 'Network Authentication Required' // RFC 6585
	};

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(274);
	var Response = __webpack_require__(315);
	var Base64 = __webpack_require__(316);
	var inherits = __webpack_require__(107);
	
	var Request = module.exports = function (xhr, params) {
	    var self = this;
	    self.writable = true;
	    self.xhr = xhr;
	    self.body = [];
	    
	    self.uri = (params.protocol || 'http:') + '//'
	        + params.host
	        + (params.port ? ':' + params.port : '')
	        + (params.path || '/')
	    ;
	    
	    if (typeof params.withCredentials === 'undefined') {
	        params.withCredentials = true;
	    }
	
	    try { xhr.withCredentials = params.withCredentials }
	    catch (e) {}
	    
	    if (params.responseType) try { xhr.responseType = params.responseType }
	    catch (e) {}
	    
	    xhr.open(
	        params.method || 'GET',
	        self.uri,
	        true
	    );
	
	    xhr.onerror = function(event) {
	        self.emit('error', new Error('Network error'));
	    };
	
	    self._headers = {};
	    
	    if (params.headers) {
	        var keys = objectKeys(params.headers);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (!self.isSafeRequestHeader(key)) continue;
	            var value = params.headers[key];
	            self.setHeader(key, value);
	        }
	    }
	    
	    if (params.auth) {
	        //basic auth
	        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
	    }
	
	    var res = new Response;
	    res.on('close', function () {
	        self.emit('close');
	    });
	    
	    res.on('ready', function () {
	        self.emit('response', res);
	    });
	
	    res.on('error', function (err) {
	        self.emit('error', err);
	    });
	    
	    xhr.onreadystatechange = function () {
	        // Fix for IE9 bug
	        // SCRIPT575: Could not complete the operation due to error c00c023f
	        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
	        if (xhr.__aborted) return;
	        res.handle(xhr);
	    };
	};
	
	inherits(Request, Stream);
	
	Request.prototype.setHeader = function (key, value) {
	    this._headers[key.toLowerCase()] = value
	};
	
	Request.prototype.getHeader = function (key) {
	    return this._headers[key.toLowerCase()]
	};
	
	Request.prototype.removeHeader = function (key) {
	    delete this._headers[key.toLowerCase()]
	};
	
	Request.prototype.write = function (s) {
	    this.body.push(s);
	};
	
	Request.prototype.destroy = function (s) {
	    this.xhr.__aborted = true;
	    this.xhr.abort();
	    this.emit('close');
	};
	
	Request.prototype.end = function (s) {
	    if (s !== undefined) this.body.push(s);
	
	    var keys = objectKeys(this._headers);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = this._headers[key];
	        if (isArray(value)) {
	            for (var j = 0; j < value.length; j++) {
	                this.xhr.setRequestHeader(key, value[j]);
	            }
	        }
	        else this.xhr.setRequestHeader(key, value)
	    }
	
	    if (this.body.length === 0) {
	        this.xhr.send('');
	    }
	    else if (typeof this.body[0] === 'string') {
	        this.xhr.send(this.body.join(''));
	    }
	    else if (isArray(this.body[0])) {
	        var body = [];
	        for (var i = 0; i < this.body.length; i++) {
	            body.push.apply(body, this.body[i]);
	        }
	        this.xhr.send(body);
	    }
	    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
	        var len = 0;
	        for (var i = 0; i < this.body.length; i++) {
	            len += this.body[i].length;
	        }
	        var body = new(this.body[0].constructor)(len);
	        var k = 0;
	        
	        for (var i = 0; i < this.body.length; i++) {
	            var b = this.body[i];
	            for (var j = 0; j < b.length; j++) {
	                body[k++] = b[j];
	            }
	        }
	        this.xhr.send(body);
	    }
	    else if (isXHR2Compatible(this.body[0])) {
	        this.xhr.send(this.body[0]);
	    }
	    else {
	        var body = '';
	        for (var i = 0; i < this.body.length; i++) {
	            body += this.body[i].toString();
	        }
	        this.xhr.send(body);
	    }
	};
	
	// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
	Request.unsafeHeaders = [
	    "accept-charset",
	    "accept-encoding",
	    "access-control-request-headers",
	    "access-control-request-method",
	    "connection",
	    "content-length",
	    "cookie",
	    "cookie2",
	    "content-transfer-encoding",
	    "date",
	    "expect",
	    "host",
	    "keep-alive",
	    "origin",
	    "referer",
	    "te",
	    "trailer",
	    "transfer-encoding",
	    "upgrade",
	    "user-agent",
	    "via"
	];
	
	Request.prototype.isSafeRequestHeader = function (headerName) {
	    if (!headerName) return false;
	    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
	};
	
	var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    return keys;
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	var indexOf = function (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0; i < xs.length; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	};
	
	var isXHR2Compatible = function (obj) {
	    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
	    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
	    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
	};


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(274);
	var util = __webpack_require__(105);
	
	var Response = module.exports = function (res) {
	    this.offset = 0;
	    this.readable = true;
	};
	
	util.inherits(Response, Stream);
	
	var capable = {
	    streaming : true,
	    status2 : true
	};
	
	function parseHeaders (res) {
	    var lines = res.getAllResponseHeaders().split(/\r?\n/);
	    var headers = {};
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	        if (line === '') continue;
	        
	        var m = line.match(/^([^:]+):\s*(.*)/);
	        if (m) {
	            var key = m[1].toLowerCase(), value = m[2];
	            
	            if (headers[key] !== undefined) {
	            
	                if (isArray(headers[key])) {
	                    headers[key].push(value);
	                }
	                else {
	                    headers[key] = [ headers[key], value ];
	                }
	            }
	            else {
	                headers[key] = value;
	            }
	        }
	        else {
	            headers[line] = true;
	        }
	    }
	    return headers;
	}
	
	Response.prototype.getResponse = function (xhr) {
	    var respType = String(xhr.responseType).toLowerCase();
	    if (respType === 'blob') return xhr.responseBlob || xhr.response;
	    if (respType === 'arraybuffer') return xhr.response;
	    return xhr.responseText;
	}
	
	Response.prototype.getHeader = function (key) {
	    return this.headers[key.toLowerCase()];
	};
	
	Response.prototype.handle = function (res) {
	    if (res.readyState === 2 && capable.status2) {
	        try {
	            this.statusCode = res.status;
	            this.headers = parseHeaders(res);
	        }
	        catch (err) {
	            capable.status2 = false;
	        }
	        
	        if (capable.status2) {
	            this.emit('ready');
	        }
	    }
	    else if (capable.streaming && res.readyState === 3) {
	        try {
	            if (!this.statusCode) {
	                this.statusCode = res.status;
	                this.headers = parseHeaders(res);
	                this.emit('ready');
	            }
	        }
	        catch (err) {}
	        
	        try {
	            this._emitData(res);
	        }
	        catch (err) {
	            capable.streaming = false;
	        }
	    }
	    else if (res.readyState === 4) {
	        if (!this.statusCode) {
	            this.statusCode = res.status;
	            this.emit('ready');
	        }
	        this._emitData(res);
	        
	        if (res.error) {
	            this.emit('error', this.getResponse(res));
	        }
	        else this.emit('end');
	        
	        this.emit('close');
	    }
	};
	
	Response.prototype._emitData = function (res) {
	    var respBody = this.getResponse(res);
	    if (respBody.toString().match(/ArrayBuffer/)) {
	        this.emit('data', new Uint8Array(respBody, this.offset));
	        this.offset = respBody.byteLength;
	        return;
	    }
	    if (respBody.length > this.offset) {
	        this.emit('data', respBody.slice(this.offset));
	        this.offset = respBody.length;
	    }
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	;(function () {
	
	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error;
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';
	
	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (
	  object.btoa = function (input) {
	    for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next input index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      input.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	    ) {
	      charCode = input.charCodeAt(idx += 3/4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });
	
	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (
	  object.atob = function (input) {
	    input = input.replace(/=+$/, '');
	    if (input.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      buffer = input.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	        // and if not first of each 4 characters,
	        // convert the first 8 bits to one ascii character
	        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	    ) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });
	
	}());


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__(318);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(320);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(319)(module), (function() { return this; }())))

/***/ },
/* 319 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(321);
	exports.encode = exports.stringify = __webpack_require__(322);


/***/ },
/* 321 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 322 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	var http = __webpack_require__(313);
	
	var https = module.exports;
	
	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};
	
	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    return http.request.call(this, params, cb);
	}


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {var exec = __webpack_require__(4).exec;
	var shelly = __webpack_require__(325);
	var exiftoolExec = 'exiftool';
	
	var coordinate2degree = function(data) {
		var values = data.split(',');
		var deg = parseFloat(values[0]), min = parseFloat(values[1]), sec = parseFloat(values[2]);
	
		return deg + (min / 60 ) + (sec / 3600);
	};
	var getLatitudeSign = function(ref) {
		if(ref == 'W')
			return -1;
		return 1;
	};
	var getLongitudeSign = function(ref) {
		if(ref == 'S')
			return -1;
		return 1;
	};
	var converters = {
		'GPSLatitude' : function(data) {
			return coordinate2degree(data);
		},
		'GPSLongitude' : function(data) {
			return coordinate2degree(data);
		},
		'GPSAltitude' : function(data) {
			return parseInt(data);
		},
		'GPSTimeStamp' : function(data) {
			return data;
		},
		'GPSImgDirection' : function(data) {
			return data;
		},
		'GPSLatitudeRef' : function(data) {
			if(data == 'North') {
				return 'N';
			}
			return 'S';
		},
		'GPSLongitudeRef' : function(data) {
			if(data == 'East') {
				return 'E';
			}
			return 'W';
		}
	}
	
	var fetchGpsInfo = function(data) {
		var gpsKeys, i, len, gpsData, key;
		try {
			gpsData = {};
			gpsKeys = Object.keys(data);
			for( i = 0, len = gpsKeys.length; i < len; i++) {
				if(converters[gpsKeys[i]]) {
					gpsData[gpsKeys[i]] = converters[gpsKeys[i]](data[gpsKeys[i]]);
				} else {
					gpsData[gpsKeys[i]] = data[gpsKeys[i]];
				}
			}
			if(gpsData['GPSLatitude'] && gpsData['GPSLatitudeRef']) {
				gpsData['GPSLatitude'] *= getLatitudeSign(gpsData['GPSLatitudeRef']);
			}
			if(gpsData['GPSLongitude'] && gpsData['GPSLongitudeRef']) {
				gpsData['GPSLongitude'] *= getLongitudeSign(gpsData['GPSLongitudeRef']);
			}
			return gpsData;
		} catch(e) {
			console.error(e);
		}
		return null;
	};
	
	module.exports = function(file, callback) {
		var cmd = shelly("? -lang en -j -c '%d,%d,%.15f,' '-GPS*' ?", exiftoolExec, file);
		exec(cmd, function(err, result) {
			try {
				result = JSON.parse(result);
				result = result[0];
			} catch(e) {
				return callback(e, null);
			}
	
			if(result.hasOwnProperty('GPSLatitude')) {
				return callback(null, fetchGpsInfo(result));
			}
	
			return callback(null, null);
		});
	};
	
	module.exports.delAll = function(file, callback) {
		var cmd = shelly('? -lang en -gps:all= ?', exiftoolExec, file);
		exec(cmd, function(err, result) {
			if(err) {
				return callback(err, null);
			}
	
			callback(null, result.trim() == '1 image files updated');
		});
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(326);

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var shellwords = __webpack_require__(327);
	
	module.exports = function(cmd){
	  var args = arguments;
	  var len = args.length;
	  var i = 1;
	
	  cmd = cmd.replace(/\?/g, function(){
	    return shellwords.escape(String(args[i++]));
	  });
	
	  while (i < len) {
	    cmd += ' ' + shellwords.escape(String(args[i++]));
	  }
	
	  return cmd;
	};

/***/ },
/* 327 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.3.3
	(function() {
	  var scan;
	
	  scan = function(string, pattern, callback) {
	    var match, result;
	    result = "";
	    while (string.length > 0) {
	      match = string.match(pattern);
	      if (match) {
	        result += string.slice(0, match.index);
	        result += callback(match);
	        string = string.slice(match.index + match[0].length);
	      } else {
	        result += string;
	        string = "";
	      }
	    }
	    return result;
	  };
	
	  exports.split = function(line) {
	    var field, words;
	    if (line == null) {
	      line = "";
	    }
	    words = [];
	    field = "";
	    scan(line, /\s*(?:([^\s\\\'\"]+)|'((?:[^\'\\]|\\.)*)'|"((?:[^\"\\]|\\.)*)"|(\\.?)|(\S))(\s|$)?/, function(match) {
	      var dq, escape, garbage, raw, seperator, sq, word;
	      raw = match[0], word = match[1], sq = match[2], dq = match[3], escape = match[4], garbage = match[5], seperator = match[6];
	      if (garbage != null) {
	        throw new Error("Unmatched quote");
	      }
	      field += word || (sq || dq || escape).replace(/\\(?=.)/, "");
	      if (seperator != null) {
	        words.push(field);
	        return field = "";
	      }
	    });
	    if (field) {
	      words.push(field);
	    }
	    return words;
	  };
	
	  exports.escape = function(str) {
	    if (str == null) {
	      str = "";
	    }
	    if (str == null) {
	      return "''";
	    }
	    return str.replace(/([^A-Za-z0-9_\-.,:\/@\n])/g, "\\$1").replace(/\n/g, "'\n'");
	  };
	
	}).call(this);


/***/ },
/* 328 */
/***/ function(module, exports) {

	var getDMSLongitudeNotation = function(decDegrees) {
		if(decDegrees < 0)
			return "W";
		return "E";
	};
	var getDMSLatitudeNotation = function(decDegrees) {
		if(decDegrees < 0)
			return "S";
		return "N";
	};
	var getDMSLongitude = function(decDegrees) {
		var dd = toDMS(decDegrees);
		return dd.degrees + " " + dd.minutes + "' " + dd.seconds + "\" " + getDMSLongitudeNotation(decDegrees);
	};
	var getDMSLatitude = function(decDegrees) {
		var dd = toDMS(decDegrees);
		return dd.degrees + " " + dd.minutes + "' " + dd.seconds + "\" " + getDMSLatitudeNotation(decDegrees);
	};
	var toDMS = function(decDegrees) {
		var dd = {};
		decDegrees = Math.abs(decDegrees);
		dd.degrees = Math.floor(decDegrees);
		dd.minutes = Math.floor(decDegrees * 60) % 60;
		dd.seconds = Math.round(100 * ((decDegrees * 3600) % 60)) / 100;
		return dd;
	};
	
	var toDD = function(degrees, minutes, seconds) {
		var d = degrees;
		d += minutes/60;
		d += seconds/3600;
		return Math.round(10000 * d) / 10000;
	};
	
	module.exports = {
		toDD : toDD,
		getDMSLatitude : getDMSLatitude,
		getDMSLongitude : getDMSLongitude,
		toDMS : toDMS
	};


/***/ },
/* 329 */
/***/ function(module, exports) {

	/**
	 * http://en.wikipedia.org/wiki/Geohash
	 */
	var base32String = '0123456789bcdefghjkmnpqrstuvwxyz';
	
	var encode = function(latitude, longitude, precision) {
		var precision = precision || 12;
		var geohash = [], bits = [16, 8, 4, 2, 1], bit = 0;
		var maxLat = 90, minLat = -90;
		var maxLng = 180, minLng = -180;
		var mid, hashPos, even = true, bitsLen = bits.length;
		while(geohash.length < precision) {
			for( hashPos = 0, bit = 0; bit < bitsLen; bit++) {
				if(even) {
					mid = (maxLng + minLng) / 2;
					if(longitude > mid) {
						hashPos |= bits[bit];
						minLng = mid;
					} else {
						maxLng = mid;
					}
				} else {
					mid = (maxLat + minLat) / 2;
					if(latitude > mid) {
						hashPos |= bits[bit];
						minLat = mid;
					} else {
						maxLat = mid;
					}
				}
				even = !even;
			}
			geohash.push(base32String[hashPos]);
		}
		return geohash.join('');
	};
	
	var decode = function(hash) {
		var maxLat = 90, minLat = -90;
		var maxLng = 180, minLng = -180;
		var i, len, even = true, bit, hashPos, mid;
		var lat, lng;
		for( i = 0, len = hash.length; i < len; i++) {
			hashPos = base32String.indexOf(hash[i]);
			if(hashPos == -1) {
				throw new Error('Invalid hash character');
			}
			for( bit = 4; bit >= 0; bit--) {
				if(even) {
					mid = (maxLng + minLng) / 2;
					if(((hashPos >> bit) & 1) == 1) {
						minLng = mid;
					} else {
						maxLng = mid;
					}
				} else {
					mid = (maxLat + minLat) / 2;
					if(((hashPos >> bit) & 1) == 1) {
						minLat = mid;
					} else {
						maxLat = mid;
					}
				}
				even = !even;
			}
		}
		lat = (minLat + maxLat) / 2;
		lng = (minLng + maxLng) / 2;
		return {
			latitude : lat,
			longitude : lng,
			error : {
				latitude : maxLat - lat,
				longitude : maxLng - lng,
			}
		};
	};
	
	module.exports = {
		geohashDecode : decode,
		geohashEncode : encode
	}

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var exiftool = __webpack_require__(324);
	var imageGpsInfo = function(image, callback) {
		return exiftool(image, callback);
	};
	
	var removeGPSInfo = function(image, callback) {
		return exiftool.delAll(image, callback);
	};
	
	module.exports = {
		imageGpsInfo : imageGpsInfo,
		removeGPSInfo : removeGPSInfo
	};


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xml2js = __webpack_require__(272), parser = new xml2js.Parser();
	
	var http = __webpack_require__(313);
	var https = __webpack_require__(323);
	
	var ATTRIBUTE_NAME = '$';
	
	var Trackpoint = function() {
		this.lat = null;
		this.lng = null;
		this.altitude = null;
		this.time = null;
		this.speed = null;
		this.distance = null;
	};
	var getTrackpoint = function(trackPoint) {
		var point = new Trackpoint();
		if(trackPoint.Position) {
			point.lat = parseFloat(trackPoint.Position[0].LatitudeDegrees);
			point.lng = parseFloat(trackPoint.Position[0].LongitudeDegrees);
		}
		point.altitude = parseFloat(trackPoint.AltitudeMeters);
		point.distance = parseFloat(trackPoint.DistanceMeters);
		if(trackPoint.Extensions) {
			point.speed = parseFloat(trackPoint.Extensions[0].TPX[0].Speed);
		}
		point.time = new Date(trackPoint.Time);
		return point;
	};
	var getTrk = function(trks) {
		var returnTrks = [], trkpts, trkpt;
		var i, len, j, jlen;
		if(!( trks instanceof Array)) {
			trks = [trks];
		}
		for( i = 0, len = trks.length; i < len; i++) {
			trkpts = trks[i].Lap[0].Track[0].Trackpoint;
			for( j = 0, jlen = trkpts.length; j < jlen; j++) {
				trkpt = getTrackpoint(trkpts[j]);
				returnTrks.push(trkpt);
			}
		}
	
		return returnTrks;
	};
	var tcxParse = function(data, callback) {
		parser.parseString(data, function(err, result) {
			if(err) {
				return callback(err, null);
			}
			if(result.TrainingCenterDatabase && result.TrainingCenterDatabase.Activities) {
				return callback(null, getTrk(result.TrainingCenterDatabase.Activities[0].Activity));
			} else {
				return callback(new Error('Unexpected data'), null);
			}
		});
	};
	var tcxParseFile = function(filename, callback) {
	    fs.readFile(filename, function(err, result) {
			if(err) {
				return callback(err, null);
			}
			return tcxParse(result, callback);
		});
	};
	var tcxParseURL = function(url, callback, secure) {
		var h = secure? https : http;
	
		h.get(url, function(res) {
			var data = '';
			res.on('data', function(chunk) {
				data += chunk;
			});
			res.on('end', function() {
				if(res.statusCode == 200) {
					return tcxParse(new Buffer(data), callback);
				} else {
					return callback(new Error('Got unexpected response code'), null);
				}
			});
		}).on('error', function(err) {
			return callback(err, null);
		});
	};
	
	module.exports = {
		tcxParse : tcxParse,
		tcxParseFile : tcxParseFile,
		tcxParseURL : tcxParseURL
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144).Buffer))

/***/ },
/* 332 */
/***/ function(module, exports) {

	module.exports = "\n<div>\n  <nav id=\"menu\">\n    <a :class=\"{'active' : addFlag}\" @click.prevent.stop=\"onFlag\"></a>\n  </nav>\n  <div id=\"map\"></div>\n  <div id=\"snackbar\" class=\"mdl-js-snackbar mdl-snackbar\">\n    <div class=\"mdl-snackbar__text\"></div>\n    <button class=\"mdl-snackbar__action\" type=\"button\"></button>\n  </div>\n</div>\n";

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {var __vue_script__, __vue_template__
	__webpack_require__(334)
	__vue_script__ = __webpack_require__(337)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] vue/components/about.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(338)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/charlie/Charlie/Mywork/side-project/openVenue/openVenue-frontend/vue/components/about.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(335);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(34)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./about.vue", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./about.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(33)();
	// imports
	
	
	// module
	exports.push([module.id, "\n  \n  .index-first-section {\n    position: relative;\n    height: 100%;\n    bottom:0px;\n    width: auto;\n    background-color: #f3f3f3;\n    background: url(" + __webpack_require__(336) + ") center 30% no-repeat;\n    background-size: cover;\n  }\n\n  .logo-font {\n    font-family: 'Roboto', 'Helvetica', 'Arial', sans-serif;\n    line-height: 1;\n    color: #767777;\n    font-weight: 500;\n  }\n\n  .index-slogan {\n    font-size: 60px;\n    padding-top: 140px;\n  }\n\n  .index-sub-slogan {\n    font-size: 21px;\n    padding-top: 24px;\n  }\n\n  .index-create-character {\n  font-size: 21px;\n  padding-top: 300px;\n}\n\n  .index-create-character a {\n    text-decoration: none;\n    color: #767777;\n    font-weight: 300;\n  }\n", "", {"version":3,"sources":["/./vue/components/about.vue?f5e6b2ce"],"names":[],"mappings":";;EAkCA;IACA,mBAAA;IACA,aAAA;IACA,WAAA;IACA,YAAA;IACA,0BAAA;IACA,+DAAA;IACA,uBAAA;GACA;;EAEA;IACA,wDAAA;IACA,eAAA;IACA,eAAA;IACA,iBAAA;GACA;;EAEA;IACA,gBAAA;IACA,mBAAA;GACA;;EAEA;IACA,gBAAA;IACA,kBAAA;GACA;;EAEA;EACA,gBAAA;EACA,mBAAA;CACA;;EAEA;IACA,sBAAA;IACA,eAAA;IACA,iBAAA;GACA","file":"about.vue","sourcesContent":["<template>\n  <div class=\"index-first-section mdl-typography--text-center\">\n    <div class=\"logo-font index-slogan\">{{Description}}</div>\n    <div class=\"logo-font index-sub-slogan\">->->/</div>\n    <div class=\"logo-font index-create-character\">\n      Developed by <a href=\"https://github.com/ccharlieli\">Charlie</a>\n    </div>\n  </div>\n</template>\n\n<script>\n  import mdl from 'material-design-lite/material.js';\n  export default {\n    name: 'IndexView',\n    data () {\n      return {\n        Description: ''\n      };\n    },\n    route: { },\n    created () {},\n    ready () {\n      this.$nextTick(function(){\n        componentHandler.upgradeAllRegistered();\n      })\n    },\n    destroyed () {},\n    methods: {},\n    filters: {}\n  }\n</script>\n\n<style type=\"text/css\">\n  \n  .index-first-section {\n    position: relative;\n    height: 100%;\n    bottom:0px;\n    width: auto;\n    background-color: #f3f3f3;\n    background: url('../assets/slide01.jpg') center 30% no-repeat;\n    background-size: cover;\n  }\n\n  .logo-font {\n    font-family: 'Roboto', 'Helvetica', 'Arial', sans-serif;\n    line-height: 1;\n    color: #767777;\n    font-weight: 500;\n  }\n\n  .index-slogan {\n    font-size: 60px;\n    padding-top: 140px;\n  }\n\n  .index-sub-slogan {\n    font-size: 21px;\n    padding-top: 24px;\n  }\n\n  .index-create-character {\n  font-size: 21px;\n  padding-top: 300px;\n}\n\n  .index-create-character a {\n    text-decoration: none;\n    color: #767777;\n    font-weight: 300;\n  }\n</style>"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "cd09afada5c49be5b2e00d95a35c9b6d.jpg";

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _material = __webpack_require__(261);
	
	var _material2 = _interopRequireDefault(_material);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  name: 'IndexView',
	  data: function data() {
	    return {
	      Description: ''
	    };
	  },
	
	  route: {},
	  created: function created() {},
	  ready: function ready() {
	    this.$nextTick(function () {
	      componentHandler.upgradeAllRegistered();
	    });
	  },
	  destroyed: function destroyed() {},
	
	  methods: {},
	  filters: {}
	};
	// </script>
	//
	// <style type="text/css">
	//
	//   .index-first-section {
	//     position: relative;
	//     height: 100%;
	//     bottom:0px;
	//     width: auto;
	//     background-color: #f3f3f3;
	//     background: url('../assets/slide01.jpg') center 30% no-repeat;
	//     background-size: cover;
	//   }
	//
	//   .logo-font {
	//     font-family: 'Roboto', 'Helvetica', 'Arial', sans-serif;
	//     line-height: 1;
	//     color: #767777;
	//     font-weight: 500;
	//   }
	//
	//   .index-slogan {
	//     font-size: 60px;
	//     padding-top: 140px;
	//   }
	//
	//   .index-sub-slogan {
	//     font-size: 21px;
	//     padding-top: 24px;
	//   }
	//
	//   .index-create-character {
	//   font-size: 21px;
	//   padding-top: 300px;
	// }
	//
	//   .index-create-character a {
	//     text-decoration: none;
	//     color: #767777;
	//     font-weight: 300;
	//   }
	// </style>
	/* generated by vue-loader */
	// <template>
	//   <div class="index-first-section mdl-typography--text-center">
	//     <div class="logo-font index-slogan">{{Description}}</div>
	//     <div class="logo-font index-sub-slogan">->->/</div>
	//     <div class="logo-font index-create-character">
	//       Developed by <a href="https://github.com/ccharlieli">Charlie</a>
	//     </div>
	//   </div>
	// </template>
	//
	// <script>

/***/ },
/* 338 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"index-first-section mdl-typography--text-center\">\n  <div class=\"logo-font index-slogan\">{{Description}}</div>\n  <div class=\"logo-font index-sub-slogan\">->->/</div>\n  <div class=\"logo-font index-create-character\">\n    Developed by <a href=\"https://github.com/ccharlieli\">Charlie</a>\n  </div>\n</div>\n";

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {var __vue_script__, __vue_template__
	__webpack_require__(340)
	__vue_script__ = __webpack_require__(342)
	if (__vue_script__ &&
	    __vue_script__.__esModule &&
	    Object.keys(__vue_script__).length > 1) {
	  console.warn("[vue-loader] vue/components/venue.vue: named exports in *.vue files are ignored.")}
	__vue_template__ = __webpack_require__(343)
	module.exports = __vue_script__ || {}
	if (module.exports.__esModule) module.exports = module.exports.default
	if (__vue_template__) {
	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
	}
	if (false) {(function () {  module.hot.accept()
	  var hotAPI = require("vue-hot-reload-api")
	  hotAPI.install(require("vue"), true)
	  if (!hotAPI.compatible) return
	  var id = "/Users/charlie/Charlie/Mywork/side-project/openVenue/openVenue-frontend/vue/components/venue.vue"
	  if (!module.hot.data) {
	    hotAPI.createRecord(id, module.exports)
	  } else {
	    hotAPI.update(id, module.exports, __vue_template__)
	  }
	})()}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(341);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(34)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./venue.vue", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js!./../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./venue.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(33)();
	// imports
	
	
	// module
	exports.push([module.id, "\nimg.article-image {\n  width: 100%;\n  height: auto;\n}\n.form-max-width {\n  max-width: 900px;\n  margin: auto;\n  width: 100%;\n}\n.form-max-width form {\n  max-width: 550px;\n  margin: auto;\n}\n.form-max-width h3 {\n  margin-top: 36px;\n  margin-bottom: 16px;\n}\n.form-max-width .mdl-textfield {\n  width: 100%;\n}\n.form-max-width .mdl-checkbox {\n  width: 100%;\n  margin-bottom: 10px;\n}\n.form-max-width .mdl-selectfield {\n  width: 100%;\n}\n", "", {"version":3,"sources":["/./vue/components/venue.vue?331ce401"],"names":[],"mappings":";AAuLA;EACA,YAAA;EACA,aAAA;CACA;AACA;EACA,iBAAA;EACA,aAAA;EACA,YAAA;CACA;AACA;EACA,iBAAA;EACA,aAAA;CACA;AACA;EACA,iBAAA;EACA,oBAAA;CACA;AACA;EACA,YAAA;CACA;AACA;EACA,YAAA;EACA,oBAAA;CACA;AACA;EACA,YAAA;CACA","file":"venue.vue","sourcesContent":["<template>\n  <div class=\"mdl-grid form-max-width\">\n    <div class=\"mdl-cell mdl-cell--12-col mdl-card mdl-shadow--4dp\">\n      <div class=\"mdl-card__media\">\n          <img class=\"article-image\" src=\"../assets/contact-image.jpg\" border=\"0\" alt=\"\">\n      </div>\n      <div class=\"mdl-card__supporting-text\">\n          <form id=\"signIn\" @submit.prevent.stop=\"onSubmit\">\n            <h3></h3>\n            <h5></h5>\n            <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n              <input class=\"mdl-textfield__input\" type=\"text\" id=\"venueName\" v-model=\"VenueName\">\n            </div>\n            <h5>)</h5>\n            <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n              <textarea class=\"mdl-textfield__input\" type=\"text\" rows=\"5\" id=\"Other\" v-model=\"Other\"></textarea>\n            </div>\n            <h3>/</h3>\n            <h5></h5>\n            <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n              <input class=\"mdl-textfield__input\" type=\"text\" id=\"Name\" v-model=\"UserName\">\n            </div>\n            <h5></h5>\n            <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n              <input class=\"mdl-textfield__input\" type=\"password\" id=\"Pwd\" v-model=\"Password\">\n            </div>\n            <h5></h5>\n            <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n              <input class=\"mdl-textfield__input\" type=\"text\" id=\"WeChat\" v-model=\"Wechat\">\n            </div>\n            <p>\n              <button class=\"mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--colored\" type=\"submit\">\n                /\n              </button>\n              <button class=\"mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent\" @click.prevent.stop=\"onDelete\">\n                \n              </button>\n            </p>\n          </form>\n      </div>\n      <div class=\"mdl-cell mdl-cell--12-col\" id=\"disqus_thread\"></div>\n    </div>\n    <div id=\"snackbar\" class=\"mdl-js-snackbar mdl-snackbar\">\n      <div class=\"mdl-snackbar__text\"></div>\n      <button class=\"mdl-snackbar__action\" type=\"button\"></button>\n    </div>\n  </div>\n</template>\n\n<script>\n  'use strict';\n  import auth from '../auth';\n  import mdl from 'material-design-lite/material';\n  import geo from 'gps-util';\n\n  export default {\n    name: 'VenueView',\n    data () {\n      return {\n        VenueName: '',\n        UserName: '',\n        Password: '',\n        Wechat: '',\n        Other: '',\n        Coordinate: {},\n        geoHash: ''\n      };\n    },\n    watch: {},\n    route: {\n      data ({ to }) {\n        document.title = 'OpenVenue - Venue';\n        this.geoHash = to.params.geohash;\n        this.Coordinate.lng = geo.geohashDecode(this.geoHash).longitude;\n        this.Coordinate.lat = geo.geohashDecode(this.geoHash).latitude;\n        auth.findVenue(this, {\n          data: {\n            geoHash: this.geoHash,\n          }\n        }).then((res) => {\n          if(res){\n            this.VenueName = res.venueName;\n            this.UserName = res.username;\n            this.Wechat = res.wechat;\n            this.Other = res.other;\n            this.Password = '';\n          }\n          else {\n            this.VenueName = '';\n            this.UserName = '';\n            this.Wechat = '';\n            this.Other = '';\n            this.Password = '';\n          }\n        });\n      }\n    },\n    created () {\n      mdl;\n    },\n    ready () {\n      this.$nextTick(function(){\n        componentHandler.upgradeAllRegistered();\n\n        var d = document, s = d.createElement('script');\n        s.src = '//openvenue.disqus.com/embed.js';\n        s.setAttribute('data-timestamp', +new Date());\n        (d.head || d.body).appendChild(s);\n      });\n    },\n    destroyed () {},\n    methods: {\n      onSubmit () {\n        if(!this.Coordinate.lng || !this.Coordinate.lat) {\n          this.popUp('You must set the fuck coordinate in map first.')\n        }\n        else if(!this.VenueName) {\n          this.popUp('You must set the fuck venue name.')\n        }\n        else if(!this.Other) {\n          this.popUp('You must set the information.')\n        }\n        else if(!this.UserName) {\n          this.popUp('You must set the fuck username.')\n        }\n        else if(!this.Password) {\n          this.popUp('You must set the fuck password.')\n        }\n        else if(!this.Wechat) {\n          this.popUp('You must set the fuck wechat.')\n        } \n        else {\n          //sign up\n          let credentials = {\n            data: {\n              geoHash: this.geoHash,\n              username: this.UserName,\n              password: this.Password,\n              wechat: this.Wechat,\n              venueName: this.VenueName,\n              other: this.Other,\n              coordinate: this.Coordinate\n            }\n          };\n          auth.addVenue(this, credentials, '/map').then((res) => {\n            if(res) {\n              this.popUp(res);\n            }\n          });\n        }\n      },\n      onDelete () {\n        if(!this.geoHash) {\n          this.popUp('You must set the fuck venue name.')\n        }\n        else if(!this.Password) {\n          this.popUp('You must set the fuck password.')\n        }\n        else {\n          let credentials = {\n            data: {\n              geoHash: this.geoHash,\n              password: this.Password\n            }\n          };\n          auth.deleteVenue(this, credentials, '/map').then((res) => {\n            if(res) {\n              this.popUp('Password is not right.');\n            }\n          });\n        }\n      },\n      popUp (msg) {\n        let snackbarContainer = document.querySelector('#snackbar');\n        let data = {message: msg};\n        snackbarContainer.MaterialSnackbar.showSnackbar(data);\n      }\n    },\n    filters: {}\n  }\n</script>\n\n<style>\n  img.article-image {\n    width: 100%;\n    height: auto;\n  }\n  .form-max-width {\n    max-width: 900px;\n    margin: auto;\n    width: 100%;\n  }\n  .form-max-width form {\n    max-width: 550px;\n    margin: auto;\n  }\n  .form-max-width h3 {\n    margin-top: 36px;\n    margin-bottom: 16px;\n  }\n  .form-max-width .mdl-textfield {\n    width: 100%;\n  }\n  .form-max-width .mdl-checkbox {\n    width: 100%;\n    margin-bottom: 10px;\n  }\n  .form-max-width .mdl-selectfield {\n    width: 100%;\n  }\n</style>"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	// <template>
	//   <div class="mdl-grid form-max-width">
	//     <div class="mdl-cell mdl-cell--12-col mdl-card mdl-shadow--4dp">
	//       <div class="mdl-card__media">
	//           <img class="article-image" src="../assets/contact-image.jpg" border="0" alt="">
	//       </div>
	//       <div class="mdl-card__supporting-text">
	//           <form id="signIn" @submit.prevent.stop="onSubmit">
	//             <h3></h3>
	//             <h5></h5>
	//             <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
	//               <input class="mdl-textfield__input" type="text" id="venueName" v-model="VenueName">
	//             </div>
	//             <h5>)</h5>
	//             <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
	//               <textarea class="mdl-textfield__input" type="text" rows="5" id="Other" v-model="Other"></textarea>
	//             </div>
	//             <h3>/</h3>
	//             <h5></h5>
	//             <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
	//               <input class="mdl-textfield__input" type="text" id="Name" v-model="UserName">
	//             </div>
	//             <h5></h5>
	//             <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
	//               <input class="mdl-textfield__input" type="password" id="Pwd" v-model="Password">
	//             </div>
	//             <h5></h5>
	//             <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
	//               <input class="mdl-textfield__input" type="text" id="WeChat" v-model="Wechat">
	//             </div>
	//             <p>
	//               <button class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--colored" type="submit">
	//                 /
	//               </button>
	//               <button class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent" @click.prevent.stop="onDelete">
	//                 
	//               </button>
	//             </p>
	//           </form>
	//       </div>
	//       <div class="mdl-cell mdl-cell--12-col" id="disqus_thread"></div>
	//     </div>
	//     <div id="snackbar" class="mdl-js-snackbar mdl-snackbar">
	//       <div class="mdl-snackbar__text"></div>
	//       <button class="mdl-snackbar__action" type="button"></button>
	//     </div>
	//   </div>
	// </template>
	//
	// <script>
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _auth = __webpack_require__(36);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	var _material = __webpack_require__(261);
	
	var _material2 = _interopRequireDefault(_material);
	
	var _gpsUtil = __webpack_require__(262);
	
	var _gpsUtil2 = _interopRequireDefault(_gpsUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  name: 'VenueView',
	  data: function data() {
	    return {
	      VenueName: '',
	      UserName: '',
	      Password: '',
	      Wechat: '',
	      Other: '',
	      Coordinate: {},
	      geoHash: ''
	    };
	  },
	
	  watch: {},
	  route: {
	    data: function data(_ref) {
	      var _this = this;
	
	      var to = _ref.to;
	
	      document.title = 'OpenVenue - Venue';
	      this.geoHash = to.params.geohash;
	      this.Coordinate.lng = _gpsUtil2.default.geohashDecode(this.geoHash).longitude;
	      this.Coordinate.lat = _gpsUtil2.default.geohashDecode(this.geoHash).latitude;
	      _auth2.default.findVenue(this, {
	        data: {
	          geoHash: this.geoHash
	        }
	      }).then(function (res) {
	        if (res) {
	          _this.VenueName = res.venueName;
	          _this.UserName = res.username;
	          _this.Wechat = res.wechat;
	          _this.Other = res.other;
	          _this.Password = '';
	        } else {
	          _this.VenueName = '';
	          _this.UserName = '';
	          _this.Wechat = '';
	          _this.Other = '';
	          _this.Password = '';
	        }
	      });
	    }
	  },
	  created: function created() {
	    _material2.default;
	  },
	  ready: function ready() {
	    this.$nextTick(function () {
	      componentHandler.upgradeAllRegistered();
	
	      var d = document,
	          s = d.createElement('script');
	      s.src = '//openvenue.disqus.com/embed.js';
	      s.setAttribute('data-timestamp', +new Date());
	      (d.head || d.body).appendChild(s);
	    });
	  },
	  destroyed: function destroyed() {},
	
	  methods: {
	    onSubmit: function onSubmit() {
	      var _this2 = this;
	
	      if (!this.Coordinate.lng || !this.Coordinate.lat) {
	        this.popUp('You must set the fuck coordinate in map first.');
	      } else if (!this.VenueName) {
	        this.popUp('You must set the fuck venue name.');
	      } else if (!this.Other) {
	        this.popUp('You must set the information.');
	      } else if (!this.UserName) {
	        this.popUp('You must set the fuck username.');
	      } else if (!this.Password) {
	        this.popUp('You must set the fuck password.');
	      } else if (!this.Wechat) {
	        this.popUp('You must set the fuck wechat.');
	      } else {
	        //sign up
	        var credentials = {
	          data: {
	            geoHash: this.geoHash,
	            username: this.UserName,
	            password: this.Password,
	            wechat: this.Wechat,
	            venueName: this.VenueName,
	            other: this.Other,
	            coordinate: this.Coordinate
	          }
	        };
	        _auth2.default.addVenue(this, credentials, '/map').then(function (res) {
	          if (res) {
	            _this2.popUp(res);
	          }
	        });
	      }
	    },
	    onDelete: function onDelete() {
	      var _this3 = this;
	
	      if (!this.geoHash) {
	        this.popUp('You must set the fuck venue name.');
	      } else if (!this.Password) {
	        this.popUp('You must set the fuck password.');
	      } else {
	        var credentials = {
	          data: {
	            geoHash: this.geoHash,
	            password: this.Password
	          }
	        };
	        _auth2.default.deleteVenue(this, credentials, '/map').then(function (res) {
	          if (res) {
	            _this3.popUp('Password is not right.');
	          }
	        });
	      }
	    },
	    popUp: function popUp(msg) {
	      var snackbarContainer = document.querySelector('#snackbar');
	      var data = { message: msg };
	      snackbarContainer.MaterialSnackbar.showSnackbar(data);
	    }
	  },
	  filters: {}
	};
	// </script>
	//
	// <style>
	//   img.article-image {
	//     width: 100%;
	//     height: auto;
	//   }
	//   .form-max-width {
	//     max-width: 900px;
	//     margin: auto;
	//     width: 100%;
	//   }
	//   .form-max-width form {
	//     max-width: 550px;
	//     margin: auto;
	//   }
	//   .form-max-width h3 {
	//     margin-top: 36px;
	//     margin-bottom: 16px;
	//   }
	//   .form-max-width .mdl-textfield {
	//     width: 100%;
	//   }
	//   .form-max-width .mdl-checkbox {
	//     width: 100%;
	//     margin-bottom: 10px;
	//   }
	//   .form-max-width .mdl-selectfield {
	//     width: 100%;
	//   }
	// </style>
	/* generated by vue-loader */

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = "\n<div class=\"mdl-grid form-max-width\">\n  <div class=\"mdl-cell mdl-cell--12-col mdl-card mdl-shadow--4dp\">\n    <div class=\"mdl-card__media\">\n        <img class=\"article-image\" src=\"" + __webpack_require__(344) + "\" border=\"0\" alt=\"\">\n    </div>\n    <div class=\"mdl-card__supporting-text\">\n        <form id=\"signIn\" @submit.prevent.stop=\"onSubmit\">\n          <h3></h3>\n          <h5></h5>\n          <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n            <input class=\"mdl-textfield__input\" type=\"text\" id=\"venueName\" v-model=\"VenueName\">\n          </div>\n          <h5>)</h5>\n          <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n            <textarea class=\"mdl-textfield__input\" type=\"text\" rows=\"5\" id=\"Other\" v-model=\"Other\"></textarea>\n          </div>\n          <h3>/</h3>\n          <h5></h5>\n          <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n            <input class=\"mdl-textfield__input\" type=\"text\" id=\"Name\" v-model=\"UserName\">\n          </div>\n          <h5></h5>\n          <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n            <input class=\"mdl-textfield__input\" type=\"password\" id=\"Pwd\" v-model=\"Password\">\n          </div>\n          <h5></h5>\n          <div class=\"mdl-textfield mdl-js-textfield mdl-textfield--floating-label\">\n            <input class=\"mdl-textfield__input\" type=\"text\" id=\"WeChat\" v-model=\"Wechat\">\n          </div>\n          <p>\n            <button class=\"mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--colored\" type=\"submit\">\n              /\n            </button>\n            <button class=\"mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent\" @click.prevent.stop=\"onDelete\">\n              \n            </button>\n          </p>\n        </form>\n    </div>\n    <div class=\"mdl-cell mdl-cell--12-col\" id=\"disqus_thread\"></div>\n  </div>\n  <div id=\"snackbar\" class=\"mdl-js-snackbar mdl-snackbar\">\n    <div class=\"mdl-snackbar__text\"></div>\n    <button class=\"mdl-snackbar__action\" type=\"button\"></button>\n  </div>\n</div>\n";

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8416519ae2b5a1cf9a15b750afaf3994.jpg";

/***/ }
/******/ ]);
//# sourceMappingURL=index.js.map